<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;4.&nbsp;Advanced JDO</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="up" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="prev" href="jdo.html" title="Chapter&nbsp;3.&nbsp;Castor JDO"><link rel="next" href="Spring ORM integration.html" title="Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top"><div id="header"><div class="projectlogo"><a href="./"><img class="logoImage" src="images/castor.gif" alt="Castor" border="0"></a></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="mhSpacer"></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="advanced-jdo"></a>Chapter&nbsp;4.&nbsp;Advanced JDO</h2></div></div></div>
    



  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.caching"></a>4.1.&nbsp;Castor JDO - Caching</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.introduction"></a>4.1.1.&nbsp;Introduction</h3></div></div></div><p>
           As explained at 
           <a href="jdo.html#jdo.introduction" title="3.1.&nbsp;Castor JDO - An introduction">the introduction to Castor JDO</a>,
           Castor has support for many advanced features such as caching. 
           The below sections detail the features related to caching in Castor JDO, 
           as their understanding is required to use Castor JDO in a performant and 
           secure way.
        </p><p>
           In general, performance caches enhance the application performance 
           by reducing the number of read operations against the persistence 
           storage, by storing and reusing the last read or committed values of 
           the object. Performance caches do not affect the behavior of short 
           transactions or locking. It only affects persistence objects that have 
           been released from any transactional context.
        </p><p>
           Starting from Castor 0.8.6, a performance cache implementation has been 
           added. At a technical level, Castor maintains separate (performance) caches 
           for each object type specified in the JDO mapping provided, allowing users 
           to specify - for each object type individually - the type and 
           capacity of the cache.
        </p><p>By default, the following cache types are available:</p><div class="table"><a name="d4e7716"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Available cache types</b></p><div class="table-contents"><table summary="Available cache types" border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>name</th><th>Vendor</th><th>Version</th><th>Distributable?</th><th>Open source/commercial</th><th>high volume/performance</th><th>Added in release</th></tr></thead><tbody><tr><td>none</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>unlimited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>count-limited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>time-limited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>coherence</td><td>
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.tangosol.com/coherence.jsp" target="_top">Tangosol 
                  Coherence</a>
                </td><td>2.5</td><td align="center">Yes</td><td>Commercial</td><td align="center">Yes</td><td align="center">0.9.9</td></tr><tr><td>jcs</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/jcs" target="_top">JCS</a></td><td>1.2.5</td><td align="center">Yes</td><td>Open source</td><td align="center">Yes</td><td align="center">0.9.9</td></tr><tr><td>fkcache</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jcache.sourceforge.net/" target="_top">FKCache</a></td><td>1.0-beta6</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">0.9.9</td></tr><tr><td>oscache</td><td>
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.opensymphony.com/oscache/" target="_top">OSCache</a>
                </td><td>2.5</td><td align="center">Yes</td><td>Open Source</td><td align="center">No</td><td align="center">1.0</td></tr><tr><td>fifo</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">Yes</td><td align="center">1.0</td></tr><tr><td>lru</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">Yes</td><td align="center">1.0</td></tr><tr><td>ehcache</td><td>Built-in</td><td>-</td><td align="center">Yes</td><td>Open Source</td><td align="center">?</td><td align="center">1.0.1</td></tr><tr><td>gigaspaces</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/jcs" target="_top">JCS</a></td><td>5.0</td><td align="center">Yes</td><td>Commercial</td><td align="center">Yes</td><td align="center">1.0.1</td></tr></tbody></table></div></div><br class="table-break"><p>
           As some of these cache providers allow for allow you to use it in a 
           <span class="bold"><strong>distributed</strong></span> mode, this allows Castor 
           JDO to be used in a clustered (multi-JVM) environment. Please see the 
           section 
           <a href="advanced-jdo.html#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">below</a> 
           for short summary of this feature.
        </p><p>
           Per definition, all build-in performance caches are 
           <span class="bold"><strong>write-through</strong></span>, because all 
           changes to objects as part of a transaction should be persisted into the 
           cache at commit time without delay.
        </p><p>
           For problems related to the use of performance caches, please consult with 
           the relevant entries in the 
           <a href="jdo.html#jdo.faq.performance-caches" title="3.7.4.&nbsp;Castor and performance caches">JDO F.A.Q.</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.long-transactions"></a>4.1.2.&nbsp;Caching and long transactions</h3></div></div></div><p>
           As it stands currently, performance caches also serve a dual purpose 
           as dirty checking caches for 
           <a href="advanced-jdo.html#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">long-transactions</a>.
           This limitation implies that the object's availability in the performance 
           cache determines the allowed time span of a long transaction.
        </p><p>
           This might become an issue when performance caches of type 'count-limited' or 
           'time-limited' are being used, where objects will eventually be disposed. 
           If an application tries to update an object that has been disposed from 
           the dirty checking cache, an ObjectModifedException will be thrown.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration"></a>4.1.3.&nbsp;Configuration</h3></div></div></div><p>
           The DTD declaration is as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">cache-type</span>  <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
<span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">cache-type</span>
    <span class="hl-attribute">type</span>           <span class="hl-attribute">(</span> <span class="hl-attribute">none</span> <span class="hl-attribute">|</span> <span class="hl-attribute">count-limited</span> <span class="hl-attribute">|</span> <span class="hl-attribute">time-limited</span> <span class="hl-attribute">|</span> <span class="hl-attribute">unlimited</span> <span class="hl-attribute">|</span>
                     <span class="hl-attribute">coherence</span> <span class="hl-attribute">|</span> <span class="hl-attribute">fkcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jcs</span> <span class="hl-attribute">|</span> <span class="hl-attribute">oscache</span> <span class="hl-attribute">|</span>
                     <span class="hl-attribute">fifo</span> <span class="hl-attribute">|</span> <span class="hl-attribute">lru</span> <span class="hl-attribute">|</span> <span class="hl-attribute">ehcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">gigaspaces</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"count-limited"</span>
    <span class="hl-attribute">debug</span>          <span class="hl-attribute">(true|false)</span> <span class="hl-attribute">"false"</span>
    <span class="hl-attribute">capacity</span>       <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED&gt;</span>

<span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">param</span> <span class="hl-attribute">EMPTY&gt;</span>
<span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">param</span>
          <span class="hl-attribute">name</span>   <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED</span>
          <span class="hl-attribute">value</span>  <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED&gt;</span></pre><p>
        </p><p>
           With release 1.0 of Castor the DTD has changed but it is backward compatible
           to the old one and allows to enable debugging of cache access for a specific
           class as well as passing individual configuration parameters to each cache
           instance. Only <span class="bold"><strong>count-limited</strong></span> and 
           <span class="bold"><strong>time-limited</strong></span> of the current
           build-in cache types support parameters. Parameter names are case sensitive 
           and are silently ignored if they are unknown to a cache type.
        </p><p>
           It need to be noted that there are 3 parameter names that are reserved for
           internal use. If you specify a parameter with one of the names: 
           <span class="bold"><strong>type</strong></span>, <span class="bold"><strong>name</strong></span> 
           or <span class="bold"><strong>debug</strong></span> their value will silently be 
           overwritten with another one used internally.
        </p><div class="example"><a name="advanced-jdo.caching.configuration.sample-count-limited"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Configuration sample - count-limited</b></p><div class="example-contents"><p>
               A <span class="bold"><strong>count-limited</strong></span> least-recently-used 
               cache (LRU) for 500 objects can be specified by:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"500"</span>/&gt;</pre><p>or</p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span>/&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"500"</span>/&gt;
&lt;<span class="hl-tag">/cache-type</span>&gt;</pre><p>
               If both, the capacity attribute and parameter with name="capacity" is
               specified, the parameter value takes precedence over the attribute 
               value.
            </p></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.sample-time-limited"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Configuration sample - time-limited</b></p><div class="example-contents"><p>
               A <span class="bold"><strong>time-limited</strong></span> first-in-first-out 
               cache (FIFO) that expires objects after 15 minutes can be specified by:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"900"</span>/&gt;</pre><p>or</p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span>/&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"900"</span>/&gt;
&lt;<span class="hl-tag">/cache-type</span>&gt;</pre><p>
              If both, the capacity attribute and parameter with name="ttl" is 
              specified, the parameter value takes precedence over the attribute value.
           </p></div></div><br class="example-break"><p>
           The <span class="bold"><strong>debug</strong></span> attribute can be used to enable 
           debugging for objects of a single class. In addition to setting this 
           attribut to <span class="bold"><strong>true</strong></span> you also need to set 
           logging level of <span class="bold"><strong>org.castor.cache.Cache</strong></span> 
           to debug.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              The default cache-type is <code class="literal">count-limited</code> with a 
              capacity of 30. This will be used when no cache-type is specified in 
              the mapping for a class.
           </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration.fifo-lru"></a>4.1.4.&nbsp;fifo and lru cache providers</h3></div></div></div><p>
           The cache types <span class="bold"><strong>fifo</strong></span> and 
           <span class="bold"><strong>lru</strong></span> are based on a set of articles in the
           O'Reilly Network by William Grosso, to implement a simplified and 
           1.3-compatible implementation of a Hashbelt algorithm.
        </p><p>
           Hashbelts are simple, in principle. Instead of walking all objects and 
           finding out when they're supposed to expire, use a "conveyor belt" approach. 
           At any particular point in time, objects going into the cache go into the 
           front of the conveyor belt. After a certain amount of time or when the size 
           limit of a container has been reached, move the conveyor belt - put a new, 
           empty container at the front of the conveyor belt to catch new objects, and 
           the one that drops off of the end of the conveyor belt is, by definition, 
           ready for garbage collection.
        </p><p>
           As seen in his system, you can use a set of pluggable strategies to 
           implement the actual hashbelt bits. A container strategy allows you to 
           change out the implementation of the container itself - from simple 
           hashtable-based implementations, up through more complex uses of soft 
           referenced or hashset-based implementations, depending on what you need 
           and what you want it to be used for. A pluggable "expire behavior" handler 
           allows you to determine what action is taken on something which drops off 
           of the bottom of the conveyor belt.
        </p><p>
           In difference to all other cache types the 
           <span class="bold"><strong>fifo</strong></span> and 
           <span class="bold"><strong>lru</strong></span> cache types offer various configuration 
           options. Both of them have 6 parameters to configure their behaviour.
        </p><div class="table"><a name="d4e7886"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;cache types parameters</b></p><div class="table-contents"><table summary="cache types parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">parameter</th><th align="left">description</th></tr></thead><tbody><tr><td>containers</td><td>
                   The number of containers in the conveyor belt. For example: If a 
                   box will drop off of the conveyor belt every 30 seconds, and you 
                   want a cache that lasts for 5 minutes, you want 5 / 30 = 6 
                   containers on the belt. Every 30 seconds, another, clean container 
                   goes on the front of the conveyor belt, and everything in the last 
                   belt gets discarded. If not specified 10 containers are used by default.

                   For systems with fine granularity, you are free to use a large 
                   number of containers; but the system is most efficient when the 
                   user decides on a "sweet spot" determining both the number of 
                   containers to be managed on the whole and the optimal number of 
                   buckets in those containers for managing. This is ultimately a 
                   performance/accuracy tradeoff with the actual discard-from-cache 
                   time being further from the mark as the rotation time goes up. 
                   Also the number of objects discarded at once when capacity limit 
                   is reached depends upon the number of containers.
                </td></tr><tr><td>capacity</td><td>
                   Maximum capacity of the whole cache. If there are, for example, ten
                   containers on the belt and the capacity has been set to 1000, each 
                   container will hold a maximum of 1000/10 objects. Therefore if the 
                   capacity limit is reached and the last container gets droped from 
                   the belt there are up to 100 objects discarted at once. By default 
                   the capacity is set to 0 which causes capacity limit to be ignored 
                   so the cache can hold an undefined number of objects.
                </td></tr><tr><td>ttl</td><td>
                   The maximum time an object lifes in cache. If the are, for example, 
                   ten containers and ttl is set to 300 seconds (5 minutes), a new 
                   container will be put in front of the belt every 300/10 = 30 seconds 
                   while another is dropped at the end at the same time. Due to the 
                   granularity of 30 seconds, everything just until 5 minutes 30 
                   seconds will also end up in this box. The default value for ttl 
                   is 60 seconds. If ttl is set to 0 which means that objects life 
                   in cache for unlimited time and may only discarded by a capacity 
                   limit.
                </td></tr><tr><td>monitor</td><td>
                   The monitor intervall in minutes when hashbelt cache rports the 
                   current number of containers used and objects cached. If set to 0 
                   (default) monitoring is disabled.
                </td></tr><tr><td>container-class</td><td>
                   The implementation of 
                   <span class="interface">org.castor.cache.hashbelt.container.Container</span>
                   interface to be used for all containers of the cache. 
                   Castor provides the following 3 implementations of the Container 
                   interface.
                    <div class="itemizedlist"><ul type="disc"><li><p>
                           org.castor.cache.hashbelt.container.FastIteratingContainer
                        </p></li><li><p>
                          org.castor.cache.hashbelt.container.MapContainer
                        </p></li><li><p>
                          org.castor.cache.hashbelt.container.WeakReferenceContainer
                        </p></li></ul></div>
                    If not specified the MapContainer will be used as default.
                </td></tr><tr><td>reaper-class</td><td>
                   Specific reapers yield different behaviors. The GC reaper, 
                   the default, just dumps the contents to the garbage collector. 
                   However, custom implementations may want to actually do something 
                   when a bucket drops off the end; see the javadocs on other available 
                   reapers to find a reaper strategy that meets your behavior 
                   requirements. Apart of the default 
                   <code class="classname">org.castor.cache.hashbelt.reaper.NullReaper</code> we provide 
                   3 abstract implementations of 
                   <span class="interface">org.castor.cache.hashbelt.reaper.Reaper</span> interface:
                    <div class="itemizedlist"><ul type="disc"><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.NotifyingReaper
                          </code>
                        </p></li><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.RefreshingReaper
                          </code>
                        </p></li><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.ReinsertingReaper
                          </code>
                        </p></li></ul></div>
                    to be extended by your custom implementation.
                </td></tr></tbody></table></div></div><br class="table-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-fifo"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Configuration sample - fifo</b></p><div class="example-contents"><p>
            A <span class="bold"><strong>fifo</strong></span> cache with default values 
            explained above is specified by:
          </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"fifo"</span>/&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-lru"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Configuration sample - lru</b></p><div class="example-contents"><p>
            A <span class="bold"><strong>lru</strong></span> cache with capacity=300 and 
            ttl=300 is defined by:
          </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lru"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"300"</span>/&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>or better by:</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lru"</span>&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"300"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"300"</span>/&gt;
       &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-fifo-customized"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Configuration sample - fifo (custommized)</b></p><div class="example-contents"><p>An example of a customized configuration of a <span class="bold"><strong>fifo</strong></span> cache is:</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"fifo"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"container"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"600"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"monitor"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"container-class"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.castor.cache.hashbelt.container.WeakReferenceContainer"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"reaper-class"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.castor.cache.hashbelt.reaper.NullReaper"</span>/&gt;
       &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration.clustered-environments"></a>4.1.5.&nbsp;Caching and clustered environments</h3></div></div></div><p>
           All of the cache providers added with release 0.9.9 are distributed caches 
           per se or can be configured to operate in such a mode. This effectively 
           allows Castor JDO to be used in a clustered J2EE (multi-JVM) environment, 
           where Castor JDO runs on each of the cluster instances, and where cache 
           state is automatically snychronized between these instances.
        </p><p>
           In such an environment, Castor JDO wil make use of the underlying cache 
           provider to replicate/distribute the content of a specific cache between 
           the various JDOManager instances. Through the distribution mechanism of 
           the cache provider, a client of a Castor JDO instance on one JVM will see 
           any updates made to domain objects performed against any other JVM/JDO 
           instance.
        </p><div class="example"><a name="advanced-jdo.caching.configuration.sample-coherence"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Configuration sample - Coherence</b></p><div class="example-contents"><p>The following class mapping, for example, ... </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"coherence"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
               defines that for all objects of type 
               <code class="literal">com.xyz.MyOtherObject</code> Tangosol's 
               <span class="italic">Coherence</span> cache provider should 
               be used.
            </p></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.sample-gigaspaces"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Configuration sample - Gigaspaces</b></p><div class="example-contents"><p>The following class mapping, for example, ... </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"gigaspaces"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
               defines that for all objects of type 
               <code class="literal">com.xyz.MyOtherObject</code> the 
               <span class="italic">Gigaspaces</span> cache provider should 
               be used. As Gigspaces supports various cache and clsuer modes, this 
               cache provider allows product-specific configuration as shown below:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"gigaspaces"</span> &gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"spaceURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/./"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"spaceProperties"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"useLocalCache"</span> /&gt;
        &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.custom-provider"></a>4.1.6.&nbsp;Custom cache provider</h3></div></div></div><p>
          As of release 0.9.6, Castor allows for the addition of user-defined cache 
          implementations. Whilst Castor provides a set of pre-built cache providers, 
          offering a variety of different cache algorithms, special needs still might
          require the application developer to implement a custom cache 
          algorithm. Castor facilitates such need by making available standardized
          interfaces and an easy to understand recipe for integrating a custom 
          cache provider with Castor.
       </p><p>
          As explained in <span class="package">org.exolab.castor.jdo.persist</span> 
          (API docs for the persists package), 
          <code class="classname">org.exolab.castor.persist.LockEngine</code> implements 
          a persistence engine that caches objects in memory for performance reasons 
          and thus reduces the number of operations against the persistence storage.
       </p><p>
          The main component of this package is the interface 
          <span class="interface">org.castor.cache.Cache</span>, which declares the external 
          functionality of a (performance) cache. Existing (and future) cache 
          implementations (have to) implement this interface, which is closely 
          modelled after the <span class="interface">java.util.Map</span> interface.
          </p><p>
          Below is a summary of the steps required to build a custom cache provider 
          and register it with Castor JDO:
       </p><p>
         </p><div class="orderedlist"><ol type="1"><li><p>
                Create a class that implements 
                <span class="interface">org.exolab.castor.persist.cache.Cache</span>.
              </p></li><li><p>
                Create a class that implements 
                <span class="interface">org.exolab.castor.persist.cache.CacheFacto</span>
              </p></li><li><p>
                Register your custom cache implementation with Castor JDO in the
                <code class="filename">castor.properties</code> file.
              </p></li></ol></div><p>
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.cache-implementation"></a>4.1.6.1.&nbsp;Cache implementation</h4></div></div></div><p>
               Please create a class that implements the interface
               <span class="interface">org.exolab.castor.persist.cache.Cache"&gt;Cache</span>.
            </p><p>
               To assist users in this task, a 
               <code class="classname">org.castor.cache.AbstractBaseCache</code> 
               class has been supplied, which users should derive their custom 
               <code class="classname">org.castor.cache.Cache</code> instances 
               from, if they wish so. Please consult existing 
               <code class="classname">org.castor.cache.Cache</code> implementations such as 
               <code class="classname">org.castor.cache.simple.TimeLimited</code>} or 
               <code class="classname">org.castor.cache.simple.CountLimited</code> 
               for code samples.
            </p><pre class="programlisting">
<span class="hl-comment">/**
 * My own cache implementation
 */</span> 
 <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomCache <span class="hl-keyword">extends</span> AbstractBaseCache {
 
    ...
    
 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.cachefactory-implementation"></a>4.1.6.2.&nbsp;CacheFactory implementation</h4></div></div></div><p>
               Please add a class that imnplements the 
               <span class="interface">org.castor.cache.CacheFactory</span> interface 
               and make sure that you provide valid values for the two 
               properties <code class="literal">name</code> and <code class="literal">className</code>.
            </p><p>
               To assist users in this task, a 
               <code class="classname">org.castor.cache.AbstractCacheFactory</code> 
               class has been supplied, which users should derive their custom 
               <span class="interface">org.castor.cache.CacheFactory</span> instances 
               from, if they wish so. Please consult existing 
               <span class="interface">org.castor.cache.CacheFactory</span> implementations 
               such as <code class="classname">org.castor.cache.simple.TimeLimitedFactory</code>} or 
               <code class="classname">org.castor.cache.simple.CountLimitedFactory</code> 
               for code samples.
            </p><pre class="programlisting">
<span class="hl-comment">/**
 * My own cache factory implementation
 */</span> 
 <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomCacheFactory <span class="hl-keyword">extends</span> AbstractCacheFactory {
 
    <span class="hl-comment">/**
     * The name of the factory
     */</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String NAME = <span class="hl-string">"custom"</span>;

    <span class="hl-comment">/**
     * Full class name of the underlying cache implementation.
     */</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CLASS_NAME = <span class="hl-string">"my.company.project.CustomCache"</span>; 
    
    <span class="hl-comment">/**
     * Returns the short alias for this factory instance.
     * @return The short alias name. 
     */</span>
    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> NAME;
    }
    
    <span class="hl-comment">/**
     * Returns the full class name of the underlying cache implementation.
     * @return The full cache class name. 
     */</span>
    <span class="hl-keyword">public</span> String getCacheClassName() {
        <span class="hl-keyword">return</span> CLASS_NAME;   
    }
    
 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.configuration"></a>4.1.6.3.&nbsp;Configuration</h4></div></div></div><p>
               The file <code class="filename">castor.properties</code> holds a property
               <code class="literal">org.castor.cache.Factories</code> that enlists the available
               cache types through their related CacheFactory instances.
            </p><pre class="programlisting">
# 
# Cache implementations
# 
org.castor.cache.Factories=\
  org.castor.cache.simple.NoCacheFactory,\
  org.castor.cache.simple.TimeLimitedFactory,\
  org.castor.cache.simple.CountLimitedFactory,\
  org.castor.cache.simple.UnlimitedFactory,\
  org.castor.cache.distributed.FKCacheFactory,\
  org.castor.cache.distributed.JcsCacheFactory,\
  org.castor.cache.distributed.JCacheFactory,\
  org.castor.cache.distributed.CoherenceCacheFactory,\
  org.castor.cache.distributed.OsCacheFactory,\
  org.castor.cache.hashbelt.FIFOHashbeltFactory,\
  org.castor.cache.hashbelt.LRUHashbeltFactory</pre><p>
               To add your custom cache implementation, please append the 
               fully-qualified class name to this list as shown below:
            </p><pre class="programlisting">
# 
# Cache implementations
# 
org.castor.cache.Factories=\
  org.castor.cache.simple.NoCacheFactory,\
  org.castor.cache.simple.TimeLimitedFactory,\
  org.castor.cache.simple.CountLimitedFactory,\
  org.castor.cache.simple.UnlimitedFactory,\
  org.castor.cache.distributed.FKCacheFactory,\
  org.castor.cache.distributed.JcsCacheFactory,\
  org.castor.cache.distributed.JCacheFactory,\
  org.castor.cache.distributed.CoherenceCacheFactory,\
  org.castor.cache.distributed.OsCacheFactory,\
  org.castor.cache.hashbelt.FIFOHashbeltFactory,\
  org.castor.cache.hashbelt.LRUHashbeltFactory,\
  <span class="bold"><strong>org.whatever.somewhere.nevermind.CustomCache</strong></span></pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.cachemanager"></a>4.1.7.&nbsp;CacheManager - monitoring and clearing caches</h3></div></div></div><p>
	     Sometimes it is necessary to interact with Castor's (performance) caches to 
         e.g.  (selectively) clear a Castor cache of its content, or inquire about 
         whether a particular object instance (as identified by its identity) is 
         cached already.
      </p><p>
	     For this purpose a 
         <code class="classname">org.exolab.castor.jdo.CacheManager</code> can 
	     be obtained from a <code class="classname">org.exolab.castor.jdo.Database</code> 
         instance by issuing the following code:
      </p><pre class="programlisting">
	  
JDO jdo = ....;
Database db = jdo.getDatabase();
CacheManager manager = db.getCacheManager();
	  </pre><p>
	     This instance can subsequently be used to selectively clear the 
         Castor performance cache using one of the following methods:
      </p><p>
	     </p><div class="itemizedlist"><ul type="disc"><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache()</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class,Object)</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class,Object[])</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class[])</code>
	          </p></li></ul></div><p>
	  </p><p>
	     To inquire whether an object has already been cached, please use the 
         following method:
      </p><p>
	     </p><div class="itemizedlist"><ul type="disc"><li><p>
	            <code class="methodname">org.exolab.castor.jdo.CacheManager.isCached (Class, Object);</code>
	          </p></li></ul></div><p>
	  </p><p>
	     Please note that once you have closed the Database instance from which you 
         have obtained the CacheManager, the CacheManager cannot be used anymore and 
         will throw a 
	     <code class="exceptionname">org.exolab.castor.jdo.PersistenceException</code>.
	  </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.oql-to-sql-translator"></a>4.2.&nbsp;OQL to SQL translator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.news"></a>4.2.1.&nbsp;News</h3></div></div></div><p>
               <span class="bold"><strong>Release 0.9.6</strong></span>:
               </p><div class="itemizedlist"><ul type="disc"><li><p>
                      Added support for LIMIT clause for MS SQL Server.
                    </p></li><li><p>
                      In the case a RDBMS does not support LIMIT/OFFSET clauses, a
                      SyntaxNotSupportedException is thrown.
                    </p></li><li><p>
                      Added support for a limit clause and an offset clause. 
                      Currently, only HSQL, mySQL and postgreSQL are supported.
                    </p></li><li><p>
                      Added an 
                      <a href="advanced-jdo.html#advanced-jdo.oql-to-sql-translator.examples" title="4.2.10.&nbsp;Examples">example 
                      section</a>.
                    </p></li></ul></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.status"></a>4.2.2.&nbsp;Status</h3></div></div></div><p>
                The Castor OQL implementation is currently in phase 3 of development.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                This documentation is not yet finished
              </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.introduction"></a>4.2.3.&nbsp;Introduction</h3></div></div></div><p>
               This document describes an OQL to SQL translator to be added to the
               Castor JDO Java object 
               <a href="advanced-jdo.html#advanced-jdo.persist.api" title="4.4.2.&nbsp;Persistence API">Persistence API</a>. 
               The translator will accept OQL queries passed as strings, and generate 
               a parse tree of the OQL. It will then traverse the tree creating the 
               appropriate SQL. The user will then be able to bind parameters to 
               parameterized queries. Type checking will be performed on the bound 
               parameters. When the user executes the query, the system will submit 
               the query to the SQL database, and then postprocess the SQL resultset 
               to create the appropriate result as a Java Object or literal. The 
               current <span class="package">org.exolab.castor.mapping</span> and
               <span class="package">org.exolab.castor.persist</span> packages will be used 
               for metadata and RDBMS communication.
            </p><p>
               Four of the (now defunct) SourceXchange milestones for this project 
               call for java source code. These milestones will be referred to here 
               as phase 1, 2, 3, and 4. There are many possible OQL features that 
               can be supported, but weren't discussed in the proposal or RFP. 
               Many of these are probably unwanted. These additional features are 
               specified as phase 5, which is out of the scope of this SourceXChange 
               project.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.overview"></a>4.2.4.&nbsp;Overview</h3></div></div></div><p>
                The parser will construct a parse tree as output from an OQL query
                string given as input. The OQL syntax is a subset of the syntax
                described in the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.odmg.org/" target="_top">ODMG 3.0</a> 
                specification section 4.12, with some additional constructs. 
                Following is a description of the supported OQL syntax, and its SQL 
                equivalent.
            </p><p>
                Certain features of OQL may not be directly translatable to SQL, but
                may still be supported, by post processing the query. For example, the
                <span class="bold"><strong>first()</strong></span> and 
                <span class="bold"><strong>last()</strong></span> collection functions supported 
                in OQL are not directly translatable to standard SQL, but a resultset 
                can be post-processed to return the appropriate values. Features 
                requiring post-processing of SQL resultsets will be documented as such
                below.
            </p><p>
               Currently the OQLQuery checks for correct syntax at the same time as
               it does type checking and other types of error checking. The new code
               will involve a multiple pass strategy, with the following passes:
               </p><div class="orderedlist"><ol type="1"><li><p>
                       Parse the String query checking for syntax errors, and return
                       a parse tree.
                    </p></li><li><p>
                       Traverse the parse tree checking for correct types, valid 
                       member and method identifiers, and use of features which are 
                       unsupported. This pass may also generate some data necessary 
                       for creating the SQL.
                    </p></li><li><p>
                       Traverse the tree one final time, creating the equivalent SQL
                       statement to the OQL Query originally passed.
                    </p></li></ol></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.syntax"></a>4.2.5.&nbsp;Syntax</h3></div></div></div><p>
               This section describes the first pass which will be done by the
               parser. The parser will create a StringTokenizer like this:
               </p><pre class="programlisting">
StringTokenizer tokenizer
    = <span class="hl-keyword">new</span> StringTokenizer(oql,
    <span class="hl-string">"\n\r\t,.()[]+-*/&lt;&gt;=:|$"</span>, true);</pre><p>
               This will create a StringTokenizer with the delimiter
               characters listed in the second argument, and it will return delimeters
               as well as tokens. The parser will also create a Vector to be used as a
               token buffer. As tokens are returned from the StringTokenizer they will 
               be added to the Vector. Older tokens will be removed from the Vector 
               when it reaches a certain size. The Vector will also be modified when 
               the StringTokenizer returns multi character operators as seperate 
               tokens, for example the -&gt; method invocation operator.
            </p><p>
               The parser will consume tokens from the StringTokenizer, generating a
               ParseTree. Each ParseTree node will have a nodeType corresponding to 
               its symbol in the OQL syntax. After each node is created it will look 
               at the next token and act acordingly, either modifying its properties 
               (i.e. for DISTINCT property of selectExpr), creating a new child node 
               or returning an error. If the error travels up to the root node of the
               ParseTree, there is a syntax error in the OQL submitted. At the end of 
               this pass, the ParseTree will contain an apropriate representation of 
               the query, which will be analyzed, and used to create SQL. Below is 
               the modified EBNF which will be the Castor OQL syntax.
            </p><p>
               </p><pre class="programlisting">
query                   ::= selectExpr
                            | expr

selectExpr              ::= <span class="bold"><strong>select</strong></span> [<span class="bold"><strong>distinct</strong></span>] 
                            projectionAttributes
                            fromClause
                            [whereClause]
                            [groupClause]
                            [orderClause]
                            [limitClause [offsetClause]]

projectionAttributes    ::= projectionList
                          | *

projectionList          ::= projection {, projection }

projection              ::= field
                          | expr [<span class="bold"><strong>as</strong></span> identifier]

fromClause              ::= <span class="bold"><strong>from</strong></span> iteratorDef {, iteratorDef}

iteratorDef             ::= identifier [ [<span class="bold"><strong>as</strong></span> ] identifier ]
                          | identifier <span class="bold"><strong>in</strong></span> identifier

whereClause             ::= <span class="bold"><strong>where</strong></span> expr

groupClause             ::= <span class="bold"><strong>group by</strong></span> fieldList {havingClause}

havingClause            ::= <span class="bold"><strong>having</strong></span> expr

orderClause             ::= <span class="bold"><strong>order by</strong></span> sortCriteria

limitClause             ::= <span class="bold"><strong>limit </strong></span> queryParam

offsetClause            ::= <span class="bold"><strong>offset</strong></span> queryParam

sortCriteria            ::= sortCriterion {, sortCriterion }

sortCriterion           ::= expr [ (<span class="bold"><strong>asc</strong></span> | <span class="bold"><strong>desc</strong></span>) ]

expr                    ::= castExpr

castExpr                ::= orExpr
                            | <span class="bold"><strong>(</strong></span> type <span class="bold"><strong>)</strong></span> castExpr

orExpr                  ::= andExpr {<span class="bold"><strong>or</strong></span> andExpr}

andExpr                 ::= quantifierExpr {<span class="bold"><strong>and</strong></span> quantifierExpr}

quantifierExpr          ::= equalityExpr
                            | <span class="bold"><strong>for all</strong></span> inClause <span class="bold"><strong>:</strong></span> equalityExpr
                            | <span class="bold"><strong>exists</strong></span> inClause <span class="bold"><strong>:</strong></span> equalityExpr

inClause                ::= identifier <span class="bold"><strong>in</strong></span> expr

equalityExpr            ::= relationalExpr
                            {(<span class="bold"><strong>=</strong></span> | <span class="bold"><strong>!=</strong></span>) 
                                [compositePredicate] relationalexpr }
                            | relationalExpr {<span class="bold"><strong>like</strong></span> relationalExpr}

relationalExpr          ::= additiveExpr
                            {(<span class="bold"><strong>&lt;</strong></span> | <span class="bold"><strong>&lt;=</strong></span> 
                                | <span class="bold"><strong>&gt;</strong></span> | <span class="bold"><strong>&gt;=</strong></span> ) 
                                    [ compositePredicate ] additiveExpr }
                                | additiveExpr <span class="bold"><strong>between</strong></span> 
                                    additiveExpr <span class="bold"><strong>and</strong></span> additiveExpr

compositePredicate      ::= <span class="bold"><strong>some</strong></span> | <span class="bold"><strong>any</strong></span> | <span class="bold"><strong>all</strong></span>

additiveExpr            ::= multiplicativeExpr
                                {<span class="bold"><strong>+</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>-</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>union</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>except</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>||</strong></span> multiplicativeExpr}

multiplicativeExpr      ::= inExpr {<span class="bold"><strong>*</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>/</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>mod</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>intersect</strong></span> inExpr}

inExpr                  ::= unaryExpr {<span class="bold"><strong>in</strong></span> unaryExpr}

unaryExpr               ::= <span class="bold"><strong>+</strong></span> unaryExpr
                            | <span class="bold"><strong>-</strong></span> unaryExpr
                            | <span class="bold"><strong>abs</strong></span> unaryExpr
                            | <span class="bold"><strong>not</strong></span> unaryExpr
                            | postfixExpr

postfixExpr             ::= primaryExpr{<span class="bold"><strong>[</strong></span> index <span class="bold"><strong>]</strong></span>}
                            | primaryExpr
                            {(<span class="bold"><strong>.</strong></span> | <span class="bold"><strong>-&gt;</strong></span>)identifier[arglist]}

index                   ::= expr {<span class="bold"><strong>,</strong></span> expr}
                            | expr <span class="bold"><strong>:</strong></span> expr

argList                 ::= <span class="bold"><strong>(</strong></span>[ valueList ]<span class="bold"><strong>)</strong></span>

primaryExpr             ::= conversionExpr
                            | collectionExpr
                            | aggregateExpr
                            | undefinedExpr
                            | collectionConstruction
                            | identifier[ arglist ]
                            | queryParam
                            | literal
                            | <span class="bold"><strong>(</strong></span> query <span class="bold"><strong>)</strong></span>

conversionExpr          ::= <span class="bold"><strong>listtoset(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>element(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>distinct(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>flatten(</strong></span> query <span class="bold"><strong>)</strong></span>

collectionExpr          ::= <span class="bold"><strong>first(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>last(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>unique(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>exists(</strong></span> query <span class="bold"><strong>)</strong></span>

aggregateExpr           ::= <span class="bold"><strong>sum(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>min(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>max(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>avg(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>count(</strong></span>( query | * )<span class="bold"><strong>)</strong></span>

undefinedExpr           ::= <span class="bold"><strong>is_undefined(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>is_defined(</strong></span> query <span class="bold"><strong>)</strong></span>

fieldList               ::= field {, field}

field                   ::= identifier<span class="bold"><strong>:</strong></span> expr

collectionConstruction  ::= <span class="bold"><strong>array(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>set(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>bag(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>list(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>list(</strong></span>listRange<span class="bold"><strong>)</strong></span>

valueList               ::= expr {, expr}

listRange               ::= expr..expr

queryParam              ::= <span class="bold"><strong>$</strong></span>[(type)]longLiteral

type                    ::= [<span class="bold"><strong>unsigned</strong></span>] <span class="bold"><strong>short</strong></span>
                            | [<span class="bold"><strong>unsigned</strong></span>] <span class="bold"><strong>long</strong></span>
                            | <span class="bold"><strong>long long</strong></span>
                            | <span class="bold"><strong>float</strong></span>
                            | <span class="bold"><strong>double</strong></span>
                            | <span class="bold"><strong>char</strong></span>
                            | <span class="bold"><strong>string</strong></span>
                            | <span class="bold"><strong>boolean</strong></span>
                            | <span class="bold"><strong>octet</strong></span>
                            | <span class="bold"><strong>enum</strong></span> [identifier.]identifier
                            | <span class="bold"><strong>date</strong></span>
                            | <span class="bold"><strong>time</strong></span>
                            | <span class="bold"><strong>interval</strong></span>
                            | <span class="bold"><strong>timestamp</strong></span>
                            | <span class="bold"><strong>set &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>bag &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>list &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>array &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>dictionary &lt;</strong></span>type, type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>identifier</strong></span>

identifier              ::= letter{letter| digit| _}

literal                 ::= booleanLiteral
                            | longLiteral
                            | doubleLiteral
                            | charLiteral
                            | stringLiteral
                            | dateLiteral
                            | timeLiteral
                            | timestampLiteral
                            | <span class="bold"><strong>nil</strong></span>
                            | <span class="bold"><strong>undefined</strong></span>

booleanLiteral          ::= <span class="bold"><strong>true</strong></span>
                            | <span class="bold"><strong>false</strong></span>

longLiteral             ::= digit{digit}

doubleLiteral           ::= digit{digit}.digit{digit}
                            [(<span class="bold"><strong>E</strong></span> | <span class="bold"><strong>e</strong></span>)[<span class="bold"><strong>+</strong></span>|<span class="bold"><strong>-</strong></span>]digit{digit}]

charLiteral             ::= 'character'

stringLiteral           ::= "{character}"

dateLiteral             ::= <span class="bold"><strong>date</strong></span>
                                'longliteral-longliteral-longliteral'

timeLiteral             ::= <span class="bold"><strong>time</strong></span>
                                'longliteral:longLiteral:floatLiteral'

timestampLiteral        ::= <span class="bold"><strong>timestamp</strong></span>
                                'longLiteral-longLiteral-longLiteral
                                longliteral:longLiteral:floatLiteral'

floatLiteral            ::= digit{digit}.digit{digit}

character               ::= letter
                            | digit
                            | special-character

letter                  ::= <span class="bold"><strong>A</strong></span>|<span class="bold"><strong>B</strong></span>|...|<span class="bold"><strong>Z</strong></span>|
                            <span class="bold"><strong>a</strong></span>|<span class="bold"><strong>b</strong></span>|...|<span class="bold"><strong>z</strong></span>

digit                   ::= <span class="bold"><strong>0</strong></span>|<span class="bold"><strong>1</strong></span>|...|<span class="bold"><strong>9</strong></span>

special-character       ::= <span class="bold"><strong>?</strong></span>|<span class="bold"><strong>_</strong></span>|<span class="bold"><strong>*</strong></span>|<span class="bold"><strong>%</strong></span>|<span class="bold"><strong>\</strong></span>
               </pre><p>
            </p><p>
              The following symbols were removed from the standard OQL Syntax for
              the following reasons:

              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="bold"><strong>andthen</strong></span>: Cannot be implemented in
                    a single SQL query. 
                  </p></li><li><p>
                    <span class="bold"><strong>orelse</strong></span>: Same as above. 
                  </p></li><li><p>
                    <span class="bold"><strong>import</strong></span>: This is advanced
                    functionality which may be added later. This phase will use the
                    castor mapping mechanism to define the namespace. 
                  </p></li><li><p>
                    Defined Queries: This is another feature
                    which can be added later. It is unclear where the queries would be
                    stored, and what their scope would be seeing as how this project
                    is an OQL to SQL translator, and not an ODBMS. 
                  </p></li><li><p>
                    iteratorDef was changed so that all
                    instances of expr were replaced by identifier. This means that the
                    from clause can only contain extent names (class names), rather
                    than any expression. This is the most common case and others could
                    create complicated SQL sub-queries or post-processing
                    requirements.
                  </p></li><li><p>
                    objectConstruction and
                    structConstruction were removed. What is the scope of the
                    constructed object or struct, and how is a struct defined in Java?
                  </p></li></ul></div><p>
            </p><p>
              The following symbols were added or modified.
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="bold"><strong>between</strong></span> added to relationalExpr.
                  </p></li><li><p>
                    Optional type specification added to
                    queryParam. 
                  </p></li></ul></div><p>
            </p><p>
	            The rest of the standard OQL syntax remains unchanged. 
	            Certain syntactically correct queries may not be supported in Castor. 
	            For example, top level expressions which do not contain a selectExpr 
	            anywhere in the query may not be supported. This will be discussed 
	            further in the next section.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.type-and-validity-checking"></a>4.2.6.&nbsp;Type and validity checking</h3></div></div></div><p>
	            The first pass over the ParseTree will do type checking, and create some
	            structures used in the SQL generation pass. It will also check whether
	            the identifiers used are valid, and whether the query uses unsupported
	            features. The following table describes each type of node in the 
	            ParseTree, and how it will be processed in the first pass.
	        </p><p>
            </p><div class="table"><a name="d4e8302"></a><p class="title"><b>Table&nbsp;4.3.&nbsp;The first pass</b></p><div class="table-contents"><table summary="The first pass" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>expr</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            A query whose top level element is an expr, rather 
			                            than a selectExpr will not be supported within the 
			                            scope of this project. These queries can either be 
			                            stated as a selectExpr, like aggregateExpr's, or 
			                            they would require post-processing of the SQL 
			                            results, like 
			                            <span class="bold"><strong>element()</strong></span>
			                            <span class="bold"><strong>first()</strong></span> and 
			                            <span class="bold"><strong>last()</strong></span>.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projectionAttributes</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
		                                select * will return a Collection of Arrays of Objects.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projectionList</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Selecting multiple fields will return a Collection 
			                            of Arrays of Objects.
		                            </p></li><li><p>
			                            When there are multiple fields selected, 
			                            a list of field names and aliases will be kept for 
			                            checking validity of expr's in the whereClause, 
			                            groupClause, and orderClause.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>Alias identifier will be stored.</p></li><li><p>
		                                 expr in projection may only be identifier, 
		                                 without an arglist.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            expr in projection may only be identifier 
			                            (with optional argList), aggregateExpr, undefinedExpr, 
			                            and postfixExpr (for selecting fields and accessors).
		                            </p></li><li><p>
			                            The subquery in aggregateExpr and undefinedExpr can be 
			                            identifier (with optional arglist), or postfixExpr for 
			                            applying these functions to fields and accessors.
		                            </p></li><li><p>
			                            If an identifier before the 
			                            <span class="bold"><strong>.</strong></span> or 
			                            <span class="bold"><strong>-&gt;</strong></span> contains an 
			                            arglist, it will be considered a SQL function, and 
			                            passed through to the RDBMS.
		                            </p></li><li><p>
			                            If the postfixExpr contains one of the above 
			                            operators, the mapping mechanism will be used 
			                            to determine if the path expression is valid 
			                            and to generate a list of required join tables, 
			                            using the manyKey and manyTable from the 
			                            JDOFieldDescriptor.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>fromClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            The class of the extent being selected from will be 
			                            stored, and ClassDescriptor objects will be 
			                            instantiated.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            expr in whereClause may onlycontain orExpr, 
			                            andExpr, equalityExpr (without compositePredicate), 
			                            relationalExpr, additiveExpr (without set operators 
			                            <span class="bold"><strong>union</strong></span> and 
			                            <span class="bold"><strong>except</strong></span>), 
			                            multiplicativeExpr (without set operator 
			                            <span class="bold"><strong>intersect</strong></span>), 
			                            unaryExpr, postFixExpr (must be only primaryExpr, 
			                            no array or property reference or method calls).
		                            </p></li><li><p>
			                            primaryExpr may only contain identifier (without an 
			                            argList), literal and queryParam. Identifier will 
			                            be checked against object name and alias in 
			                            projectionList.
		                            </p></li><li><p>
			                            For equalityExpr, relationalExpr, aditiveExpr, 
			                            multiplicativeExpr, the left side and right side 
			                            expr's must evaluate to comparable types.
		                            </p></li><li><p>
			                            For unaryExpr, simple type checking for numerical 
			                            or character based types will be performed.
		                            </p></li><li><p>
			                            If the operands for any of the relational, 
			                            equality, additive, multiplicative, or unary 
			                            operators is a query parameter, an expected type 
			                            will be determined. If the parameter included a 
			                            specified type which is incompatible with the 
			                            system determined type, an error will be generated.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Support for built in OQL functions will be added 
			                            to the whereClause: is_defined, is_undefined.
		                            </p></li><li><p>inExpr will be supported in whereClause.</p></li><li><p>
			                            inExpr will only allow collectionConstruction for 
			                            the right side argument to 
			                            <span class="bold"><strong>in</strong></span>. No subQueries
			                            will be allowed.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            identifiers will be able to contain an 
			                            optional arglist. If the arglist is before a 
			                            <span class="bold"><strong>.</strong></span> or 
			                            <span class="bold"><strong>-&gt;</strong></span> the 
			                            identifier will be considered a SQL function and 
			                            will be passed through to the DBMS. Otherwise, 
			                            the identifier will be for an accessor method, 
			                            or a property name.
		                            </p></li><li><p>
			                            Accessor methods and property references will cause 
			                            a check through the ClassDescriptor and 
			                            FieldDescriptors for the object type, and the 
			                            required join tables.
		                            </p></li></ul></div>
		                </td><td>Phase 3</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
		                                compositePredicate will be suported in equalityExpr.
		                            </p></li><li><p>exists(query) will be supported.</p></li><li><p>
			                            quantifierExpr will support 
			                            <span class="bold"><strong>for all</strong></span> and 
			                            <span class="bold"><strong>exists</strong></span>.
		                            </p></li><li><p>
			                            Subqueries will be supported on the right side of
			                            the <span class="bold"><strong>in</strong></span> operator.
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr><tr><td>groupClause, havingClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Will identify appropriate fields
			                            in SQL schema for each expr.
		                            </p></li><li><p>aggregateExpr will be supported.</p></li><li><p>
			                            Only expr's which translate to SQL columns which 
			                            are already being selected will be supported.
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr><tr><td>orderClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            May only contain expr's which translate into SQL 
			                            columns which are already being selected.
		                            </p></li></ul></div>
		                </td><td>Phase 3</td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.sql-generation"></a>4.2.7.&nbsp;SQL Generation</h3></div></div></div><p>
            After the first pass, the ParseTree is free of errors, and ready for
            the SQL generation step. The existing implementation of the OQLParser
            uses the persistence API for SQL generation. This API lacks the
            necessary features to generate SQL from any OQL. The SQLEngine class
            which implements Persistence is used to create a JDBCQueryExpression.
            The SQL is derived from the finder, which is a JDBCQueryExpression
            produced by the SQLEngine. The problem is that the SQLEngine only
            supports single objects. It cannot generate SQL for path expressions
            like this:
            </p><pre class="programlisting">
select p.address from Person p </pre><p>

            This query requires a SQL statement like this:
            </p><pre class="programlisting">
select address.* from person, address
    where person.address_id = address.address_id</pre><p>
            The buildFinder method should not be used to generate a
            queryExpression. The SQLEngine should be used to get a ClassDescriptor,
            and to create a new QueryExpression. The OQLParser should use the
            methods in the QueryExpression to generate the SQL. The
            JDBCQueryExpression which is an implementation of QueryExpression is
            also lacking in necessary features. This class should continue to be
            used, but the following features will need to be added:
            </p><div class="variablelist"><dl><dt><span class="term">addColumn(String)</span></dt><dd><p>
	                  For adding something to select without specifying the tablename,
	                  for use with functions (i.e. select count(*))
                  </p></dd><dt><span class="term">addTable(String)</span></dt><dd><p>For when the table has to be added manually.</p></dd><dt><span class="term">addCondition(String)</span></dt><dd><p>
	                    Add a condition created outside the class, for nested 
	                    expressions, and other expressions that are not of the form 
	                    table.column op table.column.
                    </p></dd><dt><span class="term">setDistinct(boolean)</span></dt><dd><p>Used for select distinct.</p></dd><dt><span class="term">
                    addOrderColumn(String tableName, String columnName, boolean desc)
                </span></dt><dd><p>Used for order by</p></dd><dt><span class="term">addGroupExpr(String)</span></dt><dd><p>Used for group by</p></dd><dt><span class="term">addHavingExpr(String)</span></dt><dd><p>Used for having.</p></dd></dl></div><p>
        </p><p>
            The following table lists each type of tree node, and how it will be 
            processed in the SQL generation pass.
        </p><p>
            </p><div class="table"><a name="d4e8475"></a><p class="title"><b>Table&nbsp;4.4.&nbsp;SQL generation pass</b></p><div class="table-contents"><table summary="SQL generation pass" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>selectExpr</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                        distinct in the selectExpr will result in a call to
			                        setDistinct(true) in the queryExpr.
		                          </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                        The queryExpr will be populated with the columns 
			                        and tables necessary to retrieve the object. This 
			                        will use code similar to SQLEngine.addLoadSql(...).
		                          </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            aggregateExpr and SQL functions
			                            will be passed to addColumn.
		                            </p></li><li><p>
			                            undefinedExpr will be translated to 
			                            <span class="bold"><strong>is null</strong></span> and 
			                            <span class="bold"><strong>is not null</strong></span>
		                            </p></li><li><p>
			                            postfixExpr (for selecting fields and 
			                            accessors) will result in a different group 
			                            of select expressions and "from tables" being
			                            generated.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Entire expr in where clause will be translated, 
			                            and then added to the QueryExpr, using a single 
			                            call to addCondition(String), and multiple 
			                            calls to addTable(String).
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            <span class="bold"><strong>is_defined()</strong></span>
			                             will translate into 
			                             <span class="bold"><strong>is not null</strong></span>
			                             and 
			                             <span class="bold"><strong>is_undefined()</strong></span>
			                             will translate into 
			                             <span class="bold"><strong>is null</strong></span>.
		                            </p></li><li><p>
			                            inExpr will translate directly, with the 
			                            collectionConstruction removed.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            compositePredicate and exists(query) 
			                            translate directly to SQL.
		                            </p></li><li><p>
			                            For quantifierExpr, 
			                            <span class="bold"><strong>exists</strong></span>
			                            will translate into an exists() SQL subquery. 
			                            <span class="bold"><strong>for all</strong></span>
			                            will translate into the contrapositive(?) 
			                            exists query, for example:
		
		                            </p><pre class="programlisting">
	for all x in teachers:
	    x.name = 'Nis'</pre><p>
	                            translates to:
	                            </p><pre class="programlisting">
	not exists (select * from teachers
	    where name != 'Nis')</pre><p>
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.oql-faq"></a>4.2.8.&nbsp;OQL FAQ</h3></div></div></div><p>
            Please see the <a href="jdo.html#jdo.faq.oql" title="3.7.5.&nbsp;OQL">OQL section</a>
            of the JDO FAQ.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.summary"></a>4.2.9.&nbsp;Summary</h3></div></div></div><p>
            The Parser and ParseTree classes will be improved through the phases
            of this project. The top level of OQL to SQL translation will look very
            simple, like this:
            </p><pre class="programlisting">
OQLParser parser = <span class="hl-keyword">new</span> OQLParser(query);
ParseTree pt = parser.getParseTree();
pt.checkPass();
<span class="hl-comment">//the SQL generation pass</span>
_expr = pt.getQueryExpr();
            </pre><p>

            These methods will have some additional parameters passed
            for storing and retrieving data relevant to the query. Following is a
            table containing a list of what will be introduced in each coding phase
            of the project.
        </p><p>
            </p><div class="table"><a name="d4e8548"></a><p class="title"><b>Table&nbsp;4.5.&nbsp;Coding phases</b></p><div class="table-contents"><table summary="Coding phases" border="1"><colgroup><col><col></colgroup><tbody><tr><td>Phase 1</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>
		                                New parser structure which generates symbol tree
		                            </p></li><li><p>
	                                    Parser still supports only limited OQL
	                                </p></li><li><p>selected field aliases</p></li><li><p>
	                                    whereClause supports or, and, equality, 
	                                    additive, multiplicative, and unary Operators.
	                                </p></li><li><p>support for specifying parameter types</p></li><li><p>
	                                    check specified parameter type
	                                    against system determined type
	                                </p></li><li><p>specifying ordered parameters.</p></li><li><p>
		                                JDBCQueryExpression must support
		                                addCondition(String condition)
	                                </p></li></ul></div>
	                     </td></tr><tr><td>Phase 2</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>
	                                    Distinct keyword will be supported in selectExpr
	                                </p></li><li><p>
		                                aggregateExpr and undefinedExpr supported in 
		                                projection (Select statement)
	                                </p></li><li><p>isDefined, isUndefined in whereClause</p></li><li><p>inExpr in whereClause</p></li><li><p>type checking/conversion in bind()</p></li><li><p>
		                                fields and accessors in the
		                                projection. Mapping mechanism may need some additional
		                                features.
	                                </p></li><li><p>SQL functions in the projection</p></li><li><p>order by</p></li></ul></div>
	                    </td></tr><tr><td>Phase 3</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>fields and accessors in whereClause</p></li><li><p>SQL functions in the where clause</p></li></ul></div>
	                    </td></tr><tr><td>Phase 4</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>sub queries</p></li><li><p>exists()</p></li><li><p>compositePredicate</p></li><li><p>quantifierExpr's: for all and exists</p></li><li><p>group by</p></li><li><p>having</p></li></ul></div>
	                    </td></tr><tr><td>Phase 5:</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>expr as top level symbol</p></li><li><p>
		                                queries selecting multiple fields or as
		                                comma separated list or * 
	                                </p></li></ul></div>
	                    </td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.examples"></a>4.2.10.&nbsp;Examples</h3></div></div></div><p>
          Please find below various examples of OQL queries using the Java class files 
          as outlined below.
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.oql-to-sql-translator.examples.java-class-files"></a>4.2.10.1.&nbsp;Java class files</h4></div></div></div><p>
              The following fragment shows the Java class declaration for the 
              <code class="classname">Product</code> class:
          </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product 
{
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name; 

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price; 

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}
	  </pre><p>
          The following fragment shows the Java class declaration for the 
          <code class="classname">ProductGroup</code> class:
      </p><pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.oql-to-sql-translator.limit-clause"></a>4.2.10.2.&nbsp;Limit Clause</h4></div></div></div><p>
            On a selected number of RDBMS, Castor JDO now supports the use of 
            LIMIT/OFFSET clauses.
         </p><p>
            As per this release, the following RDBMS have full/partial support for this
            feature.
         </p><div class="table"><a name="d4e8639"></a><p class="title"><b>Table&nbsp;4.6.&nbsp;Limit support</b></p><div class="table-contents"><table summary="Limit support" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">RDBMS</th><th>LIMIT</th><th>OFFSET</th></tr></thead><tbody><tr><td>postgreSQL</td><td>Yes</td><td>Yes</td></tr><tr><td>mySQL</td><td>Yes</td><td>Yes</td></tr><tr><td>Oracle - 1)2)</td><td>Yes</td><td>Yes</td></tr><tr><td>HSQL</td><td>Yes</td><td>Yes</td></tr><tr><td>MS SQL</td><td>Yes</td><td>-</td></tr><tr><td>DB2</td><td>Yes</td><td>-</td></tr></tbody></table></div></div><br class="table-break"><p>
            1) Oracle has full support for LIMIT/OFFSET clauses for release 8.1.6 and
            later.
         </p><p>
            2) For the LIMIT/OFFSET clauses to work properly the OQL query is required
			to include a ORDER BY clause.
	     </p><p>
            The following code fragment shows an OQL query that uses the LIMIT keyword 
            to select the first 10 ProductGroup instances.
         </p><pre class="programlisting">
query = db.getOQLQuery(<span class="hl-string">"select p from ProductGroup as p LIMIT $1"</span>);
query.bind(10);
         </pre><p>
            Below is the same OQL query again, restricting the number of ProductGroup instances
            returned to 10, though this time it is specified that the ProductGroup 
            instances 11 to 20 should be returned.
         </p><pre class="programlisting">
query = db.getOQLQuery (<span class="hl-string">"select p from ProductGroup as p LIMIT $1 OFFSET $2"</span>);
query.bind(10);
         </pre><p>
            In the case a RDBMS does not support LIMIT/OFFSET clauses, a 
            SyntaxNotSupportedException will be thrown.
         </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.locking"></a>4.3.&nbsp;Transaction And Locking Modes</h2></div><div><span xmlns:fo="http://www.w3.org/1999/XSL/Format" class="author"><span class="firstname">Assaf</span> <span class="surname">Arkin</span> 
            ()
            </span></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.model"></a>4.3.1.&nbsp;The JDO Model</h3></div></div></div><p>
           In order to understand how the JDO transaction model affects applications
           performance and transactional integrity, you must first understand the semantics
           of the Java Data Objects. Java Data Objects are objects loaded from and stored
           to the database, but are disassociated from the database itself. That is, once an
           object has been loaded into memory, changes to the object in memory are not
           reflect in the database until the transaction commits.
        </p><p>
           The following table shows a sample code and the state of the JDO object and
           the relevant database field:
        </p><div class="table"><a name="d4e8692"></a><p class="title"><b>Table&nbsp;4.7.&nbsp;JDO objects</b></p><div class="table-contents"><table summary="JDO objects" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Code</th><th>Object value</th><th>Record value</th></tr></thead><tbody><tr><td><code class="code">results = oql.execute();</code></td><td align="center">N/A</td><td align="center">X</td></tr><tr><td><code class="code">obj = results.next();</code></td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="code">obj.setValue( Y );</code></td><td align="center">Y</td><td align="center">X</td></tr><tr><td><code class="code">db.commit();</code></td><td align="center">Y</td><td align="center">Y</td></tr></tbody></table></div></div><br class="table-break"><p>
             Concurrency conflicts do not occur when an object is changed in memory,
             but rather when the transaction commits and changes are saved back to the
             database. No changes are saved if the transaction rolls back.
         </p><p>
             Conflicts could occur if two threads attempted to modify the same object,
             or the same thread receives two objects associated with the same database 
             record and performs different changes to each object. Castor solves these 
             issues through a transaction-object-identity association.
         </p><p>
             When the same transaction attempts to query the same database record twice,
             (e.g. as the result of two different queries) the same object is returned,
             assuring that different changes will be synchronized through the same 
             object.
         </p><p>
             When two transactions attempt to query the same database record, each 
             transaction receives a different object mapping to the same record, 
             assuring that changes done in one transaction are not visible to the 
             other transactions. Changes should only become visible when the 
             transaction commits and all its changes are made durable.
         </p><p>
             This approach places the responsibility of synchronization and deadlock 
             detection on the Castor persistence engine, easing the life of the 
             developer.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.modes"></a>4.3.2.&nbsp;Locking Modes</h3></div></div></div><p>
          Concurrent access requires use of locking to synchronize two transactions
          attempting to work with the same object. The locking mechanism has to take into
          account several possible use of objects, as well as help minimize database access
          through caching and is-modified checking.
      </p><p>
          Locking modes are declared in the <a href="jdo.html#jdo.mapping.file.class-element" title="3.6.3.2.&nbsp;The <class&gt; element">
          class element</a> of the XML mapping on a per class basis.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.shared"></a>4.3.2.1.&nbsp;Access mode: Shared</h4></div></div></div><p>
           The shared mode is the default for all objects, unless otherwise specified in the
           mapping file. Shared mode allows two transactions to read the same record at the
           same time. Each transaction will get it's own view of the record as a separate
           object, to prevent in-memory changes from conflicting with each other. However,
           the values loaded from the database are the same for both transactions.
        </p><p>
           When transactions query different objects or query the same objects but for
           read-only purposes, shared access provides the most efficient means of access
           in terms of performance, utilizing record caching and eliminating lock
           contention. For example, when each transaction retrieves a different Customer
           record and all transactions retrieved the same set of Department records but
           hardly ever change them, both Customer and Department should be declared as
           having a shared lock.
        </p><p>
           However, when two transactions attempt to access the same object, modify it,
           and commit the changes, a concurrency conflict will occur. Some concurrency
           conflicts can lead to one of the transactions aborting. For example, if two
           transactions happen to load the same Account object with a balance of X,
           one adds 50 and the other adds 60, if both were allowed to commit the changes
           the new account balance will be either X+50 or X+60, but not X+110.
        </p><p>
           In the above case either exclusive or db-locked modes should be used to
           reduce potential conflicts. However exclusive and db-locked modes may cause
           the application to perform slower due to lock contention and should not be
           used as the general case. In rare cases conflicts may occur where shared
           locks are the preferred choice, e.g. when two transactions attempt to
           modify the same Department object, or somehow get hold of the same Customer
           records.
        </p><p>
           Castor detects such conflicts as they occur and uses two mechanisms to
           deal with them: write locks and deadlock detection. When a transaction commits
           Castor first tries to determine whether the object has been modified from
           it's known state (i.e. during query). If the object has not been modified,
           Castor will not attempt to store the object to the database. If the object 
           has been modified, Castor acquires a write lock on the object preventing 
           other transactions from accessing the object until the current transaction 
           completes storing all changes to the database. A write lock prevents other 
           transactions from acquiring either a write or read lock, preventing them 
           from accidentally loading a dirty image of the object.
        </p><p>
           If the second transaction has a read lock on the object, the current
           transaction will block until the second transaction releases the lock,
           either by rolling back or by not modifying its object. If the other
           transaction modifies the object and attempts to store it, a deadlock
           occurs. If both transactions have a read lock, both require a write lock in
           order to proceed and neither can proceed until the other terminates.
        </p><p>
           Castor detects such deadlock occurences and causes the second transaction
           to rollback, allowing the first transaction to commit properly. Such
           conflicts do not happen often, but when they happen some transactions will
           fail. The application developer should either be aware of the possibility
           of failing, or choose to use a more severe lock type.
        </p><p>
           Conflicts occur not just from other Castor transactions, but also from
           direct database access. Consider another application modifying the exact
           same record through direct JDBC access, or a remote server connecting to
           the same database. To detect such conflicts Castor uses a dirty checking
           mechanism.
        </p><p>
           When an object is about to be stored, Castor compares the current values
           in the database records with those known when the object was originally
           loaded from the database. Any changes are regarded as dirty fields and
           cause the transaction to rollback with the proper error message.
        </p><p>
           Not all fields are necessarily sensitive to dirty checking. The balance
           in a bank account is a sensitive field, but the date of the last transaction
           might not be. Since the date does not depend on the original value of the
           account, but on the last modification to it, dirty checking can be avoided.
        </p><p>
           A field marked with dirty="ignore" will not take part in dirty 
           checking. Furthermore, modifications to such a field will not require a 
           write lock on the object, further improving throughput. Marking fields as 
           non-dirty should be done with extreme care.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.exclusive"></a>4.3.2.2.&nbsp;Access mode: Exclusive</h4></div></div></div><p>
           The exclusive mode assures that no two transactions can use the same
           record at the same time. Exclusive mode works by acquiring a write lock in
           memory and synchronizing transactions through a lock mechanism with configured
           timeout.
        </p><p>
           Using in-memory locks, exclusive access provides some transaction synchronization
           that is efficient in terms of performance and increases the chance of a commit
           being successful. It does not, however, guarantee commit. Since the lock is
           acquired by Castor, it can be used to synchronize Castor access, but other forms
           of direct database access may still modify the database record.
        </p><p>
           When a transaction obtains an object that was specified as exclusive access
           in the mapping file or when performing a query, Castor will always obtain a
           write lock on that object. The write lock will prevent a second transaction
           from being able to access the object either for read or write, until the current
           transaction commits. If the object is already being accessed by another
           transaction, the current transaction will block until the other transaction
           commits and release the lock.
        </p><p>
           It is possible to upgrade from a shared to an exclusive lock by calling the
           <code class="methodname">org.exolab.castor.jdo.Database.lock(java.lang.Object)</code>
           method. This method can be used with shared objects when the application
           wants to assure that other transactions will be blocked and changes can be
           made to the current object.
        </p><p>
           Because direct database access can modify the same record as represented by
           an exclusive locked object, Castor uses dirty checking when updating the
           database. Dirty checking does not have a severe affect on performance, and can
           be disabled by marking all the fields of the object with dirty="ignore".
        </p><p>
           To reduce the possibility of dirty reads, Castor will always synchronize
           exclusive locked objects with the database at the beginning of a transaction.
           That is, when an object is loaded the first time in a transaction with an
           exclusive lock, Castor will retrieve a fresh copy of the object from the
           database. Castor will not, however, refresh the object if the lock is upgraded
           in the middle of a transaction using the <code class="methodname">lock</code> method.
        </p><p>
           Exclusive mode does cause lock contention and can have an affect on application
           performance when multiple transactions attempt to access the same record.
           However, when used smartly with on a small set of objects it can help reduce
           the possibility of concurrency conflicts. It can also be used to force an object
           to be loaded from the database and the cache refreshed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.database-locked"></a>4.3.2.3.&nbsp;Access mode: Database Locked</h4></div></div></div><p>
           The locked mode performs optimistic locking using the underlying database
           engine to assure that only one transaction has access to the record.
           In addition to acquiring a write lock in memory, Castor performs a query
           with a special SQL construct (FOR UPDATE in Oracle, HOLDLOCK in Sybase)
           to guarantee access by one transaction.
        </p><p>
           In the event that the same database record will be accessed directly through
           JDBC, stored procedure, or a second machine using Castor, the only way to
           achieve object locking is through the database layer. However, such write
           locks should be cooperative, that is, other forms of database access should
           attempt to use the same locking mechanism.
        </p><p>
           In some isolation levels, when Castor acquires a write lock on the database
           it will prevent other applications from accessing the same record until the
           Castor transaction commits. However, certain isolation levels allow other 
           applications to obtain a dirty image of the record.
        </p><p>
           Write locks on the database have a severe impact on application performance.
           They incur overhead in the database manager, and increase lock contention.
           It is recommended to use database locks with care, pay extra attention to the
           isolation level being used, and follow good practices recommended by the
           database vendor with regards to such locks.
        </p><p>
           In the future long transaction will be supported. Long transactions rely on
           the dirty checking mechanism and only hold connections open for as long as
           they are required for queries. Long transactions cannot be used with database
           locking.
        </p><p>
           Locked mode must be specified for the object in the mapping file or when
           conducting the query. It is not possible to upgrade to a locked lock in the
           middle of a transaction.
        </p><p>
           Objects loaded in this mode are always synchronized with the database, that
           is, they will never be obtained from the cache and always re-loaded for each
           new transaction.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.read-only-queries"></a>4.3.2.4.&nbsp;Read-only Queries</h4></div></div></div><p>
           When a query is performed in read-only mode or no mode is specified and the
           object is marked as read-only in the database, Castor will return a transient
           object. The returned object will not be locked and will not participate in the
           transaction commit/rollback.
        </p><p>
           When the same object is queried twice in a transaction as read-only, Castor
           will return two separate objects, allowing the caller to modify one object
           without altering the other. Castor will utilize the cache and only perform
           one load from the database to the cache.
        </p><p>
           Read-only access is recommended only when the object is intentionally queried
           as read-only and changes to the object should not be reflected in the database.
           If the object will not be modified, or modifications will be stored in the
           database, it is recommended to use the shared mode. Shared mode allows the
           same object to be returned twice in the same transaction.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.visibility-of-changes"></a>4.3.3.&nbsp;Visibility of Changes</h3></div></div></div><p>
            The visibility of changes occuring in one transaction to other transactions
            depends upon the transaction isolation level specified for the database connection.
            Whether or not the changes are visible in the current transaction depends upon the
            operation being done.
        </p><p>
            There are four types of changes, the following table summarizes the affect of
            each change in one transaction on other queries in that transaction as well
            as other transactions.
        </p><div class="table"><a name="d4e8773"></a><p class="title"><b>Table&nbsp;4.8.&nbsp;Changes</b></p><div class="table-contents"><table summary="Changes" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Type of change</th><th>Same transaction</th><th>Other transaction</th></tr></thead><tbody><tr><td>Create new object</td><td>New object is visible and will be returned from a query</td><td>New object might be visible, depending on isolation level, but access
                         is blocked until the first transaction completes</td></tr><tr><td>Delete existing object</td><td>Object is no longer visible and will not be returned from a query</td><td>Object might not be visible, depending on isolation level, but access
                         is blocked until the first transaction completes</td></tr><tr><td>setXXX()</td><td>Change is visible in object itself</td><td>Change is not visible, object is accessible depending on lock</td></tr><tr><td>update()</td><td>Change is visible in object itself</td><td>Change might be visible, depending on isolation level, object might
                         be accessible depending on lock</td></tr></tbody></table></div></div><br class="table-break"></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.persist"></a>4.4.&nbsp;Castor Persistence Architecture</h2></div><div><span xmlns:fo="http://www.w3.org/1999/XSL/Format" class="author"><span class="firstname">Assaf</span> <span class="surname">Arkin</span> 
            ()
            </span></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.layered-architecture"></a>4.4.1.&nbsp;Layered Achitecture</h3></div></div></div><p>
          The Castor persistence engine is based on a layer
          architecture allowing different APIs to be plugged on top of
          the system, and different persistence engines to be combined
          in a single environment.
        </p><div align="center"><img src="images/persistence-layered-architecture.png" align="middle"></div><p>
          At the top level are the application level APIs. These are industry standard APIs
          that allow an application to be ported in and to other environments. These APIs
          consist of interfaces as well as semantics that make them suitable for a particular
          type of applications.
        </p><p>
          At the medium level is the Castor persistence mechanism. The persistence 
          mechanism exposes itself to the application through the application level 
          APIs. These typically have a one to one mapping with the persistence 
          mechanism API. The persistence mechanism takes care of object caching and 
          rollback, locking and deadlock detection, transactional integrity, and two 
          phase commit.
        </p><p>
          At the bottom level are the Castor service providers. SPIs provide the 
          persistence and query support into a variety of persistence mechanism. 
          This version of Castor is bundled with an SQL 92 and LDAP persistence SPIs. 
          Additional SPIs can be added, for example, alternative engines streamlined 
          for Oracle, Sybase, DB2 and other databases.
        </p><p>
          This document will describe the persistence mechanism API and SPI to allow 
          for those interested in adding new top level APIs or service providers.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.api"></a>4.4.2.&nbsp;Persistence API</h3></div></div></div><p>
          The persistence mechanism is responsible for object caching and rollback, 
          locking and deadlock detection, transaction integrity and two phase commit. 
          All data access goes through the persistence mechanism. All operations are 
          performed in the context of a transaction, even if the underlying SPI does 
          not support transactions (e.g. LDAP).
        </p><p>
          The persistence API is defined in the package 
          <span class="package">org.exolab.castor.persist</span>.
          The persistence mechanism implements the 
          <span class="interface">org.exolab.castor.persist.PersistenceEngine</span>
          interface, which allows objects to be loaded, created, deleted and locked 
          in the context of a transaction. The actual implementation is obtained from
          <code class="classname">org.exolab.castor.persist.PersistenceEngineFactory</code>.
        </p><p>
          All operations are performed through the context of a transaction. 
          A transaction is required in order to properly manage locking and caching, 
          and to automatically commit or rollback objects at transaction termination 
          (write-at-commit). Persistence operations are performed through the 
          <span class="interface">org.exolab.castor.persist.TransactionContext</span>
          interface.
        </p><p>
          The actual implementation of a transaction context is specific to each 
          application API and set of SPIs. One is created from an 
          <code class="classname">org.exolab.castor.persist.XAResourceSource</code>
          which abstracts the data source for the purpose of connection pooling and 
          XA transaction enlistment. A default implementation of 
          <span class="interface">XAResource</span> is available from
          <code class="classname">org.exolab.castor.persist.XAResourceImpl</code>.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.transactions"></a>4.4.2.1.&nbsp;Transactions</h4></div></div></div><p>
           Every persistence operation is performed within the context of a transaction.
           This allows changes to objects to be saved when the transaction commits and 
           to be rolled back when the transaction aborts. Using a transactional API 
           relieves the application developer from worrying about the commit/rollback 
           phase. In addition it allows distributed transactions to be managed by a 
           transactional environment, such as an EJB server.
        </p><p>
           Each time an object is retrieved or created the operation is performed 
           in the context of a transaction and the object is recorded with the 
           transaction and locked. When the transaction completes, the modified 
           object is persisted automatically. If not all objects can be persisted, 
           the transaction rolls back. The transaction context implements full 
           two phase commit.
        </p><p>
           Each transaction sees it's own view of the objects it retrieves from 
           persistent storage. Until the transaction commit, these changes are 
           viewable only within that transaction. If the transaction rolled back, 
           the objects are automatically reverted to their state in persistent storage.
        </p><p>
           The transaction context 
           (<code class="classname">org.exolab.castor.persist.TransactionContext</code>)
           is the only mechanism by which the top level APIs can interact with the 
           persistence engine. A new transaction must be opened in order to perform 
           any operation.
        </p><p>
           A transaction context is not created directly, but through a derived class 
           that implements the proper mechanism for obtaining a new connection, 
           committing and rolling back the connection. Note that commit and rollback 
           operations are only required in a non-JTA environment. When running inside 
           a JTA environment (e.g. an EJB server), the container is responsible to 
           commit/rollback the underlying connection.
        </p><p>
           Application level APIs implement data sources that can be enlisted directly 
           with the transaction monitor through the JTA 
           <span class="interface">XAResource</span> 
           interface. A data source can be implemented using 
           <code class="classname">org.exolab.castor.persist.XAResourceSource</code>
           which serves as a factory for new transaction contexts and
           <code class="classname">org.exolab.castor.persist.XAResourceImpl</code> 
           which provides an <span class="interface">XAResource</span> implementation.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.oids-and-locks"></a>4.4.2.2.&nbsp;OIDs and Locks</h4></div></div></div><p>
           Each object participating in a transaction is associated with an object 
           identifier, or <span class="bold"><strong>OID</strong></span> 
           (<code class="classname">org.exolab.castor.persist.OID</code>). 
           The OID identifies the object through its type and identity value. 
           The identity object must be unique across all OIDs for the same object type 
           in the same persistence engine.
        </p><p>
           Each object is also associated with a lock 
           (<code class="classname">org.exolab.castor.persist.ObjectLock</code>).
           An <span class="bold"><strong>object lock</strong></span> supports read and write 
           locks with deadlock detection. Any number of transactions may acquire a 
           read lock on the object. Read lock allows the transaction to retrieve the 
           object, but not to delete or store it. Prior to deleting or storing the 
           object, the transaction must acquire a write lock. Only one transaction 
           may acquire a write lock, and a write lock will not be granted if there 
           is any read lock on the object.
        </p><p>
           If an object is loaded read-only, a read lock is acquired at the begin of 
           the load operation and realeased when the load is finished. Someone now 
           could ask why do you acquire a read lock at all if it only lasts during 
           the load operation. For an explanation we have to take a look on what 
           happens if an object is loaded. Loading one object from database may cause
           castor to load a whole tree of objects with relations to each other. 
           In the background castor may performs various queries to load all related 
           objects. For this object tree to be consistent and reflect the persistent 
           state of all the objects in the database at one point in time we need to 
           lock all objects involved in all load operations to prevent any involved 
           object to be write locked and changed by another transaction. If the load 
           operation is finished these read locks are not required anymore. On the 
           other hand, read locks are acquired to prevent an object already locked 
           in the write mode from getting the read lock.
        </p><p>
           Write locks are acquired at the begin of the load operation similar then 
           read locks. But in contrast to read locks, write locks are hold until the 
           transaction is commited or rolled back. Holding the write lock until the 
           end of the transaction is required as the changes to the objects, that 
           could happen anytime between begin and end of the transaction, are only 
           persisted if the transaction successfully commits.
        </p><p>
           If a transaction requires a read lock on an object which is write locked 
           by another transaction, or requires a write lock on an object which is read 
           or write locked by another transaction, the transaction will block until the 
           lock is released, or the lock timeout has elapsed. The lock timeout is a 
           property of the transaction and is specified in seconds. A
           <code class="classname">org.exolab.castor.persist.LockNotGrantedException</code> 
           is thrown if the lock could not be acquired within the specified timeout.
        </p><p>
           This locking mechanism can lead to the possibility of a deadlock. The object 
           lock mechanism provides automatic deadlock detection by tracking blocked 
           transactions, without depending on a lock wait to timeout.
        </p><p>
           Write locks and exclusive locks are always delegated down to the persistence 
           storage. In a distributed environment the database server itself provides 
           the distributed locking mechanism. This approach assures proper concurrency 
           control in a distributed environments where multiple application servers 
           access the same database server.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.cache-engine"></a>4.4.2.3.&nbsp;Cache Engine</h4></div></div></div><p>
           The concurrency engine includes a layer that acts as a cache engine. 
           This layer is particularly useful for implementing optimistic locking and 
           reducing synchronization with the database layer. It is also used to perform 
           dirty checks and object rollback. The cache engine is implemented in 
           <code class="classname">org.exolab.castor.persist.CacheEngine</code> and
           exposed to the application through the 
           <code class="classname">org.exolab.castor.persist.PersistenceEngine</code>.
        </p><p>
           When an object is retrieved from persistent storage it is placed in the 
           cache engine. Subsequent requests to retrieve the same object will return 
           the cached copy (with the exception of pessimistic locking, more below). 
           When the transaction commits, the cached copy will be updated with the 
           modified object. When the transaction rolls back, the object will be 
           reverted to its previous state from the cache engine.
        </p><p>
           In the event of any error or doubt, the cached copy will be dumped from 
           the cache engine. The least recently used objects will be cleared from 
           the cache periodically.
        </p><p>
           The cache engine is associated with a single persistence mechanism, 
           e.g. a database source, and LDAP directory. Proper configuration is 
           the only way to assure that all access to persistent storage goes 
           through the same cache engine.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.pessimistic-or-optimistic-locking"></a>4.4.2.4.&nbsp;Pessimistic/Optimistic Locking</h4></div></div></div><p>
           The concurrency engine works in two locking modes, based on the type of 
           access requested by the application (typically through the API). 
           Pessimistic locking are used in read-write access mode, optimistic locking 
           are used in exclusive access mode.
        </p><p>
           In <span class="bold"><strong>optimistic locking mode</strong></span> it is assumed 
           that concurrent access to the same object is rare, or that objects are 
           seldom modified. Therefore objects are retrieved with a read lock and 
           are cached in memory across transactions.
        </p><p>
           When an object is retrieved for read/write access, if a copy of the object 
           exists in the cache, that copy will be used. A read lock will be acquired 
           in the cache engine, preventing other Castor transactions from deleting or 
           modifying the object. However, no lock is acquired in persistent storage, 
           allowing other applications to delete or modify the object while the Castor 
           transaction is in progress.
        </p><p>
           To prevent inconsistency, Castor will perform 
           <span class="bold"><strong>dirty checking</strong></span> prior to storing the object, 
           detecting whether the object has been modified in persistent storage. 
           If the object has been modified outside the transaction, the transaction 
           will rollback. The application must be ready for that possibility, or 
           resort to using pessimistic locking.
        </p><p>
           In <span class="bold"><strong>pessimistic locking mode</strong></span> it is assumed 
           that concurrent access to the same object is the general case and that 
           objects are often modified. Therefore objects are retrieved with a write 
           lock and are always synchronized against the persistence storage. When 
           talking to a database server, a request to load an object in exclusive mode 
           will always load the object (unless already loaded in the same transaction)
           using a <code class="code">SELECT .. FOR UPDATE</code> which assures no other application 
           can change the object through direct access to the database server.
        </p><p>
           The locking mode is a property of the chosen access mode. The two access 
           modes as well as read-only access can be combined in a single transaction, 
           as a property of the query or object lookup. However, it is not possible 
           to combine access modes for the same object, in certain cases this will 
           lead to a conflict.
        </p><p>
           The pessimistic locking mode is not supported in LDAP and similar 
           non-transactional servers. LDAP does not provide a mechanism to lock 
           records and prevent concurrent access while they are being used in a 
           transaction. Although all Castor access to the LDAP server is properly 
           synchronized, it is possible that an external application will modify 
           or delete a record while that record is being used in a Castor transaction. 
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.relations"></a>4.4.2.5.&nbsp;Relations</h4></div></div></div><p>TBD</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.queryresults"></a>4.4.2.6.&nbsp;QueryResults</h4></div></div></div><p>TBD</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.spi"></a>4.4.3.&nbsp;Service Providers (SPI)</h3></div></div></div><p>
          Castor supports a service provider architecture that allows different 
          persistence storage providers to be plugged in. The default implementation 
          includes an SQL 92 provider and an and an LDAP provider. Additional 
          providers will be available optimized for a particular database server 
          or other storage mechanisms.
      </p><p>
          The service provider is defined through two interfaces, 
          <span class="interface">org.exolab.castor.persist.spi.Persistence</span>
          and <span class="interface">org.exolab.castor.persist.spi.PersistenceQuery</span>. 
          The first provides creation, deletion, update and lock services, 
          the second is used to process queries and result sets. Service providers 
          are obtained through the 
          <span class="interface">org.exolab.castor.persist.spi.PersistenceFactory</span>
          interface.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.spi.persistence"></a>4.4.3.1.&nbsp;Persistence</h4></div></div></div><p>
           The interface 
           <span class="interface">org.exolab.castor.persist.spi.Persistence</span> defines 
           the contract between the persistence mechanism and a persistence service 
           provider. Each persistence storage (i.e. database server, directory server) 
           is associated with a single persistence engine, which in turn contains a 
           number of service providers, one per object type. Service providers are 
           acquired through a 
           <span class="interface">org.exolab.castor.persist.spi.PersistenceFactory</span> 
           interface, which is asked by each persistence engine to return 
           implementations for all the object types supported by that persistence 
           engine.
        </p><p>
           The object's identity is an object that unique identifies the object within 
           persistent storage. Typically this would be the primary key on a table, or 
           an RDN for LDAP. The identity object may be a simple type (e.g. integer, 
           string) or a complex type.
        </p><p>
           The service provider may support the stamp mechanism for efficiently 
           tracking dirty objects. The stamp mechanism is a unique identifier of 
           the persistent object that changes when the object is modified in 
           persistent storage. For example, a RAWID in Oracle or TIMESTAMP in Sybase. 
           If a stamp is return by certain operations it will be stored with the 
           object's OID and passed along to the store method.
        </p><p>
           The <code class="methodname">create</code> method is called to create a new object 
           in persistent storage. This method is called when the created object's 
           identity is known. If the object's identity is not know when the object is 
           made persistent, this method will be called only when the transaction 
           commits. This method must check for duplicate identity with an already 
           persistent object, create the object in persistent storage, such that 
           successful completion of the transaction will result in durable storage, 
           and retain a write lock on that object for the duration of the transaction.
        </p><p>
           The <code class="methodname">load</code> method is called to load an object from 
           persistent storage. An object is passed with the requested identity. If the 
           object is found in persistent storage, it's values should be copied into the 
           object passed as argument. If the lock flag is set, this method must create 
           a write lock on the object at the same time it loads it.
        </p><p>
           The <code class="methodname">load</code> method is called in two cases, when an 
           object is first loaded or when an object is synchronized with the database 
           (reloaded) in exclusive access mode. In the second case this method will 
           be called with an object that is already set with values that are not 
           considered valued, and must reset these values.
        </p><p>
           The <code class="methodname">store</code> method is called to store an object into 
           persistent storage. The store method is called for an object that was loaded 
           and modified during a transaction when the transaction commits, as well as 
           for an object that was created during the transaction. This method must 
           update the object in persistent storage and retain a write lock on that 
           object.
        </p><p>
           This method might be given two views of an object, one that is being saved 
           and one that was originally loaded. If the original view is provided as 
           well, this method should attempt to perform dirty check prior to storing 
           the object. Dirty check entails a comparison of the original object against 
           the copy in persistent storage, to determine whether the object has changed 
           in persistent storage since it was originally loaded. The class descriptor 
           will indicate whether the object is interested in dirty checking and which 
           of its fields should be checked.
        </p><p>
           The <code class="methodname">delete</code> method is called to delete an object 
           from persistent storage. The delete method is called when the transaction 
           commits and expects the object to deleted, if it exists. This method is not 
           called when the transaction rolls back, objects created during the 
           transaction with the create method are automatically rolled back by the 
           persistent storage mechanism.
        </p><p>
           The <code class="methodname">writeLock</code> method is called to obtain a write 
           lock on an object for which only a read lock was previously obtained. 
           The <code class="methodname">changeIdentity</code> method is called to change 
           the identity of the object after it has been stored with the old identity.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.spi.persistencequery"></a>4.4.3.2.&nbsp;PersistenceQuery</h4></div></div></div><p>
           The interface 
           <span class="interface">org.exolab.castor.persist.spi.PersistenceQuery</span> 
           defines the contract between the persistence engine and a query mechanism.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.ejb-cmp"></a>4.4.4.&nbsp;Enterprise JavaBeans CMP</h3></div></div></div><p>TBD</p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.key-generator"></a>4.5.&nbsp;Castor JDO Key Generator Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.introduction"></a>4.5.1.&nbsp;Introduction</h3></div></div></div><p>
         The key generator gives a possibility to generate identity field
         values automatically. During <code class="literal">create</code> the value of the
         identity field is set to the value obtained from the key generator.
         Different algorithms may be used here, both generic and specific
         for database server.
      </p><p>
         The key generator for the given class is set in the mapping specification 
         file (<code class="filename">mapping.xml</code>), in the 
         <code class="literal">key-generator</code> attribute of the 
         <code class="literal">class</code> element, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"MAX"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
      </pre><p>
         The following key generator names are supported in Castor 1.0:
      </p><div class="table"><a name="d4e8927"></a><p class="title"><b>Table&nbsp;4.9.&nbsp;Supported key generator names</b></p><div class="table-contents"><table summary="Supported key generator names" border="1"><colgroup><col><col></colgroup><tbody><tr><td>MAX</td><td>"MAX( pk ) + 1" generic algorithm</td></tr><tr><td>HIGH-LOW</td><td>HIGH-LOW generic algorithm</td></tr><tr><td>UUID</td><td>UUID generic algorithm</td></tr><tr><td>IDENTITY</td><td>
                Supports autoincrement identity fields in Sybase ASE/ASA, 
                MS SQL Server, MySQL and Hypersonic SQL
              </td></tr><tr><td>SEQUENCE</td><td>
                Supports SEQUENCEs in Oracle, PostgreSQL, Interbase and SAP DB
              </td></tr></tbody></table></div></div><br class="table-break"><p>
         Some of these algorithms have parameters, which can be specified 
         in the <code class="literal">key-generator</code> element of the mapping
         specification file, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"HIGH-LOW"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"table"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key-column"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ_TableName"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"value-column"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ_MaxPKValue"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"grab-size"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"HIGH-LOW"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>
         It is possible to create several key generators with the same
         algorithms but different parameters.
         In this case you have to specify the <code class="literal">alias</code> attribute
         in the <code class="literal">key-generator</code> element, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SEQUENCE"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"A"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sequence"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"a_seq"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SEQUENCE"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"RETURNING"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sequence"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"b_seq"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"returning"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"RETURNING"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
      </pre><p>
         Below all supported key generators a described in details.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.max"></a>4.5.2.&nbsp;MAX key generator</h3></div></div></div><p>
         MAX key generator fetches the maximum value of the primary key 
         and lock the record having this value until the end of transaction.
         Then the generated value is set to (MAX + 1).
         Due to the lock concurrent transactions which perform insert 
         to the same table using the same key generator algorithm will wait 
         until the end of the transaction and then will fetch new MAX value.
         Thus, duplicate key exception is almost impossible (see below).
         Note, that it is still possible to perform multiple inserts during
         the same transaction.
      </p><p>
         There is one "singular" case of this algorithm: the case when the table 
         is empty. In this case there is nothing to lock, so duplicate key exception
         is possible. The generated value in this case is 1.
      </p><p>
         This algorithm has no parameters. Primary key must have type 
         <span class="type">integer</span>, <span class="type">bigint</span> or <span class="type">numeric</span>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.high-low"></a>4.5.3.&nbsp;HIGH-LOW key generator</h3></div></div></div><p>
         This key generator uses one of the variants of the generic HIGH-LOW
         algorithm. It is needed a special auxiliary table ("sequence table")
         which has the unique column which contains table names (of the type
         <span class="type">char</span> or <span class="type">varchar</span>) and the column which is used 
         to reserve values of the primary keys (of the type <span class="type">integer</span>,
         <span class="type">bigint</span> or <span class="type">numeric</span>).
         The key generator seeks for the given table name, reads the last
         reserved value and increases it by some number N, which is called 
         "grab size". Then the lock on the auxiliary table is released,
         so that concurrent transactions can perform insert to the same table.
         The key generator generates the first value from the grabbed 
         interval.
         During the next (N - 1) invocations it generates the other grabbed
         values without database access, and then grabs the next portion.
         Note, that the auxiliary table must be in the same database as
         the table for which key is generated. So, if you work with multiple 
         databases, you must have one auxiliary table in each database.
      </p><p>
         If the grab size is set to 1, the key generator each time stores
         the true maximum value of the primary key to the auxiliary table.
         In this case the HIGH-LOW key generator is basically equivalent to
         the MAX key generator.
         On you want to have LOW part of the key consisting of 3 decimal
         digits, set the grab size to 1000. If you want to have 2 LOW bytes in
         the key, set the grab size to 65536.
         When you increase the grab size, the speed of 
         key generation also increases because the average number of 
         SQL commands that are needed to generate one key is (2 / N).
         But that average number of key values that will be skipped (N / 2)
         also increases.
      </p><p>
         The HIGH-LOW key generator has the following parameters:
      </p><div class="table"><a name="d4e8972"></a><p class="title"><b>Table&nbsp;4.10.&nbsp;parameters of the HIGH-LOW key generator</b></p><div class="table-contents"><table summary="parameters of the HIGH-LOW key generator" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>table</td><td>The name of the special sequencetable.</td><td>Mandatory</td></tr><tr><td>key-column</td><td>The name of the column which contains table names</td><td>Mandatory</td></tr><tr><td>value-column</td><td>
                The name of the column which is used to reserve primary key values
              </td><td>Mandatory</td></tr><tr><td>grab-size</td><td>
                The number of new keys the key generator should grab from the sequence 
                table at a time.
              </td><td>Optional, default="10"</td></tr><tr><td>same-connection</td><td>
                To use the same Connection for writing to the sequence table, values:
                "true"/"false". This is needed when working in EJB environment, though 
                less efficient.
              </td><td>Optional, default="false"</td></tr><tr><td>global</td><td>To generate globally unique keys, values: "true"/"false".</td><td>Optional, default="false"</td></tr><tr><td>global-key</td><td>
                The name of key, which is used when globally unique keys are generated.
              </td><td>Optional, default="&lt;GLOBAL&gt;"</td></tr></tbody></table></div></div><br class="table-break"><p>
         If the parameter <code class="literal">global</code> is set to <code class="literal">true</code>, 
         the sequence table contains only one row with the value set in parameter 
         <code class="literal">global-key</code> (or "&lt;GLOBAL&gt;" if "global-key was not set") 
         instead of the table name. This row serves for all tables.
      </p><p>
         Don't forget to set same-connection="true" if you are working in 
         EJB environment!
      </p><p>
         Note, that the class <code class="classname">HighLowKeyGenerator</code> is not final, 
         so you can extend it in order to implement other variants of HIGH-LOW
         algorithm (for example, HIGH/MID/LOW or char key values).
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.uuid"></a>4.5.4.&nbsp;UUID key generator</h3></div></div></div><p>
         This key generator generates global unique primary keys.
         The generated key is a combination of the IP address, the current
         time in milliseconds since 1970 and a static counter.
         The complete key consists of a 30 character fixed length string.
      </p><p>
         This algorithm has no parameters. Primary key must have type 
         <span class="type">char</span>, <span class="type">varchar</span> or <span class="type">longvarchar</span>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.identity"></a>4.5.5.&nbsp;IDENTITY key generator</h3></div></div></div><p>
         IDENTITY key generator can be used only with autoincrement primary
         key columns (identities) with Sybase ASE/ASA, MS SQL Server, MySQL and
         Hypersonic SQL.
      </p><p>
         After the insert the key generator selects system variable
         <code class="literal">@@identity</code> which contains the last identity value for
         the current database connection.
      </p><p>
         In the case of MySQL and Hypersonic SQL the system functions
         <code class="function">LAST_INSERT_ID()</code> and <code class="function">IDENTITY()</code> 
         are called, respectively.
      </p><p>This algorithm has no parameters.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.sequence"></a>4.5.6.&nbsp;SEQUENCE key generator</h3></div></div></div><p>
         The SEQUENCE key generator type is supported in conjunction with the following
         DBMS: Derby, Interbase, Oracle, PostgreSQL, and SAP DB.
      </p><p>It generates keys using database sequence objects.</p><p>
         The key generator has the following parameters:
      </p><div class="table"><a name="d4e9032"></a><p class="title"><b>Table&nbsp;4.11.&nbsp;parameters of the SEQUENCE key generator</b></p><div class="table-contents"><table summary="parameters of the SEQUENCE key generator" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>sequence</td><td>The name of the sequence</td><td>Optional, default="{0}_seq"</td></tr><tr><td>returning</td><td>RETURNING mode for Oracle8i, values: "true"/"false"</td><td>Optional, default="false"</td></tr><tr><td>increment</td><td>Increment for Interbase</td><td>Optional, default="1"</td></tr><tr><td>trigger</td><td>
	               Assume that there is a trigger that already generates key. 
	               Values: "true"/"false"
	             </td><td>Optional, default="false"</td></tr></tbody></table></div></div><br class="table-break"><p>
         Usually one sequence is used for one table, so in general you have to
         define one key generator per table.
      </p><p>
         But if you use some naming pattern for sequences, you can use one 
         key generator for all tables.
      </p><p>
         For example, if you always obtain sequence name by adding "_seq" to
         the name of the correspondent table, you can set "sequence" parameter
         of the key generator to "{0}_seq" (the default value).
      </p><p>
         In this case the key generator will use sequence "a_seq" for table 
         "a", "b_seq" for table "b", etc.  Castor also allows for inserting 
         the primary key into the sequence name as well.  This is accomplished 
         by including the {1} tag into the "sequence" parameter. Example: 
         "{0}_{1}_seq"
      </p><p>
         Actually the SEQUENCE key generator is "4 in 1". 
         With PostgreSQL it performs "SELECT nextval(sequenceName)" before 
         INSERT and produces identity value that is then used in INSERT.
         Similarly, with Interbase it performs
         "select gen_id(sequenceName, increment) from rdb$database" before
         INSERT.
      </p><p>
         With Oracle by default (returning=false) and with SAP DB it transforms
         the Castor-generated INSERT statement into the form
         "INSERT INTO tableName (pkName,...) VALUES 
         (sequenceName.nextval,...)" and after INSERT it performs "SELECT 
         seqName.currval FROM tableName" to obtain the identity value. With 
         Oracle8i it is possible to use more efficient RETURNING mode: to 
         the above INSERT statement is appened "RETURNING primKeyName INTO 
         ?" and the identity value is fetched by Castor during INSERT, so 
         that only one SQL query is needed.
      </p><p> 
         In case when your table has an on_Insert trigger which already generates
         values for your key, like the following Oracle example: 
      </p><pre class="programlisting">
create or replace trigger "trigger_name"
before insert on "table_name" for each row 
begin 
   select "seq_name".nextval into :new."pk_name" from dual;
end;</pre><p>    
          you may set the "trigger" parameter to "true". This will prevent the 
          "Sequence_name".nexval from being pulled twice (first time in the insert 
          statement (see above), then in the trigger). Also usefull in combination 
          with the "returning" parameter set to "true" for Oracle (in this case you 
          may not specify the sequence name).
       </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.long-transactions"></a>4.6.&nbsp;Castor JDO Long Transactions Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.introduction"></a>4.6.1.&nbsp;Introduction</h3></div></div></div><p>
         The usual Castor transactions are called here short
         transactions: an object is read, modified and written within the
         bounds of one transaction.
         Long transactions consist of two Castor transactions:
         an object is read in the first and written in the second.
         Between them the object is sent "outwards" and modified there.
         For example, the object may be send to a client application and
         dispayed to a user, or it may be sent to a servlet engine and is
         displayed on a web page. After that the modified object returns
         back and is written to the database in the second transaction.
         At this point the object is usually not the same physical instance
         as one that was read in the first transaction.
         The example code for writing the object in the second Castor
         transaction follows:
         </p><pre class="programlisting">
    <span class="hl-comment">// a customer go to a webpage to review her personal information.</span>
    <span class="hl-comment">// The servlet then call this server side function: getCustomerInfo</span>
    <span class="hl-keyword">public</span> CustomerInfo getCustomerInfo( Integer customNum ) {
         
         <span class="hl-comment">// in most case, users simply review information and</span>
         <span class="hl-comment">// make no change. Even if they make changes, it often</span>
         <span class="hl-comment">// takes time for them to decide. We don't want to</span>
         <span class="hl-comment">// lock the database row, so commit right after we load.</span>
         db.begin();
         CustomerInfo info = (CustomerInfo)
            db.load( CustomerInfo.<span class="hl-keyword">class</span>, customNum );

         
         <span class="hl-comment">// we also want to keep track of customers patterns</span>
         <span class="hl-comment">// well...it helps us provide better service.</span>
         info.setLastVisit( today );
         db.commit();
         <span class="hl-keyword">return</span> info;
    }

    <span class="hl-comment">// Three days passed, the indecisive customer finally agrees to</span>
    <span class="hl-comment">// marry Joe. She changes her last name in the webpage and</span>
    <span class="hl-comment">// clicked the "Submit" button on the webpage.</span>
    
    <span class="hl-comment">// The servlet then calls updateCustomerInfo to update the</span>
    <span class="hl-comment">// last name for the indecisive customer.</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateCustomerInfo( CustomerInfo info ) {
        db.begin();
        db.update(info);
        db.commit();
    }
         </pre><p>
         Note, that it is natural to read the object in the first
         transaction in the read-only mode.
      </p><p>
         Since the time interval between the first and the second
         transaction is relatively big, it is desirable to perform dirty
         checking, i.e. to check that the object has not been modified
         in the database during the long transaction.
         For that the object must hold a timestamp: it is set by
         Castor during the first Castor transaction and is checked during
         the second one.
         In order to enable the dirty checking for long transactions,
         the object should implement the interface
         org.exolab.castor.jdo.TimeStampable
         having two methods: <code class="code">long jdoGetTimeStamp()</code> and
         <code class="code">void jdoSetTimeStamp(long timeStamp)</code>

         
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.bounded-dirty-checking"></a>4.6.2.&nbsp;Bounded dirty checking</h3></div></div></div><p>
         The advantage of the bounded dirty checking is that it doesn't require
         any changes to the database schema. It uses the Castor cache to store
         object timestamps. The disadvantage of this algorithm is that it is
         bounded by a lifetime of the cached copy of the object. After the
         cached copy has been purged, db.update() causes ObjectModifiedException.
      </p><p>
         Thus, parameters of the cache define dirty checking capabilities.
         The cache-type attribute is part of the
         <a href="jdo.html#jdo.mapping.file.class-element" title="3.6.3.2.&nbsp;The <class&gt; element">
         &lt;class&gt; element</a> in the XML mapping. Consider the existing cache types:
         
         </p><div class="itemizedlist"><ul type="disc"><li><p>none - the bounded dirty checking is impossible</p></li><li><p>
               count-limited - the count limit for the cache is a count
               limit for the objects of this class that can participate in long
               and short transactions simultaneously.
             </p></li><li><p>
               time-limited - the time limit for the cache is a time limit
               for the long transaction.
             </p></li><li><p>
               unlimited - the bounded dirty checking gives correct results
               while the cache exists, i.e. until the crash of the server.
             </p></li></ul></div><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.no-dependance-on-cache"></a>4.6.3.&nbsp;Long transactions that do not depend on cache</h3></div></div></div><p>
			For long transactions (detached objects) it was required 
	      	that the entity has been kept in cache from being loaded until its update. 
	      	If the entity was expired from cache before the update an 
	      	ObjectModifiedException had been thrown. While this is no 
	      	problem if all entities of an application can be kept in 
	      	cache all the time, it is one for large scale applications 
	      	with millions of entities.
	    </p><p>
			With release 1.3 we have changed the handling of timestamps. 
			While it is still possible to rely on cache only it is now 
			also possible to persist the timestamp together with the 
			other properties of the entity. Doing so will ensure that 
			the timestamp do not change even if the entity got expired 
			from cache from being loaded until it gets updated. If this 
			happens the entity gets reloaded during update which also 
			loads the previous timestamp. Having said that it still is 
			possible that an ObjectModifiedException is thrown when 
			another user has changed the same entity in the meantime.
	    </p><p>See an example entity and its mapping below: </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Entity <span class="hl-keyword">implements</span> TimeStampable {
    <span class="hl-keyword">private</span> Integer _id;
    <span class="hl-keyword">private</span> String _name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> _timeStamp;
    
    <span class="hl-keyword">public</span> Integer getId() { <span class="hl-keyword">return</span> _id; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> Integer id) { _id = id; }
    
    <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> _name; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) { _name = name; }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getTimeStamp() { <span class="hl-keyword">return</span> _timeStamp; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTimeStamp(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> timeStamp) {
        _timeStamp = timeStamp;
    }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> jdoGetTimeStamp() { <span class="hl-keyword">return</span> _timeStamp; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> jdoSetTimeStamp(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> timestamp) {
        _timeStamp = timestamp;
    }
}       </pre><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Entity"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"300"</span>/&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"entity"</span>/&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"true"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timeStamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.nested-attributes"></a>4.7.&nbsp;Nested Attributes</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.introduction"></a>4.7.1.&nbsp;Introduction</h3></div></div></div><p>
	        In some cases it is desirable to map a plain sequence of fields
	        in a database record to more complicated structure of attributes
	        in a Java object, where the target attributes are contained (nested)
	        in other attributes.
	        In brief, you can specify a path to the target attribute as a name 
	        of the field in a configuration file, and Castor is able to handle
	        such nested attributes.
	        For example:
	        </p><pre class="programlisting">
&lt;field name=<span class="hl-string">"address.country.code"</span>...&gt;
  &lt;sql name=<span class="hl-string">"person_country"</span>/&gt;
&lt;/field&gt;
	        </pre><p>
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.application-types"></a>4.7.2.&nbsp;Application types</h3></div></div></div><p>
	        The first case is an attribute of an application type that is 
	        a container for some value of a Java type supported by Castor.
	        Usually the application type also has some business methods. 
	        Examples are: class Balance that contains a BigDecimal value and 
	        has some accounting-specific methods; 
	        class CountryCode that contains a String value and has 
	        methods validate(), getDisplayName(), etc.; class Signature that 
	        contains a byte[] value and has some security-specific methods. 
	        In order to use such type with Castor you should provide 
	        a pair of methods to get/set the value of the Castor-supported type, 
	        e.g. getBigDecimal/setBigDecimal, getCode/setCode, getBytes/setBytes. 
	     </p><p>
	        Assume that you have the class Address
	        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Address {
    <span class="hl-keyword">private</span> CountryCode _country;
    <span class="hl-keyword">private</span> String      _city;
    <span class="hl-keyword">private</span> String      _street;

    <span class="hl-keyword">public</span> CountryCode getCountry() {
        <span class="hl-keyword">return</span> _country;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setCountry(CountryCode country) {
        _country = country;
    }
    ...
}
	        </pre><p>
	        where the class <code class="classname">CountryCode</code> is like this
	        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CountryCode {
    <span class="hl-keyword">private</span> String _code;
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> String[] _allCodes;
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> String[] _allDisplayNames;

    <span class="hl-keyword">public</span> String getCode() {
        <span class="hl-keyword">return</span> _code;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setCode(String code) {
        _code = code;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getDisplayName() {
    ...
}
	        </pre><p>
	        then write in the configuration file:
	        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Address"</span><span class="hl-attribute">...&gt;</span>
  <span class="hl-attribute">&lt;field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"country.code"</span><span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">&lt;sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"addr_country"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  ...
&lt;<span class="hl-tag">/class</span>&gt;
	        </pre><p>
	        When reading the object from the database Castor will use
	        </p><pre class="programlisting">
object.getCountry().setCode(value);
	        </pre><p>
	        to set the nested attribute value.
	        Moreover, if object.getCountry() is null, Castor will create the 
	        intermediate object of the application type:
	        </p><pre class="programlisting">
country = <span class="hl-keyword">new</span> CountryCode();
country.setCode(value);
object.setCountry(country);
	        </pre><p>
	        When writing the object to the database Castor will use
	        </p><pre class="programlisting">
value = object.getCountry().getCode();
	        </pre><p>
	        to get the value of the correspondent database field.
	     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.compound-attributes"></a>4.7.3.&nbsp;Compound types</h3></div></div></div><p>
        The second case is an attribute that is a part of a compound 
        attribute, which contains several database fields.
        For example, database fields person_country, person_city, 
        person_street of the table <span class="database">PERSON</span> 
        correspond to one compound attribute "address" of the class 
        <code class="classname">Person</code>:
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {
    <span class="hl-keyword">private</span> String  _firstName;
    <span class="hl-keyword">private</span> String  _lastName;
    <span class="hl-keyword">private</span> Address _address;

    <span class="hl-keyword">public</span> Address getAddress() {
        <span class="hl-keyword">return</span> _address;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress(Address address) {
        _address = address;
    }
    ...
}
        </pre><p>
        where the class <code class="classname">Address</code> is the same as in the 
        previous section. Then write in the configuration file:
        </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Person"</span>...&gt;
  &lt;field name=<span class="hl-string">"address.country.code"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_country"</span>/&gt;
  &lt;/field&gt;
  &lt;field name=<span class="hl-string">"address.city"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_city"</span>/&gt;
  &lt;/field&gt;
  &lt;field name=<span class="hl-string">"address.street"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_street"</span>/&gt;
  &lt;/field&gt;
  ...
&lt;/<span class="hl-keyword">class</span>&gt;
        </pre><p>
        Similarly to the previous section, Castor will use a proper 
        sequence of get/set methods to access the nested attributes and 
        will create the intermediate objects when necessary.
        Don't forget to provide parameterless constructors for the 
        container classes.
     </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.pooling"></a>4.8.&nbsp;Using Pooled Database Connections</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.news"></a>4.8.1.&nbsp;News</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                   <span class="bold"><strong>10/22/2004</strong></span>: 
                   Added JDBC Datasource configuration for mySQL.
               </p></li><li><p>
                   <span class="bold"><strong>9/14/2004</strong></span>: 
                   Added section about using Jakarta's DBCP with Castor.
               </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.agents"></a>4.8.2.&nbsp;Pooling Agents</h3></div></div></div><p>
         There is no mechanism within Castor JDO to provide pooling of
         JDBC drivers. Rather, Castor JDO relies on the drivers or
         external driver wrappers to implement a pooling mechanism.
         Some drivers, such as Oracle, provides a pooling mechanism in
         the driver.  For those that do not, there are tools such as
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://sourceforge.net/projects/proxool/" target="_top">Proxool</a> 
         and Jakarta's 
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/dbcp/" target="_top">DBCP</a>
         project.
      </p><p>
         Here, I'll go over the various usage of the PostgreSQL driver
         with Castor.  We start with the most basic configurations
         that do not use any pooling, to those with pooling via DBCP. 
         I'll include how to configure the pooling version of the 
         PostgreSQL JDBC driver ths will be usable with PostgreSQL 7.3 and 
         later, how to setup a Tomcat JNDI context that Castor can use to get 
         a pooled JDBC connection. Finally, I'll explain how to configure a 
         <code class="classname">BasicDataSource</code> from the DBCP package using the 
         &lt;data-source&gt; element.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.standard-database-connections"></a>4.8.3.&nbsp;Standard Database Connections</h3></div></div></div><p>
           A standard jdo-conf.xml entry for using PostgreSQL without pooling
           looks like this:
        </p><pre class="programlisting">

&lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.Driver"</span>
        <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:postgresql://localhost/app"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/driver</span>&gt;
        </pre><p>
	        On the other hand, if you wanted to use the PostgresqlDataSource, you
	        would use the data-source tag instead, and the connection entry would
	        look like this:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"app"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
      </pre><p>
         (Note that only versions before 7.3 of the PostgreSQL JDBC driver
         include this class)
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.jdbc-datasources"></a>4.8.4.&nbsp;Pooling and JDBC DataSources</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.postgresql-7-3"></a>4.8.4.1.&nbsp;PostgreSQL 7.3 and later</h4></div></div></div><p>
               In the 7.3 release of PostgreSQL, they will start providing a
               pooling mechanism with their driver.  The Castor SVN repository
               includes a beta version of the driver with this functionality.
               Here is the 'current' configuration needed for the upcoming 7.3
               release of PostgreSQL. (Unless they change it.) Note that in this
               pooling mechanism currently lacks some features of standrd pooling 
               packages such as DBCP, such as timing out idle connections and removing 
               failed connections from the pool.  In this case, we can create the 
               following  data-source entry in the jdo-conf.xml file to provide 
               for our connections with Castor.
            </p><pre class="programlisting">
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.jdbc2.optional.PoolingDataSource"</span>&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"app"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initial-connections"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-connections"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;

            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.oracle"></a>4.8.4.2.&nbsp;Oracle</h4></div></div></div><p>
              Here is the configuration needed for using a connection pool
              with the Oracle JDBC DataSource implementations.
            </p><pre class="programlisting">
   &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"URL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span> /&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
   &lt;<span class="hl-tag">/data-source</span>&gt;
            
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.mysql"></a>4.8.4.3.&nbsp;mySQL</h4></div></div></div><p>
              Here is the configuration needed for using a connection pool
              with the mySQL JDBC DataSource implementations.
            </p><pre class="programlisting">        

&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource"</span>&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3306"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;

            </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.tomcat-jdbc-configuration"></a>4.8.5.&nbsp;Configuring JDBC DataSources in Tomcat to be used with Castor</h3></div></div></div><p>
            Finally, I want to show the configuration for using a pooling
	        data-source for Castor which is retrieved from a JNDI context
	        that Apache fills.  The first example is using the PostgreSQL
	        pooling data-source, and the second is using Castor.  The
	        information to gain here is that we did not need to change the
	        jdo-conf.xml file or the webapp's web.xml file to achieve
	        this.
         </p><p>
            First, we modify the deployment context for the webapp in Tomcat &gt;= 4.0 for our 
	        webapp in the conf/server.xml directory. (With Tomcat/Catalina releases 4.0 and higher 
	        there's more than one way of adding a 
	        <code class="literal">&lt;Resource&gt;</code> entry. Please consult with the 
	        manuals for more and more detailed information).
         </p><p>
            We add the following information (using the PostgreSQL JDBC DataSource 
	        implementations as introduced above.):
         </p><pre class="programlisting">
	        
&lt;<span class="hl-tag">Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/webapp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"test"</span> <span class="hl-attribute">debug</span>=<span class="hl-value">"10"</span>&gt;
 &lt;<span class="hl-tag">Resource</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdbc/appDb"</span> <span class="hl-attribute">auth</span>=<span class="hl-value">"Container"</span>
            <span class="hl-attribute">type</span>=<span class="hl-value">"org.postgresql.jdbc2.optional.PoolingDataSource"</span>/&gt;
   &lt;<span class="hl-tag">ResourceParams</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdbc/appDb"</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;factory&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;org.postgresql.jdbc2.optional.PGObjectFactory&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
     &lt;<span class="hl-tag">name</span>&gt;dataSourceName&lt;<span class="hl-tag">/name</span>&gt;
     &lt;<span class="hl-tag">value</span>&gt;appDb&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
     &lt;<span class="hl-tag">name</span>&gt;initialConnections&lt;<span class="hl-tag">/name</span>&gt;
     &lt;<span class="hl-tag">value</span>&gt;2&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;maxConnections&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;5&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;databaseName&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;app&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;user&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;smith&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;password&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;secret&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;serverName&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;localhost&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
  &lt;<span class="hl-tag">/ResourceParams</span>&gt;
&lt;<span class="hl-tag">/Context</span>&gt;
	     </pre><p>
            Here, we are using the PostgreSQL PGObjectFactory which
	        provides the JNDI server (Tomcat) the ability to create the
	        correct data source.  Now, the web.xml file for the webapp
	        needs to be updated too.
         </p><pre class="programlisting">        
	        
&lt;<span class="hl-tag">resource-env-ref</span>&gt;
  &lt;<span class="hl-tag">description</span>&gt;PostgreSQL pooling check&lt;<span class="hl-tag">/description</span>&gt;
  &lt;<span class="hl-tag">resource-env-ref-name</span>&gt;jdbc/appDb&lt;<span class="hl-tag">/resource-env-ref-name</span>&gt;
  &lt;<span class="hl-tag">resource-env-ref-type</span>&gt;javax.sql.DataSource&lt;<span class="hl-tag">/resource-env-ref-type</span>&gt;
&lt;<span class="hl-tag">/resource-env-ref</span>&gt;
	
	      </pre><p>
             Note that we are only calling the ref type a DataSource
	         object, not using the PostgreSQL class name.  This will
	         enable us to make changes easily.  Now, in the jdo-conf.xml
	         file that Castor uses, we no longer list the driver or
	         data-source tag, but use the JNDI one, and it is simply this:
          </p><pre class="programlisting">
	         
&lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/appDb"</span>/&gt;
	     </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.jakarta-commons-dbcp"></a>4.8.6.&nbsp;Jakarta Commons DBCP - BasicDataSource</h3></div></div></div><p>
          Commons-DBCP provides database connection pooling services, and together with 
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/pool/" target="_top">Commons-Pool</a>
          it is the default JNDI datasource provider for Tomcat.
       </p><p>
          With release 1.1 of the Jakarta Commons DBCP component, one of the major 
          new features of the JDBC 3.0 API has (finally) been added to 
          BasicDataSource, support for prepared statement pooling.
       </p><p>
          To configure Castor for the use of DBCP, please provide the following 
          &lt;data-source&gt; entry in the jdo-conf.xml file.
       </p><pre class="programlisting">
       
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
        </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jakarta-commons-dbcp.prepared-statement"></a>4.8.6.1.&nbsp;Prepared statement pooling</h4></div></div></div><p>
               As mentioened above, please note that with DBCP 1.1 and later 
			   releases, support for prepared statement pooling has been added 
			   to DBCP. As Castor JDO does <span class="bold"><strong>not</strong></span> 
			   implement prepared statement pooling itself, you will to configure 
			   DBCP explicitely to enable this feature.
            </p><p>
               To configure Castor for the use of DBCP, and to turn prepared statement
	           pooling on, please provide the following 
	           <code class="literal">&lt;data-source&gt;</code> entry in the 
	           <code class="filename">jdo-conf.xml</code> file.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pool-prepared-statements"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
            </pre><p>
	            There's plenty of information on 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/dbcp/configuration.html" target="_top">configuration</a>
	            of BasicDataSource.
	        </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.postgresql-blobs"></a>4.9.&nbsp;Blobs in PostgreSQL</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.postgresql-blobs.oid-support"></a>4.9.1.&nbsp;OID Support</h3></div></div></div><p>
		     PostgreSQL's blob support has evolved over the years. Today
		     PostgreSQL fields can be of unlimited length. And there are
		     specific data types for character and binary large objects. 
		     The current Castor support for blobs, however, uses an earlier
		     PostgreSQL blob support. This support places the blob data in
		     the pg_largeobject table and a object id in the referring
		     table. For most practical purposes using this earlier support
		     does not matter.
	     </p><p>
		     Database version and the JDBC driver version matter greatly. To get
		     everything to work I eventually built and installed PostgreSQL 7.2.2 and
		     used the JDBC driver from this build (i.e. not the one from
		     <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jdbc.postgresql.org/" target="_top">http://jdbc.postgresql.org</a>.
	     </p><p>
		     Since Castor is using the earlier blob support the JDBC has to be
		     placed in PostgreSQL 7.1 comparability mode. To do this use the
		     following JDBC URL
	     </p><pre class="programlisting">
	      jdbc:postgresql://host:port/database?compatible=7.1      </pre><p>
		     Once you have resolved the PostgreSQL version issues Castor
		     works as documented.
	     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.postgresql-blobs.oid-example"></a>4.9.2.&nbsp;OID Example</h3></div></div></div><p>
	      Here are the details of an example configuration.
	    </p><pre class="programlisting">
	      Client Windows 2000, Sun Java Standard Edition 1.3.1_03, Castor 0.9.3.21
	      Server RedHat 7.2, PostgreSQL 7.2.2     </pre><p>
	      The interface I am using is
	    </p><pre class="programlisting">
	    
	    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Document {
	        String      getTitle();
	        <span class="hl-keyword">void</span>        setTitle( String title );
	        Date        getCreatedOn();
	        <span class="hl-keyword">void</span>        setCreatedOn( Date createdOn );
	        String      getContentType();
	        <span class="hl-keyword">void</span>        setContentType( String contentType );
	        InputStream getContent();
	        <span class="hl-keyword">void</span>        setContent( InputStream content );
	    }
	    </pre><p>
	      and this is implemented by the class <code class="classname">DocumentImpl</code>.
	    </p><p>The mapping file is</p><pre class="programlisting">
	    
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
    &lt;<span class="hl-tag">mapping</span>&gt;
     &lt;<span class="hl-tag">class</span>
         <span class="hl-attribute">name</span>=<span class="hl-value">"com.ingenta.DocumentImpl"</span>
         <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>
         <span class="hl-attribute">key-generator</span>=<span class="hl-value">"SEQUENCE"</span> &gt;
         &lt;<span class="hl-tag">description</span> /&gt;
         &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;  
         &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"documents"</span> /&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> &gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span>/&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"title"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"title"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"longvarchar"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"createdOn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"createdon"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contentType"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contenttype"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"longvarchar"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"content"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"stream"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"content"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
     &lt;<span class="hl-tag">/class</span>&gt;
 &lt;<span class="hl-tag">/mapping</span>&gt;
	 </pre><p>Note that the blob is not dirty checked.</p><p>And the SQL is</p><pre class="programlisting">
	    
    create table documents (
        id          serial    not null,
        title       text      null,
        createdon   timestamp null,
        contenttype text      null,
        content     oid       null,
        primary key ( id )
    );
	    </pre><p>
		    Castor caches objects between transactions for performance. With
		    a blob however the cached object's InputStream is not
		    reusable. To workaround this I have told the cache to not cache
		    any objects of this class by adding to the class mapping, as
		    noted above.
	    </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.best-practice"></a>4.10.&nbsp;Castor JDO - Best practice</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.introduction"></a>4.10.1.&nbsp;Introduction</h3></div></div></div><p>
	       There's many users of Castor JDO out there, who (want to) use Castor JDO in 
	       in high-volume applications. To fine-tune Castor for such environment, it is 
	       necessary to understand many of the product features in detail and to be able to
	       balance their use according to the application needs. Even though many of these
	       features are detailed in various places, people have frequently been asking 
	       for a 'best practise' document, a document that brings together these technical 
	       topics (in one place) and presents them as a set of easy-to-use recipes.
	    </p><p>
	       Please be aware that this document is <span class="emphasis"><em>under construction</em></span>, 
	       but still we believe that - even when in its conception phase 
	       - it provides valuable information to users of Castor JDO.
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.general-suggestions"></a>4.10.2.&nbsp;General suggestions</h3></div></div></div><p>
           Let's start with some general suggestions that you should have a look at. Please don't 
           feel upset if some are really primitive but there may be users reading this document
		   that are not aware of them.
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Switch to version 0.9.9 of Castor as we have fixed some 100+ bugs 
                    that may causesome of your problems.
                </p><p>
                    Sidenote: Performance has, generally, improved recently. 
                    If you're not seeing performance improvements, then it's worth 
                    spending some time thinking about why.
                </p></li><li><p>
                    Initialize your JDOManager instance once and reuse it all over 
                    your application. Don't reuse the Database instances. 
                    Creating them is inexpensive, and JDBC rules state that one thread 
                    &lt;-&gt; one JDBC connection is the rule. Do not multithread inside 
                    of a Database instance; as a corrolary, do not multithread on a 
                    single JDBC connection.
                </p></li><li><p>
                    Use a Datasource instead of a Driver configuration as they enable 
                    connection pooling which gives you a great performance improvement.
                </p><p>
                    We highly suggest DBCP, here, with the beneficial use of prepared 
                    statement caching.
                </p><p>
                    Should you be running on a system where read performance is 
                    critical, feel free to take the SQL code generated by castor, 
                    and dumped to logs during the DB mapping load in debug output, 
                    and turn those into stored procedures that you then invoke via 
                    SQL CALL to perform those loads; however, I find personally that 
                    stored procedures would be a minimal improvement over the DBCP 
                    prepared statement cache; your mileage may vary. 
                    <code class="methodname">db.load()</code> has performance benefits that 
                    are worth keeping, IMO, and the pleasure of having pretty stored 
                    procedures in your database is far outweighed by the nightmare 
                    of change management.
                </p><p>
                    Have a look at 
                   <a href="advanced-jdo.html#advanced-jdo.pooling.jakarta-commons-dbcp" title="4.8.6.&nbsp;Jakarta Commons DBCP - BasicDataSource">the 
                   HTML docs</a> for Jakarta DBCP, which has details about how to 
                   use and configure DBCP with Castor and Tomcat.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                        'prepared statement caches' refer to the fact that DBCP is a 
                        JDBC 3.0-compliant product, and as such has to support caching 
                        of prepared statements. This basically allows the JDBC driver 
                        to maintain a pool of prepared statements across all 
                        connections, a feature that has been added to the JDBC 
                        specification with release 3.0 only.
                    </p></td></tr></table></div><p>
                    DBCP setup is generally outside of the scope of this list, 
                    but basically, here's my two cent description:
                </p><p>
                  </p><div class="itemizedlist"><ul type="disc"><li><p>
                          Use tomcat 5.5, because mucking about in server.xml sucks. 
                          For those of you working with Tomcat 4.1.x, there's no need 
                          to muck about in server.xml, either. Afaik, a web app can be 
                          deployed using a web app descriptor copied into 
                          $TOMCAT_HOME/webapps, which is the place top define anything
                           specific to a web app context. Details can vary, of course.
                      </p></li><li><p>
                            Create a META-INF directory in your WAR deploy scripts, and put a 
                            context.xml in it.
                        </p></li><li><p>
                            In that context.xml, describe all of the things you want 
                            to be made available via JNDI to your application. 
                            These include things like UserTransaction and 
                            TransactionManager (for those of us using JOTM), all your 
                            database connection pools as datasources, etc. You can also 
                            add your JDO factory here, should you choose to do so.
                      </p></li><li><p>
                        Configure Castor to load those JNDI names to retrieve connections.
                      </p></li></ul></div><p>
                </p><p>Hit the deploy button, and bob's your uncle.</p></li><li><p>
                    Always commit or rollback your transactions and close your Database 
                    instances properly; also in fail situations.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			            Just the obvious general rule on Java objects that hold 
			            resources: Don't wait for the VM to finalize to have something 
			            happen to your objects when you could have released critical 
			            resources at the appropriate point in the codebase.
                    </p></td></tr></table></div></li><li><p>
                    Keep your transactions as short as possible. If you have an open 
                    transaction that holds a write lock on an object no other 
                    transaction can get a write lock on the same object which will 
                    lead to a LockNotGrantedException.
                </p><pre class="programlisting">
execute() {
   Database db = jdo.getDatabase();
   db.begin();
   <span class="hl-comment">// query objects from database with read only</span>
   db.commit();
   db.close();

   <span class="hl-comment">// do some time consuming processing with the data</span>

   Database db = jdo.getDatabase();
   db.begin();
   <span class="hl-comment">// use db.load() to load the objects you need to change again</span>
   <span class="hl-comment">// create, update or delete some objects</span>
   db.commit();
   db.close();
}               </pre><p>
                    It doesn't make sense to make a own transaction for every change 
                    you want to do to an object as this will slow down your application. 
                    On the other hand if you have transactions with lots of objects 
                    involved taking an valuable amonth of time you may consider to 
                    split this transactions to reduce the time an object is locked.
                </p><p>
                    Also keep in mind that folks using lockmode of DBLocked do 
                    <code class="function">FOR UPDATE</code> calls on things they read while 
                    the transaction is open; if you're using dblocked mode, be aware 
                    of how your application does things. If you're in one of the 
                    other modes, locks happen inside castor, and it's your 
                    responsibility to always use the right access mode when accessing 
                    content.
                </p><p>
                    If you can, for example, decide at the API layer whether or not an 
                    operation is going to ever need to modify an object, and know that 
                    you will only ever use an instance in read only mode, load objects 
                    with access mode read only, and not shared.
                </p><p>
                    Limit use of read-write objects to situations in which it is likely 
                    you will need to perform updates.
                </p><p>
                    Imagine, for a moment, that these transactions were in DBLocked 
                    mode - transactions which translate directly into locks on the 
                    database.
                </p><p>
                    If you're opening something up for modification on the DB 
                    - marking it as select <code class="function">FOR UPDATE</code> 
                    - then that row will be locked until you commit. 
                    The database would prevent any other transaction that wants to 
                    touch that row from doing anything to it, and it would block on 
                    your transaction - deadlock at the SQL level.
                </p><p>
                    Castor does the same things internally for its own access modes 
                    - Shared and Exclusive. Each has different locking semantics; 
                    having good performance means understanding those locking semantics.
                </p><p>
                    For example - read only transactions (should be) cheap. 
                    So there's no issue with holding those transactions open a 
                    long time; because they only translate, for an instant, into 
                    a lock. The lock is released the moment the load is completed 
                    and the object is dropped into read-only state within your 
                    transaction; read only operations therefore operate, pretty much, 
                    without locking.
                </p><p>
                    The lock is of course acquired because you might also have it in 
                    SHARED or EXCLUSIVE mode on another thread - and that read-only 
                    operation isn't safe until those transactions close.
                </p><p>
                    Once the lock is released, you're lock-free again, so the 
                    transaction basically has nothing in it that needs anything doing.
                </p><p>
                    That's not to say that holding transactions open is good practice 
                    - but transactions should always be thought of as cheap to create 
                    and destroy and expensive to hold on to - never do heavy 
                    computation inside of one, unless you're willing to live with the 
                    consequences that arise from holding transactions on object sets 
                    that others might need to access.
                </p></li><li><p>
                   Query or load your objects <span class="bold"><strong>read only</strong></span>
                   whenever possible. Even if castor creates a lock on them this does 
                   not prevent other threads from reading or writing them. Read only 
                   queries are also about 7 times faster compared with default 
                   shared mode.
               </p><p>for queries:</p><pre class="programlisting">
String oql = "select o from FooBar o";
Query query = db.getOQLQuery(oql);
QueryResults results = query.execute(Database.ReadOnly);</pre><p>to load an object by its identity:</p><pre class="programlisting">
Integer id = <span class="hl-keyword">new</span> Integer(7);
Foo foo = (Foo) db.load(Foo.<span class="hl-keyword">class</span>, id, Database.ReadOnly);</pre><p>Default accessmode is evaluated as follows:</p><p>
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                                if specified castor uses access mode from db.load()
                                or query.execute(),
                            </p></li><li><p>
                                if this is not available it takes access mode specified 
                                in class mapping,
                            </p></li><li><p>
                                if nothing is specified in mapping it defaults to shared.
                            </p></li></ul></div><p>
                </p><p>
                    One cannot stress how important this is: If 99% of your application 
                    never writes an object, and you as a programmer know it won't, 
                    then do something about it. If you're in a situation where you want 
                    the object to be read-only most of the time, and only want a 
                    writable every now and then, do so just-in-time by performing a 
                    load-modify-store operation in a single transaction for the 
                    shareable you want.</p><p>
                    In other words: Don't use read-write objects unless you know you're likely 
                    to want to write them.
                </p></li><li><p>
                   If there is a possibility you should prefer 
                   <code class="methodname">Database.load(Class, object)</code> over 
                   <code class="methodname">Query.execute(String)</code>. I suggest that as 
                   <code class="methodname">load()</code> first tries to load the requested 
                   object from cache and only retrieves it from database when it is 
                   not available there. When executing queries with 
                   <code class="methodname">Query.execute()</code> the object will always 
                   be loaded from database without looking at the cache. You may gain 
                   a improvement by a factor of 10 and more when changing from 
                   <code class="methodname">Query.execute()</code> to 
                   <code class="methodname">Database.load()</code>.
                </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.further-optimization"></a>4.10.3.&nbsp;Further optimization</h3></div></div></div><p>
            We hope above suggestions help you to resolve the problems you have. 
            If you still need more performance there are areas of improvement 
            that are more difficult to resolve. For further ideas to improve 
            your applications performance you should take a loock at out performance 
            test suite (PTF) which you can find in Castor's source distribution under: 
            src/tests/ptf/jdo.
		</p><p>
            Now, there's lots left to do - there is still the issue, for example, 
            of dependent objects being slightly sub-optimal in performance both in 
            terms of the SQL that gets generated and the way it gets managed 
            - but there will be improvements over time to the way that this and 
            other operations are performed.
        </p><p>
            But performance should be good right now. If it isn't, you'll need to 
            think about whether you are using the optimal set of operations. 
            No environment can predict your requirements - hinting to the system when 
            objects can be safely assumed to be read-only is vital to a 
            high-performance implementation.
        </p></div></div>
  
</div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jdo.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="Spring ORM integration.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Castor JDO&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:85%;"><a href="http://www.castor.org/" title="The Castor community">The Castor community</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM</td></tr></table></div></body></html>