<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Castor 1.4.0 - Reference documentation</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d4e1"></a>Castor 1.4.0 - Reference documentation</h1></div><div><div class="legalnotice"><a name="d4e4"></a>
         <p>Copies of this document may be made for your own use and
            for
            distribution to others, provided that you do not charge any fee for such
            copies and further provided that each copy contains this Copyright
            Notice, whether distributed in print or electronically.
         </p>
      </div></div></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#XML data binding">1. Castor XML - XML data binding</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e8">1.1. XML framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10">1.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#xml.framework.data.binding.framework">1.1.2. Castor XML - The XML data binding framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e33">1.1.2.1. Introspection mode</a></span></dt><dt><span class="section"><a href="#d4e62">1.1.2.2. Mapping mode</a></span></dt><dt><span class="section"><a href="#d4e116">1.1.2.3. Descriptor mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e119">1.1.3. Sources and destinations</a></span></dt><dt><span class="section"><a href="#d4e242">1.1.4. 
         XMLContext - A consolidated way to bootstrap Castor
      </a></span></dt><dt><span class="section"><a href="#d4e258">1.1.5. Using existing Classes/Objects</a></span></dt><dt><span class="section"><a href="#xml.framework.class.descriptors">1.1.6. Class Descriptors</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping">1.2. XML Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.introduction">1.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#xml.mapping.overview">1.2.2. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.overview.marshalling">1.2.2.1. Marshalling Behavior</a></span></dt><dt><span class="section"><a href="#xml.mapping.overview.unmarshalling">1.2.2.2. Unmarshalling Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping.mappingfile">1.2.3. The Mapping File</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.mappingfile.sampledomainobjects">1.2.3.1. Sample domain objects</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.mapping">1.2.3.2. The &lt;mapping&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.class">1.2.3.3. The &lt;class&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.mapto">1.2.3.4. The &lt;map-to&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.field">1.2.3.5. The &lt;field&gt; element</a></span></dt><dt><span class="section"><a href="#d4e786">1.2.3.6. Description of the content</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.bindxml">1.2.3.7. The &lt;bind-xml&gt; element</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping.mappingfile.bindxml.usagepattern">1.2.4. Usage Pattern</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.xsitype">1.2.5. xsi:type</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.locationattribute">1.2.6. Location attribute</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.tips">1.2.7. Tips</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e963">1.2.7.1. Automatically create a mapping file</a></span></dt><dt><span class="section"><a href="#d4e967">1.2.7.2. Create your own FieldHandler</a></span></dt><dt><span class="section"><a href="#d4e972">1.2.7.3. Mapping constructor arguments (since 0.9.5)</a></span></dt><dt><span class="section"><a href="#d4e981">1.2.7.4. Preventing Castor from checking for a default constructor (since 0.9.5)</a></span></dt><dt><span class="section"><a href="#d4e984">1.2.7.5. Type safe enumeration mapping (since 0.9.5)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.configuration">1.3. Configuring Castor XML (Un)Marshaller</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e990">1.3.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e993">1.3.2. Configuring the Marshaller</a></span></dt><dt><span class="section"><a href="#d4e1018">1.3.3. Configuring the Unmarshaller</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1040">1.4. Usage of Castor and XML parsers</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1042">1.4.1. SAX/DOM</a></span></dt><dt><span class="section"><a href="#d4e1072">1.4.2. StAX</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1078">1.5. XML configuration file</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1080">1.5.1. News</a></span></dt><dt><span class="section"><a href="#d4e1102">1.5.2. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1318">1.5.3. Accessing the properties from within code</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1340">1.6. Castor XML - Tips &amp; Tricks</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1342">1.6.1. Logging and Tracing</a></span></dt><dt><span class="section"><a href="#d4e1356">1.6.2. Indentation</a></span></dt><dt><span class="section"><a href="#d4e1362">1.6.3. XML:Marshal validation</a></span></dt><dt><span class="section"><a href="#d4e1367">1.6.4. NoClassDefFoundError</a></span></dt><dt><span class="section"><a href="#d4e1370">1.6.5. Mapping: auto-complete</a></span></dt><dt><span class="section"><a href="#d4e1383">1.6.6. Create method</a></span></dt><dt><span class="section"><a href="#d4e1400">1.6.7. MarshalListener and UnmarshalListener</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1428">1.7. Castor XML: Writing Custom FieldHandlers</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1430">1.7.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1438">1.7.2. Writing a simple FieldHandler</a></span></dt><dt><span class="section"><a href="#xml.field.handler.generalized">1.7.3. Writing a GeneralizedFieldHandler</a></span></dt><dt><span class="section"><a href="#d4e1479">1.7.4. Use ConfigurableFieldHandler for more flexibility</a></span></dt><dt><span class="section"><a href="#d4e1510">1.7.5. Reuse a <code class="classname">ConfigurableFieldHandler</code> for more than one field definition</a></span></dt><dt><span class="section"><a href="#d4e1524">1.7.6. No Constructor, No Problem!</a></span></dt><dt><span class="section"><a href="#d4e1547">1.7.7. Collections and FieldHandlers</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1569">1.8. Best practice</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1574">1.8.1. General</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1576">1.8.1.1. Source Generator</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1582">1.8.2. Performance Considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1584">1.8.2.1. General</a></span></dt><dt><span class="section"><a href="#d4e1593">1.8.2.2. Use of XMLContext - With and without a mapping file</a></span></dt><dt><span class="section"><a href="#d4e1659">1.8.2.3. Use of Marshaller/Unmarshaller</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d4e1719">1.9. Castor XML - HOW-TO's</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1721">1.9.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1724">1.9.2. Documentation</a></span></dt><dt><span class="section"><a href="#d4e1739">1.9.3. Contribution</a></span></dt><dt><span class="section"><a href="#d4e1754">1.9.4. Mapping</a></span></dt><dt><span class="section"><a href="#d4e1799">1.9.5. Validation</a></span></dt><dt><span class="section"><a href="#d4e1805">1.9.6. Source generation</a></span></dt><dt><span class="section"><a href="#d4e1811">1.9.7. Others</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1823">1.10. XML FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.faq.general">1.10.1. General</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1851">1.10.1.1. How do I set the encoding?</a></span></dt><dt><span class="section"><a href="#d4e1857">1.10.1.2. 
				I'm getting an error about 'xml' prefix already
				declared?
			</a></span></dt><dt><span class="section"><a href="#d4e1872">1.10.1.3. Why is my 'get' method called twice?</a></span></dt><dt><span class="section"><a href="#d4e1875">1.10.1.4. 
				How can I speed up marshalling/unmarshalling
				performance?
			</a></span></dt><dt><span class="section"><a href="#d4e1896">1.10.1.5. 
				How do I ignore elements during unmarshalling?
			</a></span></dt><dt><span class="section"><a href="#d4e1909">1.10.1.6. 
				Where does Castor search for the castor.properties file?
			</a></span></dt><dt><span class="section"><a href="#d4e1923">1.10.1.7. 
				Can I programmatically change the properties found in
				the castor.properties file?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.introspection">1.10.2. Introspection</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1929">1.10.2.1. Can private methods be introspected?</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.mapping">1.10.3. Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1934">1.10.3.1. My mapping file seems to have no effect!</a></span></dt><dt><span class="section"><a href="#d4e1938">1.10.3.2. 
				Are there any tools to automatically create a mapping
				file?
			</a></span></dt><dt><span class="section"><a href="#d4e1943">1.10.3.3. 
				How do I specify a namespace in the mapping file?
			</a></span></dt><dt><span class="section"><a href="#d4e1950">1.10.3.4. 
				How do I prevent a field from being marshaled?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.marshalling">1.10.4. Marshalling</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1958">1.10.4.1. 
				The XML is marshalled on one line, how do I force
				line-breaks?
			</a></span></dt><dt><span class="section"><a href="#d4e1966">1.10.4.2. What is the order of the marshalled XML elements?</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.generation">1.10.5. Source code generation</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1972">1.10.5.1. Can I use a DTD with the source generator?</a></span></dt><dt><span class="section"><a href="#d4e1976">1.10.5.2. 
				My XML output looks incorrect, what could be wrong?
			</a></span></dt><dt><span class="section"><a href="#d4e1981">1.10.5.3. 
				The generated source code has incorrect or missing
				imports for imported schema types
			</a></span></dt><dt><span class="section"><a href="#d4e2000">1.10.5.4. 
				How can I make the generated source code more JDO
				friendly?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.misc">1.10.6. Miscellaneous</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2011">1.10.6.1. 
				Is there a way to automatically create an XML Schema
				from an XML instance?
			</a></span></dt><dt><span class="section"><a href="#d4e2015">1.10.6.2. How to enable XML validation with Castor XML</a></span></dt><dt><span class="section"><a href="#d4e2022">1.10.6.3. 
				Why is mapping ignored when using a FieldHandlerFactory
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.serialization">1.10.7. Serialization</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2035">1.10.7.1. 
				Is it true that the use of Castor XML mandates 
                Apache Xerces as
				XML parser?
			</a></span></dt><dt><span class="section"><a href="#d4e2042">1.10.7.2. 
				Do I still have to download Xerces when using Castor XML
				with Java 5.0?
			</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#xml.code.generator">2. XML code generation</a></span></dt><dd><dl><dt><span class="section"><a href="#introduction.why-code-generator">2.1. Why Castor XML code generator - Motivation</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction">2.2. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.introduction.news">2.2.1. News</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.introduction.news.newFieldNamingConventions">2.2.1.1. Source generation &amp; Java field naming conventions</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.news.java50">2.2.1.2. Source generation &amp; Java 5.0</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.introduction.introduction">2.2.2. Introduction</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.invocation">2.2.3. Invoking the XML code generator</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.xml.schema">2.2.4. XML Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.properties">2.3. Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.properties.overview">2.3.1. Overview</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.process">2.3.2. Customization - Lookup mechanism</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed">2.3.3. Detailed descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.properties.detailed.java50">2.3.3.1. org.exolab.castor.builder.javaVersion</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.enumerations">2.3.3.2. org.exolab.castor.builder.javaVersion</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.bound.properties">2.3.3.3. org.exolab.castor.builder.boundproperties</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.class.creation">2.3.3.4. org.exolab.castor.builder.javaclassmapping</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.super.class">2.3.3.5. org.exolab.castor.builder.superclass</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.namespace.mapping">2.3.3.6. org.exolab.castor.builder.nspackages</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.equals">2.3.3.7. org.exolab.castor.builder.equalsmethod</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.use.cyclebreaker">2.3.3.8. org.exolab.castor.builder.useCycleBreaker</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.primitive.wrappers">2.3.3.9. org.exolab.castor.builder.primitivetowrapper</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.name.conflict.resolution">2.3.3.10. org.exolab.castor.builder.automaticConflictResolution</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.extra.collection">2.3.3.11. org.exolab.castor.builder.extraCollectionMethods</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.class.printing">2.3.3.12. org.exolab.castor.builder.jclassPrinterFactories</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.extra.documentation">2.3.3.13. org.exolab.castor.builder.extraDocumentationMethods</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.custom.bindings">2.4. Custom bindings</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file">2.4.1. Binding File</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.binding">2.4.1.1. &lt;binding&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.include">2.4.1.2. &lt;include&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.package">2.4.1.3. &lt;package&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.namingXML">2.4.1.4. &lt;namingXML&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.componentBinding">2.4.1.5. &lt;componentBinding&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2642">2.4.1.6. &lt;java-class&gt;</a></span></dt><dt><span class="section"><a href="#d4e2705">2.4.1.7. &lt;member&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2759">2.4.1.8. &lt;contentMember&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2789">2.4.1.9. &lt;enumBinding&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2808">2.4.1.10. Not implemented yet</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e2822">2.4.2. Class generation conflicts</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2831">2.4.2.1. Collision reporting</a></span></dt><dt><span class="section"><a href="#d4e2875">2.4.2.2. Automatic collision resolution</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations">2.5. Invoking the XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.anttask">2.5.1. Ant task definition</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.source">2.5.1.1. Specifying the source for generation</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.parameters">2.5.1.2. Parameters</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.examples">2.5.1.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations.maven">2.5.2. Maven 2 plugin</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.maven.configuration">2.5.2.1. Configuration</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.maven.life-cycle">2.5.2.2. Integration into build life-cycle</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.maven.example">2.5.2.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations.cmd">2.5.3. Command line</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.cmd.first.steps">2.5.3.1. First steps</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.cmd.options">2.5.3.2. Source Generator - command line options</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.schema.support">2.6. XML schema support</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3438">2.6.1. Supported XML Schema Built-in Datatypes</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.schema.support.datatypes.built-in.primitive">2.6.1.1. Primitive Datatypes</a></span></dt><dt><span class="section"><a href="#xml.code.generator.schema.support.datatypes.built-in.derived">2.6.1.2. Derived Datatypes</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.schema.support.structures">2.6.2. Supported XML Schema Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.schema.support.structures.groups">2.6.2.1. Groups</a></span></dt><dt><span class="section"><a href="#xml.code.generator.schema.support.structures.wildcard">2.6.2.2. Wildcard</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.examples">2.7. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema">2.7.1. The invoice XML schema</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.file">2.7.1.1. The schema file</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.running">2.7.1.2. Running the XML code generator</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.generated">2.7.1.3. The generated code</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial">2.7.2. Non-trivial real world example</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial.schema">2.7.2.1. The Supply Chain XSD</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial.binding">2.7.2.2. Binding file? -- IT IS REQUIRED!</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#xml.code.generator.extensions">3. XML code generation - Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.extensions.why">3.1. XML code generation extensions - Motivation</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.extensions">3.1.1. JDO extensions for the Castor XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.extensions.why">3.1.1.1. JDO extensions - Motivation</a></span></dt><dt><span class="section"><a href="#jdo.extensions.limitations">3.1.1.2. Limitations</a></span></dt><dt><span class="section"><a href="#jdo.extensions.prerequisites">3.1.1.3. Prerequisites</a></span></dt><dt><span class="section"><a href="#jdo.extensions.generation">3.1.1.4. Configuring the XML code generator</a></span></dt><dt><span class="section"><a href="#jdo.extensions.schema.elements">3.1.1.5. The JDO annotations for XML schemas</a></span></dt><dt><span class="section"><a href="#jdo.extensions.usage">3.1.1.6. Using the generated (domain) classes with Castor JDO</a></span></dt></dl></dd><dt><span class="section"><a href="#solrj.extensions">3.1.2. SOLRJ extensions for the Castor XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#solrj.extensions.why">3.1.2.1. SOLRJ extensions - Motivation</a></span></dt><dt><span class="section"><a href="#solrj.extensions.prerequisites">3.1.2.2. Prerequisites</a></span></dt><dt><span class="section"><a href="#solrj.extensions.schema.elements">3.1.2.3. The SOLRJ annotations for XML schemas</a></span></dt><dt><span class="section"><a href="#solrj.extensions.usage">3.1.2.4. Using the generated domain classes with SOLR</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div>
   

   

   <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="XML data binding"></a>Chapter&nbsp;1.&nbsp;Castor XML - XML data binding</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e8"></a>1.1.&nbsp;XML framework</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10"></a>1.1.1.&nbsp;Introduction</h3></div></div></div><p>
         Castor XML is an XML data binding framework. Unlike the two
         main XML APIs, DOM (Document Object Model) and
         SAX (Simple
         API for XML) which deal with the structure of an XML
         document, Castor enables you to deal with the
         data defined
         in an XML document through an object model which represents
         that data.
      </p><p>
         Castor XML can marshal almost any "bean-like" Java Object to
         and from XML. In most cases the marshalling
         framework uses a
         set of ClassDescriptors and FieldDescriptors to describe how
         an Object should be marshalled and
         unmarshalled from XML.
      </p><p>
         For those not familiar with the terms "marshal" and
         "unmarshal", it's simply the act of converting a stream
         (sequence of bytes) of data to and from an Object. The act
         of "marshalling" consists of converting an Object to
         a
         stream, and "unmarshalling" from a stream to an Object.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.data.binding.framework"></a>1.1.2.&nbsp;Castor XML - The XML data binding framework</h3></div></div></div><p>
         The XML data binding framework, as it's name implies, is
         responsible for doing the conversion between Java and
         XML.
         The framework consists of two worker classes,
         <code class="classname">org/exolab/castor/xml/Marshaller</code>
         and
         <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
         respectively, and a bootstrap class
         <code class="classname">org.exolab.castor.xml.XMLContext</code>
         used for configuration of the XML data binding framework and
         instantiation of the two worker objects.
      </p><p>
         Lets walk through a very simple example. Assume we have a
         simple
         <code class="classname">Person</code>
         class as follows:
      </p><pre class="programlisting">
         <span class="hl-keyword">import</span> java.util.Date;

         <span class="hl-comment">/** An simple person class */</span>
         <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person
         <span class="hl-keyword">implements</span> java.io.Serializable {

         <span class="hl-comment">/** The name of the person */</span>
         <span class="hl-keyword">private</span> String name = null;

         <span class="hl-comment">/** The Date of birth
         */</span>
         <span class="hl-keyword">private</span> Date dob = null;

         <span class="hl-comment">/** Creates a Person with no name */</span>
         <span class="hl-keyword">public</span> Person() {
         <span class="hl-keyword">super</span>();
         }

         <span class="hl-comment">/** Creates a Person
         with the given name */</span>
         <span class="hl-keyword">public</span> Person(String name) { <span class="hl-keyword">this</span>.name = name; }

         <span class="hl-comment">/**
         * @return date of birth of the person
         */</span>
         <span class="hl-keyword">public</span> Date getDateOfBirth() { <span class="hl-keyword">return</span> dob; }

         <span class="hl-comment">/**
         * @return name of the person
         */</span>
         <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span>
         name; }

         <span class="hl-comment">/**
         * Sets the date of birth of the person
         * @param name the name of the person
         */</span>
         <span class="hl-keyword">public</span> <span class="hl-keyword">void</span>
         setDateOfBirth(Date dob) { <span class="hl-keyword">this</span>.dob = dob; }

         <span class="hl-comment">/**
         * Sets the name of the person
         * @param name the name of the
         person
         */</span>
         <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { <span class="hl-keyword">this</span>.name = name; }
         }
      </pre><p>
         To (un-)marshal data to and from XML, Castor XML can be used
         in one of three modes:
      </p><div class="itemizedlist"><ul type="disc"><li><p>introspection mode</p></li><li><p>mapping mode</p></li><li><p>descriptor mode (aka generation mode)</p></li></ul></div><p>
         The following sections discuss each of these modes at a high
         level.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e33"></a>1.1.2.1.&nbsp;Introspection mode</h4></div></div></div><p>
            The
            <span class="italic">introspection mode</span>
            is the simplest mode to use from a user perspective, as
            it does not require any configuration from the user.
            As
            such, the user does not have to provide any mapping
            file(s), nor point Castor to any generated descriptor
            classes (as discussed in the 'descriptor mode' section).
         </p><p>
            In this mode, the user makes use of
            <span class="bold"><strong>static</strong></span>
            methods on the
            <code class="classname">org.exolab.castor.xml.Marshaller</code>
            and
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
            classes, providing all required data as parameters on
            these method calls.
         </p><p>
            To marshal an instance of the person class you simply
            call the
            <code class="classname">org.exolab.castor.xml.Marshaller</code>
            as follows:
         </p><pre class="programlisting">
            <span class="hl-comment">// Create a new Person</span>
            Person person = <span class="hl-keyword">new</span> Person(<span class="hl-string">"Ryan 'Mad Dog'
            Madden"</span>);
            person.setDateOfBirth(<span class="hl-keyword">new</span> Date(1955, 8, 15));

            <span class="hl-comment">// Create a File to marshal to</span>
            writer = <span class="hl-keyword">new</span>
            FileWriter(<span class="hl-string">"test.xml"</span>);

            <span class="hl-comment">// Marshal the person object</span>
            Marshaller.marshal(person, writer);
         </pre><p>
            This produces the XML shown in
            <a href="#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a>
         </p><div class="example"><a name="xml.framework.introspection.ouput"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;XML produced in introspection mode</b></p><div class="example-contents"><pre class="programlisting">
               XML to written
            </pre></div></div><br class="example-break"><p>
            To unmarshal an instance of the person class from XML,
            you simply call the
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
            as follows:
         </p><pre class="programlisting">
            <span class="hl-comment">// Create a Reader to the file to unmarshal from</span>
            reader = <span class="hl-keyword">new</span>
            FileReader(<span class="hl-string">"test.xml"</span>);

            <span class="hl-comment">// Marshal the person object</span>
            Person person = (Person)
            Unmarshaller.unmarshal(Person.<span class="hl-keyword">class</span>, reader);
         </pre><p>
            Marshalling and unmarshalling is basically that simple.
         </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            Note: The above example uses the
            <span class="italic">
               <span class="bold"><strong>static</strong></span>
            </span>
            methods of the marshalling framework, and as such no
            Marshaller and/or Unmarshaller instances need to be
            created. A common mistake in this context when using a
            <span class="bold"><strong>mapping file</strong></span>
            is to call the
            <code class="classname">org.exolab.castor.xml.Marshaller</code>
            or
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
            as in the above example. This won't work, as the mapping
            will be ignored.
         </td></tr></table></div><p>
            In
            <span class="italic">introspection mode</span>
            , Castor XML uses Java reflection to establish the
            binding between the Java classes (and their properties)
            and the XML, following a set of (default) naming rules.
            Whilst it is possible to change to a different set of
            naming rules, there's no way to override this (default)
            naming for individual artifacts. In such a case, a
            <span class="italic">mapping file</span>
            should be used.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e62"></a>1.1.2.2.&nbsp;Mapping mode</h4></div></div></div><p>
            In
            <span class="italic">mapping mode</span>
            , the user provides Castor XML with a user-defined
            mapping (in form of a mapping file) that allows the
            (partial) definition of a customized mapping between
            Java classes (and their properties) and XML.
         </p><p>
            When you are using a mapping file, create an instance of the
            <code class="classname">org.exolab.castor.xml.XMLContext</code>
            class and use the
            <code class="methodname">org.exolab.castor.xml.XMLContext.addMapping(Mapping)
            </code>
            method to provide Castor XML with one of more mapping files.
         </p><p>
            To start using Castor XML for marshalling and/or
            unmarshalling based upon your custom mapping, create
            instances of
            <code class="classname">org.exolab.castor.xml.Marshaller</code>
            and
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
            as needed using one of the following methods:
         </p><div class="table"><a name="d4e72"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;
               Methods on XMLContext to create Un-/Marshaller
               objects
            </b></p><div class="table-contents"><table summary="&#xA;               Methods on XMLContext to create Un-/Marshaller&#xA;               objects&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Method name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                        <p>
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
                              createMarshaller
                           </a>
                        </p>
                     </td><td align="center">
                        <p>
                           Creates a
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Marshaller" target="_top">
                              Marshaller
                           </a>
                           instance.
                        </p>
                     </td></tr><tr><td align="center">
                        <p>
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
                              createUnmarshaller
                           </a>
                        </p>
                     </td><td align="center">
                        <p>
                           Creates a
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Unmarshaller" target="_top">
                              Unmarshaller
                           </a>
                           instance.
                        </p>
                     </td></tr></tbody></table></div></div><br class="table-break"><p>
            and call any of the
            <span class="bold"><strong>non-static</strong></span>
            (un)marshal methods to trigger data binding in either
            way.
         </p><p>
            Below code shows a full example that demonstrates
            unmarshalling a
            <code class="literal">Person</code>
            instance from XML using a
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
            instance as obtained from an XMLContext previously
            configured to your needs.
         </p><div class="example"><a name="d4e101"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Unmarshalling from XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
               <span class="hl-keyword">import</span> org.exolab.castor.xml.XMLContext; <span class="hl-keyword">import</span>
               org.exolab.castor.mapping.Mapping; <span class="hl-keyword">import</span>
               org.exolab.castor.xml.Unmarshaller;

               <span class="hl-comment">// Load Mapping</span>
               Mapping
               mapping = <span class="hl-keyword">new</span> Mapping();
               mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);


               <span class="hl-comment">// initialize and configure XMLContext</span>

               XMLContext context = <span class="hl-keyword">new</span> XMLContext();
               context.addMapping(mapping);


               <span class="hl-comment">// Create a Reader to the file to</span>
               unmarshal from

               reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);

               <span class="hl-comment">// Create a new Unmarshaller</span>
               Unmarshaller unmarshaller =
               context.createUnmarshaller();
               unmarshaller.setClass(Person.<span class="hl-keyword">class</span>);

               <span class="hl-comment">// Unmarshal the person object</span>
               Person
               person = (Person)
               unmarshaller.unmarshal(reader);
            </pre></div></div><br class="example-break"><p>
            To marshal the very same
            <code class="literal">Person</code>
            instance to XML using a
            <code class="classname">org.exolab.castor.xml.Marshaller</code>
            obtained from the
            <span class="bold"><strong>same</strong></span>
            <code class="classname">org.exolab.castor.xml.XMLContext</code>
            ,
            use code as follows:
         </p><div class="example"><a name="d4e109"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Marshalling to XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
               <span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

               <span class="hl-comment">// create a Writer to the</span>
               file to marshal to
               Writer writer = <span class="hl-keyword">new</span> FileWriter(<span class="hl-string">"out.xml"</span>);

               <span class="hl-comment">// create a new Marshaller</span>
               Marshaller
               marshaller = context.createMarshaller();
               marshaller.setWriter(writer);

               <span class="hl-comment">// marshal the person object</span>
               marshaller.marshal(person);
            </pre></div></div><br class="example-break"><p>
            Please have a look at
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping</a>
            for a detailed discussion of the mapping file and its
            structure.
         </p><p>
            For more information on how to effectively deal with
            loading mapping file(s) especially in multi-threaded
            environments, please check the
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-best-practice.html" target="_top">best practice</a>
            section.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e116"></a>1.1.2.3.&nbsp;Descriptor mode</h4></div></div></div><p>TBD</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e119"></a>1.1.3.&nbsp;Sources and destinations</h3></div></div></div><p>
         Castor supports multiple sources and destinations from which
         objects can be marshalled and unmarshalled.
      </p><div class="table"><a name="d4e122"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;
            Marshalling destinations.
         </b></p><div class="table-contents"><table summary="&#xA;            Marshalling destinations.&#xA;         " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Destination</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                     <p>
                        <code class="classname">marshal(java.io.Writer)</code>
                     </p>
                  </td><td align="center">
                     <p>
                        The character stream.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(org.xml.sax.DocumentHandler)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        The SAX document handler.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(org.xml.sax.ContentHandler)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        The SAX content handler.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(org.w3c.dom.Node)</code>
                     </p>
                  </td><td align="center">
                     <p>
                        The DOM node to marshall object into.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(javax.xml.stream.XMLStreamWriter)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        The STaX cursor API.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(javax.xml.stream.XMLEventWriter)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        The STaX iterator API.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">marshal(javax.xml.transform.Result)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        <code class="literal">javax.xml.transform.dom.DOMResult
                        </code>
                        ,
                        <code class="literal">javax.xml.transform.sax.SAXResult
                        </code>
                        and
                        <code class="literal">javax.xml.transform.stream.StreamResult
                        </code>
                        are supported.
                     </p>
                  </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e177"></a><p class="title"><b>Table&nbsp;1.3.&nbsp;
            Unmarshalling sources.
         </b></p><div class="table-contents"><table summary="&#xA;            Unmarshalling sources.&#xA;         " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Source</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(java.io.Reader)</code>
                     </p>
                  </td><td align="center">
                     <p>
                        A character stream.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(org.xml.sax.InputSource)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        A SAX input source.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(org.w3c.dom.Node)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        A W3C DOM node which will be used for unmarshalling.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(javax.xml.stream.XMLStreamReader)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        A StAX cursor.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(javax.xml.stream.XMLEventReader)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        A StAX iterator.
                     </p>
                  </td></tr><tr><td align="center">
                     <p>
                        <code class="classname">unmarshal(javax.xml.transform.Source)
                        </code>
                     </p>
                  </td><td align="center">
                     <p>
                        Supports
                        <code class="literal">javax.xml.transform.dom.DOMSource
                        </code>
                        ,
                        <code class="literal">javax.xml.transform.sax.SAXSource
                        </code>
                        and
                        <code class="literal">javax.xml.transform.stream.StreamSource
                        </code>
                        .
                     </p>
                  </td></tr></tbody></table></div></div><br class="table-break"><p>
         Castor 1.3.2 and 1.3.3 introduced support for the STaX API for
         both for marshalling and unmarshalling. The
         framework fully
         supports the STaX cursor and iterator API.
      </p><p>
         An example of marshalling using STaX:
      </p><div class="example"><a name="d4e228"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Marshalling to a StAX java.xml.stream.XMLStreamWriter
         </b></p><div class="example-contents"><pre class="programlisting">
            <span class="hl-comment">// marshalling using STaX</span>
            StringWriter writer = <span class="hl-keyword">new</span> StringWriter();
            XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
            XMLStreamWriter xmlStreamWriter =
            outputFactory.createXMLStreamWriter(writer);

            marshaller.setXmlStreamWriter(xmlStreamWriter);
            marshaller.marshal(object);
         </pre></div></div><br class="example-break"><p>
         Also beginning from version 1.3.3, the framework has been
         modified to support Source and Result interfaces.
         Now it
         is possible to use SAXSource, DOMSource and StreamSource
         for unmarshalling and corresponding classes for
         marshalling.
      </p><p>
         Below an example of marshalling into Result:
      </p><div class="example"><a name="d4e233"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;
            Marshalling to a
            <code class="literal">javax.xml.transform.dom.DOMResult</code>
         </b></p><div class="example-contents"><pre class="programlisting">
            <span class="hl-comment">// instance of object to be marshalled</span>
            Object obj = ...

            <span class="hl-comment">// marshalling</span>
            into DOM node
            XMLContext xmlContext = ... <span class="hl-comment">// creates the xml context</span>

            <span class="hl-comment">// creates marshaller</span>
            Marshaller
            marshaller = xmlContext.createMarshaller();

            <span class="hl-comment">// creates DOM factory</span>
            DocumentBuilderFactory factory =
            DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            <span class="hl-comment">// creates</span>
            document
            Document document = builder.newDocument();

            <span class="hl-comment">// sets the DOM result for the marshaller</span>
            marshaller.setResult(<span class="hl-keyword">new</span> DOMResult(document));

            <span class="hl-comment">// marshalls object</span>
            marshaller.marshall(obj);
         </pre></div></div><br class="example-break"><p>
         Another example of unmarshalling from Source:
      </p><div class="example"><a name="d4e238"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;
            Unmarshalling from a
            <code class="literal">javax.xml.transform.sax.SAXSource</code>
         </b></p><div class="example-contents"><pre class="programlisting">
            <span class="hl-comment">// unmarshalling from SAX InputSource</span>
            XMLContext xmlContext = ... <span class="hl-comment">//</span>
            creates the xml context

            <span class="hl-comment">// creates unmarshaller</span>
            Unmarshaller unmarshaller = xmlContext.createUnmarshaller();

            <span class="hl-comment">// creates SAX input source</span>
            InputSource inputSource = <span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> StringReader(xml));

            <span class="hl-comment">// creates</span>
            instance of SAXSource
            SAXSource saxSource = <span class="hl-keyword">new</span> SAXSource(inputSource);

            <span class="hl-comment">// unmarshalls object</span>
            Object result =
            unmarshaller.unmarshal(saxSource);
         </pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e242"></a>1.1.4.&nbsp;
         XMLContext - A consolidated way to bootstrap Castor
      </h3></div></div></div><p>
         With Castor 1.1.2, the
         <code class="classname">org.exolab.castor.xml.XMLContext</code>
         class has been added to the Castor marshalling framework.
         This new class provides a bootstrap mechanism for
         Castor
         XML, and allows easy (and efficient) instantiation of
         <code class="classname">org.exolab.castor.xml.Marshaller</code>
         and
         <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
         instances as needed.
      </p><p>
         As shown above, the
         <code class="classname">org.exolab.castor.xml.XMLContext</code>
         class offers various factory methods to obtain a new
         <code class="classname">org.exolab.castor.xml.Marshaller</code>
         ,
         <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
         .
      </p><p>
         When you need more than one
         <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
         instance in your application, please call
         <code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()
         </code>
         as required. As all
         <code class="literal">Unmarshaller</code>
         instances are created from the very same
         <code class="literal">XMLContext</code>
         instance, overhead will be minimal. Please note, though,
         that use of one
         <code class="literal">Unmarshaller</code>
         instance is not thread-safe.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e258"></a>1.1.5.&nbsp;Using existing Classes/Objects</h3></div></div></div><p>
         Castor can marshal "almost" any arbitrary Object to and from
         XML. When descriptors are not available for a
         specfic Class,
         the marshalling framework uses reflection to gain
         information about the object.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         Actually an in memory set of descriptors are created for the
         object and we will soon have a way for saving
         these
         descriptors as Java source, so that they may be modified and
         compiled with little effort.
      </td></tr></table></div><p>
         If a set of descriptors exist for the classes, then Castor
         will use those to gain information about how to
         handle the
         marshalling. See
         <a href="#xml.framework.class.descriptors" title="1.1.6.&nbsp;Class Descriptors">Section&nbsp;1.1.6, &#8220;Class Descriptors&#8221;</a>
         for more information.
      </p><p>
         There is one main restrictions to marshalling objects. These
         classes must have have a public default
         constructor (ie. a
         constructor with no arguments) and adequete "getter" and
         "setter" methods to be properly be
         marshalled and
         unmarshalled.
      </p><p>
         The example illustrated in the previous section
         <a href="#xml.framework.data.binding.framework" title="1.1.2.&nbsp;Castor XML - The XML data binding framework">Section&nbsp;1.1.2, &#8220;Castor XML - The XML data binding framework&#8221;</a>
         demonstrates how to use the framework with existing classes.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.class.descriptors"></a>1.1.6.&nbsp;Class Descriptors</h3></div></div></div><p>
         Class descriptors provide the "Castor Framework" with
         necessary information so that the Class can be
         marshalled
         properly. The class descriptors can be shared between the
         JDO and XML frameworks.
      </p><p>
         Class descriptors contain a set of
         <a href="#">???</a>
      </p><p>
         XML Class descriptors provide the marshalling framework with
         the information it needs about a class in order to
         be
         marshalled to and from XML. The XMLClassDescriptor
         <code class="classname">org.exolab.castor.xml.XMLClassDescriptor</code>
         .
      </p><p>
         XML Class Descriptors are created in four main ways. Two of
         these are basically run-time, and the other two are
         compile
         time.

         </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e275"></a>1.&nbsp;Compile-Time Descriptors</h5></div></div></div><p>
               To use "compile-time" class descriptors, one can
               either implement the
               <code class="classname">org.exolab.castor.xml.XMLClassDescriptor
               </code>
               interface for each class which needs to be
               "described", or have the
               <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/sourcegen.xml" target="_top">Source Code Generator</a>
               create the proper descriptors.
            </p><p>
               The main advantage of compile-time descriptors is
               that they are faster than the run-time approach.
            </p></div><p>
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e281"></a>2.&nbsp;Run-Time Descriptors</h5></div></div></div><p>
               To use "run-time" class descriptors, one can either
               simply let Castor introspect the classes, a mapping
               file can be provided, or a combination of both
               "default introspection" and a specified mapping file
               may be
               used.
            </p><p>
               For "default introspection" to work the class being
               introspected must have adequete setter/getter
               methods for each field of the class that should be
               marshalled and unmarshalled. If no getter/setter
               methods exist, Castor can handle direct field access
               to public fields. It does not do both at the same
               time. So if the respective class has any
               getter/setter methods at all, then no direct field
               access will
               take place.
            </p><p>
               There is nothing to do to enable "default
               introspection". If a descriptor cannot be found for
               a class,
               introspection occurs automatically.
            </p><p>
               Some behavior of the introspector may be controlled
               by setting the appropriate properties in the
               <span class="italic">castor.properties</span>
               file. Such behavior consists of changing the naming
               conventions, and whether primitive types are treated
               as attributes or elements. See
               <span class="italic">castor.properties</span>
               file for more information.
            </p><p>
               A mapping file may also be used to "describe" the
               classes which are to be marshalled. The mapping is
               loaded before any marshalling/unmarshalling takes
               place. See
               <code class="classname">org.exolab.castor.mapping.Mapping</code>
            </p><p>
               The main advantage of run-time descriptors is that
               it takes very little effort to get something
               working.
            </p></div><p>
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.mapping"></a>1.2.&nbsp;XML Mapping</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.introduction"></a>1.2.1.&nbsp;Introduction</h3></div></div></div><p>Castor XML mapping is a way to simplify the binding of java classes to
      XML document. It allows to transform the data contained in a java object
      model into/from an XML document.</p><p>Although it is possible to rely on Castor's default behavior to marshal and
        unmarshal Java objects into an XML document, it might be necessary to have more
        control over this behavior. For example, if a Java object model already exists,
        Castor XML Mapping can be used as a bridge between the XML document and that
        Java object model.</p><p>Castor allows one to specify some of its marshalling/unmarshalling behavior
        using a mapping file. This file gives explicit information to Castor on how a
        given XML document and a given set of Java objects relate to each other.</p><p>A Castor mapping file is a good way to dissociate the changes in the structure
        of a Java object model from the changes in the corresponding XML document
        format.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.overview"></a>1.2.2.&nbsp;Overview</h3></div></div></div><p>The mapping information is specified by an XML document. This document is
        written from the point of view of the Java object and describes how the
        properties of the object have to be translated into XML. One constraint for the
        mapping file is that Castor should be able to infer unambiguously from it how a
        given XML element/attribute has to be translated into the object model during
        unmarshalling.</p><p>The mapping file describes for each object how each of its fields have to be
        mapped into XML. A field is an abstraction for a property of an object. It can
        correspond directly to a public class variable or indirectly to a property via
        some accessor methods (setters and getters).</p><p>It is possible to use the mapping and Castor default behavior in conjunction:
        when Castor has to handle an object or an XML data but can't find information
        about it in the mapping file, it will rely on its default behavior. Castor will
        use the Java Reflection API to introspect the Java objects to determine what to do.</p><p><span class="bold"><strong>Note:</strong></span> Castor can't handle all possible mappings. In some complex cases, it may be
        necessary to rely on an XSL transformation in conjunction with Castor to adapt the
        XML document to a more friendly format.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.marshalling"></a>1.2.2.1.&nbsp;Marshalling Behavior</h4></div></div></div><p>For Castor, a Java class has to map into an XML element. When Castor marshals an
          object, it will:</p><div class="itemizedlist"><ul type="disc"><li><p>use the mapping information, if any, to find the name of the element to create</p></li></ul></div><p>or</p><div class="itemizedlist"><ul type="disc"><li><p>by default, create a name using the name of the class</p></li></ul></div><p>It will then use the fields information from the mapping file to determine how a
          given property of the object has to be translated into one and only one of the
          following:</p><div class="itemizedlist"><ul type="disc"><li><p>an attribute</p></li><li><p>an element</p></li><li><p>text content</p></li><li><p>nothing, as we can choose to ignore a particular field</p></li></ul></div><p>This process will be recursive: if Castor finds a property that has a class type
          specified elsewhere in the mapping file, it will use this information to marshal
          the object.</p><p>By default, if Castor finds no information for a given class in the mapping
          file, it will introspect the class and apply a set of default rules to guess the
          fields and marshal them. The default rules are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>All primitive types, including the primitive type wrappers (Boolean,
            Short, etc...) are marshalled as attributes.</p></li><li><p>All other objects are marshalled as elements with either text content
            or element content.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.unmarshalling"></a>1.2.2.2.&nbsp;Unmarshalling Behavior</h4></div></div></div><p>When Castor finds an element while unmarshalling a document, it will try to use
          the mapping information to determine which object to instantiate. If no mapping
          information is present, Castor will use the name of the element to try to guess
          the name of a class to instantiate (for example, for an element named
          'test-element', Castor will try to instantiate a class named 'TestElement' if no
          information is given in the mapping file). Castor will then use the field
          information of the mapping file to handle the content of the element.</p><p>If the class is not described in the mapping file, Castor will instrospect the
          class using the Java Reflection API to determine if there is any function of the
          form getXxxYyy()/setXxxYyy(&lt;type&gt; x). This accessor will be associated with XML
          element/attribute named 'xxx-yyy'. In the future, we will provide a way to
          override this default behavior.</p><p>Castor will introspect object variables and use direct access _only_ if no
          get/set methods have been found in the class. In this case, Castor will look for
          public variables of the form:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; xxxYYY;
        </pre><p>and expect an element/attribute named 'xxx-yyy'. The only handled
          collections for &lt;type&gt; are java.lang.Vector and array. (up to version
          0.8.10)</p><p>For primitive &lt;type&gt;, Castor will look for an attribute first and then an
          element. If &lt;type&gt; is not a primitive type, Castor will look for an element
          first and then an attribute.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile"></a>1.2.3.&nbsp;The Mapping File</h3></div></div></div><p>
    		The following sections define the syntax for each of the mapping file artefacts
    		and their semantical meaning.
    	</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.sampledomainobjects"></a>1.2.3.1.&nbsp;Sample domain objects</h4></div></div></div><p>
    			This section defines a small domain model that will be referenced by
    			various mapping file (fragments/samples) in the following sections. The model consists 
    			of two two classes <code class="classname">Order</code> and <code class="classname">OrderItem</code>, where an order 
    			holds a list of order items.
    		</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Order {

    <span class="hl-keyword">private</span> List orderItems;
    <span class="hl-keyword">private</span> String orderNumber;
    
    <span class="hl-keyword">public</span> List getOrderItems() {
        <span class="hl-keyword">return</span> orderItems;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderItems(List orderItems) {
        <span class="hl-keyword">this</span>.orderItems = orderItems;
    }
    <span class="hl-keyword">public</span> String getOrderNumber() {
        <span class="hl-keyword">return</span> orderNumber;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderNumber(String orderNumber) {
        <span class="hl-keyword">this</span>.orderNumber = orderNumber;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderItem {
    
    <span class="hl-keyword">private</span> String id;
    <span class="hl-keyword">private</span> Integer orderQuantity;
    
    <span class="hl-keyword">public</span> String getId() {
        <span class="hl-keyword">return</span> id;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(String id) {
        <span class="hl-keyword">this</span>.id = id;
    }
    <span class="hl-keyword">public</span> Integer getOrderQuantity() {
        <span class="hl-keyword">return</span> orderQuantity;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderQuantity(Integer orderQuantity) {
        <span class="hl-keyword">this</span>.orderQuantity = orderQuantity;
    }
}</pre><p>
	        	As shown above in bold, the <code class="classname">Order</code> instance has a (private) field <code class="classname">'orderItems'</code>
				to hold a collection of <code class="classname">OrderItem</code> instances. This field is publically exposed
				by corresponding getter and setter methods.
	        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapping"></a>1.2.3.2.&nbsp;The &lt;mapping&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT mapping ( description?, include*, field-handler*, <span class="hl-keyword">class</span>*, key-generator* )&gt;
        </pre><p>The &lt;mapping&gt; element is the root element of a mapping file. It contains:</p><div class="itemizedlist"><ul type="disc"><li><p>an optional description</p></li><li><p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li><li><p>zero of more &lt;field-handler&gt; defining custom, configurable field handlers</p></li><li><p>zero or more &lt;class&gt; descriptions: one for each class we intend to give
            mapping information</p></li><li><p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li></ul></div><p>A mapping file look like this:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;

&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
      castor.org
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
	&lt;description&gt;Description of the mapping&lt;/description&gt;
	
	&lt;include href=<span class="hl-string">"other_mapping_file.xml"</span>/&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'A'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"A"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'B'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"B"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.class"></a>1.2.3.3.&nbsp;The &lt;class&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT class ( description?, cache-type?, map-to?, field+ )&gt;
&lt;!ATTLIST class
          name            ID       #REQUIRED
          extends         IDREF    #IMPLIED
          depends         IDREF    #IMPLIED
          auto-complete   ( true |false ) "false"
          identity        CDATA    #IMPLIED
          access          ( read-only | shared | exclusive | db-locked )  "shared"
          key-generator   IDREF    #IMPLIED &gt;</pre><p>The  <code class="classname">&lt;class&gt;</code> element contains all the information used to 
           map a Java class into an XML document. The content of <code class="classname">&lt;class&gt;</code>
           is mainly used to describe the fields that will be mapped.</p><div class="table"><a name="d4e381"></a><p class="title"><b>Table&nbsp;1.4.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The fuly-qualified name of the Java class that we want to map to.</td></tr><tr><td><span class="bold"><strong>extends</strong></span></td><td>The fully qualified name of a parent class. This attribute should be used <span class="bold"><strong>only</strong></span>
					if this class extends another class for which a class mapping is provided. It 
					should <span class="bold"><strong>not</strong></span> be used if there's no class maping for the extended 
					class.</td></tr><tr><td><span class="bold"><strong>depends</strong></span></td><td>Used with Castor JDO only; for more information on this field, please
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>auto-complete</strong></span></td><td>If true, the class will be introspected to determine its field and 
				    the fields specified in the mapping file will be used to overide the 
				    fields found during the introspection.</td></tr><tr><td><span class="bold"><strong>identity</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>access</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>key-generator</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr></tbody></table></div></div><br class="table-break"><p>The auto-complete attributes is interesting as it allow a fine degree
           of control of the introspector: it is possible to specifiy only the
           fields whose Castor default behavior does not suite our needs. These
           feature should simplify the handling of complexe class containing many
           fields. Please see below for an example usage of this attribute.</p><div class="table"><a name="d4e424"></a><p class="title"><b>Table&nbsp;1.5.&nbsp;Description of the content</b></p><div class="table-contents"><table summary="Description of the content" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>description</strong></span></td><td>An optional description.</td></tr><tr><td><span class="bold"><strong>cache-type</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>map-to</strong></span></td><td>
					Used if the name of the element is not the name of the class. By
					default, Castor will infer the name of the element to be mapped from
					the name of the class: a Java class named 'XxxYyy' will be transformed
					in 'xxx-yyy'. If you don't want Castor to generate the name, you need
					to use &lt;map-to&gt; to specify the name you want to use. &lt;map-to&gt; is
					only used for the root element.
				</td></tr><tr><td><span class="bold"><strong>field</strong></span></td><td>Zero or more &lt;field&gt; elements, which are used to describe the properties 
				    of the Java class being mapped.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.sampleclassmappings"></a>1.2.3.3.1.&nbsp;Sample &lt;class&gt; mappings</h5></div></div></div><p>The following mapping fragment defines a class mapping for the <code class="classname">OrderItem</code>
           class:</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem&gt;
           
   &lt;map-to xml="</span>item"/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

   &lt;/field name=<span class="hl-string">"orderQuantity"</span> type=<span class="hl-string">"integer"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling an	<code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;quantity&gt;100&lt;/quantity&gt;
&lt;/item&gt;</pre><p>The following mapping fragment defines a class mapping for the same
			   class, where for all properties but <code class="classname">id</code> introspection should
			   be used; the use of the <code class="classname">auto-complete</code> attribute instructs Castor XML
			   to use introspection for all attributes other than <code class="classname">'id'</code>, where
			   the given field mapping will be used.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;map-to xml=<span class="hl-string">"item"</span>/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/item&gt;</pre><p>
        	By removing the &lt;map-to&gt; element from above class mapping, ...
        </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	... Castor will use introspection to infer the element name from the Java 
        	class name (<code class="classname">OrderItem</code>), applying a default naming convention scheme.
        </p><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;order-item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapto"></a>1.2.3.4.&nbsp;The &lt;map-to&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT map-to EMPTY&gt;
&lt;!ATTLIST map-to
          table               NMTOKEN  #IMPLIED
          xml                 NMTOKEN  #IMPLIED
          ns-uri              NMTOKEN  #IMPLIED
          ns-prefix           NMTOKEN  #IMPLIED
          ldap-dn             NMTOKEN  #IMPLIED
          element-definition  (true|false) "false"     <span class="bold"><strong>NEW as of 1.0M3</strong></span>
          ldap-oc             NMTOKEN  #IMPLIED&gt;</pre><p><code class="classname">&lt;map-to&gt;</code> is used to specify the name of the element that should 
           be associated with the given class. <code class="classname">&lt;map-to&gt;</code> is only used for 
           the root class. If this information is not present, Castor will:</p><div class="itemizedlist"><ul type="disc"><li><p>for marshalling, infer the name of the element to be mapped from the name of
            the class: a Java class named 'XxxYyy' will be transformed into 'xxx-yyy'.</p></li><li><p>for unmarshalling, infer the name of the class from the name of the element:
            for an element named 'test-element' Castor will try to use a
            class named 'TestElement'</p></li></ul></div><p>Please note that it is possible to change the naming scheme used by Castor 
           to translate between the XML name and the Java class name in the 
           <code class="classname">castor.properties</code> file.</p><div class="table"><a name="d4e488"></a><p class="title"><b>Table&nbsp;1.6.&nbsp;Description of attributes</b></p><div class="table-contents"><table summary="Description of attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>xml</strong></span></td><td>Name of the element that the class is associated to.</td></tr><tr><td><span class="bold"><strong>ns-uri</strong></span></td><td>Namespace URI</td></tr><tr><td><span class="bold"><strong>ns-prefix</strong></span></td><td>Desired namespace</td></tr><tr><td><span class="bold"><strong>element-definition</strong></span></td><td><code class="classname">True</code> if the descriptor as created from a schema definition that 
	              was of type element (as opposed to a &lt;complexType&gt; definition). This 
	              only is useful in the context of source code generation.</td></tr><tr><td><span class="bold"><strong>ldap-dn</strong></span></td><td>Not used for Castor XML</td></tr><tr><td><span class="bold"><strong>ldap-oc</strong></span></td><td>Not used for Castor XML</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.mapto.samples"></a>1.2.3.4.1.&nbsp;&lt;map-to&gt; samples</h5></div></div></div><p>The following mapping fragment defines a &lt;map-to element for the 
			   <code class="classname">OrderItem</code> class, manually setting the element name to a value 
			   of <code class="classname">'item'</code>.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> /&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>The following mapping fragment instructs Castor to assign a namespace URI of 
			   <code class="classname">http://castor.org/sample/mapping/</code> to the &lt;item&gt; element, 
			   and use a namespace prefix of <code class="classname">'castor'</code> during un-/marshalling.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">ns-uri</span>=<span class="hl-value">"http://castor.org/sample/mapping/"</span>
           <span class="hl-attribute">ns-prefix</span>=<span class="hl-value">"castor"</span>/&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>
        	When marshalling an <code class="classname">OrderItem</code> instance, this will yield the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;castor:order-item xmlns:castor=<span class="hl-string">"http://castor.org/sample/mapping/"</span> identity=<span class="hl-string">"12"</span>&gt;
   &lt;castor:order-quantity&gt;100&lt;/castor:order-quantity&gt;
&lt;/castor:order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.field"></a>1.2.3.5.&nbsp;The &lt;field&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT field ( description?, sql?, bind-xml?, ldap? )&gt;
&lt;!ATTLIST field
    name           NMTOKEN  #REQUIRED
    type           NMTOKEN  #IMPLIED
    handler        NMTOKEN  #IMPLIED
    required       ( true | false )  "false"
    direct         ( true | false )  "false"
    lazy           ( true | false )  "false"
    transient      ( true | false )  "false"
    nillable       ( true | false )  "false"
    container      ( true | false )  "false"
    get-method     NMTOKEN  #IMPLIED
    set-method     NMTOKEN  #IMPLIED
    create-method  NMTOKEN  #IMPLIED
    collection     ( array | vector | hashtable | collection | set | map )  #IMPLIED&gt;
        </pre><p><code class="classname">&lt;field&gt;</code> is used to describe a property of a Java object 
           we want to marshal/unmarshal. It gives:</p><div class="itemizedlist"><ul type="disc"><li><p>its identity ('name')</p></li><li><p>its type (infered from 'type' and 'collection')</p></li><li><p>its access method (infered from 'direct', 'get-method', 'set-method')</p></li></ul></div><p>From this information, Castor is able to access a given property in the Java
           class.</p><p>In order to determine the signature that Castor expects, there are two easy
          rules to apply.</p><p><span class="bold"><strong>1. Determine &lt;type&gt;.</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If there is no 'collection' attribute</strong></span>, the &lt;type&gt; is just the Java type
            specified in &lt;type_attribute&gt; (the value of the 'type' attribute in the XML
            document). The value of &lt;type_attribute&gt; can be a fully qualified Java object
            like 'java.lang.String' or one of the allowed short name:</p><div class="table"><a name="d4e552"></a><p class="title"><b>Table&nbsp;1.7.&nbsp;Type shortnames</b></p><div class="table-contents"><table summary="Type shortnames" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>short name</th><th>Primitive type?</th><th>Java Class</th></tr></thead><tbody><tr><td>other</td><td>N</td><td>java.lang.Object</td></tr><tr><td>string</td><td>N</td><td>java.lang.String</td></tr><tr><td>integer</td><td>Y</td><td>java.lang.Integer.TYPE</td></tr><tr><td>long</td><td>Y</td><td>java.lang.Long.TYPE</td></tr><tr><td>boolean</td><td>Y</td><td>java.lang.Boolean.TYPE</td></tr><tr><td>double</td><td>Y</td><td>java.lang.Double.TYPE</td></tr><tr><td>float</td><td>Y</td><td>java.lang.Float.TYPE</td></tr><tr><td>big-decimal</td><td>N</td><td>java.math.BigDecimal</td></tr><tr><td>byte</td><td>Y</td><td>java.lang.Byte.TYPE</td></tr><tr><td>date</td><td>N</td><td>java.util.Date</td></tr><tr><td>short</td><td>Y</td><td>java.lang.Short.TYPE</td></tr><tr><td>char</td><td>Y</td><td>java.lang.Character.TYPE</td></tr><tr><td>bytes</td><td>N</td><td>byte[]</td></tr><tr><td>chars</td><td>N</td><td>char[]</td></tr><tr><td>strings</td><td>N</td><td>String[]</td></tr><tr><td>locale</td><td>N</td><td>java.util.Locale</td></tr></tbody></table></div></div><br class="table-break"><p>Castor will try to cast the data in the XML file in the proper Java type.</p></li><li><p><span class="bold"><strong>If there is a collection attribute</strong></span>
	, you can use the following table:</p><div class="table"><a name="d4e629"></a><p class="title"><b>Table&nbsp;1.8.&nbsp;Type implementations</b></p><div class="table-contents"><table summary="Type implementations" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>name</th><th>&lt;type&gt;</th><th>default implementation</th></tr></thead><tbody><tr><td>array</td><td>&lt;type_attribute&gt;[]</td><td>&lt;type_attribute&gt;[]</td></tr><tr><td>arraylist</td><td>java.util.List</td><td>java.util.Arraylist</td></tr><tr><td>vector</td><td>java.util.Vector</td><td>java.util.Vector</td></tr><tr><td>hashtable</td><td>java.util.Hashtable</td><td>java.util.Hashtable</td></tr><tr><td>collection</td><td>java.util.Collection</td><td>java.util.Arraylist</td></tr><tr><td>set</td><td>java.util.Set</td><td>java.util.Hashset</td></tr><tr><td>map</td><td>java.util.Map</td><td>java.util.Hashmap</td></tr><tr><td>sortedset</td><td>java.util.SortedSet</td><td>java.util.TreeSet</td></tr></tbody></table></div></div><br class="table-break"><p>The type of the object inside the collection is &lt;type_attribute&gt;. The 'default
              implementation' is the type used if the object holding the collection is found
              to be null and need to be instantiated.</p><p>For hashtable and maps (since 0.9.5.3), Castor will save both key and values.
               When marshalling output &lt;key&gt; and &lt;value&gt;
               elements. These names can be controlled by using a top-level or nested class mapping for
               the org.exolab.castor.mapping.MapItem class.
            </p><p>Note: for backward compatibility with prior versions of Castor, the <span class="italic">saveMapKeys</span>
              property can be set to false in the castor.properties file.</p><p>For versions prior to 0.9.5.3, hashtable and maps, Castor will save only the value
               during marshalling and during unmarshalling will add a map entry using the object as
               both the key and value, e.g. map.put(object, object).
            </p></li></ul></div><p>It is necessary to use a collection when the content model of the
          element expects more than one element of the specified type.</p><p><span class="bold"><strong>Determine the signature of the function</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If 'direct' is set to true</strong></span>, Castor expects to find a class variable with the
            given signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;name&gt;;
          </pre></li><li><p><span class="bold"><strong>If 'direct' is set to false or omitted</strong></span>, Castor will access the property
              though accessor methods. Castor determines the signature of the accessors as
              follow: If the 'get-method' or 'set-method' attributes are supplied, it will
              try to find a function with the following signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;get-method&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> &lt;set-method&gt;(&lt;type&gt; value);
            </pre><p>If 'get-method' and 'set-method' attributes are not provided, Castor will try to
              find the following function:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; get&lt;capitalized-name&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> set&lt;capitalized-name&gt;(&lt;type&gt; value);
            </pre><p>&lt;capitalized-name&gt; means that Castor takes the &lt;name&gt; attribute and put its first
              letter in uppercase without modifying the other letters.</p><p>The content of &lt;field&gt; will contain the information on how to map this given
              field to SQL, XML, ...</p></li><li><p><span class="bold"><strong>Exceptions concerning collection fields:</strong></span></p><p>The default is to treat the 'get-method' as a simple getter returning 
                   the collection field, and the 'set-method' as a simple getter used to set
                   a new instance on the collection field.</p><div class="table"><a name="d4e699"></a><p class="title"><b>Table&nbsp;1.9.&nbsp;Collection field access</b></p><div class="table-contents"><table summary="Collection field access" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>'get-method'</td><td>
                					<p>
                						If a 'get-method' is provided
                						for a collection field, Castor -
                						in adition to the default
                						behaviour described above - will
                						deviate from the standard case
                						for the following special
                						prefixes:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Iterator iterate...();
                					</pre>

                					<p>
                						A 'get-method' starting with the
                						prefix '
                						<code class="classname">iterate</code>
                						' is treated as Iterator method
                						for the given collection field.
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Enumeration enum...();
                					</pre>

                					<p>
                						A 'get-method' starting with '
                						<code class="classname">enum</code>
                						' is treated as Enumeration
                						method for the given collection
                						field.
                					</p>
                				</td></tr><tr><td>'set-method'</td><td>
                					<p>
                						If 'set-method' is provided for
                						a collection field, Castor - in
                						addition to the default
                						behaviour described above - will
                						accept an 'add' prefix and
                						expect the following signature:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add...(&lt;type&gt; value);
                					</pre>

                					<p>
                						This method is called for each
                						collection element while
                						unmarshalling.
                					</p>
                				</td></tr></tbody></table></div></div><br class="table-break"></li></ul></div><div class="table"><a name="d4e723"></a><p class="title"><b>Table&nbsp;1.10.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The field 'name' is required even if no such field exists in the
                    class. If 'direct' access is used, 'name' should be the name of 
                    a public instance member in the object to be mapped (the field 
                    must be public, not static and not transient). If no direct access 
                    and no 'get-/set-method' is specified, this name will be used to 
                    infer the name of the accessors methods.</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>The Java type of the field. It is used to access the field. Castor 
                    will use this information to cast the XML information (like string 
                    into integer). It is also used to define the signature of the accessor 
                    methods. If a collection is specified, this is used to specify the 
                    type of the objects held by the collection. See description
                    above for more details.</td></tr><tr><td><span class="bold"><strong>required</strong></span></td><td>A field can be optional or required.</td></tr><tr><td><span class="bold"><strong>nillable</strong></span></td><td>A field can be of content '<code class="classname">nil</code>'.</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>If true, this field will be ignored during the marshalling. This 
                    is usefull when used together with the auto-complete="true"
                    option.</td></tr><tr><td><span class="bold"><strong>direct</strong></span></td><td>If true, Castor will expect a public variable in the containing class
                    and will access it directly (for both reading and writing).</td></tr><tr><td><span class="bold"><strong>container</strong></span></td><td>Indicates whether the field should be treated as a container, 
                    i.e. only it's fields should be persisted, but not the containing
                    class itself. In this case, the container attribute should be set 
                    to true (supported in Castor XML only).</td></tr><tr><td><span class="bold"><strong>collection</strong></span></td><td>If a parent expects more than one occurrence of one of its 
                    element, it is necessary to specify which collection Castor will 
                    use to handle them. The type specified is used to define the type 
                    of the content inside the collection.</td></tr><tr><td><span class="bold"><strong>get-method</strong></span></td><td>Optional name of the 'get method' Castor should use. If this attribute 
                    is not set and the set-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>set-method</strong></span></td><td>Optional name of the 'set method' Castor should use. If this attribute 
                    is not set and the get-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>create-method</strong></span></td><td>Optionally defines a factory method for the instantiation of a FieldHandler</td></tr><tr><td><span class="bold"><strong>handler</strong></span></td><td>If present, specifies one of the following:
                    <div class="itemizedlist"><ul type="disc"><li><p>The fully-qualified class name of a custom field handler implementation, or</p></li><li><p>The (short) name of a 
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-fieldhandlers.html#Use-ConfigurableFieldHandler-for-more-flexibility" target="_top">configurable field handler</a>
                           definition.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e786"></a>1.2.3.6.&nbsp;Description of the content</h4></div></div></div><p>
             In the case of XML mapping, the content of a field element should be one and
             only one <span class="bold"><strong>&lt;bind-xml&gt;</strong></span> element describing how this given field will be mapped into the
             XML document.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.field.constructorarguments"></a>1.2.3.6.1.&nbsp;Mapping constructor arguments (since 0.9.5)</h5></div></div></div><p>
               Starting with release 0.9.5, for <span class="italic">attribute</span> 
               mapped fields, support has been added to map a constructor field using 
               the <code class="classname">set-method</code> attribute.
            </p><p>
               To specify that a field (mapped to an attribute) should be used as a constructor 
               argument during object initialization, please specify a <code class="classname">set-method</code> attribute on the
               <code class="classname">&lt;field&gt;</code> mapping and use "%X" as the value of the
               <code class="classname">set-method</code> attribute, where <code class="literal">X</code>
               is a positive integer number, e.g. <code class="literal">%1</code> or 
               <code class="literal">%21</code>.
            </p><p>For example:</p><pre class="programlisting">
&lt;field name=<span class="hl-string">"foo"</span> set-method=<span class="hl-string">"%1"</span> get-method=<span class="hl-string">"getFoo"</span> type=<span class="hl-string">"string"</span>&gt;
   &lt;bind-xml node=<span class="hl-string">"attribute"</span>/&gt;
&lt;/field&gt;</pre><p>
              Note that because the <code class="classname">set-method</code> is specified, the <code class="classname">get-method</code> also 
              must be specified.
           </p><p>
	          <span class="bold"><strong>Tip</strong></span>: the <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML HOW-TO section</span> has a HOW-TO document for 
	          mapping constructor arguments, incl. a fully working mapping.
	       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e811"></a>1.2.3.6.2.&nbsp;Sample 1: Defining a custom field handler</h5></div></div></div><p>The following mapping fragment defines a <code class="classname">&lt;field&gt;</code> element for the 
			   <code class="classname">member</code> property of the <code class="classname">org.some.package.Root</code> class, 
			   specifying a custom <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
			   implementation.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e820"></a>1.2.3.6.3.&nbsp;Sample 2: Defining a custom configurable field handler</h5></div></div></div><p>
   			   The same custom field handler as in the previous sample can be defined 
   			   with a separate configurable &lt;field-handler&gt; definition, where additional 
   			   configuration can be provided.
   			</p><pre class="programlisting">
&lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>&gt;
   &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
&lt;/field-handler&gt;</pre><p>
   				and subsequently be referred to by its <span class="bold"><strong>name</strong></span> as shown in the 
   				following field mapping:
   			</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e829"></a>1.2.3.6.4.&nbsp;Sample 3: Using the container attribute</h5></div></div></div><p>
               Assume you have a class mapping for a class <code class="classname">Order</code> which defines -
               amongst others - a field mapping as follows, where the field <code class="classname">item</code>
               refers to an instance of a class <code class="classname">Item</code>.
            </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Order"</span>&gt;
            
   ...
   &lt;field name=<span class="hl-string">"item"</span> type=<span class="hl-string">"some.example.Item"</span> &gt;
      &lt;bind-xml&gt; name=<span class="hl-string">"item"</span> node=<span class="hl-string">"element"</span> /&gt;
   &lt;/field&gt;
   ...
&lt;/<span class="hl-keyword">class</span>&gt;

&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Item"</span>&gt;
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"long"</span> /&gt;
   &lt;field name=<span class="hl-string">"description"</span> type=<span class="hl-string">"string"</span> /&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
                Marshalling an instance of <code class="classname">Order</code> would produce XML as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">item</span>&gt;
        &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
        &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
    &lt;<span class="hl-tag">/item</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre><p>
               If you do not want the <code class="classname">Item</code> instance to be marshalled,
               but only its fields, change the field mapping for the <code class="classname">item</code>
               member to be as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"some.example.Item"</span> <span class="hl-attribute">container</span>=<span class="hl-value">"false"</span> &gt;
   &lt;<span class="hl-tag">bind-xml</span>&gt; name="item" node="element" /&gt;
&lt;<span class="hl-tag">/field</span>&gt;</pre><p>
                The resulting XML would look as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.bindxml"></a>1.2.3.7.&nbsp;The &lt;bind-xml&gt; element</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.grammar"></a>1.2.3.7.1.&nbsp;Grammar</h5></div></div></div><pre class="programlisting">
&lt;!ELEMENT bind-xml (class?, property*)&gt;
&lt;!ATTLIST bind-xml
          name     NMTOKEN     #IMPLIED
          type     NMTOKEN     #IMPLIED
          location CDATA       #IMPLIED
          matches  NMTOKENS    #IMPLIED
          QName-prefix NMTOKEN #IMPLIED
          reference   ( true | false ) "false"
          node        ( attribute | element | text )    #IMPLIED
          auto-naming ( deriveByClass | deriveByField ) #IMPLIED
          transient   ( true | false ) "false"&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="xml.mapping.mappingfile.bindxml.definition"></a>1.2.3.7.1.1.&nbsp;Definiton</h6></div></div></div><p>
            The <code class="classname">&lt;bind-xml&gt;</code> element is used to describe how a given Java field 
                should appear in an XML document. It is used both for marshalling 
                and unmarshalling.
        </p></div></div><div class="table"><a name="d4e854"></a><p class="title"><b>Table&nbsp;1.11.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The name of the element or attribute.
		              <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The name is a QName, and a namespace prefix may be used to indicate the
		              element or attribute belongs to a certain namespace. Note the prefix is not
		              preserved or used during marshalling, it's simply used for
		              qualification of which namespace the element or attribute belongs.</p></td></tr></table></div></td></tr><tr><td><span class="bold"><strong>auto-naming</strong></span></td><td>If no name is specified, this attribute controls how castor will 
		    	    automatically create a name for the field. Normally, the name is 
		    	    created using the field name, however many times it is necessary 
		    	    to create the name by using the class type instead (such as
            		heterogenenous collections).</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>XML Schema type (of the value of this field) that requires specific 
            	    handling in the Castor Marshalling Framework (such as 'QName' for 
            	    instance).</td></tr><tr><td><span class="bold"><strong>location</strong></span> (since 0.9.4.4)</td><td>Allows the user to specify the "sub-path" for which the value
                    should be marshalled to and from. This is useful for "wrapping" values in 
                    elements or for mapping values that appear on sub-elements to the 
                    current "element" represented by the class mapping. For more information,
                    see the <a href="#xml.mapping.mappingfile.locationattribute" title="1.2.6.&nbsp;Location attribute">Location attribute</a> below.</td></tr><tr><td><span class="bold"><strong>QName-prefix</strong></span></td><td>When the field represents a QName value, a prefix can be provided that
                    is used when marshalling value of type QName. More information on the 
                    use of 'QName-prefix' can be found in the 
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">SourceGenerator Documentation</a></td></tr><tr><td><span class="bold"><strong>reference</strong></span></td><td>Indicates if this field has to be treated as a reference by the 
            	    unmarshaller. In order to work properly, you must specify the node 
            	    type to 'attribute' for both the 'id' and the 'reference'. In 
            	    newer versions of Castor, 'element' node for reference is allowed. 
            	    Remember to make sure that an <span class="italic">identity</span> field is specified
                    on the <code class="classname">&lt;class&gt;</code> mapping for the object type being 
                    referenced so that Castor knows what the object's identity is.</td></tr><tr><td><span class="bold"><strong>matches</strong></span></td><td>Allows overriding the matches rules for the name of the element. It 
            	    is a standard regular expression and will be used instead of the 'name'
            	    field. A '*' will match any xml name, however it will only be matched 
            	    if no other field exists that matches the xml name.</td></tr><tr><td><span class="bold"><strong>node</strong></span></td><td>Indicates if the name corresponds to an attribute, an element,
                    or text content. By default, primitive types are assumed to be 
                    an attribute, otherwise the node is assumed to be an elemen</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>Allows for making this field transient for XML. The default value is 
            	    inherited from the &lt;field&gt; element.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.nestedclassmapping"></a>1.2.3.7.2.&nbsp;Nested class mapping</h5></div></div></div><p>Since 0.9.5.3, the bind-xml element supports a nested class mapping, which 
             is often useful when needing to specify more than one mapping for a 
             particular class. A good example of this is when mapping Hashtable/HashMap/Map.</p><pre class="programlisting">
&lt;bind-xml ...&gt;
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.exolab.castor.mapping.MapItem"</span>&gt;
      &lt;field name=<span class="hl-string">"key"</span> type=<span class="hl-string">"java.lang.String"</span>&gt;
        &lt;bind-xml name=<span class="hl-string">"id"</span>/&gt;
      &lt;/field&gt;
      &lt;field name=<span class="hl-string">"value"</span> type=<span class="hl-string">"com.acme.Foo"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;
&lt;/bind-xml&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.bindxml.usagepattern"></a>1.2.4.&nbsp;Usage Pattern</h3></div></div></div><p>Here is an example of how Castor Mapping can be used. We want to map an XML
        document like the following one (called 'order.xml').
        model.</p><pre class="programlisting">
&lt;Order reference=<span class="hl-string">"12343-AHSHE-314159"</span>&gt;
  &lt;Client&gt;
    &lt;Name&gt;Jean Smith&lt;/Name&gt;
    &lt;Address&gt;2000, Alameda de las Pulgas, San Mateo, CA 94403&lt;/Address&gt;
  &lt;/Client&gt;

  &lt;Item reference=<span class="hl-string">"RF-0001"</span>&gt;
    &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
    &lt;Quantity&gt;10&lt;/Quantity&gt;
    &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-0034"</span>&gt;
    &lt;Description&gt;Chocolate&lt;/Description&gt;
    &lt;Quantity5&lt;/Quantity&gt;
    &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-3341"</span>&gt;
     &lt;Description&gt;Cookie&lt;/Description&gt;
     &lt;Quantity&gt;30&lt;/Quantity&gt;
     &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
  &lt;/Item&gt;
&lt;/Order&gt;</pre><p>Into the following object model composed of 3 classes:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>MyOrder:</strong></span> represent an order</p></li><li><p><span class="bold"><strong>Client:</strong></span> used to store information on the client</p></li><li><p><span class="bold"><strong>Item:</strong></span> used to store item in an order</p></li></ul></div><p>The sources of these classes follow.</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Vector;
<span class="hl-keyword">import</span> java.util.Enumeration;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyOrder {

    <span class="hl-keyword">private</span> String _ref;
    <span class="hl-keyword">private</span> ClientData _client;
    <span class="hl-keyword">private</span> Vector _items;
    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span> _total;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setReference(String ref) {
        _ref = ref;
    }

    <span class="hl-keyword">public</span> String getReference() {
        <span class="hl-keyword">return</span> _ref;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setClientData(ClientData client) {
        _client = client;
    }

    <span class="hl-keyword">public</span> ClientData getClientData() {
        <span class="hl-keyword">return</span> _client;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItemsList(Vector items) {
        _items = items;
    }

    <span class="hl-keyword">public</span> Vector getItemsList() {
        <span class="hl-keyword">return</span> _items;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTotal(<span class="hl-keyword">float</span> total) {
        _total = total;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotal() {
        <span class="hl-keyword">return</span> _total;
    }

    <span class="hl-comment">// Do some processing on the data</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotalPrice() {
        <span class="hl-keyword">float</span> total = 0.0f;

        <span class="hl-keyword">for</span> (Enumeration e = _items.elements() ; e.hasMoreElements() ;) {
            Item item = (Item) e.nextElement();
            total += item._quantity * item._unitPrice;
        }

        <span class="hl-keyword">return</span> total;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ClientData {

    <span class="hl-keyword">private</span> String _name;
    <span class="hl-keyword">private</span> String _address;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress(String address) {
        _address = address;
    }

    <span class="hl-keyword">public</span> String getAddress() {
        <span class="hl-keyword">return</span> _address;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item {
    <span class="hl-keyword">public</span> String _reference;
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>    _quantity;
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span>  _unitPrice;
    <span class="hl-keyword">public</span> String _description;
}</pre><p>The XML document and the java object model can be connected by using the
        following mapping file:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyOrder"</span>&gt;
    &lt;map-to xml=<span class="hl-string">"Order"</span>/&gt;

    &lt;field name=<span class="hl-string">"Reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Total"</span>
           type=<span class="hl-string">"float"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"total-price"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ClientData"</span>
           type=<span class="hl-string">"ClientData"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Client"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ItemsList"</span>
           type=<span class="hl-string">"Item"</span>
              collection=<span class="hl-string">"vector"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Item"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"ClientData"</span>&gt;
    &lt;field name=<span class="hl-string">"Name"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Name"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Address"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Address"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Item"</span>&gt;
    &lt;field name=<span class="hl-string">"_reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_quantity"</span>
           type=<span class="hl-string">"integer"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_unitPrice"</span>
           type=<span class="hl-string">"float"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"UnitPrice"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_description"</span>
           type=<span class="hl-string">"string"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Description"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre><p>The following class is an example of how to use Castor XML Mapping to
        manipulate the file 'order.xml'. It unmarshals the document 'order.xml',
        computes the total price, sets the total price in the java object and
        marshals the object model back into XML with the calculated price.</p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.Mapping;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.MappingException;

<span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
<span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> java.io.FileReader;
<span class="hl-keyword">import</span> java.io.OutputStreamWriter;

<span class="hl-keyword">import</span> org.xml.sax.InputSource;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String args[]) {

        Mapping      mapping = <span class="hl-keyword">new</span> Mapping();

        <span class="hl-keyword">try</span> {
            <span class="hl-comment">// 1. Load the mapping information from the file</span>
            mapping.loadMapping( <span class="hl-string">"mapping.xml"</span> );

            <span class="hl-comment">// 2. Unmarshal the data</span>
            Unmarshaller unmar = <span class="hl-keyword">new</span> Unmarshaller(mapping);
            MyOrder order = (MyOrder)unmar.unmarshal(<span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> FileReader(<span class="hl-string">"order.xml"</span>)));

            <span class="hl-comment">// 3. Do some processing on the data</span>
            <span class="hl-keyword">float</span> total = order.getTotalPrice();
            System.out.println(<span class="hl-string">"Order total price = "</span> + total);
            order.setTotal(total);

            <span class="hl-comment">// 4. marshal the data with the total price back and print the XML in the console</span>
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(<span class="hl-keyword">new</span> OutputStreamWriter(System.out));
            marshaller.setMapping(mapping);
            marshaller.marshal(order);

        } <span class="hl-keyword">catch</span> (Exception e) {
            System.out.println(e);
            <span class="hl-keyword">return</span>;
        }
    }
}
       </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.xsitype"></a>1.2.5.&nbsp;xsi:type</h3></div></div></div><p>Ordinarily, a mapping will only reference types that are concrete classes (i.e. not interfaces
        nor abstract classes).  The reason is that to unmarshal a type requires instantiating it and
        one cannot instantiate an interface.  However, in many real situations, object models depend
        on the use of interfaces.  Many class properties are defined to have interface types to support
        the ability to swap implementations.  This is often the case in frameworks.</p><p>The problem is that a different mapping must be used each time the same model is to be
       used to marshal/unmarshal an implementation that uses different concrete types.  This is
       not convenient.  The mapping should represent the model and the specific concrete type
       used to unmarshal a document is a configuration parameter; it should be specified in the
       instance document to be unmarshalled, not the mapping.</p><p>For example, assume a very simple object model of an engine that has one property that
      is a processor:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> IProcessor {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> process();
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Engine {
    <span class="hl-keyword">private</span> IProcessor processor;
    <span class="hl-keyword">public</span> IProcessor getProcessor() {
        <span class="hl-keyword">return</span> processor;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProcessor(IProcessor processor) {
        <span class="hl-keyword">this</span>.processor = processor;
    }
}
            </pre><p>A typical mapping file for such a design may be:</p><pre class="programlisting">  
&lt;mapping&gt;
    &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;

        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml name=<span class="hl-string">"processor"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;

     &lt;/<span class="hl-keyword">class</span>&gt;
  &lt;/mapping&gt;</pre><p>It is possible to use such a mapping and still have the marshal/unmarshal process work
       by specifying the concrete implementation of IProcessor in the document to be unmarshalled,
       using the xsi:type attribute, as follows:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;processor xsi:type=<span class="hl-string">"java:com.abc.MyProcessor"</span> /&gt;
  &lt;/engine&gt;
            </pre><p>In this manner, one is still able to maintain only a single mapping, but vary the
      manner in which the document is unmarshalled from one instance document to the next.
      This flexibility is powerful because it enables the support of polymorphism within
      the castor xml marshalling framework.</p><p>Suppose we wanted the following XML instead:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;myProcessor/&gt;
  &lt;/engine&gt;</pre><p>In the above output our XML name changed to match the type of the class used instead of
         relying on the xsi:type attribute. This can be achieved by modifying the mapping
         file as such:
      </p><pre class="programlisting">
  &lt;mapping&gt;
     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;
        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml auto-naming=<span class="hl-string">"deriveByClass"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyProcessor"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"myProcessor"</span> /&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.locationattribute"></a>1.2.6.&nbsp;Location attribute</h3></div></div></div><p>Since 0.9.5</p><p>
          The location attribute allows the user to map fields from nested
          elements or specify a wrapper element for a given field. Wrapper
          elements are simply elements which appear in the XML instance, but
          do not have a direct mapping to an object or field within the
          object model.
        </p><p>
          For example to map an instance of the following class:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Bar bar = null;

    <span class="hl-keyword">public</span> Foo();

    <span class="hl-keyword">public</span> getBar() {
        <span class="hl-keyword">return</span> bar;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBar(Bar bar) {
        <span class="hl-keyword">this</span>.bar = bar;
    }
}</pre><p>
          into the following XML instance:
    </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;;
   &lt;<span class="hl-tag">abc</span>&gt;
      &lt;<span class="hl-tag">bar</span>&gt;...&lt;<span class="hl-tag">/bar</span>&gt;
   &lt;<span class="hl-tag">/abc</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;</pre><p>
          <span class="italic">(notice that an 'abc' field doesn't exist in the Bar class)</span>
          One would use the following mapping:</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
   ...
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"Bar"</span>&gt;
         &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span>/&gt;
      &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">/class</span>&gt;
   ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
          Note the "location" attribute. The value of this attribute is the name
          of the wrapper element. To use more than one wrapper element, the name
          is separated by a forward-slash as such:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc/xyz"</span> /&gt;</pre><p>
          Note that the name of the element is not part of the location itself and
          that the location is always relative to the class in which the field is
          being defined.

          This works for attributes also:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span> /&gt;</pre><p>
          will produce the following:
</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">abc</span> <span class="hl-attribute">bar</span>=<span class="hl-value">"..."</span>/&gt;;
&lt;<span class="hl-tag">/foo</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.tips"></a>1.2.7.&nbsp;Tips</h3></div></div></div><p>Some helpful hints...</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e963"></a>1.2.7.1.&nbsp;Automatically create a mapping file</h4></div></div></div><p>
         Castor comes with a tool that can automatically create a mapping from
         class files. Please see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.faq" target="_top">XML FAQ</a> for more
         information.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e967"></a>1.2.7.2.&nbsp;Create your own FieldHandler</h4></div></div></div><p>
          Sometimes to handle complex situations you'll need to create your
          own FieldHandler. Normally a FieldHandler deals with a specific class
          and field, however generic, reusable FieldHandlers can also be created
          by extending org.exolab.castor.mapping.GeneralizedFieldHandler or
          org.exolab.castor.mapping.AbstractFieldHandler.
          The FieldHandler can be specified on the &lt;field&gt; element.
       </p><p>
          For more information on writing a custom FieldHandler please
          see the following:
          <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML FieldHandlers</span>.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e972"></a>1.2.7.3.&nbsp;Mapping constructor arguments (since 0.9.5)</h4></div></div></div><p>
          You may map any attributes to constructor arguments. For more information
          on how to map constructor arguments see the information available
          in the section on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.mapping.mappingfile.field.constructorarguments" target="_top">set-method</a>
          above.
       </p><p>Please note that mapping <span class="bold"><strong>elements</strong></span> to constructor arguments is 
          not yet supported.
       </p><p>
          <span class="bold"><strong>Tip</strong></span>: the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.how-to" target="_top">XML HOW-TO section</a> has a HOW-TO document for 
          mapping constructor arguments.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e981"></a>1.2.7.4.&nbsp;Preventing Castor from checking for a default constructor (since 0.9.5)</h4></div></div></div><p>
          Sometimes it's useful to prevent Castor from checking for a default constructor,
          such as when trying to write a mapping for an interface or type-safe enum. You can use the
          "undocumented" verify-constructable="false" attribute on the &lt;class&gt; element to
          prevent Castor from looking for the default constructor.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e984"></a>1.2.7.5.&nbsp;Type safe enumeration mapping (since 0.9.5)</h4></div></div></div><p>
          While you can always use your own custom FieldHandler for handling type-safe enumeration
          classes, Castor does have a built-in approach to dealing with these types of classes.
          If the type-safe enum class has a <span class="bold"><strong>public static &lt;type&gt; valueOf(String)</strong></span> method
          Castor will call that method so that the proper instance of the enumeration is returned.
          Note: You'll also need to disable the default constructor check in the mapping file
          (see section 7.4 above to see more on this).
       </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.configuration"></a>1.3.&nbsp;Configuring Castor XML (Un)Marshaller</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e990"></a>1.3.1.&nbsp;Introduction</h3></div></div></div><p>To be defined ...</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e993"></a>1.3.2.&nbsp;Configuring the Marshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Marshaller</code>
			class for marshalling Java objects to XML, the
			<code class="classname">Marshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e998"></a><p class="title"><b>Table&nbsp;1.12.&nbsp;Marshaller properties</b></p><div class="table-contents"><table summary="Marshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>suppressNamespaces</td><td>&nbsp;</td><td>
							<code class="literal">true</code>
							or
							<code class="literal">false</code>
						</td><td>
							<code class="literal">false</code>
						</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1018"></a>1.3.3.&nbsp;Configuring the Unmarshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Unmarshaller</code>
			class for unmarshalling Java objects from XML, the
			<code class="classname">Unmarshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e1023"></a><p class="title"><b>Table&nbsp;1.13.&nbsp;Unmarshaller properties</b></p><div class="table-contents"><table summary="Unmarshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>rootObject</td><td>&nbsp;</td><td>
							A Class instance identifying the root class
							to use for unmarshalling.
						</td><td>-</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1040"></a>1.4.&nbsp;Usage of Castor and XML parsers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1042"></a>1.4.1.&nbsp;SAX/DOM</h3></div></div></div><p>
           Being an <span class="bold"><strong>XML data binding framework</strong></span> by definition, Castor XML relies on the 
           availability of an XML parser at run-time. In Java, an XML parser is by 
           default accessed though either the DOM or the SAX APIs: that implies
           that the XML Parser used needs to comply with either (or both) of these APIs.
        </p><p>
           With the creation of the JAXP API (and its addition to the Java language 
           definition as of Java 5.0), Castor internally has been enabled to allow
           usage of the JAXP interfaces to interface to XML parsers. As such, 
           Castor XML allows the use of a JAXP-compliant XML parser as well.
        </p><p>
           By default, Castor ships with
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           2.6.2. You may, of course, upgrade to a newer version
           of
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           at your convenience, or switch to any other XML parser as long as it is
           JAXP compliant or implements a particular SAX interface. Please note that
           users of Java 5.0 and above do not need to have Xerces available 
           at run-time, as JAXP and Xerces have both been integrated into the run-time
           library of Java.
        </p><p>
           For marshalling, Castor XML can equally use any JAXP complaint XML parser (or
           interact with an XML parser that implements the SAX API), with the exception 
           of the following special case: when using 'pretty printing' during marshalling 
           (by setting the corresponding property in <code class="literal">castor.properties</code>
           to <code class="literal">true</code>) with Java 1.4 or below, 
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           has to be on the classpath, as Castor XML internally uses Xerces' <code class="literal">XMLSerializer</code>
           to implement this feature.
        </p><p>
           The following table enlists the requirements relative to the Java version
           used in your environment.
        </p><div class="table"><a name="d4e1056"></a><p class="title"><b>Table&nbsp;1.14.&nbsp;XML APIs on various Java versions</b></p><div class="table-contents"><table summary="XML APIs on various Java versions" border="1"><colgroup><col><col align="center"></colgroup><thead><tr><th>Java 1.4 and below</th><th align="center">Java 5.0 and above</th></tr></thead><tbody><tr><td>Xerces 2.6.2</td><td align="center"> - </td></tr><tr><td>XML APIs</td><td align="center"> - </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1072"></a>1.4.2.&nbsp;StAX</h3></div></div></div><p>
            As of Castor 1.3.2, Castor XML can be used with a StAX-compliant parser to unmarshal from XML. 
            Please see <a href="#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a> for StAX-specific 
            <code class="methodname">unmarshal</code> methods added to 
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>.  
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1078"></a>1.5.&nbsp;XML configuration file</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1080"></a>1.5.1.&nbsp;News</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					Added a section on how to access the properties as
					defined in the Castor properties file from within
					code.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2.1:</strong></span>
					: Added new
					<code class="classname">
						org.exolab.castor.xml.lenient.integer.validation
					</code>
					property to allow configuration of leniency for
					validation for Java properties generated from
					<code class="classname">&lt;xs:integer&gt;</code>
					types during code generation.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2:</strong></span>
					: Access to the
					<code class="classname">org.exolab.castor.util.LocalConfiguration</code>
					class has been removed completely. To access the
					properties as used by Castor from code, please refer
					to the below section.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.1.3:</strong></span>
					Added special processing of proxied classes. The
					property org.exolab.castor.xml.proxyInterfaces
					allows you to specify a list of interfaces that such
					proxied objects implement. If your object implements
					one of these interfaces Castor will not use the
					class itself but its superclass at introspection or
					to find class mappings and ClassDescriptors.
				</p></li><li><p>
					<span class="bold"><strong>Release 0.9.7:</strong></span>
					Added new org.exolab.castor.persist.useProxies
					property to allow configuration of JDBC proxy
					classes. If enabled, JDBC proxy classes will be used
					to wrap
					<code class="classname">java.sql.Connection</code>
					and
					<code class="classname">java.sql.PreparedStatement</code>
					instances, to allow for more detailed and complete
					JDBC statements to be output during logging. When
					turned off, no logging statements will be generated
					at all.
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1102"></a>1.5.2.&nbsp;Introduction</h3></div></div></div><p>
			Castor uses a configuration file for environmental
			properties that are shared across all the Castor sub
			systems. The configuration file is specified as a Java
			properties file with the name <code class="filename">castor.properties</code>.
		</p><p>
			By definition, a default configuration file is included with the
            Castor XML JAR. Custom properties can be supplied using one of the
            following methods. Please note that the custom properties specified
            will <span class="bold"><strong>override</strong></span> the default 
            configuration. 
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    anywhere on the classpath of your application.
                </p></li><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    in the working directory of your application.
                </p></li><li><p>
                    Use the system property 
                    <code class="literal">org.castor.user.properties.location</code> to
                    specify the location of your custom properties.
                </p></li></ul></div><p>
            Please note that Castor XML - upon startup - will try the methods
            given above in exactly the sequence as stated above; if it managed
            to find a custom property file using any of the given methods,
            it will cancel its search.
        </p><p>
			When running the provided examples, Castor will use the
			configuration file located in the examples directory which
			specifies additional debugging information as well as pretty
			printing of all produced XML documents.
		</p><p>
			The following properties are currently supported in the
			configuration file:
		</p><div class="table"><a name="d4e1121"></a><p class="title"><b>Table&nbsp;1.15.&nbsp;</b></p><div class="table-contents"><table border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>
						org.exolab.castor.xml.introspector.primitive.nodetype
					</td><td>
						Property specifying the type of XML node to use
						for primitive values, either
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">attribute</code>
					</td><td>-</td></tr><tr><td>org.exolab.castor.parser</td><td>
                        Property specifying the class name of the SAX
                        XML parser to use.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.parser.validation</td><td>
                        Specifies whether to perform XML document
                        validation by default.
                    </td><td>
                        <code class="classname">true</code>
                        and
                        <code class="classname">false</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.parser.namespaces</td><td>
                        Specifies whether to support XML namespaces by
                        default.
                    </td><td>
                        <code class="classname">false</code>
                        and
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.xml.nspackages</td><td>
                        Specifies a list of XML namespace to Java
                        package mappings.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.naming</td><td>
                        Property specifying the 'type' of the XML naming
                        conventions to use. Values of this property must
                        be either
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                        .
                    </td><td>
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                    </td><td>
                        <code class="classname">lower</code>
                    </td><td>-</td></tr><tr><td>org.castor.xml.java.naming</td><td>
                        Property specifying the 'type' of the Java
                        naming conventions to use. Values of this
                        property must be either
                        <code class="classname">null</code>
                        or the name of a class which extends
                        <code class="classname">link org.castor.xml.JavaNaming</code>.
                    </td><td>
                        <p>
                           <code class="classname">null</code>
                           or the name of a class which extends
                           <code class="classname">link org.castor.xml.JavaNaming</code>.
                        </p>
                    </td><td>
                        <code class="classname">null</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.marshalling.validation
                    </td><td>
                        Specifies whether to use validation during
                        marshalling.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.indent</td><td>
                        Specifies whether XML documents (as generated at
                        marshalling) should use indentation or not.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.sax.features</td><td>Specifies additional features for the XML parser.
                    </td><td>A comma separated list of SAX (parser) features (that might or might not be supported by the specified SAX parser).</td><td><code class="classname">http://apache.org/xml/features/disallow-doctype-decl</code></td><td>-</td></tr><tr><td>org.exolab.castor.sax.features-to-disable</td><td>Specifies features to be disbaled on the underlying SAX parser.</td><td>A comma separated list of SAX (parser) features to be disabled.</td><td>
                        <code class="classname">http://xml.org/sax/features/external-general-entities</code>, 
                        <code class="classname">http://xml.org/sax/features/external-parameter-entities</code>, 
                        <code class="classname">http://apache.org/xml/features/nonvalidating/load-external-dtd</code>
                    </td><td>
                        <p><span class="bold"><strong>1.0.4</strong></span></p>
                    </td></tr><tr><td>org.exolab.castor.regexp</td><td>Specifies the regular expression validator to use.</td><td>A class that implements <code class="classname">org.exolab.castor.util.RegExpValidator</code>.</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.strictelements</td><td>
                        Specifies whether to apply strictness to
                        elements when unmarshalling. When enabled, the
                        existence of elements in the XML document, which
                        cannot be mapped to a class, causes a {@link
                        SAXException} to be thrown. If set to false,
                        these 'unknown' elements are ignored.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.xml.loadPackageMappings
                    </td><td>
                        Specifies whether the ClassDescriptorResolver
                        should (automatically) search for and consult
                        with package mapping files (
                        <code class="classname">.castor.xml</code>
                        ) to retrieve class descriptor information
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>
                        <span class="bold"><strong>1.0.2</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.serializer.factory
                    </td><td>
                        Specifying what XML serializers factory to use.
                    </td><td>A class name</td><td>
                        org.exolab.castor.xml.XercesXMLSerializerFactory
                    </td><td>
                        <span class="bold"><strong>1.0</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.sequence.order
                    </td><td>
                        Specifies whether sequence order validation
                        should be lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.id.validation
                    </td><td>
                        Specifies whether id/href validation should be
                        lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.proxyInterfaces</td><td>
                        Specifies whether or not to search for an proxy
                        interface at marshalling. If property is not
                        empty the objects to be marshalled will be
                        searched if they implement one of the given
                        interface names. If the interface is
                        implemented, the superclass will be marshalled
                        instead of the class itself.
                    </td><td>A list of proxy interfaces</td><td>-</td><td>
                        <span class="bold"><strong>1.1.3</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.integer.validation
                    </td><td>
                        Specifies whether validation for Java properties
                        generated from &lt;xs:integer&gt; should be
                        lenient, i.e. allow for
                        <code class="classname">int</code>
                        s as well.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.2.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.version</td><td>
                        Specifies the XML document version number to be used 
                        during marshalling; defaults to 1.0.
                    </td><td>
                        <code class="classname">1.0</code>
                        or
                        <code class="classname">1.1</code>
                    </td><td>
                        <code class="classname">1.0</code>
                    </td><td>
                        <span class="bold"><strong>1.3.2</strong></span>
                    </td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         As of Castor 1.3.3, the default values for <code class="classname">org.exolab.castor.sax.features</code> 
         and <code class="classname">org.exolab.castor.sax.features-to-disable</code> have changed to include/disable 
         selected features.
        </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1318"></a>1.5.3.&nbsp;Accessing the properties from within code</h3></div></div></div><p>
			As of Castor 1.1, it is possible to read and set the value of properties programmatically using the
			<code class="classname">getProperty(String)</code> and <code class="classname">setProperty(String,String)</code>
			on the following classes:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.Marshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.XMLContext</code>
				</p></li></ul></div><p>
			Whilst using the setter methods on the first two classes will change the settings of the respective instances only,
			using the <code class="classname">setProperty()</code> method on the <code class="classname">org.exolab.castor.xml.XMLContext</code>
			class will change the configuration globally, and affect all <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			and <code class="classname">org.exolab.castor.xml.Marshaller</code> instances created thereafter using the
			<code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code> and
			<code class="methodname">org.exolab.castor.xml.XMLContext.createMarshaller()</code> methods.
		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1340"></a>1.6.&nbsp;Castor XML - Tips &amp; Tricks</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1342"></a>1.6.1.&nbsp;Logging and Tracing</h3></div></div></div><p>When developing using Castor, we recommend that you use the various
         <code class="literal">setLogWriter</code> methods to get detailed information and error
         messages.</p><p>Using a logger with <code class="classname">org.exolab.castor.mapping.Mapping</code> will
         provide detailed information about mapping decisions made by Castor and
         will show the SQL statements being used.</p><p>Using a logger with <code class="classname">org.exolab.castor.jdo.JDO</code> will provide
         trace messages that show when Castor is loading, storing, creating and
         deleting objects. All database operations will appear in the log; if an
         object is retrieved from the cache or is not modified, there will be no
         trace of load/store operations.</p><p>Using a logger with <code class="classname">org.exolab.castor.xml.Unmarshaller</code> will
         provide trace messages that show conflicts between the XML document and
         loaded objects.</p><p>A simple trace logger can be obtained from
         <code class="classname">org.exolab.castor.util.Logger</code>. This logger uses the
         standard output stream, but prefixes each line with a short message
         that indicates who generated it. It can also print the time and date of
         each message. Since logging is used for warning messages and simple
         tracing, Castor does not require a sophisticated logging mechanism.</p><p>Interested in integratating Castor's logging with Log4J? Then see
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-faq.html#How-can-I-integrate-Castor's-logging-with-a-logging-infrastructure-using-Log4J?" target="_top">
         this question</a> in the JDO FAQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1356"></a>1.6.2.&nbsp;Indentation</h3></div></div></div><p>By default the marshaler writes XML documents without indentation. When
         developing using Castor or when debugging an application that uses
         Castor, it might be desireable to use indentation to make the XML
         documents human-readable. To turn indentation on, modify the Castor
         properties file, or create a new properties file in the classpath
         (named <code class="literal">castor.properties</code>) with the following content:</p><pre class="programlisting">
org.exolab.castor.indent=true
      </pre><p>Indentation inflates the size of the generated XML documents, and also
         consumes more CPU. It is recommended not to use indentation in a
         production environment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1362"></a>1.6.3.&nbsp;XML:Marshal validation</h3></div></div></div><p>It is possible to disable the validation in the marshaling framework
           by modifying the Castor properties file or by creating a new
           properties file in the classpath (named <code class="literal">castor.properties</code>)
           with the following content:</p><pre class="programlisting">
 org.exolab.castor.marshalling.validation=false
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1367"></a>1.6.4.&nbsp;NoClassDefFoundError</h3></div></div></div><p>
          Check your CLASSPATH, check it often, there is no reason not to!
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1370"></a>1.6.5.&nbsp;Mapping: auto-complete</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This only works with Castor-XML.</p></td></tr></table></div><p>
          To save time when writing your mappings, try using the <span class="italic">auto-complete</span>
          attribute of <span class="italic">class</span>. When using auto-complete, Castor will introspect
          your class and automatically fill in any missing fields.
       </p><p>
          <span class="bold"><strong>Example:</strong></span>
          </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.acme.Foo"</span> <span class="hl-attribute">auto-complete</span>=<span class="hl-value">"true"</span>/&gt;
          </pre><p>
       </p><p>
          This is also compatible with generated descriptor files. You can use a mapping file
          to override some of the behavior of a compiled descriptor by using auto-complete.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Be careful to make sure you use the exact field name as specified
          in the generated descriptor file in order to modify the behavior of the field descriptor!
          Otherwise, you'll probably end up with two fields being marshaled!
          </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1383"></a>1.6.6.&nbsp;Create method</h3></div></div></div><p>
         Castor requires that classes have a public, no-argument constructor
         in order to provide the ability to marshal &amp; unmarshal objects of that type.
      </p><p>
         create-method is an optional attribute to the <code class="literal">&lt;field&gt;</code> mapping
         element that can be used to overcome this restriction in cases where you
         have an existing object model that consists of, say, singleton classes
         where public, no-argument constructors must not be present by definition.
      </p><p>
         Assume for example that a class "<code class="literal">A</code>" that you want to be able
         to unmarshal uses a singleton class as one of its properties. When
         attempting to unmarshal class "<code class="literal">A</code>", you should get an exception
         because the singleton property has no public no-arg constructor.
         Assuming that a reference to the singleton can be obtained via a static
         getInstance() method, you can add a "create method" to class <code class="literal">A</code>
         like this:
      </p><pre class="programlisting">
 <span class="hl-keyword">public</span> MySingleton getSingletonProperty() {
    <span class="hl-keyword">return</span> MySingleton.getInstance();
 }
      </pre><p>
         and in the mapping file for class <code class="classname">A</code>, you can define 
         the singleton property like this:
      </p><pre class="programlisting">
 &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySingletonProperty"</span>
       <span class="hl-attribute">type</span>=<span class="hl-value">"com.u2d.MySingleton"</span>
       <span class="hl-attribute">create-method</span>=<span class="hl-value">"getSingletonProperty"</span>&gt;
    &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my-singleton-property"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
 &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
         This illustrates how the create-method attribute is quite a useful
         mechanism for dealing with exceptional situations where you might
         want to take advantage of marshaling even when some classes do not
         have no-argument public constructors.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
           As of this writing, the specified create-method must
           exist as a method in the current class (i.e. the class being described
           by the current <code class="literal">&lt;class&gt;</code> element). In the future it may be possible
           to use external static factory methods.
        </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1400"></a>1.6.7.&nbsp;MarshalListener and UnmarshalListener</h3></div></div></div><p>
         Castor allows control on the object being marshaled or unmarshaled by
         a set of two listener interfaces: MarshalListener and UnmarshalListener.
      </p><p>
         The MarshalListener interface located in <code class="code">org.exolab.castor.xml</code> listens to
         two different events that are intercepted by the following methods:
         </p><div class="itemizedlist"><ul type="disc"><li><p>preMarshal: this method is called before an object gets marshaled.</p></li><li><p>postMarshal: this method is called once an object has been marshaled.</p></li></ul></div><p>
      </p><p>
         The UnmarshalListener located also in <code class="literal">org.castor.xml</code> listens to
         four different events that are intercepted by the following methods:
      </p><div class="itemizedlist"><ul type="disc"><li><p>initialized: this method is called once an object has been instantiated.</p></li><li><p>attributesProcessed: this method is called when the attributes have just been read and processed.</p></li><li><p>fieldAdded: this method is called when an object is added to a parent.</p></li><li><p>unmarshalled: this method is called when an object has been <span class="bold"><strong>fully</strong></span> unmarshaled</p></li></ul></div><p>
         <span class="bold"><strong>Note:</strong></span> The <code class="classname">UnmarshalListener</code> had been part of <code class="code">org.exolab.castor.xml</code>
         but as an extention of this interface had been required a new interface in <code class="code">org.castor.xml</code>
         was introduced. Currently the <code class="code">org.exolab.castor.xml.UnmarshalListener</code> interface
         can still be used but is deprecated.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1428"></a>1.7.&nbsp;Castor XML: Writing Custom FieldHandlers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1430"></a>1.7.1.&nbsp;Introduction</h3></div></div></div><p>
          Sometimes we need to deal with a data format that Castor doesn't
          support out-of-the-box, such as an unsupported Date/Time
          representation, or we want to wrap and unwrap fields in Wrapper
          objects to get the desired XML output without changing our object
          model. To handle these cases Castor allows specifying a custom
          <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
          which can do these varying conversions during calls to the fields
          setter and getter methods.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
       		The
       		<span class="italic">FieldHandler</span>
       		is the basic interface used by the Castor Framework when
       		accessing field values or setting them. By specifying a
       		custom
       		<span class="italic">FieldHandler</span>
       		in the mapping file we can basically intercept the calls
       		to retrieve or set a field's value and do whatever
       		conversions are necessary.
       	</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1438"></a>1.7.2.&nbsp;Writing a simple FieldHandler</h3></div></div></div><p>
         When a writing a FieldHandler handler we need to provide implementations
         of the various methods specified in the FieldHandler interface. The main
         two methods are the <span class="italic">getValue</span> and <span class="italic">setValue</span> methods which
         will basically handle all our conversion code. The other methods provide
         ways to create a new instance of the field's value or reset the field
         value.
       </p><p>
         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
                It's actually even easier to write custom field handlers if we use
                a GeneralizedFieldHandler. See more details in 
                <a href="#xml.field.handler.generalized" title="1.7.3.&nbsp;Writing a GeneralizedFieldHandler">Section&nbsp;1.7.3, &#8220;Writing a GeneralizedFieldHandler&#8221;</a>
            </p></td></tr></table></div><p>
       </p><p>
         Let's take a look at how to convert a date in the format YYYY-MM-DD using
         a custom FieldHandler. We want to marshal the following XML input file <code class="classname">text.xml</code>:
         </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">root</span>&gt;2004-05-10&lt;<span class="hl-tag">/root</span>&gt;</pre><p>

         The class we'll be marshalling from and unmarshalling to looks as follows:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {

    <span class="hl-keyword">private</span> Date _date;

    <span class="hl-keyword">public</span> Root() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Date getDate() {
        <span class="hl-keyword">return</span> _date;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDate(<span class="hl-keyword">final</span> Date date) {
        _date = date;
    }
         </pre><p>

        So we need to write a custom FieldHandler that takes the input String
        and converts it into the proper java.util.Date instance:

       </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">implements</span> FieldHandler
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(<span class="hl-keyword">final</span> Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value) 
       <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
       
        Root root = (Root)object;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }


    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }


    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }
}
       </pre><p>

         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The <span class="italic">newInstance</span> method should return null for immutable types.</p></td></tr></table></div><p>

       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
          There is also an
          <code class="classname">org.exolab.castor.mapping.AbstractFieldHandler</code>
          that we can extend instead of implementing FieldHandler directly.
          Not only do we not have to implement deprecated methods, but we can also
          gain access to the <span class="italic">FieldDescriptor</span> used by Castor.
        </p></td></tr></table></div><p>

       In order to tell Castor that we want to use our Custom FieldHandler
       we must specify it in the mapping file <code class="classname">mapping.xml</code>:

        </p><pre class="programlisting">

&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"MyDateHandler"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"text"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;

        </pre><p>

         We can now use a simple Test class to unmarshal our XML document:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	       <span class="hl-comment">//--load mapping</span>
	       Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	       mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

           System.out.println(<span class="hl-string">"unmarshalling root instance:"</span>);
           System.out.println();

           Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
           Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Root.<span class="hl-keyword">class</span>);
           unmarshaller.setMapping(mapping);
           Root root = (Root) unmarshaller.unmarshal(reader);
           reader.close();

           System.out.println(<span class="hl-string">"Root#getDate : "</span> + root.getDate());
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}

         </pre><p>

         Now simply compile the code and run!

         </p><pre class="programlisting">
% java Test
unmarshalling root instance:

Root#getDate : Mon May 10 00:00:00 CDT 2004
         </pre><p>

         After running our test program we can see that Castor invoked our
         custom FieldHandler and we got our properly formatted date in our
         Root.class.

       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.field.handler.generalized"></a>1.7.3.&nbsp;Writing a GeneralizedFieldHandler</h3></div></div></div><p>
         A <code class="classname">org.exolab.castor.mapping.GeneralizedFieldHandler</code>
         is an extension of FieldHandler interface
         where we simply write the conversion methods and Castor will automatically
         handle the underlying get/set operations. This allows us to re-use the
         same FieldHandler for fields from different classes that require the
         same conversion.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
         <span class="bold"><strong>Note:</strong></span>
         Currently the GeneralizedFieldHandler cannot be used from a
         <span class="italic">binding-file</span> for use with the SourceGenerator, an
         enhancement patch will be checked into SVN for this feature,
         shortly after 0.9.6 final is released.
         </p></td></tr></table></div><p>
        The same FieldHandler we used above can be written as a GeneralizedFieldHandler
        as such:
        </p><pre class="programlisting">

<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">extends</span> GeneralizedFieldHandler {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * getValue method is called. The getValue method will
     * obtain the actual field value from given 'parent' object.
     * This convert method is then invoked with the field's
     * value. The value returned from this method will be
     * the actual value returned by getValue method.
     *
     * @param value the object value to convert after
     *  performing a get operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * setValue method is called. The setValue method will
     * call this method to obtain the converted value.
     * The converted value will then be used as the value to
     * set for the field.
     *
     * @param value the object value to convert before
     *  performing a set operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        <span class="hl-keyword">return</span> date;
    }

    <span class="hl-comment">/**
     * Returns the class type for the field that this
     * GeneralizedFieldHandler converts to and from. This
     * should be the type that is used in the
     * object model.
     *
     * @return the class type of of the field
     */</span>
    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Date.<span class="hl-keyword">class</span>;
    }

    <span class="hl-comment">/**
     * Creates a new instance of the object described by
     * this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple
     *  type and cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}

        </pre><p>

        Everything else is the same. So we can re-run our test case using this
        GeneralizedFieldHandler and we'll get the same result. The main difference
        is that we implement the <span class="italic">convertUponGet</span> and <span class="italic">convertUponSet</span>
        methods.
        </p><p>
           Notice that we never reference the <span class="italic">Root</span> 
           class in our <code class="classname">GeneralizedFieldHandler</code>. This allows us 
           to use the same exact <code class="classname">FieldHandler</code> for any field 
           that requires this type of conversion.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1479"></a>1.7.4.&nbsp;Use ConfigurableFieldHandler for more flexibility</h3></div></div></div><p>
   		In some situations, the <code class="classname">GeneralizedFieldHandler</code> might not 
           provide sufficient flexibility. Suppose your XML document uses more than one 
           date format. You could solve this by creating a <code class="classname">GeneralizedFieldHandler</code> 
           subclass per date format, but that would lead to code duplication, which in 
           itself is not desirable. 
         </p><p>
         	A <code class="classname">ConfigurableFieldHandler</code> is a <code class="classname">FieldHandler</code> 
            that can be configured in the mapping file
         	with any kind and any number of parameters. You can simply configure two (or more)
         	instances of the same <code class="classname">ConfigurableFieldHandler</code> class 
            with different date format patterns.
         	Here's a mapping file that uses a <code class="classname">ConfigurableFieldHandler</code> 
            to marshal and unmarshal the
         	date field, similar to the preceding examples:
            
         	</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;mapping&gt;
   
   &lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"FieldHandlerImpl"</span>&gt;
      &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
   &lt;/field-handler&gt;
   
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Root"</span>&gt;
      &lt;field name=<span class="hl-string">"date"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;
         	</pre><p>
         	
         	The <span class="italic">field-handler</span> element defines the 
            <code class="classname">ConfigurableFieldHandler</code>. 
         	The class must be an implementation of the 
         	<span class="italic">org.exolab.castor.mapping.ConfigurableFieldHandler</span> 
            interface. This 
         	instance is configured with a date format. However, each implementation can decide
         	which, and how many parameters to use.
         </p><p>
         	The field handler instance is referenced by the 
            <span class="italic">field</span> element, using
         	the <span class="italic">handler</span> attribute.
         </p><p>
      	Here's the ConfigurableFieldHandler implementation:
      	</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.text.DateFormat;
<span class="hl-keyword">import</span> java.util.Date;
<span class="hl-keyword">import</span> java.util.Properties;

<span class="hl-keyword">import</span> org.exolab.castor.mapping.ConfigurableFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler {

    <span class="hl-keyword">private</span> DateFormat formatter;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setConfiguration(<span class="hl-keyword">final</span> Properties config) <span class="hl-keyword">throws</span> ValidityException {
    	String pattern = config.getProperty(<span class="hl-string">"date-format"</span>);
    	<span class="hl-keyword">if</span> (pattern == null) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Required parameter \"date-format\" is missing for FieldHandlerImpl."</span>);
    	}
    	<span class="hl-keyword">try</span> {
    		formatter = <span class="hl-keyword">new</span> SimpleDateFormat(pattern);
    	} <span class="hl-keyword">catch</span> (IllegalArgumentException e) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Pattern \""</span>+pattern+<span class="hl-string">"\" is not a valid date format."</span>);
    	}
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        <span class="hl-keyword">return</span> formatter.format(value);
    }

    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        Root root = (Root)object;
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }
    
    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent)
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }

}
      	</pre><p>
         
         	This implementation is similar to the first 
            <span class="italic">MyDateHandler</span> example
         	on this page, except that is adds a 
            <span class="italic">setConfiguration</span> method as
         	specified by the 
            <span class="italic">ConfigurableFieldHandler</span> interface. All parameters 
         	that are configured	in the mapping file will be passed in as a 
            <span class="italic">Properties</span>
         	object. The implementing method is responsible for processing 
            the configuration data.
         </p><p>
         	As a convenience, 
            <span class="italic">org.exolab.castor.mapping.AbstractFieldHandler</span> 
            already 
         	implements <span class="italic">ConfigurableFieldHandler</span>. However, 
            the <span class="italic">setConfiguration</span>
         	method is not doing anything. Any subclass of 
            <span class="italic">AbstractFieldHandler</span> only
         	has to override this method to leverage the configuration capabilities. Since 
            <span class="italic">
         	AbstractFieldHandler</span> and its subclass 
            <span class="italic">GeneralizedFieldHandler</span> are
         	useful abstract classes, you'd probably want to use them anyway. It eliminates the 
         	need to	implement the 
            <span class="italic">ConfigurableFieldHandler</span> interface yourself. 
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1510"></a>1.7.5.&nbsp;Reuse a <code class="classname">ConfigurableFieldHandler</code> for more than one field definition</h3></div></div></div><p>
    		Imagine a scenario where you want to use above <code class="classname">ConfigurableFieldHandler</code> 
    		instance for more than one field - a valid use case as it promotes reuse.
    	</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
   
   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myFirstHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyyMMddHHmmss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;

   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySecondHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyy-MM-ddHH:mm:ss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;
   
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"firstDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"secondDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thirdDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mySecondHandler"</span>/&gt;
   &lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">/mapping</span>&gt;
         </pre><p>
    		For this to work, there's one more thing you will have to do: your 
    		<code class="classname">ConfigurableFieldHandler</code> implementation has to implement the 
    		<code class="classname">ClonableFieldHandlerMarker</code> interface and implement
    		the <code class="methodname">copyFieldHandler()</code> method. As indicated by the name, 
    		please return a clone/copy of your <code class="classname">FieldHandler</code> instance ... and you 
    		are all set.
    	</p><p>
    		A simplified sample implementation could look as follows, extending the 
    		<code class="classname">FieldHandlerImpl</code> class from the previous section:
    	</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler, ClonableFieldHandlerMarker {

    <span class="hl-keyword">private</span> DateFormat format;

    ...

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFormat(DateFormat format) {
        <span class="hl-keyword">this</span>.format = format;
    }

    @Override
    <span class="hl-keyword">public</span> FieldHandler copyFieldHandler() {
        FieldHandlerImpl handler = <span class="hl-keyword">new</span> FieldHandlerImpl();
        handler.setFormat(<span class="hl-keyword">this</span>.getFormat());
        <span class="hl-keyword">return</span> handler;
    }
    
}    	
    	</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1524"></a>1.7.6.&nbsp;No Constructor, No Problem!</h3></div></div></div><p>
         A number of classes such as type-safe enum style classes have no constructor, but
         instead have some sort of static factory method used for converting a string value
         into an instance of the class. With a custom FieldHandler we can allow Castor to
         work nicely with these types of classes.
      </p><p>
       </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
          Castor XML automatically supports these types of classes if they have a specific
          method:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> {Type} valueOf(String)
          </pre><p>
          </p></td></tr></table></div><p>
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>We're working on the same support for Castor JDO</p></td></tr></table></div><p>
     </p><p>
     Even though Castor XML supports the "valueOf" method type-safe enum style classes, we'll
     show you how to write a custom handler for these classes anyway since it's useful for
     any type of class regardless of the name of the factory method.
     </p><p>
       Let's look at how to write a handler for the following type-safe enum style class,
       which was actually generated by Castor XML (javadoc removed for brevity):
       </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.Serializable;
<span class="hl-keyword">import</span> java.util.Enumeration;
<span class="hl-keyword">import</span> java.util.Hashtable;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Color <span class="hl-keyword">implements</span> java.io.Serializable {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> RED_TYPE = 0;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color RED = <span class="hl-keyword">new</span> Color(RED_TYPE, <span class="hl-string">"red"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> GREEN_TYPE = 1;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color GREEN = <span class="hl-keyword">new</span> Color(GREEN_TYPE, <span class="hl-string">"green"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> BLUE_TYPE = 2;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color BLUE = <span class="hl-keyword">new</span> Color(BLUE_TYPE, <span class="hl-string">"blue"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable _memberTable = init();

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> type = -1;

    <span class="hl-keyword">private</span> java.lang.String stringValue = null;


    <span class="hl-keyword">private</span> Color(<span class="hl-keyword">int</span> type, java.lang.String value) {
        <span class="hl-keyword">super</span>();
        <span class="hl-keyword">this</span>.type = type;
        <span class="hl-keyword">this</span>.stringValue = value;
    } <span class="hl-comment">//-- test.types.Color(int, java.lang.String)</span>


    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> java.util.Enumeration enumerate()
    {
        <span class="hl-keyword">return</span> _memberTable.elements();
    } <span class="hl-comment">//-- java.util.Enumeration enumerate()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getType()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.type;
    } <span class="hl-comment">//-- int getType()</span>

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable init()
    {
        Hashtable members = <span class="hl-keyword">new</span> Hashtable();
        members.put(<span class="hl-string">"red"</span>, RED);
        members.put(<span class="hl-string">"green"</span>, GREEN);
        members.put(<span class="hl-string">"blue"</span>, BLUE);
        <span class="hl-keyword">return</span> members;
    } <span class="hl-comment">//-- java.util.Hashtable init()</span>

    <span class="hl-keyword">public</span> java.lang.String toString()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.stringValue;
    } <span class="hl-comment">//-- java.lang.String toString()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> Color valueOf(java.lang.String string)
    {
        Object obj = null;
        <span class="hl-keyword">if</span> (string != null) obj = _memberTable.get(string);
        <span class="hl-keyword">if</span> (obj == null) {
            String err = <span class="hl-string">"'"</span> + string + <span class="hl-string">"' is not a valid Color"</span>;
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(err);
        }
        <span class="hl-keyword">return</span> (Color) obj;
    } <span class="hl-comment">//-- test.types.Color valueOf(java.lang.String)</span>

}
       </pre><p>

      The <span class="italic">GeneralizedFieldHandler</span> for the above <span class="italic">Color</span> class is as follows
      (javadoc removed for brevity):

      </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-comment">/**
 * The FieldHandler for the Color class
**/</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ColorHandler
    <span class="hl-keyword">extends</span> GeneralizedFieldHandler
{

    <span class="hl-keyword">public</span> ColorHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        Color color = (Color)value;
        <span class="hl-keyword">return</span> color.toString();
    }


    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        <span class="hl-keyword">return</span> Color.valueOf((String)value);
    }

    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Color.<span class="hl-keyword">class</span>;
    }

    <span class="hl-keyword">public</span> Object newInstance( Object parent )
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}
     </pre><p>
     </p><p>
      That's all there really is to it. Now we just need to hook this up to our mapping file
      and run a sample test.
     </p><p>
       If we have a root class <span class="italic">Foo</span> as such:
     </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Color _color = null;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _size = 0;
    <span class="hl-keyword">private</span> String _name = null;

    <span class="hl-keyword">public</span> Foo() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Color getColor() {
        <span class="hl-keyword">return</span> _color;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getSize() {
        <span class="hl-keyword">return</span> _size;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setColor(Color color) {
        _color = color;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSize(<span class="hl-keyword">int</span> size) {
        _size = size;
    }

}
       </pre><p>
       Our mapping file would be the following:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"size"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>/&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"color"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"ColorHandler"</span>/&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
       </pre><p>

       We can now use our custom FieldHandler to unmarshal the following xml input:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">name</span>&gt;MyFoo&lt;<span class="hl-tag">/name</span>&gt;
   &lt;<span class="hl-tag">size</span>&gt;345&lt;<span class="hl-tag">/size</span>&gt;
   &lt;<span class="hl-tag">color</span>&gt;blue&lt;<span class="hl-tag">/color</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;
       </pre><p>

       A sample test class is as follows:
       </p><pre class="programlisting">

<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	        <span class="hl-comment">//--load mapping</span>
	        Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	        mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

            System.out.println(<span class="hl-string">"unmarshalling Foo:"</span>);
            System.out.println();

            Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
            Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Foo.<span class="hl-keyword">class</span>);
            unmarshaller.setMapping(mapping);
            Foo foo = (Foo) unmarshaller.unmarshal(reader);
            reader.close();

            System.out.println(<span class="hl-string">"Foo#size : "</span> + foo.getSize());
            System.out.print(<span class="hl-string">"Foo#color: "</span>);
            <span class="hl-keyword">if</span> (foo.getColor() == null) {
                System.out.println(<span class="hl-string">"null"</span>);
            }
            <span class="hl-keyword">else</span> {
                System.out.println(foo.getColor().toString());
            }

            PrintWriter pw = <span class="hl-keyword">new</span> PrintWriter(System.out);
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(pw);
            marshaller.setMapping(mapping);
            marshaller.marshal(foo);
            pw.flush();
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}
        </pre><p>
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1547"></a>1.7.7.&nbsp;Collections and FieldHandlers</h3></div></div></div><p>
         </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                With Castor 0.9.6 and later, the <span class="italic">GeneralizedFieldHandler</span> 
                automatically supports iterating over the items of a collection and passing them 
                one-by-one to the <span class="italic">convertUponGet</span>.
            </p><p> 
                For backward compatibility or to handle the collection iteration yourself, 
                simply add the following to the constructor of your 
                <code class="classname">GeneralizedFieldHandler</code> implementation:

            </p><pre class="programlisting">
setCollectionIteration(false);
            </pre><p>
         
            </p></td></tr></table></div><p>
      </p><p>
         If you're going to be using custom field handlers for collection fields with
         a <code class="classname">GeneralizedFieldHandler</code> using versions of Castor 
         prior to 0.9.6, then you'll need to handle the collection iteration yourself in the
         <span class="italic">convertUponGet</span>  method.
       </p><p>
         If you're not using a <code class="classname">GeneralizedFieldHandler</code>, then 
         you'll need to handle the collection iteration yourself in the 
         <span class="italic">FieldHandler#getValue()</span> method.
       </p><p>
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
               Since Castor incrementally adds items to collection fields, there
               usually is no need to handle collections directly in the
               <span class="italic">convertUponSet</span> method (or the <span class="italic">setValue()</span> for those
               not using <code class="classname">GeneralizedFieldHandler</code>).
            </p></td></tr></table></div><p>
       </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1569"></a>1.8.&nbsp;Best practice</h2></div></div></div><p>
        There are many users of Castor XML who (want to) use Castor XML in in
        high-volume applications. To fine-tune Castor for such an environment,
        it is necessary to understand many of the product features in detail
        and to be able to balance their use according to the application needs.
        Even though many of these features are documented in various places,
        people frequently asked for a 'best practices' document, a document
        that brings together these technical topics in one place and that
        presents them as a set of easy-to-use recipes.
    </p><p>
        Please be aware that this document is <span class="italic">under construction</span>.  
        But still we believe that this document -- even when in its conception
        phase -- provides valuable information to users of Castor XML.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1574"></a>1.8.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1576"></a>1.8.1.1.&nbsp;Source Generator</h4></div></div></div><p>
             It is not generally recommended to generate code into the default
             package, especially since code in the default package cannot be
             referenced from code in any other package.
           </p><p>
             Additionally, we recommend that generated code go into a different
             package then the code that makes use of the generated code.  For
             example, if your application uses Castor to process an XML
             configuration file that is used by code in the package
             <code class="literal">org.example.userdialog</code> then we do not recommend that the
             generated code also go into that package.  However, it would be
             reasonable to generate source to process this XML configuration file
             into the package <code class="literal">org.example.userdialog.xmlconfig</code>.
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1582"></a>1.8.2.&nbsp;Performance Considerations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1584"></a>1.8.2.1.&nbsp;General</h4></div></div></div><p>
          Creating instances of <code class="classname">org.exolab.castor.xml.Marshaller</code> and
          <code class="classname">org.exolab.castor.xml.Unmarshaller</code> for the purpose of XML
          data binding is easy to achieve at the API usage level.  However,
          details of API use have an impact on application performance; each
          instance creation involves setup operations.
        </p><p>
          This is generally not an issue for one-off invocations; however, in a
          multi-threaded, high volume use scenario this can be become a serious
          issue. Internally, Castor uses a collection of <span class="italic">Descriptor</span>
          classes to keep information about the Java entities to be marshaled
          and unmarshaled. With each instance creation of (Un)Marshaller, this
          collection will be built from scratch (again and again).
        </p><p>
          To avoid this initial configuration 'penalty', Castor allows you to
          cache these Descriptor classes through its
          <code class="classname">org.exolab.castor.xml.ClassDescriptorResolver</code> component.
          This cache allows reuse of these Descriptor instances between
          (Un)Marshaller invocations.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1593"></a>1.8.2.2.&nbsp;Use of XMLContext - With and without a mapping file</h4></div></div></div><p>
          With the introduction of the new <code class="classname">org.exolab.castor.xml.XMLContext</code> 
          class, the use of a 
          <code class="literal">ClassDescriptorResolver</code> has been greatly simplified in that such
          an instance is managed by the XMLContext per default. As such, there's no need
          to pass a <code class="literal">ClassDescriptorResolver</code> instance to 
          <code class="literal">Marshaller</code>/
          <code class="literal">Unmarshaller</code> instances anymore, as this is done automatically
          when such instances are created through
          
          </p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createMarshaller()</code></p></li><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code></p></li></ul></div><p>
          
          For example, to create a <code class="literal">Marshaller</code> instance that is pre-configured
          with an instance of <code class="literal">ClassDescriptorResolver</code>, use the following code 
          fragment:
        </p><pre class="programlisting">
Mapping mapping = <span class="hl-keyword">new</span> Mapping();
mapping.loadMapping(<span class="hl-keyword">new</span> InputSource(...));
        
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addMapping(mapping);

Marshaller marshaller = context.createMarshaller();</pre><p>
            In the case where no mapping file is used, it is still possible 
            to instruct the <code class="classname">org.exolab.castor.xml.XMLContext</code> to
            <span class="italic">pre-load</span> class descriptors for a given 
            package via the methods enlisted below.
         </p><p>
            As above, create an instance of <code class="classname">org.exolab.castor.xml.XMLContext</code> 
            and configure it according to your needs as shown below:
         </p><pre class="programlisting">
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addPackage(<span class="hl-string">"your.package.name"</span>);

Marshaller marshaller = context.createMarshaller();</pre><p>
            The <code class="classname">org.exolab.castor.xml.XMLContext</code> class 
            provides for various methods to load class descriptors for individual classes 
            and/or packages.
         </p><div class="table"><a name="d4e1619"></a><p class="title"><b>Table&nbsp;1.16.&nbsp;Methods on XMLContext to create Un-/Marshaller objects</b></p><div class="table-contents"><table summary="Methods on XMLContext to create Un-/Marshaller objects" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th><code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(Class)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for one class.</td><td>n/a</td></tr><tr><td><code class="methodname">addClass(Class[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptors for a collection of classes.</td><td>n/a</td></tr><tr><td><code class="methodname">addPackage(String)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined package.</td><td>Required</td></tr><tr><td><code class="methodname">addPackages(String[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined packages.</td><td>Required</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
               For some of the methods, pre-loading class descriptords will only work if you provide 
               the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
               code generator). If no such file is shipped, Castor will not be able to pre-load the 
               descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1659"></a>1.8.2.3.&nbsp;Use of Marshaller/Unmarshaller</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1661"></a>1.8.2.3.1.&nbsp;Use of ClassDescriptorResolver</h5></div></div></div><p>
             When you do not use the <code class="literal">XMLContext</code> class, you will have 
             to manually manage your 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>. To do 
             so, first create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
             using the following code fragment:
           </p><pre class="programlisting">
XMLClassDescriptorResolver classDescriptorResolver = 
   (XMLClassDescriptorResolver) ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
MappingUnmarshaller mappingUnmarshaller = <span class="hl-keyword">new</span> MappingUnmarshaller();
MappingLoader mappingLoader = 
   mappingUnmarshaller.getMappingLoader(mapping, BindingType.XML);
classDescriptorResolver.setMappingLoader(mappingLoader);</pre><p>and then reuse this instance as shown below:</p><pre class="programlisting">
   Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller();
   unmarshaller.setResolver(classDescriptorResolver);
   unmarshaller.unmarshal(...);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1670"></a>1.8.2.3.2.&nbsp;Use of ClassDescriptorResolver for pre-loading compiled descriptors</h5></div></div></div><p>
               When you are not using a mapping file, but you have generated Java 
               classes and their corresponding descriptor classes using the Castor
               XML code generator, you might want to instruct the 
               <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code> to
               <span class="italic">pre-load</span> class descriptors (as enumerated explicitly 
               or for a given package) using various <code class="literal">add*</code> methods.
            </p><p>
             As above, create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver"&gt;XMLClassDescriptorResolver</code> 
             using the following code fragment:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.A"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.B"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.C"</span>);
           </pre><p>
              and then reuse this instance as shown above. Alternatively, add complete
              packages to the resolver configuration as follows:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addPackage(<span class="hl-string">"your.package.name"</span>);
           </pre><p>
              The <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
              interface provides various other methods to load class descriptors for individual
              classes and/or packages.
           </p><div class="table"><a name="d4e1683"></a><p class="title"><b>Table&nbsp;1.17.&nbsp;blah</b></p><div class="table-contents"><table summary="blah" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th>Requires <code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(String)</code></td><td>Loads the class descriptor for one class.</td><td>No</td></tr><tr><td><code class="methodname">addClass(String[])</code></td><td>Loads the class descriptors for a collection of classes.</td><td>No</td></tr><tr><td><code class="methodname">addPackage(String)</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr><tr><td><code class="methodname">addPackages(String[])</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              For some of the methods, pre-loading class descriptords will only work if you provide 
              the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
              code generator). If no such file is shipped, Castor will not be able to pre-load the 
              descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1719"></a>1.9.&nbsp;Castor XML - HOW-TO's</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1721"></a>1.9.1.&nbsp;Introduction</h3></div></div></div><p>
			This is a collection of HOW-TOs. The Castor project is
			actively seeking additional HOW-TO contributors to expand
			this collection. For information on how to do that, please
			see 'How to write a How-to'.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1724"></a>1.9.2.&nbsp;Documentation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					How to Author a How-To
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author an FAQ
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author a Code Snippet
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author Core Documentation
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1739"></a>1.9.3.&nbsp;Contribution</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-submit-an-xml-bug.html" target="_top">
						How to submit an XML-specific bug report
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prepare-a-patch.html" target="_top">
						How to prepare a patch
					</a>
				</p></li><li><p>
					How to Contribute a Patch via Jira
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-run-xml-ctf-suite.html" target="_top">
						How to run Castor XML's test suite
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1754"></a>1.9.4.&nbsp;Mapping</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-XMLContext.html" target="_top">
						How to use XMLContext for un-/marshalling
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-collection.html" target="_top">
						How to map a collection of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-hashtable.html" target="_top">
						How to map a map/hashtable of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-list-at-root.html" target="_top">
						How to map a list of elements at the root
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-class-with-constructors.html" target="_top">
						How to map constructor arguments
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-an-inner-class.html" target="_top">
						How to map an inner class
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-unmarshal-raw-xml.html" target="_top">
						How to Unmarshal raw XML segments into arbitrary
						types
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-references-in-xml.html" target="_top">
						How to use references in XML and Castor
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-wrap-a-collection-with-a-wrapper-element.html" target="_top">
						How to wrap a collection with a wrapper element
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prevent-collection-from-being-exposed.html" target="_top">
						How to prevent a collection from being exposed
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-write-a-configurablefieldhandler.html" target="_top">
						How to write a configurable field handler
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-both-structure-and-content.html" target="_top">
						How to map text content
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-work-with-wrapper-elements-around-collections.html" target="_top">
						How to work with wrapper elements around
						collections
					</a>
				</p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-marshall-version-1.1-xml.html" target="_top">
                        How to work marshal XML documents with version 1.1
                    </a>
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1799"></a>1.9.5.&nbsp;Validation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-enable-xml-validation.html" target="_top">
						How to use XML validation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1805"></a>1.9.6.&nbsp;Source generation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-a-binding-file-with-source-generation.html" target="_top">
						How to use a binding file with source generation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1811"></a>1.9.7.&nbsp;Others</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-implement-custom-serializer.html" target="_top">
						How to implement a custom serializer
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-fetch-dtds-and-schemas-from-jars.html" target="_top">
						How to fetch DTDs and XML Schemas from JAR files
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-hibernate-proxies.html" target="_top">
						How to marshal Hibernate proxies
					</a>
				</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1823"></a>1.10.&nbsp;XML FAQ</h2></div></div></div><p>
        This section provides answers to frequently answered questions, i.e.
        questions that have been asked repeatedly on one of the mailing 
        lists. Please check with these F.A.Q.s frequently, as addressing questions
        that have been answered in the past already again and again places
        an unnecessary burden on the committers/contributors. 
    </p><p>
        This section is structured along the lines of the following areas ...
        
    </p><div class="itemizedlist"><ul type="disc"><li><p><a href="#xml.faq.general" title="1.10.1.&nbsp;General">Section&nbsp;1.10.1, &#8220;General&#8221;</a></p></li><li><p><a href="#xml.faq.introspection" title="1.10.2.&nbsp;Introspection">Section&nbsp;1.10.2, &#8220;Introspection&#8221;</a></p></li><li><p><a href="#xml.faq.mapping" title="1.10.3.&nbsp;Mapping">Section&nbsp;1.10.3, &#8220;Mapping&#8221;</a></p></li><li><p><a href="#xml.faq.marshalling" title="1.10.4.&nbsp;Marshalling">Section&nbsp;1.10.4, &#8220;Marshalling&#8221;</a></p></li><li><p><a href="#xml.faq.generation" title="1.10.5.&nbsp;Source code generation">Section&nbsp;1.10.5, &#8220;Source code generation&#8221;</a></p></li><li><p><a href="#xml.faq.misc" title="1.10.6.&nbsp;Miscellaneous">Section&nbsp;1.10.6, &#8220;Miscellaneous&#8221;</a></p></li><li><p><a href="#xml.faq.serialization" title="1.10.7.&nbsp;Serialization">Section&nbsp;1.10.7, &#8220;Serialization&#8221;</a></p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.general"></a>1.10.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1851"></a>1.10.1.1.&nbsp;How do I set the encoding?</h4></div></div></div><p>
				Create a new instance of the
				<code class="classname">Marshaller</code>
				class and use the
				<code class="classname">setEncoding</code>
				method. You'll also need to make sure the encoding for
				the Writer is set properly as well:
			</p><pre class="programlisting">
 ...
 String encoding = <span class="hl-string">"ISO-8859-1"</span>;
 FileOutputStream fos = <span class="hl-keyword">new</span> FileOutputStream(<span class="hl-string">"result.xml"</span>);
 OutputStreamWriter osw = <span class="hl-keyword">new</span> OuputStreamWriter(fos, encoding);
 Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(osw);
 marshaller.setEncoding(encoding);
 ...
			</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1857"></a>1.10.1.2.&nbsp;
				I'm getting an error about 'xml' prefix already
				declared?
			</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>For Castor 0.9.5.2 only</p></td></tr></table></div><p>
				The issue occurs with newer versions of Xerces than the
				version 1.4 that ships with Castor. The older version
				works OK. For some reason, when the newer version of
				Xerces encounters an "xml" prefixed attribute, such as
				"xml:lang", it tries to automatically start a prefix
				mapping for "xml". Which, in my opinion, is technically
				incorrect. They shouldn't be doing that. According to
				the w3c, the "xml" prefix should never be declared.
			</p><p>
				The reason it started appearing in the new Castor
				(0.9.5.2), is because of a switch to SAX 2 by default
				during unmarshaling.
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>
				A built in work-around has been checked into the Castor
				SVN and will automatically exist in any post 0.9.5.2
				releases. For those who are using 0.9.5.2 and can't
				upgrade, I found a simple workaround (tested with Xerces
				2.5). At first I thought about disabling namespace
				processing in Xerces, but then realized that it's
				already disabled by default by Castor ... so I have no
				idea why they call #startPrefixMapping when namespace
				processing has been disabled. But in any event...
				explicitly enabling namespace processing seems to fix
				the problem:
			</p><p>
				in the
				<code class="classname">castor.properties</code>
				file, change the following line:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=false
			</pre><p>to:</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
			</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					This work-around has only been tested with
					Xerces 2.5 and above.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1872"></a>1.10.1.3.&nbsp;Why is my 'get' method called twice?</h4></div></div></div><p>
				The get method will be called a second time during the
				validation process. To prevent this from happening,
				simply disable validation on the Marshaller or
				Unmarshaller.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1875"></a>1.10.1.4.&nbsp;
				How can I speed up marshalling/unmarshalling
				performance?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Cache the descriptors!</p><pre class="programlisting">
 <span class="hl-keyword">import</span> org.exolab.castor.xml.ClassDescriptorResolver;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.util.ClassDescriptorResolverImpl;
 ...
 ClassDescriptorResolver cdr = <span class="hl-keyword">new</span> ClassDescriptorResovlerImpl(); 
 ...
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setResolver(cdr);
					</pre><p>
						By reusing the same <code class="classname">ClassDescriptorResolver</code> any
						time you create an Unmarshaller instance, you
						will be reusing the existing class descriptors
						previously loaded.
					</p></li><li><p>Disable validation</p><pre class="programlisting">
 unm.setValidation(false);
					</pre></li><li><p>
						Reuse objects
                    </p><p>
						To cut down on object creation, you can reuse an
						existing object model, but be careful because
						this is an experimental feature. Create an
						Unmarshaller with your existing root object and
						set object reuse to true...
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span>
 Unmarshaller(myObjectRoot);
					</pre><pre class="programlisting">
 unm.setReuseObjects(true);
					</pre></li><li><p>
						If you have enabled pretty-printing (indenting),
						then disable it. The Xerces Serializer is much
						slower with indenting enabled.
					</p></li><li><p>
						Try changing parsers to something other than
						Xerces.
					</p></li></ul></div><p>
				There are probably other approaches you can use as well,
				but those seem to be the most popular ones. Let us know
				if you have a solution that you think we should add
				here.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1896"></a>1.10.1.5.&nbsp;
				How do I ignore elements during unmarshalling?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
						Use the
						<code class="classname">
							Unmarshaller#setIgnoreExtraElements()
						</code>
						method:
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setIgnoreExtraElements(true);
					</pre><p>
						If any elements appear in the XML instance that
						Castor cannot find mappings for, they will be
						skipped.
					</p></li><li><p>
						You can also set the 
						<code class="classname">
							org.exolab.castor.xml.strictelements 
						</code>
						property in the
						<code class="classname">castor.properties</code>
						file:
					</p><pre class="programlisting">
 org.exolab.castor.xml.strictelements=true
					</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1909"></a>1.10.1.6.&nbsp;
				Where does Castor search for the castor.properties file?
			</h4></div></div></div><p>
				Castor loads the castor.properties in the following
				order:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						From classpath (usually from the jar file)
					</p></li><li><p>From {java.home}/lib (if present)</p></li><li><p>From the local working directory</p></li></ul></div><p>
				Each properties file overrides the previous. So you
				don't have to come up with a properties file with all
				the properties and values, just the ones you want to
				change. This also means you don't have to touch the
				properties file found in the jar file.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					Note: You can also use
					<code class="classname">
						LocalConfiguration.getInstance().getProperties()
					</code>
					to change the properties values programatically.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1923"></a>1.10.1.7.&nbsp;
				Can I programmatically change the properties found in
				the castor.properties file?
			</h4></div></div></div><p>
				Yes, many of these properties can be set directly on the
				Marshaller or Unmarshaller, but you can also use
				<code class="classname">
					LocalConfiguration.getInstance().getProperties()
				</code>
				to change the properties values programatically.
				
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.introspection"></a>1.10.2.&nbsp;Introspection</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1929"></a>1.10.2.1.&nbsp;Can private methods be introspected?</h4></div></div></div><p>
				Castor does not currently support introspection of
				private methods. Please make sure proper public
				accesssor methods are available for all fields that you
				wish to be handled by the Marshalling Framework.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.mapping"></a>1.10.3.&nbsp;Mapping</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1934"></a>1.10.3.1.&nbsp;My mapping file seems to have no effect!</h4></div></div></div><p>
				Make sure you are not using one of the
				<span class="italic">static</span>
				methods on the Marshaller/Unmarshaller. Any
				configuration changes that you make to the Marshaller or
				Unmarshaller are not available from the static methods.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1938"></a>1.10.3.2.&nbsp;
				Are there any tools to automatically create a mapping
				file?
			</h4></div></div></div><p>
				Yes! We provide one such tool, see
				<code class="classname">org.exolab.castor.tools.MappingTool</code>
				. There are some 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/extras.html" target="_top">3rd party</a> 
                tools as well.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1943"></a>1.10.3.3.&nbsp;
				How do I specify a namespace in the mapping file?
			</h4></div></div></div><p>
				For a specific field you can use a QName for the value
				of the bind-xml name attribute as such:
			</p><pre class="programlisting">
 &lt;bind-xml name=<span class="hl-string">"foo:bar"</span> xmlns:foo=<span class="hl-string">"http://www.acme.com/foo"</span>/&gt;
			</pre><p>
				Note: The namespace prefix is only used for
				qualification during the loading of the mapping, it is
				not used during Marshaling. To map namespace prefixes
				during marshaling you currently need to set these via
				the Marshaler directly.
			</p><p>
				For a class mapping, use the &lt;map-to&gt; element. For
				more information see the
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping documentation</a>
				.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1950"></a>1.10.3.4.&nbsp;
				How do I prevent a field from being marshaled?
			</h4></div></div></div><p>
				Set the
				<span class="bold"><strong>transient</strong></span>
				attribute on the &lt;bind-xml&gt; element to true:
			</p><pre class="programlisting">
 &lt;bind-xml <span class="hl-keyword">transient</span>=<span class="hl-string">"true"</span>/&gt;
			</pre><p>
				Note: You can also set transient="true" on the
				&lt;field&gt; element.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.marshalling"></a>1.10.4.&nbsp;Marshalling</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1958"></a>1.10.4.1.&nbsp;
				The XML is marshalled on one line, how do I force
				line-breaks?
			</h4></div></div></div><p>For all versions of Castor:</p><p>
				To enable pretty-printing (indenting, line-breaks) just
				modify the
				<span class="italic">
					<span class="bold"><strong>castor.properties</strong></span>
				</span>
				file and uncomment the following:
			</p><pre class="programlisting">
 # True <span class="hl-keyword">if</span> all documents should be indented on output by <span class="hl-keyword">default</span>
 #
 #org.exolab.castor.indent=true
			</pre><p>
				Note: This will slow down the marshalling process
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1966"></a>1.10.4.2.&nbsp;What is the order of the marshalled XML elements?</h4></div></div></div><p>
      			If you are using Castor's default introspection to
      			automatically map the objects into XML, then there is no
      			guarantee on the order. It simply depends on the order in
      			which the fields are returned to Castor using the Java
      			reflection API.
      		</p><p>
      			Note: If you use a mapping file Castor will generate the XML
      			in the order in which the mapping file is specified.
      		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.generation"></a>1.10.5.&nbsp;Source code generation</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1972"></a>1.10.5.1.&nbsp;Can I use a DTD with the source generator?</h4></div></div></div><p>
				Not directly, however you can convert your DTD to an XML
				Schema fairly easily. We provide a tool (
				<code class="classname">
					org.exolab.castor.xml.dtd.Converter
				</code>
				) to do this. You can also use any number of 3rd-party
				tools such as XML Spy or XML Authority.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1976"></a>1.10.5.2.&nbsp;
				My XML output looks incorrect, what could be wrong?
			</h4></div></div></div><p>
				Also: I used the source code generator, but all my xml
				element names are getting marshaled as lowercase with
				hyphens, what's up with that?
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>

				Are the generated class descriptors compiled? Make sure
				they get compiled along with the source code for the
				object model.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1981"></a>1.10.5.3.&nbsp;
				The generated source code has incorrect or missing
				imports for imported schema types
			</h4></div></div></div><p>
				<span class="bold"><strong>Example:</strong></span>
				Castor generates the following:
			</p><pre class="programlisting">
 <span class="hl-keyword">import</span> types.Foo;
			</pre><p>instead of:</p><pre class="programlisting">
 <span class="hl-keyword">import</span> com.acme.types.Foo;
			</pre><p>
				This usually happens when the namespaces for the
				imported schemas have not been mapped to appropriate
				java packages in the
				<span class="italic">
					castorbuilder.properties
				</span>
				file.
			</p><p><span class="bold"><strong>Solution:</strong></span>
				</p><div class="itemizedlist"><ul type="disc"><li><p>
							Make sure the
							<code class="classname">
								castorbuilder.properties
							</code>
							is in your classpath when you run the
							SourceGenerator.
						</p></li><li><p>
							Uncomment and edit the
							<code class="classname">
								org.exolab.castor.builder.nspackages
							</code>
							property. Make sure to copy the value of the
							imported namespace exactly as it's referred
							to in the schema (i.e. trailing slashes and
							case-sensitivity matter!).
						</p></li></ul></div><p>
			</p><p>
				For those using 0.9.5.1, you'll need to upgrade due to a
				bug that is fixed in later releases.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2000"></a>1.10.5.4.&nbsp;
				How can I make the generated source code more JDO
				friendly?
			</h4></div></div></div><p>For Castor 0.9.4 and above:</p><p>
				Castor JDO requires a reference to the actual collection
				to be returned from the get-method. By default the
				source generator does not provide such a method. To
				enable such methods to be created, simple add the
				following line to your
				<code class="classname">castorbuilder.properties</code>
				file:
			</p><pre class="programlisting">
 org.exolab.castor.builder.extraCollectionMethods=true
			</pre><p>
				Note: The default
				<code class="classname">castorbuilder.properties</code>
				file has this line commented out. Simply uncomment it.
			</p><p>
				Your mapping file will also need to be updated to
				include the proper set/get method names.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.misc"></a>1.10.6.&nbsp;Miscellaneous</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2011"></a>1.10.6.1.&nbsp;
				Is there a way to automatically create an XML Schema
				from an XML instance?
			</h4></div></div></div><p>
				Yes! We provide such a tool. Please see
				<code class="classname">
					org.exolab.castor.xml.schema.util.XMLInstance2Schema
				</code>
				. It's not 100% perfect, but it does a reasonable job.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2015"></a>1.10.6.2.&nbsp;How to enable XML validation with Castor XML</h4></div></div></div><p>
				To enable XML validation at the parser level, please add
				properties to your
				<code class="classname">castor.properties</code>
				file as follows:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
 org.exolab.castor.sax.features=http:<span class="hl-comment">//xml.org/sax/features/validation,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema-full-checking</span>
			</pre><p>
				Please note that the example given relies on the use of
				Apache Xerces, hence the
				<code class="classname">apache.org</code>
				properties; similar options should exist for other
				parsers.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2022"></a>1.10.6.3.&nbsp;
				Why is mapping ignored when using a FieldHandlerFactory
			</h4></div></div></div><p>
				When using a custom FieldHandlerFactory as in the
				following example
			</p><pre class="programlisting">
 Mapping mapping = ... ;
 FieldHandlerFactoyt factory = ...;
 Marshaller m = <span class="hl-keyword">new</span> Marshaller(writer);
 ClassDescriptorResolverImpl cdr = <span class="hl-keyword">new</span> ClassDescriptorResolverImpl();
 cdr.getIntrospector().addFieldHandlerFactory(factory);
 m.setResolver(cdr);
 marshaller.setMapping(mapping);
			</pre><p>
				please make sure that you set the mapping file
				<span class="bold"><strong>after</strong></span>
				you set the ClassDescriptorResolver. You will note the
				following in the Javadoc for
				<code class="classname">org.exolab.castor.xml.Marshaller.html#setResolver(org.exolab.castor.xml.ClassDescriptorResolver)</code>
				:
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					<span class="bold"><strong>Note:</strong></span>
					This method will nullify any Mapping currently being
					used by this Marshaller
				</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.serialization"></a>1.10.7.&nbsp;Serialization</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2035"></a>1.10.7.1.&nbsp;
				Is it true that the use of Castor XML mandates 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xerces.apache.org" target="_top">Apache Xerces</a> as
				XML parser?
			</h4></div></div></div><p>
				Yes and no. It actually depends. When requiring
				<span class="italic">pretty printing</span>
				during marshalling, Castor internally relies on Apache's
				Xerces to implement this feature. As such, when not
				using this feature, Xerces is not a requirement, and any
				JAXP-compliant XML parser can be used (for
				unmarshalling).
			</p><p>
				In other words, with the latter use case, you do
				<span class="bold"><strong>not</strong></span>
				have to download (and use) Xerces separetely.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2042"></a>1.10.7.2.&nbsp;
				Do I still have to download Xerces when using Castor XML
				with Java 5.0?
			</h4></div></div></div><p>
				No. Starting with release 1.1, we have added support for
				using the Xerces instance as shipped with the JRE/JDK
				for serialization. As such, for Java 5.0 users, this
				removes the requirement to download Xerces separately
				when wanting to use 'pretty printing' with Castor XML
				during marshalling.
			</p><p>
				To enable this feature, please change the following
				properties in your
				<span class="bold"><strong>local</strong></span>
				<code class="classname">castor.properties</code>
				file (thus redefining the default value) as shown below:
			</p><pre class="programlisting">
 # Defines the XML parser to be used by Castor. 
 # The parser must implement org.xml.sax.Parser.
 org.exolab.castor.parser=org.xml.sax.helpers.XMLReaderAdapter

 # Defines the (<span class="hl-keyword">default</span>) XML serializer factory to use by Castor, which must
 # implement org.exolab.castor.xml.SerializerFactory; <span class="hl-keyword">default</span> is
 # org.exolab.castor.xml.XercesXMLSerializerFactory
 org.exolab.castor.xml.serializer.factory=org.exolab.castor.xml.XercesJDK5XMLSerializerFactory

 # Defines the <span class="hl-keyword">default</span> XML parser to be used by Castor.
 org.exolab.castor.parser=com.sun.org.apache.xerces.internal.parsers.SAXParser
			</pre></div></div></div></div>

   <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml.code.generator"></a>Chapter&nbsp;2.&nbsp;XML code generation</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction.why-code-generator"></a>2.1.&nbsp;Why Castor XML code generator - Motivation</h2></div></div></div><p>tbd</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.introduction"></a>2.2.&nbsp;Introduction</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.news"></a>2.2.1.&nbsp;News</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.introduction.news.newFieldNamingConventions"></a>2.2.1.1.&nbsp;Source generation &amp; Java field naming conventions</h4></div></div></div><p>
               Starting with <span class="bold"><strong>release 1.3.3</strong></span>, the Castor 
               source generator supports a new naming scheme for Java field names, which 
               will be enabled by default. As such, Java field names as generated will follow more closely the standard 
               Java property naming conventions. Should there be a need to keep using the old naming schema,
			   please amend the following property in your custom <code class="literal">castorbuilder.properties</code> file:
			</p><pre class="programlisting">
#
# Property specifying whether for Java field names the old naming conventions
# should be used.
#
# Possible values:
# - true
# - false (default)
# 
# &lt;<span class="hl-tag">pre</span>&gt;
# org.exolab.castor.builder.field-naming.old = false
# &lt;<span class="hl-tag">/pre</span>&gt;
#
org.exolab.castor.builder.field-naming.old=true
	        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.introduction.news.java50"></a>2.2.1.2.&nbsp;Source generation &amp; Java 5.0</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
                        Since <span class="bold"><strong>release 1.0.2</strong></span>, the Castor 
                        source generator supports the optional the generation of 
                        Java 5.0 compliant code.
                    </p></li><li><p>
                        With <span class="bold"><strong>release 1.3</strong></span>, the XML 
                        code generator will generate Java 5.0 compliant code by default.
                    </p></li></ol></div><p>
               With support for Java 5.0 enabled, the generated code will support the 
               following Java 5.0-specific artifacts:
           </p><div class="itemizedlist"><ul type="disc"><li><p>
            Use of parameterized collections, e.g.
            <code class="literal">ArrayList&lt;String&gt;</code>.
          </p></li><li><p>
            Use of <code class="literal">@Override</code> annotations with the generated methods
            that require it.
          </p></li><li><p>
            Use of <code class="literal">@SuppressWarnings</code> with "unused" method parameters
            on the generated methods that needed it.
          </p></li><li><p>Added "enum" to the list of reserved keywords.</p></li></ul></div><p>
          To disable this feature (on by default), please amend the following property 
          in your custom <code class="literal">castorbuilder.properties</code> file:
        </p><pre class="programlisting">
# Specifies whether the sources generated should be source compatible with
# Java 1.4 or Java 5.0. Legal values are "1.4" and "5.0".  When "5.0" is
# selected, generated source will use Java 5 features such as generics and
# annotations.
# Defaults to "5.0".
#
org.exolab.castor.builder.javaVersion=5.0
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.introduction"></a>2.2.2.&nbsp;Introduction</h3></div></div></div><p>
        Castor's Source Code Generator creates a set of Java classes which
        represent an object model for an XML Schema (W3C XML Schema 1.0 Second
        Edition, Recommendation), as well as the necessary Class
        Descriptors used by the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="../xml-framework.html" target="_top">marshaling
        framework</a> to obtain information about the generated classes.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        The generated source files will need to be compiled.  A later
        release may add an Ant taskdef to handle this automatically.
        </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.invocation"></a>2.2.3.&nbsp;Invoking the XML code generator</h3></div></div></div><p>
           The XML code generator can be invoked in many ways, including by 
           command line, via an Ant task and via Maven. Please follow the 
           below links for detailed instructions on each invocation mode.
        </p><div class="itemizedlist"><ul type="disc"><li><p><a href="#xml.code.generator.invocations.cmd" title="2.5.3.&nbsp;Command line">Section&nbsp;2.5.3, &#8220;Command line&#8221;</a></p></li><li><p><a href="#xml.code.generator.invocations.anttask" title="2.5.1.&nbsp;Ant task">Section&nbsp;2.5.1, &#8220;Ant task definition&#8221;</a></p></li><li><p><a href="#xml.code.generator.invocations.maven" title="2.5.2.&nbsp;Maven 2 plugin">Maven plugin for Castor XML</a></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.xml.schema"></a>2.2.4.&nbsp;XML Schema</h3></div></div></div><p>
        The input file for the source code generator is an XML
        schema<sup>[<a name="d4e2112" href="#ftn.d4e2112">1</a>]</sup>footnote&gt;. The currently supported version is the
        <span class="bold"><strong>W3C XML Schema 1.0, Second Edition</strong></span>
        <sup>[<a name="d4e2116" href="#ftn.d4e2116">2</a>]</sup>.
        For more information about XML schema support, check 
        <a href="#xml.code.generator.schema.support" title="2.6.&nbsp;XML schema support">Section&nbsp;2.6, &#8220;XML schema support&#8221;</a>.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.properties"></a>2.3.&nbsp;Properties</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.overview"></a>2.3.1.&nbsp;Overview</h3></div></div></div><p>
           Please find below a list of properties that can be configured through 
           the builder configuration properties, as defined in either the default
           or a custom XML code generator configuration file. These properties allow you 
           to control various advanced options of the XML source generator.
        </p><div class="table"><a name="xml.code.generator.properties.overview.grammar"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Description</th><th align="center">Values</th><th align="center">Default</th><th align="center">Since version</th></tr></thead><tbody><tr><td align="center"><a href="#xml.code.generator.properties.detailed.java50" title="2.3.3.1.&nbsp;Source generation &amp; Java 5.0">org.exolab.castor.builder.javaVersion</a></td><td align="center">Compliance with Java version</td><td align="center"><code class="literal">1.4</code>/<code class="literal">5.0</code></td><td align="center">1.4</td><td align="center"><span class="bold"><strong>1.0.2</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.enumerations.3" title="2.3.3.2.3.&nbsp;Source Generation of complex enums">org.exolab.castor.builder.forceJava4Enums</a>
               </td><td align="center">Forces the code generator to create 'old' Java 1.4 enumeration classes even in Java 5 mode.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center">false</td><td align="center"><span class="bold"><strong>1.1.3</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.bound.properties" title="2.3.3.3.&nbsp;Bound Properties">org.exolab.castor.builder.boundproperties</a>
               </td><td align="center">Generation of bound properties</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.class.creation" title="2.3.3.4.&nbsp;Class Creation/Mapping">org.exolab.castor.builder.javaclassmapping</a>
               </td><td align="center">Class generation mode</td><td align="center"><code class="literal">element</code>/<code class="literal">type</code></td><td align="center"><code class="literal">element</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.super.class" title="2.3.3.5.&nbsp;Setting a super class">org.exolab.castor.builder.superclass</a>
               </td><td align="center">Global super class (for all classes generated)</td><td align="center">Any valid class name</td><td align="center">-</td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.namespace.mapping" title="2.3.3.6.&nbsp;Mapping XML namespaces to Java packages">org.exolab.castor.builder.nspackages</a>
               </td><td align="center">XML namespace to package name mapping</td><td align="center">A series of mappings</td><td align="center">-</td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.equals" title="2.3.3.7.&nbsp;Generate equals()/hashCode() method">org.exolab.castor.builder.equalsmethod</a>
               </td><td align="center">Generation of <code class="literal">equals</code>/<code class="literal">hashCode()</code> method</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.use.cyclebreaker" title="2.3.3.8.&nbsp;Use CycleBreaker for generation of equals()/hashcode() methods.">org.exolab.castor.builder.useCycleBreaker</a>
               </td><td align="center">Use of cycle breaker code in generated <code class="literal">equals</code>/<code class="literal">hashCode()</code> method</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">true</code></td><td align="center">1.3.2</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.primitive.wrappers" title="2.3.3.9.&nbsp;Maps java primitive types to wrapper object">org.exolab.castor.builder.primitivetowrapper</a>
               </td><td align="center">Generation of Object wrappers instead of primitives</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.4</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.name.conflict.resolution" title="2.3.3.10.&nbsp;Automatic class name conflict resolution">org.exolab.castor.builder.automaticConflictResolution</a>
               </td><td align="center">Specifies whether <span class="bold"><strong>automatic class name conflict resolution</strong></span> 
                   should be used or not</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center"><span class="bold"><strong>1.1.1</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.extra.collection" title="2.3.3.11.&nbsp;Extra collection methods">org.exolab.castor.builder.extraCollectionMethods</a>
               </td><td align="center">Specifies whether <span class="bold"><strong>extra</strong></span> (additional) methods should be created for  
                   collection-style fields. Set this to true if you want your code to be
                   more compatible with Castor JDO or other persistence frameworks.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.class.printing" title="2.3.3.12.&nbsp;Class printing">org.exolab.castor.builder.jclassPrinterFactories</a>
               </td><td align="center">Enlists the available modes for (J)Class <span class="italic">printing</span> during
                   XML code generation.</td><td align="center"><code class="literal">org.exolab.castor.builder.printing.WriterJClassPrinterFactory</code>/
                   <code class="literal">org.exolab.castor.builder.printing.TemplateJClassPrinterFactory</code></td><td align="center">n/a</td><td align="center"><span class="bold"><strong>1.2.1</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.extra.documentation" title="2.3.3.13.&nbsp;Extra documentation methods">org.exolab.castor.builder.extraDocumentationMethods</a>
               </td><td align="center">specifying whether extra members/methods for extracting XML schema
                   documentation should be made available.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center"><span class="bold"><strong>1.2</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.process"></a>2.3.2.&nbsp;Customization - Lookup mechanism</h3></div></div></div><p>By default, the Castor XML code generator will look for such a property file 
           in the following places:</p><div class="orderedlist"><ol type="1"><li><p>If no custom property file is specified, the Castor XML code
              generator will use the default builder configuration
              properties at <code class="literal">org/exolab/castor/builder/castorbuilder.properties</code>
              as shipped as part of the XML code generator JAR.</p></li><li><p>If a file named <code class="literal">castorbuilder.properties</code> is available
              on the CLASSPATH, the Castor XML code generator will use each of the
              defined property values to override the default value as defined
              in the default builder configuration properties. This file is commonly 
              referred to as a <span class="bold"><strong>custom</strong></span> builder configuration file.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.detailed"></a>2.3.3.&nbsp;Detailed descriptions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.java50"></a>2.3.3.1.&nbsp;Source generation &amp; Java 5.0</h4></div></div></div><p>
                As of <span class="bold"><strong>Castor 1.0.2</strong></span>, the Castor source generator now supports the
                generation of Java 5.0 compliant code. The generated code - with the
                new feature enabled - will make use of the following Java 5.0-specific
                artifacts:
 
                </p><div class="itemizedlist"><ul type="disc"><li><p>Use of parameterized collections, e.g. ArrayList&lt;String&gt;.</p></li><li><p>Use of @Override annotations with the generated methods
                     that require it.</p></li><li><p>Use of @SupressWarnings with "unused" method parameters
                     on the generated methods that needed it.</p></li><li><p>Added "enum" to the list of reserved keywords.</p></li></ul></div><p>
            </p><p>
                To enable this feature (off by default), please uncomment the
                following property in your custom <code class="filename">castorbuilder.properties</code>
                file:
            </p><pre class="programlisting">
# This property specifies whether the sources generated
# should comply with java 1.4 or 5.0; defaults to 1.4
org.exolab.castor.builder.javaVersion=5.0</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.enumerations"></a>2.3.3.2.&nbsp;SimpleType Enumerations</h4></div></div></div><p>
                In previous versions, castor only supported (un)marshalling of "simple" 
                java5 enums, meaning enums where all facet values are valid java identifiers. 
                In these cases, every enum constant name can be mapped directly to the xml value. 
                See the following example:
            </p><div class="informalexample"><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"AlphabeticalType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"A"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"B"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"C"</span>/&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/xs:simpleType</span>&gt;</pre></div><pre class="programlisting">
<span class="hl-keyword">public</span> enum AlphabeticalType {
    A, B, C
}</pre><pre class="programlisting">
&lt;<span class="hl-tag">root</span>&gt;
  &lt;<span class="hl-tag">AlphabeticalType</span>&gt;A&lt;<span class="hl-tag">/AlphabeticalType</span>&gt;    
&lt;<span class="hl-tag">/root</span>&gt;
    </pre><p>
                So if there is at least ONE facet that cannot be mapped directly to a 
                valid java identifier, we need to extend the enum pattern. Examples for 
                these cases are value="5" or value="-s". Castor now introduces an extended 
                pattern, similar to the jaxb2 enum handling. The actual value of the 
                enumeration facet is stored in a private String property, the name of the 
                enum constant is translated into a valid identifier. Additionally, some 
                convenience methods are introduced, details about these methods are described 
                after the following example:
             </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"CompositeType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span>/&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/xs:simpleType</span>&gt;</pre><pre class="programlisting">
<span class="hl-keyword">public</span> enum CompositeType {
    VALUE_5(<span class="hl-string">"5"</span>),
    VALUE_10(<span class="hl-string">"10"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> java.lang.String value;

    <span class="hl-keyword">private</span> CompositeType(<span class="hl-keyword">final</span> java.lang.String value) {
        <span class="hl-keyword">this</span>.value = value;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> CompositeType fromValue(<span class="hl-keyword">final</span> java.lang.String value) {
        <span class="hl-keyword">for</span> (CompositeType c: CompositeType.values()) {
            <span class="hl-keyword">if</span> (c.value.equals(value)) {
                <span class="hl-keyword">return</span> c;
            }
        }
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(value);
    }

    <span class="hl-keyword">public</span> java.lang.String value() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.value;
    }
    
    <span class="hl-keyword">public</span> java.lang.String toString() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.value;
    }
}</pre><pre class="programlisting">
&lt;<span class="hl-tag">root</span>&gt;
  &lt;<span class="hl-tag">CompositeType</span>&gt;5&lt;<span class="hl-tag">/CompositeType</span>&gt;    
&lt;<span class="hl-tag">/root</span>&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.1"></a>2.3.3.2.1.&nbsp;Unmarshalling of complex enums</h5></div></div></div><p>
                Castor uses the static void <code class="methodname">fromValue(String value)</code>
                method to retrieve the correct instance from the value in the XML 
                input file. In our example, the input is "5", fromValue returns
                <code class="literal">CompositeType.VALUE_5</code>.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.2"></a>2.3.3.2.2.&nbsp;Marshalling of complex enums</h5></div></div></div><p>
                Currently, we have to distinguish between enums with a class 
                descriptor and the ones without. If you are using class descriptors, 
                the EnumerationHandler uses the value() method to write the xml output.
             </p><p>
                If no descriptor classes are available, castor uses per default the 
                <code class="methodname">toString()</code> 
                method to marshall the value. In this case, the override of the 
                <code class="methodname">java.lang.Enum.toString()</code> method is mandatory, because 
                <code class="methodname">java.lang.Enum.toString()</code> returns the NAME of the 
                facet instead of the VALUE. So in our example, <code class="literal">VALUE_10</code>
                would be returned instead of "10". To avoid this, castor expects an 
                implementation of <code class="methodname">toString()</code> that returns 
                <code class="literal">this.value</code>.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.3"></a>2.3.3.2.3.&nbsp;Source Generation of complex enums</h5></div></div></div><p>
                   If the java version is set to "5.0", the new default behavior of 
                   castor is to generate complex java5 enums for simpleType enumerations, 
                   as described above. In java 1.4 mode, nothing has changed and the old 
                   style enumeration classes using a HashMap are created.
                </p><p>
                   Users, who are in java5 mode and still want to use the old style java 
                   1.4 classes, can force this by setting the new 
                   <code class="literal">org.exolab.castor.builder.forceJava4Enums</code> property 
                   to true as follows:
                </p><pre class="programlisting">
 # Forces the code generator to create 'old' Java 1.4 enumeration classes instead 
 # of Java 5 enums for xs:simpleType enumerations, even in Java 5 mode.
 #
 # Possible values:
 # - false (default)
 # - true
org.exolab.castor.builder.forceJava4Enums=false</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.bound.properties"></a>2.3.3.3.&nbsp;Bound Properties</h4></div></div></div><p>
             Bound properties are "properties" of a class, which when
             updated the class will send out a <code class="classname">java.beans.PropertyChangeEvent</code>
             to all registered <code class="classname">java.beans.PropertyChangeListeners</code>.
          </p><p>
             To enable bound properties, please add a property definition
             to your custom builder configuration file as follows:
          </p><pre class="programlisting">
# To enable bound properties uncomment the following line. Please
# note that currently *all* fields will be treated as bound properties
# when enabled. This will change in the future when we introduce
# fine grained control over each class and it's properties.
#
org.exolab.castor.builder.boundproperties=true</pre><p>
             When enabled, <span class="bold"><strong>all</strong></span> properties will be treated as bound properties. For
             each class that is generated a <code class="literal">setPropertyChangeListener</code> method is
             created as follows:
          </p><pre class="programlisting">
<span class="hl-comment">/**
 * Registers a PropertyChangeListener with this class.
 * @param pcl The PropertyChangeListener to register.
 **/</span>

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addPropertyChangeListener (java.beans.PropertyChangeListener pcl)
{
   propertyChangeListeners.addElement(pcl);
} <span class="hl-comment">//-- void addPropertyChangeListener</span></pre><p>
             Whenever a property of the class is changed, a
             <code class="classname">java.beans.PropertyChangeEvent</code> will be sent to
             all registered listeners. The property name, the old value and
             the new value will be set in the 
             <span class="bold"><strong>java.beans.PropertyChangeEvent</strong></span>.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
             To prevent unnecessary overhead, if the property is a collection,
             the old value will be <span class="italic">null</span>.
          </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.class.creation"></a>2.3.3.4.&nbsp;Class Creation/Mapping</h4></div></div></div><p>
               The source generator can treat the XML Schema structures such as 
               <code class="literal">&lt;complexType&gt;</code> and <code class="literal">&lt;element&gt;</code> 
               in two main ways. The first, and current default method is called the
               "element" method. The other is called the "type" method.
            </p><div class="table"><a name="xml.code.generator.properties.detailed.class.creation.table"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Method</th><th align="left">Explanation</th></tr></thead><tbody><tr><td align="center">'element'</td><td align="left">
                       <p>
                           The "element" method creates classes for all elements whose type is a
                           &lt;complexType&gt;. Abstract classes are created for all top-level
                           &lt;complexType&gt;s. Any elements whose type is a top-level type will have
                           a new class create that extends the abstract class which was generated for
                           that top-level complexType.
                        </p>
                        <p>
                           Classes are not created for elements whose type is a &lt;simpleType&gt;.
                        </p>
                   </td></tr><tr><td align="center">'type'</td><td align="left">
                        <p>
                              The "type" method creates classes for all top-level &lt;complexType&gt;s, or
                              elements that contain an "anonymous" (in-lined) &lt;complexType&gt;.
                        </p>
                        <p>
                              Classes will not be generated for elements whose type is a top-level
                              type.
                        </p>
                       </td></tr></tbody></table></div></div><br class="table-break"><p>To change the "method" of class creation, please add the following property
               definition to your custom builder configuration file:</p><pre class="programlisting">
# Java class mapping of &lt;<span class="hl-tag">xsd:element</span>&gt;'s and &lt;<span class="hl-tag">xsd:complexType</span>&gt;'s
#
org.exolab.castor.builder.javaclassmapping=type</pre><p>
				Please note that setting this property will not affect class creation when the 
				<code class="literal">defaultBindingType</code> is explicitely used in a binding file. In that case,
				the value set there will take precedence.  				
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.super.class"></a>2.3.3.5.&nbsp;Setting a super class</h4></div></div></div><p>The source generator enables the user to set a super class to <span class="bold"><strong>all</strong></span> the
               generated classes (of course, class descriptors are not affected
               by this option). Please note that, though the binding file, it is possible
               to define a super class for individual classes</p><p>To set the global super class, please add the following property
               definition to your custom builder configuration file:</p><pre class="programlisting">
# This property allows one to specify the super class of *all*
# generated classes
#
org.exolab.castor.builder.superclass=com.xyz.BaseObject</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.namespace.mapping"></a>2.3.3.6.&nbsp;Mapping XML namespaces to Java packages</h4></div></div></div><p>
                An XML Schema instance is identified by a namespace. For data-binding purposes,
                especially code generation it may be necessary to map namespaces to Java packages.
            </p><p>
                This is needed for imported schema in order for Castor to generate the
                correct imports during code generation for the primary schema.
            </p><p> To allow the mapping between namespaces and Java packages , edit the castorbuilder.properties file :
            </p><pre class="programlisting">
# XML namespace mapping to Java packages
#
#org.exolab.castor.builder.nspackages=\
   http://www.xyz.com/schemas/project=com.xyz.schemas.project,\
   http://www.xyz.com/schemas/person=com.xyz.schemas.person</pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.equals"></a>2.3.3.7.&nbsp;Generate equals()/hashCode() method</h4></div></div></div><p>Since version: 0.9.1</p><p>
                The Source Generator can override the <code class="literal">equals()</code> 
                and <code class="literal">hashCode()</code> method for the generated objects.
            </p><p>
                To have <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods generated, 
                override the following property in your custom 
                castorbuilder.properties file:
            </p><pre class="programlisting">
# Set to true if you want to have an equals() and 
# hashCode() method generated for each generated class;
# false by default
org.exolab.castor.builder.equalsmethod=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.use.cyclebreaker"></a>2.3.3.8.&nbsp;Use CycleBreaker for generation of equals()/hashcode() methods.</h4></div></div></div><p>Since version: 1.3.2</p><p>
                Specifies whether cycle breaker code should be added to generated 
                methods <code class="literal">equals()</code> and <code class="literal">hashcode()</code>.
            </p><pre class="programlisting">
# Property specifying whether cycle breaker code should be added
# to generated methods 'equals' and 'hashcode'. 
#
# Possible values:
# - true (default)
# - false
#
# &lt;<span class="hl-tag">pre</span>&gt;
# org.exolab.castor.builder.useCycleBreaker
# &lt;<span class="hl-tag">/pre</span>&gt;
org.exolab.castor.builder.useCycleBreaker=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.primitive.wrappers"></a>2.3.3.9.&nbsp;Maps java primitive types to wrapper object</h4></div></div></div><p>Since version 0.9.4</p><p>
    It may be convenient to use java objects instead of primitives,
    the Source Generator provides a way to do it. Thus the following mapping can be used:
    </p><div class="itemizedlist"><ul type="disc"><li><p>boolean to java.lang.Boolean</p></li><li><p>byte to java.lang.Byte</p></li><li><p>double to java.lang.Double</p></li><li><p>float to java.lang.Float</p></li><li><p>int and integer to java.lang.Integer</p></li><li><p>long to java.lang.Long</p></li><li><p>short to java.lang.Short</p></li></ul></div><p>
       </p><p>To enable this property, edit the castor builder.properties file:
        </p><pre class="programlisting">
# Set to true if you want to use Object Wrappers instead
# of primitives (e.g Float instead of float).
# false by default.
#org.exolab.castor.builder.primitivetowrapper=false</pre><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.name.conflict.resolution"></a>2.3.3.10.&nbsp;Automatic class name conflict resolution</h4></div></div></div><p>Since version 1.1.1</p><p>With this property enabled, the XML code generator will use 
               a new automatic class name resolution mode that has special
               logic implemented to automatically resolve class name conflicts.</p><p>This new mode deals with various class name conflicts where previously
               a binding file had to be used to resolve these conflicts manually.</p><p>To enable this feature (turned off by default), please add the 
               following property definitio to your custom <code class="literal">castorbuilder.properties</code>
               file:</p><pre class="programlisting">
# Specifies whether automatic class name conflict resolution
# should be used or not; defaults to false.
#
org.exolab.castor.builder.automaticConflictResolution=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.extra.collection"></a>2.3.3.11.&nbsp;Extra collection methods</h4></div></div></div><p>
            Specifies whether <span class="bold"><strong>extra</strong></span> (additional) methods 
            should be created for collection-style fields. Set this to <code class="literal">true</code>
            if you want your code to be more compatible with Castor JDO (or other 
            persistence frameworks in general).
        </p><p>
            By setting this property to <code class="literal">true</code>, additional getter/setter methods 
            for the field in question, such as get/set by reference and set as copy methods, will 
            be added. In order to have these additional methods generated, please override the 
            following code generator property in a custom
            <code class="literal">castorbuilder.properties</code> as shown:
                
            </p><pre class="programlisting">
# Enables generation of extra methods for collection fields, such as get/set by
# reference and set as copy.  Extra methods are in addition to the usual
# collection get/set methods.  Set this to true if you want your code to be
# more compatible  with Castor JDO.
#
# Possible values:
# - false (default) 
# - true
org.exolab.castor.builder.extraCollectionMethods=true
            </pre><p>

        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.class.printing"></a>2.3.3.12.&nbsp;Class printing</h4></div></div></div><p>
            As of release 1.2, Castor supports the use of Velocity-based code templates
            for code generation. For the time being, Castor will support two modes
            for code generation, i.e. the new Velocity-based and an old legacy mode.
            <span class="bold"><strong>Default</strong></span> will be the <span class="italic">legacy</span> mode; this will be changed with a 
            later release of Castor.
        </p><p>
            In order to use the new Velocity-based code generation, please
            call the method <code class="methodname">setJClassPrinterType(String)</code> on 
            <code class="classname">org.exolab.castor.builder.SourceGenerator</code> 
            with a value of <code class="literal">velocity</code>.
        </p><p>
            As we consider the code stable enough for a major release, we do encourage users 
            to use the new Velocity-based mode and to provide us with (valuable) feedback.
        </p><p>
            Please note that we have changed the mechanics of changing the JClass printing
            type between releases 1.2 and 1.2.1.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.extra.documentation"></a>2.3.3.13.&nbsp;Extra documentation methods</h4></div></div></div><p>
            As of release 1.2, the Castor XML code generator - if configured as shown below - now
            supports generation of additional methods to allow programmatic access to 
            &lt;xs:documentation&gt; elements for top-level type/element definitions as
            follows:
            
            </p><pre class="programlisting">
public java.lang.String getXmlSchemaDocumentation(final java.lang.String source);
public java.util.Map getXmlSchemaDocumentations();</pre><p>
        </p><p>
            In order to have these additional methods generated as shown above, 
            please override the following code generator property in a custom 
            <code class="literal">castorbuilder.properties</code> as shown:
                
            </p><pre class="programlisting">
# Property specifying whether extra members/methods for extracting XML schema
# documentation should be made available; defaults to false
org.exolab.castor.builder.extraDocumentationMethods=true</pre><p>

        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.custom.bindings"></a>2.4.&nbsp;Custom bindings</h2></div></div></div><p>
           This section defines the Castor XML binding file and describes - based upon
           the use of examples - how to use it.
         </p><p>
           The default binding used to generate the Java Object Model from an XML
           schema may not meet your expectations. For instance, the default
           binding doesn't deal with naming collisions that can appear because
           XML Schema allows an element declaration and a complexType definition
           to use the same name.  The source generator will attempt to create two
           Java classes with the same qualified name.  However, the latter class
           generated will simply overwrite the first one.
         </p><p>
           Another example of where the default source generator binding may not
           meet your expectations is when you want to change the default datatype
           binding provided by Castor or when you want to add validation rules by
           implementing your own validator and passing it to the Source Generator.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.custom.bindings.file"></a>2.4.1.&nbsp;Binding File</h3></div></div></div><p>
              The binding declaration is an XML-based language that allows the user
              to control and tweak details about source generation for the generated
              classes.  The aim of this section is to provide an overview of the
              binding file and a definition of the several XML components used to
              define this binding file.
            </p><p>
              A more in-depth presentation  will be available soon in the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF).</a>
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.binding"></a>2.4.1.1.&nbsp;&lt;binding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">binding</span>
    <span class="hl-attribute">defaultBindingType</span> = <span class="hl-value">(element|type)</span>&gt;
    (include*,
     package*,
     namingXML?,
     elementBinding*,
     attributeBinding,
     complexTypeBinding,
     groupBinding)
&lt;<span class="hl-tag">/binding</span>&gt;</pre><p>
                    The binding element is the root element and contains the binding
                    information.
                </p><div class="table"><a name="xml.code.generator.custom.binding.element"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Default</th><th align="center">Required ?</th></tr></thead><tbody><tr><td align="center">defaultBindingType</td><td align="center">Controls the <a href="#xml.code.generator.properties.detailed.class.creation" title="2.3.3.4.&nbsp;Class Creation/Mapping">class creation mode</a>
                              for details on the available modes. Please note that the mode 
                              specified in this attribute will override the binding type specified 
                              in the <code class="literal">castorbuilder.properties</code> file.</td><td align="center"><code class="literal">element</code></td><td align="center">No</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.include"></a>2.4.1.2.&nbsp;&lt;include&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">include</span>
    <span class="hl-attribute">URI</span> = <span class="hl-value">xsd:anyURI</span>/&gt;</pre><p>
                    This element allows you to include a binding declaration defined in
                    another file. This allows reuse of binding files defined for various
                    XML schemas.
                </p><div class="variablelist"><p class="title"><b>Attributes of &lt;include&gt;</b></p><dl><dt><span class="term"><span class="bold"><strong>URI:</strong></span></span></dt><dd><p>The URI of the binding file to include.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.package"></a>2.4.1.3.&nbsp;&lt;package&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">package</span>&gt;
    name = xsd:string
    (namespace|schemaLocation) = xsd:string&gt;
&lt;<span class="hl-tag">/package</span>&gt;</pre><div class="table"><a name="d4e2533"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;&lt;package&gt; - Definitions</b></p><div class="table-contents"><table summary="<package&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">A fully qualified java package name.</td></tr><tr><td align="center">namespace</td><td align="left">
                                An XML namespace that will be mapped to the package name defined 
                                by the <span class="italic">name</span> element.
                            </td></tr><tr><td align="center">schemaLocation</td><td align="left">
                                A URL that locates the schema to be mapped to the package name 
                                defined by the <span class="italic">name</span> element.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                    The <code class="literal">targetNamespace</code> attribute of an XML schema 
                    identifies the namespace in which the XML schema elements are defined. This
                    language namespace is defined in the generated Java source as a package 
                    declaration. The <code class="literal">&lt;package/&gt;</code> element allows you to define
                    the mapping between an XML namespace and a Java package.
                </p><p>
                    Moreover, XML schema allows you to factor the definition of an XML
                    schema identified by a unique namespace by including several XML
                    schemas instances to build one XML schema using the
                    <code class="literal">&lt;xsd:include/&gt;</code> element. Please make sure you understand
                    the difference between <code class="literal">&lt;xsd:include/&gt;</code> and
                    <code class="literal">&lt;xsd:import/&gt;</code>. <code class="literal">&lt;xsd:include/&gt;</code> #
                    relies on the URI of the included XML schema. This element allows you to keep the
                    structure hierarchy defined in XML schema in a single generated Java
                    package. Thus the binding file allows you to define the mapping
                    between a <code class="literal">schemaLocation</code> attribute and a Java package.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.namingXML"></a>2.4.1.4.&nbsp;&lt;namingXML&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">namingXML</span>&gt;
   (elementName,complexTypeName,modelGroupName)
&lt;<span class="hl-tag">/namingXML</span>&gt;

&lt;<span class="hl-tag">elementName|complexTypeName|modelGroupName</span>&gt;
    (prefix?, suffix?) = xsd:string
&lt;<span class="hl-tag">/elementName|complexTypeName|modelGroupName</span>&gt;</pre><div class="table"><a name="d4e2566"></a><p class="title"><b>Table&nbsp;2.5.&nbsp;&lt;namingXML&gt; - Definitions</b></p><div class="table-contents"><table summary="<namingXML&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><span class="italic">prefix</span></td><td align="left">The prefix to add to the names of the generated classes.</td></tr><tr><td align="center"><span class="italic">suffix</span></td><td align="left">The suffix to append to the the names of the generated classes.</td></tr></tbody></table></div></div><br class="table-break"><p>
                    One of the aims of the binding file is to avoid naming collisions.
                    Indeed, XML schema allows &lt;element&gt;s and &lt;complexType&gt;s to share the
                    same name, resulting in name collisions when generating sources.
                    Defining a binding for each element and complexType that share the
                    same name is not always a convenient solution (for instance the BPML
                    XML schema and the UDDI v2.0 XML schema use the same names for
                    top-level complexTypes and top-level elements).
                </p><p>
                    The main aim of the <code class="literal">&lt;namingXML/&gt;</code> element is to define 
                    default prefices and suffices for the names of the classes generated for an 
                    &lt;element&gt;, a &lt;complexType&gt; or a model group definition.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                        It is not possible to control the names of the classes
                        generated to represent nested model groups (all, choice,
                        and sequence).
                    </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.componentBinding"></a>2.4.1.5.&nbsp;&lt;componentBinding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding|attributeBinding|complexTypeBinding|groupBinding</span>
    <span class="hl-attribute">name</span> = <span class="hl-value">xsd:string</span>&gt;
   ((java-class|interface|member|contentMember),
     elementBinding*,
     attributeBinding*,
     complexTypeBinding*,
     groupBinding*)
&lt;<span class="hl-tag">/elementBinding|attributeBinding|complexTypeBinding|groupBinding</span>&gt;</pre><div class="table"><a name="d4e2592"></a><p class="title"><b>Table&nbsp;2.6.&nbsp;&lt;componentBinding&gt; - Definitions</b></p><div class="table-contents"><table summary="<componentBinding&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">
                                The name of the XML schema component for which we
                                are defining a binding.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                   These elements are the tenets of the binding file since they contain
                   the binding definition for an XML schema element, attribute,
                   complex type and model group definition. The first child element
                   (<code class="literal">&lt;java-class/&gt;</code>, <code class="literal">&lt;interface&gt;</code>, 
                   <code class="literal">&lt;member&gt;</code> or <code class="literal">&lt;contentMember/&gt;</code>) 
                   will determine the type of binding one is defining. Please note that 
                   defining a <code class="literal">&lt;java-class&gt;</code> binding on an XML schema 
                   attribute will have absolutely no effect.
                 </p><p>
                   The binding file is written from an XML schema point of view; there
                   are two distinct ways to define the XML schema component for which
                   we are defining a binding.
                 </p><div class="orderedlist"><ol type="1"><li><p>(XPath-style) name</p></li><li><p>Embedded definitions</p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2617"></a>2.4.1.5.1.&nbsp;Name</h5></div></div></div><p>  
                      First we can define it through the <code class="literal">name</code> attribute.
                    </p><p>
                      The value of the name attribute uniquely identifies the XML schema
                      component. It can refer to the top-level component using the NCName
                      of that component or it can use a location language based on
                      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath" target="_top">XPath</a>. The
                      grammar of that language can be defined by the following
                      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/Backus-Naur_form" target="_top">BNF</a>:
                    </p><pre class="programlisting">
[1]Path         ::= '/'LocationPath('/'LocationPath)*
[2]LocationPath ::= (Complex|ModelGroup|Attribute|Element|Enumeration)
[3]Complex      ::= 'complexType:'(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>)
[4]ModelGroup   ::= 'group:'<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[5]Attribute    ::= '@'<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[6]Element      ::= <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[7]Enumeration  ::= 'enumType':(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>)
                    </pre><p>
                      Please note that all values for the <code class="literal">name</code> attribute 
                      have to start with a <code class="literal">'/'</code>.
                    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2633"></a>2.4.1.5.2.&nbsp;Embedded definitions</h5></div></div></div><p>
                      The second option to identify an XML schema component is to embed
                      its binding definition inside its parent binding definition.
                    </p><p>
                        Considering below XML schema fragment ...
                    </p><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fooType"</span>&gt;
    &lt;<span class="hl-tag">sequence</span>&gt;
        &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> /&gt;
    &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;</pre><p>
                      the following binding definitions are equivalent and
                      identify the &lt;element&gt; <code class="literal">foo</code> defined in the top-level
                      &lt;complexType&gt; <code class="literal">fooType</code>.
                    </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:fooType/foo&gt;
   &lt;member name="</span><span class="hl-attribute">MyFoo"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mypackage.myHandler"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;

&lt;<span class="hl-tag">complexTypeBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/fooType"</span>&gt;
   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/foo&gt;
      &lt;member name="</span><span class="hl-attribute">MyFoo"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mypackage.myHandler"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;
&lt;<span class="hl-tag">complexTypeBinding</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2642"></a>2.4.1.6.&nbsp;&lt;java-class&gt;</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">java-class</span>
    <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
    <span class="hl-attribute">package?</span> = <span class="hl-value">xsd:string</span>
    <span class="hl-attribute">final?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">abstract?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">equals?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">bound?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">(implements*,extends?)</span>
<span class="hl-attribute">&lt;/java-class&gt;</span></pre><p>
                   This element defines all the options for the class to be generated,
                   including common properties such as class name, package name, and
                   so on.
                 </p><div class="variablelist"><p class="title"><b>Attributes of &lt;java-class&gt;</b></p><dl><dt><span class="term"><span class="bold"><strong>name:</strong></span></span></dt><dd><p>The name of the class that will be generated.</p></dd><dt><span class="term"><span class="bold"><strong>package:</strong></span></span></dt><dd><p>The package of the class to be generated. if set,
              this option overrides the mapping defined in the
              <code class="literal">&lt;package/&gt;</code> element.</p></dd><dt><span class="term"><span class="bold"><strong>final:</strong></span></span></dt><dd><p>If true, the generated class will be final.</p></dd><dt><span class="term"><span class="bold"><strong>abstract:</strong></span></span></dt><dd><p>If true, the generated class will be abstract.</p></dd><dt><span class="term"><span class="bold"><strong>equals:</strong></span></span></dt><dd><p>If true, the generated class will implement the
              <code class="literal">equals()</code> and <code class="literal">hashCode()</code> method.</p></dd><dt><span class="term"><span class="bold"><strong>bound:</strong></span></span></dt><dd><p>If true, the generated class will implement bound
              properties, allowing property change notification.</p></dd></dl></div><p>
                   For instance, the following binding definition instructs the source
                   generator to generate a class <code class="literal">CustomTest</code> for a global
                   element named 'test', replacing the default class name <code class="literal">Test</code>
                   with <code class="literal">CustomTest</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"CustomTest"</span> <span class="hl-attribute">final</span>=<span class="hl-value">"true"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   In addition to the properties listed above, it is possible to define
                   that the class generated will extend a class given and/or implement
                   one or more interfaces.
                 </p><p>
                   For instance, the following binding definition instructs the source
                   generator to generate a class <code class="literal">TestWithInterface</code> that
                   implements the interface <code class="literal">org.castor.sample.SomeInterface</code> in
                   addition to <code class="literal">java.io.Serializable</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TestWithInterface"</span>&gt;
      &lt;<span class="hl-tag">implements</span>&gt;org.castor.sample.SomeInterface&lt;<span class="hl-tag">/implements</span>&gt;
   &lt;<span class="hl-tag">/java-class</span>&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;
                 </pre><p>
                   The subsequent binding definition instructs the source generator to
                   generate a class <code class="literal">TestWithExtendsAndInterface</code> that
                   implements the interface <code class="literal">org.castor.sample.SomeInterface</code> in
                   addition to <code class="literal">java.io.Serializable</code>, and extends from a
                   (probably abstract) base class <code class="literal">SomeAbstractBaseClass</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TestWithExtendsAndInterface"</span>&gt;
      &lt;<span class="hl-tag">extends</span>&gt;org.castor.sample.SomeAbstractBaseClass&lt;<span class="hl-tag">/extends</span>&gt;
      &lt;<span class="hl-tag">implements</span>&gt;org.castor.sample.SomeInterface&lt;<span class="hl-tag">/implements</span>&gt;
   &lt;<span class="hl-tag">/java-class</span>&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;
                 </pre><p>
                   The generated class <code class="literal">SomeAbstractBaseClass</code> will have a class
                   signature as shown below:
                 </p><pre class="programlisting">
...

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TestWithExtendsAndInterface
   <span class="hl-keyword">extends</span> SomeAbstractBaseClass
   <span class="hl-keyword">implements</span> SomeInterface, java.io.Serializable {
   ...
                 </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2705"></a>2.4.1.7.&nbsp;&lt;member&gt; element</h4></div></div></div><pre class="programlisting">
 &lt;<span class="hl-tag">member</span>
  <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">java-type?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">wrapper?</span> = <span class="hl-value">xsd:boolean</span>
  <span class="hl-attribute">handler?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">visibility?</span> = <span class="hl-value">(public|protected|private)</span>
  <span class="hl-attribute">collection?</span> = <span class="hl-value">(array|vector|arraylist|hashtable|collection|odmg|set|map|sortedset)</span>
  <span class="hl-attribute">validator?</span> = <span class="hl-value">xsd:string</span>/&gt;</pre><p>
                   This element represents the binding for class member. It allows the
                   definition of its name and java type as well as a custom implementation of
                   <span class="interface">FieldHandler</span> to help the Marshaling framework in handling that
                   member. Defining a validator is also possible. The names given for
                   the validator and the fieldHandler must be fully qualified.
                 </p><div class="table"><a name="d4e2710"></a><p class="title"><b>Table&nbsp;2.7.&nbsp;&lt;member&gt; - Definitions</b></p><div class="table-contents"><table summary="<member&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">
                                The name of the class member that will be
                                generated.
                            </td></tr><tr><td align="center">java-type</td><td align="left">Fully qualified name of the java type.</td></tr><tr><td align="center">wrapper</td><td align="left">
                                If true, a wrapper object will be generated in
                                case the Java type is a java primitive.
                            </td></tr><tr><td align="center">handler</td><td align="left">
                                Fully qualified name of the custom FieldHandler to
                                use.
                            </td></tr><tr><td align="center">collection</td><td align="left">
                                If the schema component can occur more than
                                once then this attribute allows specifying the collection to use
                                to represent the component in Java.
                            </td></tr><tr><td align="center">validator</td><td align="left">
                                Fully qualified name of the <span class="interface">FieldValidator</span>
                                to use.
                            </td></tr><tr><td align="center">visibility</td><td align="left">
                                A custom visibility of the content class member generated, 
                                with the default being <code class="literal">public</code>.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                    For instance, the following binding definition:
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/root/members"</span>&gt;
   &lt;<span class="hl-tag">member</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"set"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                      instructs the source generator to generate -- within a class
                      <code class="classname">Root</code> -- a Java member named 
                      <code class="literal">members</code> using the
                      collection type <code class="classname">java.util.Set</code> instead of the default
                      <code class="classname">java.util.List</code>:
                 </p><pre class="programlisting">
         <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {
         
            <span class="hl-keyword">private</span> java.util.Set members;
         
            ...
         
         }</pre><p>
                    The following (slightly amended) binding element:
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/root/members"</span>&gt;
   &lt;<span class="hl-tag">member</span> <span class="hl-attribute">name</span>=<span class="hl-value">"memberSet"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"set"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   instructs the source generator to generate -- again within a class
                   <code class="classname">Root</code> -- a Java member named 
                   <code class="literal">memberSet</code> (of the same
                   collection type as in the previous example), overriding the name of
                   the member as specified in the XML schema:
                 </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {

   <span class="hl-keyword">private</span> java.util.Set memberSet;

   ...

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2759"></a>2.4.1.8.&nbsp;&lt;contentMember&gt; element</h4></div></div></div><pre class="programlisting">
          &lt;<span class="hl-tag">contentMember</span>
           <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
           <span class="hl-attribute">visiblity?</span> = <span class="hl-value">(public|protected|private)</span></pre><p>
                   This element represents the binding for <span class="italic">content</span> 
                   class member generated as a result of a mixed mode declaration of a 
                   complex type definition. It allows the definition of its name and 
                   its visibility
                 </p><div class="variablelist"><dl><dt><span class="term"><span class="bold"><strong>name:</strong></span></span></dt><dd><p>The name of the class member that will be
              generated, overriding the default name of
<code class="literal">_content</code>.</p></dd><dt><span class="term"><span class="bold"><strong>visibility:</strong></span></span></dt><dd><p>A custom visibility of the content class member generated, with 
              the default being
<code class="literal">public</code>.</p></dd></dl></div><p>
                   For a complex type definition declared to be <span class="italic">mixed</span>
                   such as follows ...
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RootType"</span> <span class="hl-attribute">mixed</span>=<span class="hl-value">"true"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      ...
   &gt;/sequence&gt;
&gt;/complexType&gt;</pre><p>... the following binding definition ...</p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:RootType"</span>&gt;
   &lt;<span class="hl-tag">contentMember</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customContentMember"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   instructs the source generator to generate -- within a class
                   <code class="classname">RootType</code> -- a Java member named 
                   <code class="literal">customContentMember</code> of type 
                   <code class="classname">java.lang.String</code>:
                 </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RootType {

   <span class="hl-keyword">private</span> java.util.String customContentMember;

   ...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2789"></a>2.4.1.9.&nbsp;&lt;enumBinding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">enumBinding</span>&gt;
   (enumDef)
&lt;<span class="hl-tag">/enumBinding</span>&gt;

&lt;<span class="hl-tag">enumDef</span>&gt;
   (enumClassName = xsd:string, enumMember*)
&lt;<span class="hl-tag">/enumDef</span>&gt;

&lt;<span class="hl-tag">enumMember</span>&gt;
   (name = xsd:string, value = xsd:string)
&lt;<span class="hl-tag">/enumMember</span>&gt;</pre><p>
                      The <code class="literal">&lt;enumBinding&gt;</code> element allows more control on the
                      code generated for type-safe enumerations, which are used to
                      represent an XML Schema <code class="literal">&lt;simpleType&gt;</code> enumeration.
                    </p><p>
                     For instance, given the following XML schema enumeration definition:
                   </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"durationUnitType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">'xs:string'</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'Y'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'M'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'D'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'h'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'m'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'s'</span> /&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/simpleType</span>&gt;</pre><p>
                     the Castor code generator would generate code where the default
                     naming convention used during the generation would overwrite the
                     first constant definition for value '<code class="literal">M</code>' with the one
                     generated for value '<code class="literal">m</code>'.
                   </p><p>
                     The following binding definition defines -- through the means of
                     an <code class="literal">&lt;enumMember&gt;</code> definition for the enumeration
                     value '<code class="literal">M</code>' -- a special binding for this value:
                   </p><pre class="programlisting">
&lt;<span class="hl-tag">enumBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/enumType:durationUnitType"</span>&gt;
  &lt;<span class="hl-tag">enum-def</span>&gt;
    &lt;<span class="hl-tag">enumMember</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;M&lt;<span class="hl-tag">/value</span>&gt;
      &lt;<span class="hl-tag">javaName</span>&gt;CUSTOM_M&lt;<span class="hl-tag">/javaName</span>&gt;
    &lt;<span class="hl-tag">/enumMember</span>&gt;
  &lt;<span class="hl-tag">/enum-def</span>&gt;
&lt;<span class="hl-tag">/enumBinding</span>&gt;</pre><p>
                     and instructs the source generator to generate -- within a class
                     <code class="literal">DurationUnitType</code> -- a constant definition named
                     <code class="literal">CUSTOM_M</code> for the enumeration value <code class="literal">M</code>.
                   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2808"></a>2.4.1.10.&nbsp;Not implemented yet</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2810"></a>2.4.1.10.1.&nbsp;&lt;javadoc&gt;</h5></div></div></div><p>
                           The <code class="literal">&lt;javadoc&gt;</code> element allows one to enter the
                           necessary JavaDoc representing the generated classes or members.
                        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2814"></a>2.4.1.10.2.&nbsp;&lt;interface&gt; element</h5></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">interface</span>&gt;
  name = xsd:string
&lt;<span class="hl-tag">/interface</span>&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>name:</strong></span>The name of the interface to generate.</p></li></ul></div><p>
                           This element specifies the name of the interface to be generated
                           for an XML schema component.
                        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2822"></a>2.4.2.&nbsp;Class generation conflicts</h3></div></div></div><p>As mentioned previously, you use a binding file for two main reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>
                                To customize the Java code generated
                            </p></li><li><p>To avoid class generation conflicts.</p></li></ul></div><p>
                       For the latter case, you'll (often) notice such collisions by looking at 
                       generated Java code that frequently does not compile. Whilst this is relatively
                       easy for small(ish) XML schema(s), this task gets tedious for more elaborate 
                       XML schemas. To ease your life in the context of this 'collision detection', 
                       the Castor XML code generator provides you with a few advanced features. The 
                       following sections cover these features in detail.
                    </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2831"></a>2.4.2.1.&nbsp;Collision reporting</h4></div></div></div><p>
                           During code generation, the Castor XML code generator will run into
                           situations where a class (about to be generated, and as such about to be 
                           written to the file system) will overwrite an already existing class. This,
                           for example, is the case if within one XML schema there's two (local)
                           element definitions within separate complex type definitions with the same
                           name. In such a case, Castor will emit warning messages that inform the
                           user that a class will be overwritten.
                        </p><p>
                           As of release 1.1, the Castor XML code generator supports two 
                           <span class="italic">reporting modes</span> that allow different levels of control in the event 
                           of such collisions, <code class="literal">warnViaConsoleDialog</code> and <code class="literal">informViaLog</code> 
                           mode.
                        </p><div class="table"><a name="???"></a><p class="title"><b>Table&nbsp;2.8.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Mode</th><th align="center">Description</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><code class="literal">warnViaConsoleDialog</code></td><td align="center">Emits warning messages to <code class="literal">stdout</code> and ask the 
                                    users whether to continue.</td><td align="center">0.9</td></tr><tr><td align="center"><code class="literal">informViaLog</code></td><td align="center">Emits warning messages only via the standard logger.</td><td align="center">1.1</td></tr></tbody></table></div></div><br class="table-break"><p>
                           Please select the reporting mode of your choice according to your needs, the 
                           default being <code class="literal">warnViaConsoleDialog</code>. Please note that the
                           <code class="literal">informViaLog</code> reporting mode should be the preferred choice
                           when using the XML code generator in an automated environment.
                        </p><p>
                           In general, the warning messages produced are very useful in assisting
                           you in your creation of the binding file, as shown in below example
                           for the <code class="literal">warnViaConsoleDialog</code> mode:
                        </p><pre class="programlisting">
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
                         </pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2867"></a>2.4.2.1.1.&nbsp;Reporting mode 'warnViaConsoleDialog'</h5></div></div></div><p>
                              As already mentioned, this mode emits warning messages to <code class="literal">stdout</code>, and 
                              asks you whether you want to continue with the code generation or not. This 
                              allows for very fine grained control over the extent of the code generation.
                            </p><p>
                               Please note that there is several <span class="italic">setter</span> methods on the 
                               <code class="classname">org.exolab.castor.builder.SourceGenerator</code> that allow you to fine-tune
                               various settings for this reporting mode. Genuinely, we believe that for 
                               automated code generation through either Ant or Maven, the new <code class="literal">informViaLog</code>
                               is better suited for these needs.
                            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2875"></a>2.4.2.2.&nbsp;Automatic collision resolution</h4></div></div></div><p>
                           As of Castor 1.1.1, support has been added to the Castor XML code generator 
                           for a (nearly) automatic conflict resolution. To enable this new mode,
                           please override the following property in your custom property file
                           as shown below:
                        </p><pre class="programlisting">
 # Specifies whether automatic class name conflict resolution
 # should be used or not; defaults to false.
 #
 org.exolab.castor.builder.automaticConflictResolution=true</pre><p>
                           As a result of enabling automatic conflict resolution, Castor will try
                           to resolve such name collisions automatically, using one of the following 
                           two strategies:
                        </p><div class="table"><a name="???Y?"></a><p class="title"><b>Table&nbsp;2.9.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Since</th><th align="center">Default</th></tr></thead><tbody><tr><td align="center"><code class="literal">xpath</code></td><td align="center">Prepends an XPATH fragment to make the suggested Java name unique.</td><td align="center">1.1.1</td><td align="center">Yes</td></tr><tr><td align="center"><code class="literal">type</code></td><td align="center">Appends type information to the suggested Java name.</td><td align="center">1.1.1</td><td align="center">No</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2906"></a>2.4.2.2.1.&nbsp;Selecting the strategy</h5></div></div></div><p>
                               For selecting one of the two strategies during XML code
                               generation, please see the documentation for the following 
                               code artifacts:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="methodname">setClassNameConflictResolver</code> on <code class="classname">org.exolab.castor.builder.SourceGenerator</code></p></li><li><p><code class="classname">org.exolab.castor.builder.SourceGeneratorMain"</code></p></li><li><p><a href="#xml.code.generator.invocations.anttask" title="2.5.1.&nbsp;Ant task">Ant task definition</a></p></li><li><p><a href="#xml.code.generator.invocations.maven" title="2.5.2.&nbsp;Maven 2 plugin">Maven plugin for Castor XML</a></p></li></ul></div></div><p>
                           In order to explain the <span class="italic">modus operandi</span> of these two modes, please
                           assume two complex type definitions <code class="literal">AType</code> and <code class="literal">BType</code> 
                           in an XML schema, with both of them defining a local element named <code class="literal">c</code>.</p><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"AType"</span>&gt;
    &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"c"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"CType1"</span> /&gt;
    &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;            

&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"BType"</span>&gt;
    &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"c"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"CType2"</span> /&gt;
    &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;</pre><p>
                           Without automatic collision resolution enabled, Castor will create 
                           identically named classes <code class="literal">C.java</code> for both members, and one
                           will overwrite the other. Please note the different types for the
                           two <code class="literal">c</code> element definitions, which requires two class files to be 
                           generated in order not to lose this information.
                        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2932"></a>2.4.2.2.2.&nbsp;'XPATH' strategy</h5></div></div></div><p>
                               This strategy will prepend an XPATH fragment to the default Java name 
                               as derived during code generation, the default name (frequently) being the name 
                               of the XML schema artifact, e.g. the element name of the complex type name. The
                               XPATH fragment being prepended is minimal in the sense that the resulting
                               rooted XPATH is unique for the XML schema artifact being processed.
                            </p><p>
                                With automatic collision resolution enabled and the strategy 'XPATH' 
                                selected, Castor will create the following two classes, simply prepending 
                                the name of the complex type to the default element name:
                            </p><div class="itemizedlist"><ul type="disc"><li><p>ATypeC.java</p></li><li><p>BTypeC.java</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2941"></a>2.4.2.2.3.&nbsp;'TYPE' strategy</h5></div></div></div><p>
                               This strategy will append 'type' information to the default Java name 
                               as derived during code generation, the default name (frequently) being the name 
                               of the XML schema artifact, e.g. the element name of the complex type name.
                            </p><p>
                                With automatic collision resolution enabled and
                                the strategy 'TYPE' selected, Castor will create the following two 
                                classes, simply appending the name of the complex type to the default
                                element name (with a default '<code class="literal">By</code>' inserted):
                            </p><div class="itemizedlist"><ul type="disc"><li><p>CByCType1.java</p></li><li><p>CByCType2.java</p></li></ul></div><p>
                               To override the default '<code class="literal">By</code>' inserted between the default
                               element name and the type information, please override the following 
                               property in your custom property file as shown below:
                            </p><pre class="programlisting">
# Property specifying the 'string' used in type strategy to be inserted 
# between the actual element name and the type name (during automatic class name 
# conflict resolution); defaults to 'By'.
org.exolab.castor.builder.automaticConflictResolutionTypeSuffix=ByBy</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2954"></a>2.4.2.2.4.&nbsp;Conflicts covered</h5></div></div></div><p>
                               The Castor XML code generator, with automatic collision resolution
                               enabled, is capable of resolving the following collisions
                               automatically:
                            </p><div class="itemizedlist"><ul type="disc"><li><p>Name of local element definition same as name of a global element</p></li><li><p>Name of local element definition same as name of another local element definition.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                                  Please note that <span class="italic">collision resolution</span> for a local to local collision
                                  will only take place for the second local element definition encountered (and 
                                  subsequent ones).
                               </p></td></tr></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.invocations"></a>2.5.&nbsp;Invoking the XML code generator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.anttask"></a>2.5.1.&nbsp;Ant task</h3></div></div></div><p>
           An alternative to using the command line as shown in the previous section,
           the Castor Source Generator Ant Task can be used to call the source
           generator for class generation. The only requirement is that the
           castor-&lt;version&gt;-codegen-antask.jar must additionally be on 
           the CLASSPATH.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.source"></a>2.5.1.1.&nbsp;Specifying the source for generation</h4></div></div></div><p>
             As shown in the subsequent table, there's multiple ways of specifying the input
             for the Castor code generator. <span class="bold"><strong>At least one</strong></span> input source
             has to be specified. 
           </p><div class="table"><a name="xml.code.generator.invocations.anttask.source.table"></a><p class="title"><b>Table&nbsp;2.10.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Description</th><th align="center">Required</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><span class="bold"><strong>file</strong></span></td><td align="center">The XML schema, to be used as input for the source code generator.</td><td align="center">No.</td><td align="center"> - </td></tr><tr><td align="center"><span class="bold"><strong>dir</strong></span></td><td align="center">Sets a directory such that all XML schemas in this directory will have 
                      code generated for them.</td><td align="center">No</td><td align="center"> - </td></tr><tr><td align="center"><span class="bold"><strong>schemaURL</strong></span></td><td align="center">URL to an XML schema, to be used as input for the source code generator.</td><td align="center">No.</td><td align="center"><span class="bold"><strong>1.2</strong></span></td></tr></tbody></table></div></div><br class="table-break"><p>
            In addition, a nested <span class="bold"><strong>&lt;fileset&gt;</strong></span> can be specified as the source of input. 
            Please refer to the samples shown below.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.parameters"></a>2.5.1.2.&nbsp;Parameters</h4></div></div></div><p>
          Please find below the complete list of parameters that can be set on the Castor
          source generator to fine-tune the execution behavior.
        </p><div class="table"><a name="xml.code.generator.invocations.anttask.parameters.table"></a><p class="title"><b>Table&nbsp;2.11.&nbsp;Ant task properties</b></p><div class="table-contents"><table summary="Ant task properties" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Description</th><th align="center">Required</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><span class="bold"><strong>package</strong></span></td><td align="center">The default package to be used during source code generation.</td><td align="center">No; if not given, all classes will be placed in the root package.</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>todir</strong></span></td><td align="center">The destination directory to be used during source code generation. In
                      this directory all generated Java classes will be placed.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>bindingfile</strong></span></td><td align="center">A Castor source generator binding file.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>lineseparator</strong></span></td><td align="center">Defines whether to use Unix- or Windows- or Mac-style line separators during source code generation. Possible values are: 'unix', 'win' or 'mac'.</td><td align="center">No; if not set, system property 'line.separator' is used instead.</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>types</strong></span></td><td align="center">Defines what collection types to use (Java 1 vs. Java 2). Possible values: 'vector', 'arraylist' (aka 'j2') or 'odmg'.</td><td align="center">No; if not set, the default collection used will be Java 1 type</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>verbose</strong></span></td><td align="center">Whether to output any logging messages as emitted by the source generator</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>warnings</strong></span></td><td align="center">Whether to suppress any warnings as otherwise emitted by the source generator</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nodesc</strong></span></td><td align="center">If used, instructs the source generator not to generate *Descriptor classes.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>generateMapping</strong></span></td><td align="center">If used, instructs the source generator to (additionally) generate a mapping
                      file.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nomarshal</strong></span></td><td align="center">If specified, instructs the source generator not to create (un)marshalling
                      methods within the Java classes generated.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>caseInsensitive</strong></span></td><td align="center">If used, instructs the source generator to generate code for enumerated type
                      lookup in a case insensitive manner.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>sax1</strong></span></td><td align="center">If used, instructs the source generator to generate SAX-1 compliant code.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>generateImportedSchemas</strong></span></td><td align="center">If used, instructs the source generator to generate code for imported
                      schemas as well.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nameConflictStrategy</strong></span></td><td align="center">If used, sets the name conflict strategy to use during XML code generation; 
                      possible values are '<code class="literal">warnViaConsoleDialog</code>' and 
                      '<code class="literal">informViaLog</code>'.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>properties</strong></span></td><td align="center">Location of file defining a set of properties to be used during source code
                      generation. This overrides the default mechanisms of configuring the source
                      generator through a <code class="literal">castorbuilder.properties</code> (that has to be
                      placed on the CLASSPATH)</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>automaticConflictStrategy</strong></span></td><td align="center">If used, sets the name conflict resolution strategy used during XML 
                      code generation; possible values are '<code class="literal">type</code>' and '<code class="literal">xpath</code>'
                      (default being '<code class="literal">xpath</code>').</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>jClassPrinterType</strong></span></td><td align="center">Sets the mode for printing JClass instances during XML 
                      code generation; possible values are '<code class="literal">standard</code>' and '<code class="literal">velocity</code>'
                      (default being '<code class="literal">standard</code>').</td><td align="center">No</td><td align="center"><span class="bold"><strong>1.2.1</strong></span></td></tr><tr><td align="center"><span class="bold"><strong>generateJdoDescriptors</strong></span></td><td align="center">If used, instructs the source generator to generate JDO class
                      descriptors as well; default is false.</td><td align="center">No</td><td align="center"><span class="bold"><strong>1.3</strong></span></td></tr><tr><td align="center"><span class="bold"><strong>resourceDestination</strong></span></td><td align="center">
                    Sets the destination directory for (generated) resources, 
                    e.g. <code class="literal">.castor.cdr</code> files.
                  </td><td align="center">No</td><td align="center"><span class="bold"><strong>1.3.1</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.examples"></a>2.5.1.3.&nbsp;Examples</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.file"></a>2.5.1.3.1.&nbsp;Using a file</h5></div></div></div><p>
              Below is an example of how to use this task from within an Ant target
              definition named 'castor:gen:src':
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">file</span>=<span class="hl-value">"src/schema/sample.xsd"</span>
                   <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.url"></a>2.5.1.3.2.&nbsp;Using an URL</h5></div></div></div><p>
              Below is the same sample as above, this time using the <span class="bold"><strong>url</strong></span> attribute
              as the source of input instead:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">schemaURL</span>=<span class="hl-value">"http://some.domain/some/path/sample.xsd"</span>
                   <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.fileset"></a>2.5.1.3.3.&nbsp;Using a nested &lt;fileset&gt;</h5></div></div></div><p>
              Below is the same sample as above, this time using the <span class="bold"><strong>url</strong></span> attribute
              as the source of input instead:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> &gt;
       &lt;<span class="hl-tag">fileset</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"${basedir}/src/schema"</span>&gt;
          &lt;<span class="hl-tag">include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"**/*.xsd"</span>/&gt;
       &lt;<span class="hl-tag">/fileset</span>&gt;
    &lt;<span class="hl-tag">/castor-srcgen</span>&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.maven"></a>2.5.2.&nbsp;Maven 2 plugin</h3></div></div></div><p>
              For those of you working with Maven 2 instead of Ant, the Maven 2 plugin for Castor 
              can be used to integrate source code generation from XML schemas with the Castor XML
              code generator as part of the standard Maven build life-cycle. The following sections
              show how to configure the Maven 2 Castor plugin and hwo to instruct Maven 2
              to generate sources from your XML schemas.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.configuration"></a>2.5.2.1.&nbsp;Configuration</h4></div></div></div><p>To be able to start source code generation from XML schema from within Maven, 
                  you will have to configure the Maven 2 Castor plugin as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/plugin</span>&gt;
</pre><p>Above configuration will trigger source generation using the default
                  values as explained at the 
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://mojo.codehaus.org/castor-maven-plugin/howto.html" target="_top">Castor plugin page</a>, 
                  assuming that the XML schema(s) are located at <code class="literal">src/main/castor</code>, and code will 
                  be saved at <code class="literal">target/generated-sources/castor</code>. When generating sources
                  for multiple schemas at the same time, you can put namespace to 
                  package mappings into <code class="literal">src/main/castor/castorbuilder.properties</code>.</p><p>To e.g. change some of these default locations, please add a 
                  &lt;configuration&gt; section to the plugin configuration as 
                  follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">configuration</span>&gt;
      &lt;<span class="hl-tag">schema</span>&gt;src/main/resources/org/exolab/castor/builder/binding/binding.xsd&lt;<span class="hl-tag">/schema</span>&gt;
      &lt;<span class="hl-tag">packaging</span>&gt;org.exolab.castor.builder.binding&lt;<span class="hl-tag">/packaging</span>&gt;
      &lt;<span class="hl-tag">properties</span>&gt;src/main/resources/org/exolab/castor/builder/binding.generation.properties&lt;<span class="hl-tag">/properties</span>&gt;
   &lt;<span class="hl-tag">/configuration</span>&gt;
 &lt;<span class="hl-tag">/plugin</span>&gt;      
</pre><p>
                Details on the available configuration properties can be found 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://mojo.codehaus.org/castor-maven-plugin/generate-mojo.html" target="_top">here</a>.
               </p><p>By default, the Maven Castor plugin has been built and tested against 
                  a particular version of Castor. To switch to a newer version of Castor (not the
                  plugin itself), please use a &lt;dependencies&gt; section as shown below
                  to point the plugin to e.g. a newer version of Castor:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">dependencies</span>&gt;
     &lt;<span class="hl-tag">dependency</span>&gt; 
       &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.castor&lt;<span class="hl-tag">/groupId</span>&gt;
       &lt;<span class="hl-tag">artifactId</span>&gt;castor&lt;<span class="hl-tag">/artifactId</span>&gt;
       &lt;<span class="hl-tag">version</span>&gt;1.3.1-SNAPSHOT&lt;<span class="hl-tag">/version</span>&gt;
     &lt;<span class="hl-tag">/dependency</span>&gt;
   &lt;<span class="hl-tag">/dependencies</span>&gt;
 &lt;<span class="hl-tag">/plugin</span>&gt;      
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.life-cycle"></a>2.5.2.2.&nbsp;Integration into build life-cycle</h4></div></div></div><p>To integrate source code generation from XML schema into your standard
                  build life-cycle, you will have to add an &lt;executions&gt; section 
                  to your standard plugin configuration as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">executions</span>&gt;
      &lt;<span class="hl-tag">execution</span>&gt;
         &lt;<span class="hl-tag">goals</span>&gt;
            &lt;<span class="hl-tag">goal</span>&gt;generate&lt;<span class="hl-tag">/goal</span>&gt;
         &lt;<span class="hl-tag">/goals</span>&gt;
      &lt;<span class="hl-tag">/execution</span>&gt;
   &lt;<span class="hl-tag">/executions</span>&gt;            
&lt;<span class="hl-tag">/plugin</span>&gt;       
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.example"></a>2.5.2.3.&nbsp;Example</h4></div></div></div><p>Below command shows how to instruct Maven (manually) to generate Java sources
                  from the XML schemas as configured above.</p><pre class="programlisting">
&gt; mvn castor:generate</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.cmd"></a>2.5.3.&nbsp;Command line</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.cmd.first.steps"></a>2.5.3.1.&nbsp;First steps</h4></div></div></div><pre class="programlisting">
java org.exolab.castor.builder.SourceGeneratorMain -i foo-schema.xsd \
    -<span class="hl-keyword">package</span> com.xyz
            </pre><p>
              This will generate a set of source files from the the XML Schema
              <code class="literal">foo-schema.xsd</code> and place them in the package
              <code class="literal">com.xyz</code>.
            </p><p>
              To compile the generated classes, simply run <span><strong class="command">javac</strong></span> or your favorite
              compiler:
            </p><pre class="programlisting">
javac com/xyz/*.java</pre><p>
              Created class will have <code class="methodname">marshal</code> and 
              <code class="methodname">unmarshal</code> methods which are used to
              go back and forth between XML and an Object instance.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.cmd.options"></a>2.5.3.2.&nbsp;Source Generator - command line options</h4></div></div></div><p>
              The source code generator has a number of different options which may
              be set. Some of these are done using the command line and others are
              done using a properties file located by default at 
              <code class="filename">org/exolab/castor/builder/castorbuilder.properties</code>.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.cmd.options.source"></a>2.5.3.2.1.&nbsp;Specifying the input source</h5></div></div></div><p>
                   There's more than one way of specifying the input for the Castor code 
                   generator. <span class="bold"><strong>At least one</strong></span> input source must be specified. 
                </p><div class="table"><a name="xml.code.generator.invocations.cmd.options.source.table"></a><p class="title"><b>Table&nbsp;2.12.&nbsp;Input sources</b></p><div class="table-contents"><table summary="Input sources" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Args</th><th align="center">Description</th><th align="center">Version</th></tr></thead><tbody><tr><td align="center">i</td><td align="center"><span class="italic">filename</span></td><td align="center">The input XML Schema file</td><td align="center"> - </td></tr><tr><td align="center">is</td><td align="center"><span class="italic">URL</span></td><td align="center">URL of an XML Schema</td><td align="center"><span class="bold"><strong>1.2 and newer</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.cmd.options.others"></a>2.5.3.2.2.&nbsp;Other command Line Options</h5></div></div></div><div class="table"><a name="xml.code.generator.invocations.cmd.options.others.table"></a><p class="title"><b>Table&nbsp;2.13.&nbsp;Other command line options</b></p><div class="table-contents"><table summary="Other command line options" border="1"><colgroup><col><col><col align="left"><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Arguments</th><th align="left">Description</th><th align="center">Optional?</th></tr></thead><tbody><tr><td align="center"><code class="option">-package</code></td><td align="center">package-name</td><td align="left">The package for the generated source.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-dest</code></td><td align="center">path</td><td align="left">
                    The destination directory in which to create the generated source
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-line-separator</code></td><td align="center">unix | mac | win</td><td align="left">
                    Sets the line separator style for the desired platform. This is
                    useful if you are generating source on one platform, but will
                    be compiling/modifying on another platform.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-types</code></td><td align="center">type-factory</td><td align="left">
                    Sets which type factory to use. This is useful if you want JDK
                    1.2 collections instead of JDK 1.1 or if you want to pass in your
                    own FieldInfoFactory (see <a href="#xml.code.generator.invocations.cmd.options.collection.types" title="2.5.3.2.2.1.&nbsp;Collection Types">Section&nbsp;2.5.3.2.2.1, &#8220;Collection Types&#8221;</a>).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-h</code></td><td align="center">&nbsp;</td><td align="left">Shows the help/usage information.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-f</code></td><td align="center">&nbsp;</td><td align="left">
                    Forces the source generator to suppress all non-fatal errors,
                    such as overwriting pre-existing files.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nodesc</code></td><td align="center">&nbsp;</td><td align="left">Do not generate the class descriptors</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-gen-mapping</code></td><td align="center">&nbsp;</td><td align="left">(Additionally) Generate a mapping file.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nomarshall</code></td><td align="center">&nbsp;</td><td align="left">
                    Do not generate the marshaling framework methods (marshal,
                    unmarshal, validate)</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-testable</code></td><td align="center">&nbsp;</td><td align="left">
                    Generate the extra methods used by the CTF (Castor Testing
                    Framework)
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-sax1</code></td><td align="center">&nbsp;</td><td align="left">
                    Generate marshaling methods that use the SAX1 framework
                    (default is false).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-binding-file</code></td><td align="center">&lt;&lt;binding file name&gt;&gt;.</td><td align="left">
                    Configures the use of a Binding File to allow finely-grained
                    control of the generated classes
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-generateImportedSchemas</code></td><td align="center">&nbsp;</td><td align="left">
                    Generates sources for imported XML Schemas in addition to the
                    schema provided on the command line (default is false).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-case-insensitive</code></td><td align="center">&nbsp;</td><td align="left">
                    The generated classes will use a case insensitive method for
                    looking up enumerated type values.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-verbose</code></td><td align="center">&nbsp;</td><td align="left">Enables extra diagnostic output from the source generator</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nameConflictStrategy</code></td><td align="center">&lt;&lt;conflict strategy name&gt;&gt;</td><td align="left">Sets the name conflict strategy to use during XML code generation</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-fail</code></td><td align="center">&nbsp;</td><td align="left">
                    Instructs the source generator to fail on the first error. When
                    you are trying to figure out what is failing during source
                    generation, this option will help.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-classPrinter</code></td><td align="center">&lt;&lt;JClass printing mode&gt;&gt;.</td><td align="left">Specifies the JClass printing mode to use during XML code generation; possible
                      values are<code class="literal">standard</code> (default) and <code class="literal">velocity</code>; if no value
                      is specified, the default mode is <code class="literal">standard</code>.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-gen-jdo-desc</code></td><td align="center">&nbsp;</td><td align="left">(Additionally) generate JDO class descriptors.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-resourcesDestination</code></td><td align="center">&lt;destination&gt;</td><td align="left">An (optional) destination for (generated) resources</td><td align="center">Optional</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="xml.code.generator.invocations.cmd.options.collection.types"></a>2.5.3.2.2.1.&nbsp;Collection Types</h6></div></div></div><p>
                  The source code generator has the ability to use the following
                  types of collections when generating source code, using the 
                  <code class="option">-type</code> option:
                </p><div class="table"><a name="xml.code.generator.invocations.cmd.options.collection.types.table"></a><p class="title"><b>Table&nbsp;2.14.&nbsp;Collection types</b></p><div class="table-contents"><table summary="Collection types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Option value</th><th align="center">Type</th><th align="center">Default</th></tr></thead><tbody><tr><td align="center"><code class="option">-types j1</code></td><td align="center">Java 1.1</td><td align="center"><code class="classname">java.util.Vector</code></td></tr><tr><td align="center"><code class="option">-type j2</code></td><td align="center">Java 1.2</td><td align="center"><code class="classname">java.util.Collection</code></td></tr><tr><td align="center"><code class="option">-types odmg</code></td><td align="center">ODMG 3.0</td><td align="center"><code class="classname">odmg.DArray</code></td></tr></tbody></table></div></div><br class="table-break"><p>
                        The Java class name shown in above table indicates the default 
                        collection type that will be emitted during generation.
                    </p><p>
                     You can also write your own FieldInfoFactory to handle specific
                     collection types. All you have to do is to pass in the fully
                     qualified name of that FieldInfoFactory as follows:
                   </p><pre class="programlisting">-types com.personal.MyCoolFactory</pre></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
              For additional information about the Source Generator and its options,
              you can download the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF)</a>. Please note that the use of a
              binding file is not dicussed in that document.
            </td></tr></table></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.schema.support"></a>2.6.&nbsp;XML schema support</h2></div></div></div><p>
           Castor XML supports the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xmlschema-1/" target="_top">W3C
           XML Schema 1.0 Second Edition Recommendation document (10/28/2004)</a>
           The Schema Object Model (located in the package
           <span class="package">org.exolab.castor.xml.schema</span>)
           provides an in-memory representation of a given XML schema whereas the
           XML code generator provides a binding
           between XML schema data types and structures into the corresponding ones
           in Java.
        </p><p>
           The Castor Schema Object Model can read
           (<span class="package">org.exolab.castor.xml.schema.reader</span>)
           and write
           (<span class="package">org.exolab.castor.xml.schema.writer</span>)
           an XML Schema as defined by the W3C recommandation. It allows you to
           create and manipulate an in-memory view of an XML Schema.
        </p><p>
           The Castor Schema Object Model supports the W3C XML Schema
           recommendation with no limitation. However the Source Generator does
           currently not offer a one to one mapping from an XML Schema component
           to a Java component for every XML Schema components; some limitations
           exist. The aim of the following sections is to provide a list of
           supported features in the Source Generator. Please keep in mind that
           the Castor Schema Object Model again can handle any XML Schema without
           limitations.
        </p><p>
           Some Schema types do not have a corresponding type in Java.  Thus the
           Source Generator uses Castor implementation of these specific types
           (located in the <span class="package">org.exolab.castor.types</span> package).
           For instance the <code class="literal">duration</code> type is implemented directly in
           Castor. Remember that the representation of XML Schema datatypes does
           not try to fit the W3C XML Schema specifications exactly. The aim is to
           map an XML Schema type to the Java type that is the best fit to the XML
           Schema type.
        </p><p>
           You will find next a list of the supported XML Schema data types and
           structures in the Source Code Generator. For a more detailed support of
           XML Schema structure and more information on the Schema Object Model,
           please refer to  
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
           User Document (PDF).</a>
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3438"></a>2.6.1.&nbsp;Supported XML Schema Built-in Datatypes</h3></div></div></div><p>
              The following is a list of the supported datatypes with the
              corresponding facets and the Java mapping type.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.datatypes.built-in.primitive"></a>2.6.1.1.&nbsp;Primitive Datatypes</h4></div></div></div><div class="table"><a name="xml.code.generator.schema.support.datatypes.built-in.primitive.table"></a><p class="title"><b>Table&nbsp;2.15.&nbsp;Supported primitive data types</b></p><div class="table-contents"><table summary="Supported primitive data types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">XML Schema Type</th><th align="center">Supported Facets</th><th align="center">Java mapping type</th></tr></thead><tbody><tr><td align="center">anyURI</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">base64Binary</td><td align="center">&nbsp;</td><td align="center"><code class="classname">byte[]</code></td></tr><tr><td align="center">boolean</td><td align="center">pattern</td><td align="center">
                       <code class="literal">boolean</code> or <code class="classname">java.lang.Boolean</code><sup>[<a name="footnote.primitive.types" href="#ftn.footnote.primitive.types">a</a>]</sup>
                     </td></tr><tr><td align="center">date</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a name="footnote.types.primitive.1" href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Date</code></td></tr><tr><td align="center">dateTime</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.util.Date</code></td></tr><tr><td align="center">decimal</td><td align="center">
                       totalDigits, fractionDigits, pattern, whiteSpace, enumeration, maxInclusive, 
                       maxExclusive, minInclusive, minExclusive, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.math.BigDecimal</code></td></tr><tr><td align="center">double</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center">
                       <code class="classname">double</code> or <code class="classname">java.lang.Double</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">duration</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Duration</code></td></tr><tr><td align="center">float</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center">
                       <code class="classname">float</code> or <code class="classname">java.lang.Float</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">gDay</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GDay</code></td></tr><tr><td align="center">gMonth</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GMonth</code></td></tr><tr><td align="center">gMonthDay</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GMonthDay</code></td></tr><tr><td align="center">gYear</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GYear</code></td></tr><tr><td align="center">gYearMonth</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GYearMonth</code></td></tr><tr><td align="center">hexBinary</td><td align="center">&nbsp;</td><td align="center"><code class="classname">byte[]</code></td></tr><tr><td align="center">QName</td><td align="center">length, minLength, maxLength, pattern, enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">string</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">time</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Time</code></td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a name="ftn.footnote.primitive.types" href="#footnote.primitive.types">a</a>] </sup>For the various numerical types, the
                default behavior is to generate primitive types.  However, if the
                use of wrappers is enabled by the following line in the
                <code class="literal">castorbuilder.properties</code> file:
                <code class="code">org.exolab.castor.builder.primitivetowrapper=true</code> then
                the <code class="literal">java.lang.*</code> wrapper objects (as specified above) will be
                used instead.
                       </p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive.1" href="#footnote.types.primitive.1">b</a>] </sup>
                             For the date/time and numeric types, the only supported value for whitespace 
                             is "collapse".
                         </p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.datatypes.built-in.derived"></a>2.6.1.2.&nbsp;Derived Datatypes</h4></div></div></div><div class="table"><a name="xml.code.generator.schema.support.datatypes.built-in.derived.table"></a><p class="title"><b>Table&nbsp;2.16.&nbsp;Supported derived data types</b></p><div class="table-contents"><table summary="Supported derived data types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Type</th><th align="center">Supported Facets</th><th align="center">Java mapping type</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">totalDigits, fractionDigits<sup>[<a name="footnote.types.derived.4" href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, 
                            minExclusive, whitespace<sup>[<a name="footnote.types.derived.1" href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">byte</code>/<code class="classname">java.lang.Byte</code>
                       <sup>[<a name="footnote.types.primitive" href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">ENTITY</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">ENTITIES</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">ID</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">IDREF</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.lang.Object</code></td></tr><tr><td align="center">IDREFS</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.util.Vector</code> of <code class="classname">java.lang.Object</code></td></tr><tr><td align="center">int</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">int</code>/<code class="classname">java.lang.Integer</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">integer</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">language</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center">
                       treated as a <code class="literal">xsd:string</code><sup>[<a name="footnote.types.primitive.3" href="#ftn.footnote.types.primitive.3">d</a>]</sup>
                     </td></tr><tr><td align="center">long</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">Name</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">NCName</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">negativeInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn."></a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">NMTOKEN</td><td align="center">enumeration, length, maxlength, minlength</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">NMTOKENS</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.util.Vector</code> of <code class="classname">java.lang.String</code></td></tr><tr><td align="center">NOTATION</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">nonNegativeInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">nonPositiveInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">normalizedString</td><td align="center">enumeration, length, minLength, maxLength, pattern</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">positiveInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">short</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="literal">short</code>/<code class="literal">java.lang.Short</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">token</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center">
                       treated as a <code class="literal">xsd:string</code><sup>[<a href="#ftn.footnote.types.primitive.3">d</a>]</sup>,
                     </td></tr><tr><td align="center">unsignedByte</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       maxExclusive, minExclusive, maxInclusive, minInclusive, pattern, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">short</code>/<code class="classname">java.lang.Short</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">unsignedInt</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       maxExclusive, minExclusive, maxInclusive, minInclusive, pattern,
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">unsignedLong</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.math.BigInteger</code></td></tr><tr><td align="center">unsignedShort</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">int</code> or <code class="classname">java.lang.Integer</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a name="ftn.footnote.types.derived.4" href="#footnote.types.derived.4">a</a>] </sup>For 
                            the integral types, the only allowed value for fractionDigits is 0.</p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.derived.1" href="#footnote.types.derived.1">b</a>] </sup>
                               For the date/time and numeric types, the only supported value for whitespace 
                               is "collapse".
                            </p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive" href="#footnote.types.primitive">c</a>] </sup>For the various numerical types, the
                default behavior is to generate primitive types.  However, if the
                use of wrappers is enabled by the following line in the
                <code class="literal">castorbuilder.properties</code> file:
                <code class="code">org.exolab.castor.builder.primitivetowrapper=true</code> then
                the <code class="literal">java.lang.*</code> wrapper objects (as specified above) will be
                generated instead.</p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive.3" href="#footnote.types.primitive.3">d</a>] </sup>
                          Currently, <code class="literal">&lt;xsd:language&gt;</code> and 
                          <code class="literal">&lt;xsd:token&gt;</code> are treated as if they 
                          were <code class="literal">&lt;xsd:string&gt;</code>.
                      </p></div></td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.schema.support.structures"></a>2.6.2.&nbsp;Supported XML Schema Structures</h3></div></div></div><p>
              Supporting XML schema structures is a constant work. The main
              structures are already supported with some limitations. The
              following will give you a rough list of the supported structures. For a
              more detailed support of XML Schema structure in the Source Generator or
              in the Schema Object Model, please refer to
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF)</a>.
            </p><p>Supported schema components:</p><div class="itemizedlist"><ul type="disc"><li><p>Attribute declaration (<code class="literal">&lt;attribute&gt;</code>)</p></li><li><p>Element declaration (<code class="literal">&lt;element&gt;</code>)</p></li><li><p>Complex type definition (<code class="literal">&lt;complexType&gt;</code>)</p></li><li><p>Attribute group definition (<code class="literal">&lt;attributeGroup&gt;</code>)</p></li><li><p>Model group definition (<code class="literal">&lt;group&gt;</code>)</p></li><li><p>Model group (<code class="literal">&lt;all&gt;</code>, <code class="literal">&lt;choice&gt;</code> and <code class="literal">&lt;sequence&gt;</code>)</p></li><li><p>Annotation (<code class="literal">&lt;annotation&gt;</code>)</p></li><li><p>Wildcard (<code class="literal">&lt;any&gt;</code>)</p></li><li><p>Simple type definition (<code class="literal">&lt;simpleType&gt;</code>)</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.structures.groups"></a>2.6.2.1.&nbsp;Groups</h4></div></div></div><p>
                Grouping support covers both <span class="bold"><strong>model group definitions</strong></span>
                (<code class="literal">&lt;group&gt;</code>) and <span class="bold"><strong>model groups</strong></span> 
                (<code class="literal">&lt;all&gt;</code>, <code class="literal">&lt;choice&gt;</code> and  
                <code class="literal">&lt;sequence&gt;</code>). In this section
                we will label as a 'nested group' any model group whose first parent
                is another model group.
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                  For each top-level model group definition, a class is generated
                  either when using the 'element' mapping property or the 'type' one.
                </p></li><li><p>
                  If a group -- nested or not -- appears to have <code class="literal">maxOccurs &gt; 1</code> 
                  , then a class is generated to represent the items contained in the group.
                </p></li><li><p>
                  For each nested group, a class is generated. The name of the
                  generated class will follow this naming convention:
                  <code class="literal">Name,Compositor+,Counter?</code> where
                  </p><div class="itemizedlist"><ul type="circle"><li><p>
                      'Name' is name of the top-level component (element, complexType or group).
                    </p></li><li><p>
                      'Compositor' is the compositor of the nested group.  For
                      instance, if a 'choice' is nested inside a sequence, the value
                      of Compositor will be <code class="literal">SequenceChoice</code> ('Sequence'+'Choice').
                      Note: if the 'choice' is inside a Model Group and that Model
                      Group <span class="bold"><strong>parent</strong></span> is a Model Group Definition or a
                      complexType then the value of'Compositor' will be only 'Choice'.
                    </p></li><li><p>'Counter' is a number that prevents naming collision.</p></li></ul></div><p>
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.structures.wildcard"></a>2.6.2.2.&nbsp;Wildcard</h4></div></div></div><p>
                    <code class="literal">&lt;any&gt;</code> is supported and will be mapped to an 
                    <code class="classname">AnyNode</code> instance. However, full namespace 
                    validation is not yet implemented, even though an <code class="classname">AnyNode</code>
                    structure is fully namespace aware.
                </p><p>
                   <code class="literal">&lt;anyAttribute&gt;</code> is currently not supported. It is a
                   work in progress.
                </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.examples"></a>2.7.&nbsp;Examples</h2></div></div></div><p>
             In this section we illustrate the use of the XML code generator by 
             discussing the classes generated from given XML schemas. The XML code 
             generator is going to be used with the &#8220;java class mapping&#8221; property 
             set to <span class="italic">element</span> (default value).
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.examples.invoice.schema"></a>2.7.1.&nbsp;The invoice XML schema</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.file"></a>2.7.1.1.&nbsp;The schema file</h4></div></div></div><p>The input file is the schema file given with the XML code generator 
               example in the distribution of Castor 
               (under /src/examples/SourceGenerator/invoice.xsd).</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">xsd:schema</span> <span class="hl-attribute">xmlns:xsd</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://castor.exolab.org/Test/Invoice"</span>&gt;

    &lt;<span class="hl-tag">xsd:annotation</span>&gt;
        &lt;<span class="hl-tag">xsd:documentation</span>&gt;
            This is a test XML Schema for Castor XML.
        &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
    &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

    &lt;<span class="hl-comment">!--
        A simple representation of an invoice. This is simply an example
        and not meant to be an exact or even complete representation of an invoice.
    --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"invoice"</span>&gt;
        &lt;<span class="hl-tag">xsd:annotation</span>&gt;
            &lt;<span class="hl-tag">xsd:documentation</span>&gt;
                A simple representation of an invoice
            &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
        &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ship-to"</span>&gt;
                    &lt;<span class="hl-tag">xsd:complexType</span>&gt;
                        &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customer"</span> /&gt;
                    &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
                &lt;<span class="hl-tag">/xsd:element</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"item"</span>
                    <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-method"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-date"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Description of a customer --</span>&gt;
    &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customer"</span>&gt;
        &lt;<span class="hl-tag">xsd:sequence</span>&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"address"</span> /&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"phone"</span>
                <span class="hl-attribute">type</span>=<span class="hl-value">"TelephoneNumberType"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
    &lt;<span class="hl-tag">/xsd:group</span>&gt;

    &lt;<span class="hl-comment">!-- Description of an item --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Quantity"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:integer"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"PriceType"</span>
                    <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
            &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"ItemAttributes"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Shipping Method --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"shipping-method"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"carrier"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"option"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"estimated-delivery"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:duration"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Shipping date --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"shipping-date"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:date"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:time"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- A simple U.S. based Address structure --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"address"</span>&gt;
        &lt;<span class="hl-tag">xsd:annotation</span>&gt;
            &lt;<span class="hl-tag">xsd:documentation</span>&gt;
                Represents a U.S. Address
            &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
        &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-comment">!-- street address 1 --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"street1"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-comment">!-- optional street address 2 --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"street2"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"0"</span> /&gt;
                &lt;<span class="hl-comment">!-- city--</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"city"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-comment">!-- state code --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"state"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"stateCodeType"</span> /&gt;
                &lt;<span class="hl-comment">!-- zip-code --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"zip-code"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- A U.S. Zip Code --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"zip-code"</span>&gt;
        &lt;<span class="hl-tag">xsd:simpleType</span>&gt;
            &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
                &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[0-9]{5}(-[0-9]{4})?"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
        &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- State Code
        obviously not a valid state code....but this is just
        an example and I don't feel like creating all the valid
        ones.
    --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"stateCodeType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
            &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[A-Z]{2}"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- Telephone Number --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TelephoneNumberType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
            &lt;<span class="hl-tag">xsd:length</span> <span class="hl-attribute">value</span>=<span class="hl-value">"12"</span> /&gt;
            &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[0-9]{3}-[0-9]{3}-[0-9]{4}"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- Cool price type --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PriceType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:decimal"</span>&gt;
            &lt;<span class="hl-tag">xsd:fractionDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
            &lt;<span class="hl-tag">xsd:totalDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span> /&gt;
            &lt;<span class="hl-tag">xsd:minInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span> /&gt;
            &lt;<span class="hl-tag">xsd:maxInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- The attributes for an Item --</span>&gt;
    &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ItemAttributes"</span>&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:ID"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span>
            <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InStock"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:boolean"</span>
            <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span> /&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Category"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span>
            <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
    &lt;<span class="hl-tag">/xsd:attributeGroup</span>&gt;
&lt;<span class="hl-tag">/xsd:schema</span>&gt;</pre><p>The structure of this schema is simple: it is composed of a
            top-level element which is a complexType with references to
            other elements inside. This schema represents a simple
            invoice: an invoice is a customer (<code class="literal">customer</code> top-level
            group), an article (<code class="literal">item</code> element), a shipping method
            (<code class="literal">shipping-method</code> element) and a shipping date
            (<code class="literal">shipping-date</code> element). Notice that the <code class="literal">ship-to</code> element
            uses a reference to an <code class="literal">address</code> element. This <code class="literal">address</code>
            element is a top-level element that contains a reference to
            a non-top-level element (the <code class="literal">zip-cod</code> element). At the end
            of the schema we have two simpleTypes for representing a
            telephone number and a price. The Source Generator is used
            with the <code class="literal">element</code> property set for class creation
            so a class is going to be generated for all top-level elements. No classes 
            are going to be generated for complexTypes and simpleTypes since the
            simpleType is not an enumeration.</p><p>To summarize, we can expect 7 classes : <code class="literal">Invoice</code>, <code class="literal">Customer</code>, 
            <code class="literal">Address</code>, <code class="literal">Item</code>, <code class="literal">ShipTo</code>, <code class="literal">ShippingMethod</code> 
            and <code class="literal">ShippingDate</code> and the 7 corresponding class descriptors. Note 
            that a class is generated for the top-level group <code class="literal">customer</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.running"></a>2.7.1.2.&nbsp;Running the XML code generator</h4></div></div></div><p>To run the source generator and create the source from the 
            <code class="literal">invoice.xsd</code> file in a package <code class="literal">test</code>, we just call 
            in the command line:</p><pre class="programlisting">
java -cp %CP% org.exolab.castor.builder.SourceGeneratorMain -i invoice.xsd -package test</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.generated"></a>2.7.1.3.&nbsp;The generated code</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.generated.item"></a>2.7.1.3.1.&nbsp;The Item.java class</h5></div></div></div><p>To simplify this example we now focus on the <code class="literal">item</code> element.</p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Description of an item --</span>&gt;
&lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span>&gt;
  &lt;<span class="hl-tag">xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">xsd:sequence</span>&gt;
      &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Quantity"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:integer"</span>
                   <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
      &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"PriceType"</span>
                   <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
    &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
    &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"ItemAttributes"</span> /&gt;
  &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
&lt;<span class="hl-tag">/xsd:element</span>&gt;

&lt;<span class="hl-comment">!-- Cool price type --</span>&gt;
&lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PriceType"</span>&gt;
  &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:decimal"</span>&gt;
    &lt;<span class="hl-tag">xsd:fractionDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
    &lt;<span class="hl-tag">xsd:totalDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span> /&gt;
    &lt;<span class="hl-tag">xsd:minInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span> /&gt;
    &lt;<span class="hl-tag">xsd:maxInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span> /&gt;
  &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
&lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

&lt;<span class="hl-comment">!-- The attributes for an Item --</span>&gt;
&lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ItemAttributes"</span>&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:ID"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InStock"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:boolean"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span> /&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Category"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
&lt;<span class="hl-tag">/xsd:attributeGroup</span>&gt;</pre><p>To represent an <code class="literal">Item</code> object, we need to know its <code class="literal">Id</code>, the
            <code class="literal">Quantity</code> ordered and the <code class="literal">Price</code> for one item. So we can
            expect to find a least three private variables: a string for
            the <code class="literal">Id</code> element, an <code class="literal">int</code> for the <code class="literal">quantity</code> element (see the
            section on XML Schema support if you want to see the mapping
            between a W3C XML Schema type and a java type), but what type
            for the <code class="literal">Price</code> element?</p><p>While processing the <code class="literal">Price</code>
            element, Castor is going to process the type of <code class="literal">Price</code> i.e.
            the simpleType <code class="literal">PriceType</code> which base is <code class="literal">decimal</code>. Since
            derived types are automatically mapped to parent types and
            W3C XML Schema <code class="literal">decimal</code> type is mapped to a
            <code class="literal">java.math.BigDecimal</code>, the price element will be a
            <code class="literal">java.math.BigDecimal</code>. Another private variable is created
            for <code class="literal">quantity</code>: quantity is mapped to a primitive java type,
            so a boolean <code class="literal">has_quantity</code> is created for monitoring the
            state of the quantity variable. The rest of the code is the
            <span class="italic">getter/setter</span> methods and the Marshalling framework
            specific methods. Please find below the complete <code class="literal">Item</code> class
            (with Javadoc comments stripped off): </p><pre class="programlisting">
<span class="hl-comment">/** 
 * This class was automatically generated with 
 * Castor 1.0.4,
 * using an XML Schema.
 */</span>

<span class="hl-keyword">package</span> test;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item <span class="hl-keyword">implements</span> java.io.Serializable {

   <span class="hl-comment">//--------------------------/ </span>
   <span class="hl-comment">//- Class/Member Variables -/</span>
   <span class="hl-comment">//--------------------------/</span>

   <span class="hl-keyword">private</span> java.lang.String _id; 

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _quantity;

   <span class="hl-comment">/** 
    * keeps track of state for field: _quantity 
    */</span> 
   <span class="hl-keyword">private</span> <span class="hl-keyword">boolean</span> _has_quantity;

   <span class="hl-keyword">private</span> java.math.BigDecimal _price;

   <span class="hl-comment">//----------------/ </span>
   <span class="hl-comment">//- Constructors -/ </span>
   <span class="hl-comment">//----------------/</span>

   <span class="hl-keyword">public</span> Item() { 
      <span class="hl-keyword">super</span>(); 
   } <span class="hl-comment">//-- test.Item()</span>


   <span class="hl-comment">//-----------/ </span>
   <span class="hl-comment">//- Methods -/ </span>
   <span class="hl-comment">//-----------/</span>

   <span class="hl-keyword">public</span> java.lang.String getId() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._id; $
   } <span class="hl-comment">//-- java.lang.String getId()</span>

   <span class="hl-keyword">public</span> java.math.BigDecimal getPrice() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._price;
   } <span class="hl-comment">//-- java.math.BigDecimal getPrice()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getQuantity() {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._quantity;
   } <span class="hl-comment">//-- int getQuantity()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> hasQuantity() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._has_quantity;
   } <span class="hl-comment">//-- boolean hasQuantity()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isValid() {
      <span class="hl-keyword">try</span> { 
         validate();
      } <span class="hl-keyword">catch</span> (org.exolab.castor.xml.ValidationException vex) { 
         <span class="hl-keyword">return</span> false;
      }
      <span class="hl-keyword">return</span> true;
   } <span class="hl-comment">//-- boolean isValid()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> marshal(java.io.Writer out) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException,org.exolab.castor.xml.ValidationException {
      Marshaller.marshal(<span class="hl-keyword">this</span>, out);
   } <span class="hl-comment">//-- void marshal(java.io.Writer)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> marshal(org.xml.sax.DocumentHandler handler) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
      Marshaller.marshal(<span class="hl-keyword">this</span>, handler);
   } <span class="hl-comment">//-- void marshal(org.xml.sax.DocumentHandler)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(java.lang.String _id) {
      <span class="hl-keyword">this</span>._id = _id;
   } <span class="hl-comment">//-- void setId(java.lang.String)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice(java.math.BigDecimal _price) {
      <span class="hl-keyword">this</span>._price = _price;
   } <span class="hl-comment">//-- void setPrice(java.math.BigDecimal)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setQuantity(<span class="hl-keyword">int</span> _quantity) {
      <span class="hl-keyword">this</span>._quantity = _quantity;
      <span class="hl-keyword">this</span>._has_quantity = true;
   } <span class="hl-comment">//-- void setQuantity(int)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> test.Item unmarshal(java.io.Reader reader) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException,org.exolab.castor.xml.ValidationException {
      <span class="hl-keyword">return</span> (test.Item) Unmarshaller.unmarshal(test.Item.<span class="hl-keyword">class</span>, reader);
   } <span class="hl-comment">//-- test.Item unmarshal(java.io.Reader)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate() 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.ValidationException {
      org.exolab.castor.xml.Validator.validate(<span class="hl-keyword">this</span>, null);
   } <span class="hl-comment">//-- void validate()</span>

}
</pre><p>The ItemDescriptor class is a bit more complex. This class
            is containing inner classes which are the XML field
            descriptors for the different components of an &#8216;Item&#8217;
            element i.e. id, quantity and price.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.pricyType"></a>2.7.1.3.2.&nbsp;The PriceType.java class</h5></div></div></div><p>TODO ...</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.invoice"></a>2.7.1.3.3.&nbsp;The Invoice.java class</h5></div></div></div><p>In this section, we focus on the 'invoice' element as
                   shown again below:</p><pre class="programlisting">
&lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"invoice"</span>&gt;
   &lt;<span class="hl-tag">xsd:complexType</span>&gt;
      &lt;<span class="hl-tag">xsd:sequence</span>&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ship-to"</span>&gt;
            &lt;<span class="hl-tag">xsd:complexType</span>&gt;
               &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customer"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
         &lt;<span class="hl-tag">/xsd:element</span>&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"item"</span>    <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-method"</span> /&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-date"</span> /&gt;
      &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
   &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
&lt;<span class="hl-tag">/xsd:element</span>&gt;</pre><p>Amongst other things, an <code class="literal">&lt;invoice&gt;</code> is made up of at least
                   one, but potentially many <code class="literal">&lt;item&gt;</code> elements. The Castor XML code
                   generator creates a Java collection named 'itemList' for this
                   unbounded element declaration, of type <code class="literal">java.util.List</code>
                   if the scode generator is used with the '<code class="literal">arraylist</code>'
                   field factory.</p><pre class="programlisting">
    <span class="hl-keyword">private</span> java.util.List _itemList;</pre><p>If the '<code class="literal">j1</code>' field factory is used, this will be replaced 
                   with ...</p><pre class="programlisting">
    <span class="hl-keyword">private</span> java.util.Vector _itemList;</pre><p>The complete class as generated (with irrelevant code
                   parts removed) in '<code class="literal">j2</code>' (aka '<code class="literal">arraylist</code>') 
                   mode is shown below:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Invoice <span class="hl-keyword">implements</span> java.io.Serializable {


    ...
    
    <span class="hl-keyword">private</span> java.util.List _itemList;
    
    ...

    <span class="hl-keyword">public</span> Invoice() 
     {
        <span class="hl-keyword">super</span>();
        <span class="hl-keyword">this</span>._itemList = <span class="hl-keyword">new</span> java.util.ArrayList();
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Invoice()</span>

    ...

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addItem(xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-keyword">this</span>._itemList.add(vItem);
    } <span class="hl-comment">//-- void addItem(xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addItem(<span class="hl-keyword">int</span> index, xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-keyword">this</span>._itemList.add(index, vItem);
    } <span class="hl-comment">//-- void addItem(int, xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> java.util.Enumeration enumerateItem()
    {
        <span class="hl-keyword">return</span> java.util.Collections.enumeration(<span class="hl-keyword">this</span>._itemList);
    } <span class="hl-comment">//-- java.util.Enumeration enumerateItem() </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item getItem(<span class="hl-keyword">int</span> index)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-comment">// check bounds for index</span>
        <span class="hl-keyword">if</span> (index &lt; 0 || index &gt;= <span class="hl-keyword">this</span>._itemList.size()) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IndexOutOfBoundsException(<span class="hl-string">"getItem: Index value '"</span> + index 
               + <span class="hl-string">"' not in range [0.."</span> + (<span class="hl-keyword">this</span>._itemList.size() - 1) + <span class="hl-string">"]"</span>);
        }
        
        <span class="hl-keyword">return</span> (xml.c1677.invoice.generated.Item) _itemList.get(index);
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item getItem(int) </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item[] getItem()
    {
        <span class="hl-keyword">int</span> size = <span class="hl-keyword">this</span>._itemList.size();
        xml.c1677.invoice.generated.Item[] array = <span class="hl-keyword">new</span> xml.c1677.invoice.generated.Item[size];
        <span class="hl-keyword">for</span> (<span class="hl-keyword">int</span> index = 0; index &lt; size; index++){
            array[index] = (xml.c1677.invoice.generated.Item) _itemList.get(index);
        }
        
        <span class="hl-keyword">return</span> array;
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item[] getItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getItemCount()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._itemList.size();
    } <span class="hl-comment">//-- int getItemCount() </span>

    <span class="hl-keyword">public</span> java.util.Iterator iterateItem()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._itemList.iterator();
    } <span class="hl-comment">//-- java.util.Iterator iterateItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> removeAllItem()
    {
        <span class="hl-keyword">this</span>._itemList.clear();
    } <span class="hl-comment">//-- void removeAllItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> removeItem(xml.c1677.invoice.generated.Item vItem)
    {
        <span class="hl-keyword">boolean</span> removed = _itemList.remove(vItem);
        <span class="hl-keyword">return</span> removed;
    } <span class="hl-comment">//-- boolean removeItem(xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item removeItemAt(<span class="hl-keyword">int</span> index)
    {
        Object obj = <span class="hl-keyword">this</span>._itemList.remove(index);
        <span class="hl-keyword">return</span> (xml.c1677.invoice.generated.Item) obj;
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item removeItemAt(int) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItem(<span class="hl-keyword">int</span> index, xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-comment">// check bounds for index</span>
        <span class="hl-keyword">if</span> (index &lt; 0 || index &gt;= <span class="hl-keyword">this</span>._itemList.size()) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IndexOutOfBoundsException(<span class="hl-string">"setItem: Index value '"</span> 
               + index + <span class="hl-string">"' not in range [0.."</span> + (<span class="hl-keyword">this</span>._itemList.size() - 1) + <span class="hl-string">"]"</span>);
        }
        
        <span class="hl-keyword">this</span>._itemList.set(index, vItem);
    } <span class="hl-comment">//-- void setItem(int, xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItem(xml.c1677.invoice.generated.Item[] vItemArray)
    {
        <span class="hl-comment">//-- copy array</span>
        _itemList.clear();
        
        <span class="hl-keyword">for</span> (<span class="hl-keyword">int</span> i = 0; i &lt; vItemArray.length; i++) {
                <span class="hl-keyword">this</span>._itemList.add(vItemArray[i]);
        }
    } <span class="hl-comment">//-- void setItem(xml.c1677.invoice.generated.Item) </span>

}</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.examples.non-trivial"></a>2.7.2.&nbsp;Non-trivial real world example</h3></div></div></div><p>
          Two companies wish to trade with each other using a Supply Chain
          messaging system. This system sends and receives Purchase Orders and
          Order Receipt messages. After many months of discussion they have
          finally decided upon the structure of the Version 1.0 of their
          message XSD and both are presently developing solutions for it. One
          of the companies decides to use Java and Castor XML support for
          (un)marshaling and Castor's code generator to accelerate their
          development process.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.non-trivial.schema"></a>2.7.2.1.&nbsp;The Supply Chain XSD</h4></div></div></div><pre class="programlisting">
            &lt;<span class="hl-tag">title</span>&gt;supplyChainV1.0.xsd&lt;<span class="hl-tag">/title</span>&gt;
&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
           <span class="hl-attribute">elementFormDefault</span>=<span class="hl-value">"qualified"</span>
           <span class="hl-attribute">attributeFormDefault</span>=<span class="hl-value">"unqualified"</span>&gt;

    &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Data"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;
          This section contains the supply chain message data
        &lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:complexType</span>&gt;
        &lt;<span class="hl-tag">xs:choice</span>&gt;
          &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrder"</span>&gt;
            &lt;<span class="hl-tag">xs:complexType</span>&gt;
              &lt;<span class="hl-tag">xs:sequence</span>&gt;
                &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItem"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"LineItemType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span>/&gt;
              &lt;<span class="hl-tag">/xs:sequence</span>&gt;
              &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
            &lt;<span class="hl-tag">/xs:complexType</span>&gt;
          &lt;<span class="hl-tag">/xs:element</span>&gt;
          &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceipt"</span>&gt;
            &lt;<span class="hl-tag">xs:complexType</span>&gt;
              &lt;<span class="hl-tag">xs:sequence</span>&gt;
                &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItem"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"ReceiptLineItemType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span>/&gt;
              &lt;<span class="hl-tag">/xs:sequence</span>&gt;
              &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
            &lt;<span class="hl-tag">/xs:complexType</span>&gt;
          &lt;<span class="hl-tag">/xs:element</span>&gt;
        &lt;<span class="hl-tag">/xs:choice</span>&gt;
      &lt;<span class="hl-tag">/xs:complexType</span>&gt;
    &lt;<span class="hl-tag">/xs:element</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SkuType"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;Contains Product Identifier&lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ID"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ReceiptSkuType"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;Contains Product Identifier&lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
        &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"SkuType"</span>&gt;
          &lt;<span class="hl-tag">xs:sequence</span>&gt;
            &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InternalID"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
          &lt;<span class="hl-tag">/xs:sequence</span>&gt;
        &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItemType"</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Sku"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"SkuType"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Value"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:double"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"BillingInstructions"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"DeliveryDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:date"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ReceiptLineItemType"</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Sku"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"ReceiptSkuType"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Value"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:double"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PackingDescription"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ShipDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:dateTime"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:schema</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.non-trivial.binding"></a>2.7.2.2.&nbsp;Binding file? -- IT IS REQUIRED!</h4></div></div></div><p>
          If you run the Castor CodeGenerator on the above XSD you end up
          with the following set of classes. (You also get lots of warning
          messages with the present version.)
        </p><pre class="programlisting">
Data.java
DataDescriptor.java
LineItem.java
LineItemDescriptor.java
LineItemType.java
LineItemTypeDescriptor.java
OrderReceipt.java
OrderReceiptDescriptor.java
PurchaseOrder.java
PurchaseOrderDescriptor.java
ReceiptLineItemType.java
ReceiptLineItemTypeDescriptor.java
ReceiptSkuType.java
ReceiptSkuTypeDescriptor.java
Sku.java
SkuDescriptor.java
SkuType.java
SkuTypeDescriptor.java</pre><p>
          The problem here is that there are two different elements with the
          same name in different locations in the XSD. This causes a Java code
          generation conflict. By default, Castor uses the element name as the name 
          of the class. So the second class generated for the LineItem definition,
          which is different than the first, overwrites the first class
          generated.
        </p><p>
          A binding file is therefore necessary to help the Castor code
          generator differentiate between these generated classes and as such avoid
          such generation conflicts. That is, you can 'bind' an element in the XML schema 
          to a differently named class file that you want to generate. This keeps different 
          elements separate and ensures that source is properly generated for 
          each XML Schema object.
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
            The warning messages for Castor 0.99+ are very useful in assisting
            you in your creation of the binding file. For the example the
            warning messages for the example are:
          </p><pre class="programlisting">
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
          </pre></td></tr></table></div><p>
          The following binding file definition will overcome the naming
          issues for the generated classes:
        </p><pre class="programlisting">
            
&lt;<span class="hl-tag">binding</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.castor.org/SourceGenerator/Binding"</span>
         <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/SourceGenerator/Binding C:\\Castor\\xsd\\binding.xsd"</span>
         <span class="hl-attribute">defaultBinding</span>=<span class="hl-value">"element"</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/Data/PurchaseOrder/LineItem"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrderLineItem"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/Data/OrderReceipt/LineItem"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceiptLineItem"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:ReceiptLineItemType/Sku"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceiptSku"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:LineItemType/Sku"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrderSku"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

&lt;<span class="hl-tag">/binding</span>&gt;</pre><p>
          One thing to notice in the above <code class="literal">binding.xml</code> file is that
          the name path used is relative to the root of the XSD <span class="bold"><strong>and not</strong></span>
          the root of the target XML. Also notice that the two complex types
          have the "complexType:" prefix to identify them followed by the name
          path relative to the root of the XSD.
        </p><p>The new list of generated classes is:</p><pre class="programlisting">
Data.java
DataDescriptor.java
LineItem.java
LineItemDescriptor.java
LineItemType.java
LineItemTypeDescriptor.java
OrderReceipt.java
OrderReceiptDescriptor.java
<span class="bold"><strong><span class="bold"><strong>OrderReceiptLineItem.java</strong></span></strong></span>
OrderReceiptLineItemDescriptor.java
<span class="bold"><strong><span class="bold"><strong>OrderReceiptSku.java</strong></span></strong></span>
OrderReceiptSkuDescriptor.java
PurchaseOrder.java
PurchaseOrderDescriptor.java
<span class="bold"><strong><span class="bold"><strong>PurchaseOrderLineItem.java</strong></span></strong></span>
PurchaseOrderLineItemDescriptor.java
<span class="bold"><strong><span class="bold"><strong>PurchaseOrderSku.java</strong></span></strong></span>
PurchaseOrderSkuDescriptor.java
ReceiptLineItemType.java
ReceiptLineItemTypeDescriptor.java
ReceiptSkuType.java
ReceiptSkuTypeDescriptor.java
Sku.java
SkuDescriptor.java
SkuType.java
SkuTypeDescriptor.java</pre><p>
          The developers can now use these generated classes with Castor to
          (un)marshal the supply chain messages sent by their business
          partner.
        </p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e2112" href="#d4e2112">1</a>] </sup>XML Schema is a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org" target="_top">W3C</a>
        Recommendation</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e2116" href="#d4e2116">2</a>] </sup>Castor supports the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/XMLschema-1" target="_top">XML Schema 1.0 Second
        Edition</a></p></div></div></div>

   <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml.code.generator.extensions"></a>Chapter&nbsp;3.&nbsp;XML code generation - Extensions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.extensions.why"></a>3.1.&nbsp;XML code generation extensions - Motivation</h2></div></div></div><p>
        With Castor 1.2 and earlier releases it has already been possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        Starting with Castor 1.3, a mechanism has been added to the XML code generator that allows
        extension of these core offerings so that either additional content is added to the generated
        domain classes additonal descriptor classes are gernated.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.extensions"></a>3.1.1.&nbsp;JDO extensions for the Castor XML code generator</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.why"></a>3.1.1.1.&nbsp;JDO extensions - Motivation</h4></div></div></div><p>
        With Castor 1.2 and previous releases it was already possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        In addition, it was already possible to use the generated set of domain classes
        in Castor JDO for object-/relational mapping purpose by supplying a 
        (manually written) JDO-specific mapping file. Whilst technically not very difficult,
        this was still an error-prone task, especially in a context where tens or 
        hundreds of classes were generated from a set of XML schemas.
    </p><p>
        The <span class="italic">JDO extensions for the Castor XML code generator</span>
        extend the code generator in such a way that a second set of descriptor classes is
        generated: the JDO descriptor classes. These new descriptor classes define
        the mapping between Java (domain) objects and database tables/columns, and as
        such remove the requirement of having to write a JDO-specific mapping file.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
           Please note that Castor JDO - upon startup - internally converts the information
           provided in the JDO mapping file to (JDO) descriptor classes. As such, the
           approach outlined above simply re-uses an existing code base and just automates the
           production of those descriptor classes.
        </p></td></tr></table></div><p>
        The following sections introduce the general principles, define the XML schema 
        artifacts available to annotate an existing XML schema and highlight the 
        usage of these artifacts by providing examples. At the same time,
        a limited set of current product limitations are spelled out.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.limitations"></a>3.1.1.2.&nbsp;Limitations</h4></div></div></div><p>
        With release 1.3 of Castor, the following limitations exist for the JDO
        extensions of the XML code generator:
    </p><div class="orderedlist"><ol type="1"><li><p>
                The extensions currently can only be used in <span class="bold"><strong>type</strong></span>
                mode of the XML code generator.
            </p></li><li><p>
                There's currently no support for <span class="bold"><strong>key generators</strong></span>. 
                There's work in progress to add this functionality, though.
            </p></li><li><p>
                There's currently no support for bidirectional relations, modelled through
                the use of &lt;xs:id&gt; and &lt;xs:idref&gt; constructs.
            </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.prerequisites"></a>3.1.1.3.&nbsp;Prerequisites</h4></div></div></div><p>
                To facilitate the detailed explanations in the following 
                sections, we now define a few &lt;complexType&gt; definitions
                that we want to map against an existing database schema, and the 
                corresponding SQL statements to create the required tables.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.prerequisites.xml.schemas"></a>3.1.1.3.1.&nbsp;Sample XML schemas</h5></div></div></div><pre class="programlisting">
               
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;

&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lectorType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;

&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.prerequisites.ddl.statements"></a>3.1.1.3.2.&nbsp;Sample DDL statements</h5></div></div></div><pre class="programlisting">
CREATE TABLE author_table (
   sin INTEGER NOT NULL,
   name VARCHAR(20) NOT NULL
);

CREATE TABLE lector_table (
   sin INTEGER NOT NULL,
   name VARCHAR(20) NOT NULL
);

CREATE TABLE book_table (
   isbn VARCHAR(13) NOT NULL,
   pages INTEGER,
   lector_id INTEGER NOT NULL,
   author_id INTEGER NOT NULL
);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.generation"></a>3.1.1.4.&nbsp;Configuring the XML code generator</h4></div></div></div><p>
            To have the Castor XML code generator generate JDO class descriptors
            when processing a set of XML schemas, please use one of the following 
            methods:
        </p><div class="table"><a name="jdo.extensions.generation.methods"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Accessing options</b></p><div class="table-contents"><table summary="Accessing options" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Usage</th><th align="center">Method</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"><code class="classname">SourceGenerator</code></td><td align="center"><code class="methodname">setJdoDescriptorCreation(boolean)</code></td><td align="center">Supply a value of <code class="literal">true</code> to enable this feature.</td></tr><tr><td align="center"><code class="classname">SourceGeneratorMain</code></td><td align="center">Flag <code class="literal">-gen-jdo-desc</code></td><td align="center">Set this optional flag to enable this feature.</td></tr><tr><td align="center">Ant task for XML code generator</td><td align="center"><code class="literal">generateJdoDescriptors</code> option</td><td align="center">Set this to a value of <code class="literal">true</code>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.schema.elements"></a>3.1.1.5.&nbsp;The JDO annotations for XML schemas</h4></div></div></div><p>
            This section enlists the XML artifacts available to annotate an existing XML schema
            with JDO extension-specific information. These constructs are defined themselves
            in an XML schema <code class="literal">jdo-extensions.xsd</code> that has a target 
            namespace of <code class="uri">http://www.castor.org/binding/persistence</code>. 
        </p><p>
            To enable proper validation of your XML schemas when editing JDO
            annotations, and to enable XML completion in your preferred XML 
            editor, please add <code class="literal">schemaLocation</code> information to 
            your XML schema definition as follows:
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xmlns:jdo</span>=<span class="hl-value">"http://www.castor.org/binding/persistence"</span>
    <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://your/target/namespace"</span>                                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/binding/persistence http://www.castor.org/jdo-extensions.xsd"</span>&gt;
    
...

&lt;<span class="hl-tag">/xs:schema</span>&gt;        
            </pre></div><p>
          where ...
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                  The values supplied in the <code class="literal">schemaLocation</code> attribute
                  define the location of the XML schema for any XML artefacts bound to
                  the <code class="literal">http://www.castor.org/binding/persistence</code> namespace.
               </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.table"></a>3.1.1.5.1.&nbsp;&lt;table&gt; element</h5></div></div></div><p>
                The &lt;table&gt; element allows you to map an &lt;complexType&gt;
                definition to a database table within a database, and to specify the
                identity (frequently referred to as <code class="literal">primary key</code>), 
                as follows:
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_table"</span>&gt;                                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;                                                  <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
               &lt;<span class="hl-tag">jdo:key</span>&gt;siNumber&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
              </pre></div><p>
             where ...
           </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                     The <code class="literal">&lt;jdo:table ...&gt;</code> defines the name 
                     of the database table to which the complex type definition
                     <code class="literal">authorType</code> should be mapped. 
                  </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                     The <code class="literal">&lt;jdo:primary-key&gt;</code> indicates which 
                     artifacts of the content model of the complex type definition
                     should be used as the corresponding object identity; in database
                     terms, this is often referred to as <code class="literal">primary key</code>.
                  </p></td></tr></table></div><p>
                Above example maps the complex  type <code class="literal">authorType</code> to
                the table <code class="literal">author_table</code>, and specifies that the 
                member <code class="literal">siNumber</code> be used as object identity.
            </p><p>
                The XML schema definition for the <code class="literal">&lt;table&gt;</code> 
                element is defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"table"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
         &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"primaryKey"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"jdo:pkType"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessMode"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"shared"</span>&gt;
         &lt;<span class="hl-tag">xs:simpleType</span>&gt;
            &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"read-only"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"shared"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"exclusive"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db-locked"</span>/&gt;
            &lt;<span class="hl-tag">/xs:restriction</span>&gt;
         &lt;<span class="hl-tag">/xs:simpleType</span>&gt;
      &lt;<span class="hl-tag">/xs:attribute</span>&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detachable"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:boolean"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span>/&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;

&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pkType"</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.column"></a>3.1.1.5.2.&nbsp;&lt;column&gt; element</h5></div></div></div><p>
                The &lt;column&gt; element allows you to map a member of content model 
                of a &lt;complexType&gt; definition to a column within a database
                table.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;siNumber&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sin"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
              </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">siNumber</code>
                        be mapped against the database column <code class="literal">sin</code>, and
                        that the (database) type of this column is 
                        <code class="literal">integer</code>.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">isNumber</code> to
                the database column <code class="literal">sin</code>, and specifies the database type
                to be used for persistence (<code class="literal">integer</code>, in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;column&gt;</code> is 
                defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"column"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"type"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"acceptNull"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:boolean"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span>
               <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span> /&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="jdo.extensions.schema.elements.column.grammar"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column</td></tr><tr><td align="center">type</td><td align="center">JDO-type of the column</td></tr><tr><td align="center">acceptNull</td><td align="center">Whether this field accepts NULL values or not</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.one-to-one"></a>3.1.1.5.3.&nbsp;&lt;one-to-one&gt; element</h5></div></div></div><p>
                The &lt;one-to-one&gt; element allows you to map a member of content model 
                of a &lt;complexType&gt; definition to a 1:1 relation to another
                &lt;complexType&gt;.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_type_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;isbn&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;                                                      <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
               &lt;<span class="hl-tag">jdo:one-to-one</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector_id"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> &gt;
         ...
      &lt;<span class="hl-tag">/xs:element</span>&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
                </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines a 1:1 relation to another &lt;complexType&gt;, 
                        additionally providing the necessary foreign key column 
                        at the database level.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">lector</code> to a
                1:1 relation to the complex type <code class="literal">lectorType</code>, and 
                specifies the (column name of the) foreign key to be used 
                (<code class="literal">lector_id</code> in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;one-to-one&gt;</code> 
                is defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"one-to-one"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="jdo.extensions.schema.elements.one-to-one.grammar"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;&lt;one-to-one&gt; - Definitions</b></p><div class="table-contents"><table summary="<one-to-one&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column that represents the foreign key of this relation</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.one-to-many"></a>3.1.1.5.4.&nbsp;&lt;one-to-many&gt; element</h5></div></div></div><p>
                The &lt;one-to-many&gt; element allows you to map a member of the 
                content model of a &lt;complexType&gt; definition as part of a 1:M relation 
                to another &lt;complexType&gt;.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_type_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;isbn&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
               &lt;<span class="hl-tag">jdo:one-to-one</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector_id"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:one-to-many</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> /&gt;                             <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;    
      &lt;<span class="hl-tag">/xs:element</span>&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
                </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines a 1:M relation to another &lt;complexType&gt;, 
                        additionally providing the necessary foreign key column 
                        for the many member at the database level.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">authors</code> as part of a
                1:M relation to the complex type <code class="literal">authorType</code>, and 
                specifies the (column name of the) foreign key of the many member 
                to be used (<code class="literal">book_id</code> in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;one-to-many&gt;</code> 
                is given as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"one-to-many"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                with the following details applying:
            </p><div class="table"><a name="jdo.extensions.schema.elements.one-to-many.grammar"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;&lt;one-to-many&gt; - Definitions</b></p><div class="table-contents"><table summary="<one-to-many&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column that represents the (many) foreign key of this relation</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.usage"></a>3.1.1.6.&nbsp;Using the generated (domain) classes with Castor JDO</h4></div></div></div><p>
            Once you have generated domain classes and descriptor classes 
            (both XML and JDO) from your set of XML schemas, you'll be 
            able to use them as are. There's a few minor changes, which we 
            are going to highlight below, but the main benefit is that you 
            <span class="bold"><strong>not</strong></span> have to write a JDO mapping 
            file.  
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.usage.mapping.file"></a>3.1.1.6.1.&nbsp;Empty mapping file</h5></div></div></div><p>
                As you have already generated JDO descriptor classes for each 
                of your domain objects, you won't have to supply mappings for 
                those classes anymore. As such, your mapping file will stay 
                empty, as shown:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                           <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>
<span class="hl-attribute">&lt;mapping&gt;</span>

   <span class="hl-attribute">&lt;!--</span> <span class="hl-attribute">no</span> <span class="hl-attribute">mappings</span> <span class="hl-attribute">required</span> <span class="hl-attribute">--&gt;</span>
<span class="hl-attribute">&lt;/mapping&gt;</span>
            </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                    Please note that you can of course supply mappings for 
                    those classes that stand outside of the generation
                    process from your XML schemas. It is possible, too, to
                    match both modes. In other words, a domain class mapped manually
                    will be able to refer to a domain class as generated.
                </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.usage.cdr"></a>3.1.1.6.2.&nbsp;Use of a <code class="classname">JDOClassDescriptorResolver</code></h5></div></div></div><p>
                In order for Castor to be able to access the generated (JDO) class
                descriptors and to load those classes from the file system,
                you will have to configure an instance of 
                <code class="classname">JDOClassDescriptorResolver</code> and pass it to your
                <code class="classname">JDOManager</code> instance when loading the JDO 
                configuration.
            </p><p>
                The following example shows how to configure Castor JDO so that 
                the classes generated from the sample XML schema above can be used 
                with CASTOR JDO seamlessly. 
            </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = <span class="hl-keyword">new</span> JDOClassDescriptorResolverImpl();
resolver.addClass(org.castor.jdo.extension.sample.BookType.<span class="hl-keyword">class</span>);
resolver.addClass(org.castor.jdo.extension.sample.LectorType.<span class="hl-keyword">class</span>);            
resolver.addClass(org.castor.jdo.extension.sample.AuthorType.<span class="hl-keyword">class</span>);

InputSource jdoConfiguration = ....;
JDOManager.loadConfiguration(jdoConfiguration, null, null, resolver);
   
JDOManager jdoManager = JDOManager.createInstance(<span class="hl-string">"jdo-extensions"</span>);
...             
            </pre><p>
                Alternatively, if the classes generated from the sample 
                XML schema shown above reside in the same package, you can 
                configure the <code class="classname">JDOClassDescriptorResolver</code>
                as follows:  
            </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = new JDOClassDescriptorResolverImpl();
resolver.addPackage("org.castor.jdo.extension.sample");
...
            </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
                   For the latter approach to work, you will have to make sure that the 
                   <code class="filename">.castor.jdo.cdr</code> files generated alongside
                   your domain (and descriptor classes) are included in your
                   application deployment units. If not, Castor JDO will not be 
                   able to load the descriptor classes from the file system, and
                   throw an exception. 
               </p></td></tr></table></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="solrj.extensions"></a>3.1.2.&nbsp;SOLRJ extensions for the Castor XML code generator</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.why"></a>3.1.2.1.&nbsp;SOLRJ extensions - Motivation</h4></div></div></div><p>
        With Castor 1.2 and previous releases it was already possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        The <span class="italic">SOLRJ extensions for the Castor XML code generator</span>
        extend the code generator in such a way that the set of domain classes is
        augmented with SOLRJ-specific <code class="literal">@Field</code> annotations.
    </p><p>
        The following sections introduce the general principles, define the XML schema 
        artifacts available to annotate an existing XML schema and highlight the 
        usage of these artifacts by providing examples.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.prerequisites"></a>3.1.2.2.&nbsp;Prerequisites</h4></div></div></div><p>
        To facilitate the detailed explanations in the following 
        sections, we now define a few &lt;complexType&gt; definitions
        that we want to be able to store in a SOLR index in addition to vanilla XML
        data binding funtionality.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="solrj.extensions.prerequisites.xml.schemas"></a>3.1.2.2.1.&nbsp;Sample XML schemas</h5></div></div></div><pre class="programlisting">
       
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.schema.elements"></a>3.1.2.3.&nbsp;The SOLRJ annotations for XML schemas</h4></div></div></div><p>
            This section enlists the XML artifacts available to annotate an existing XML schema
            with SOLRJ extension-specific information. These constructs are defined themselves
            in an XML schema <code class="literal">solrj-extensions.xsd</code> that has a target 
            namespace of <code class="uri">http://www.castor.org/binding/solrj</code>. 
        </p><p>
            To enable proper validation of your XML schemas when editing SOLRJ
            annotations, and to enable XML completion in your preferred XML 
            editor, please add <code class="literal">schemaLocation</code> information to 
            your XML schema definition as follows:
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xmlns:solr</span>=<span class="hl-value">"http://www.castor.org/binding/solrj"</span>
    <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/binding/solrj http://www.castor.org/solrj-extens</span><span class="co"><img src="images/callouts/1.png" alt="(1)"></span><span class="hl-value">ions.xsd"</span>&gt;
    
...

&lt;<span class="hl-tag">/xs:schema</span>&gt;        
            </pre></div><p>
          where ...
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                  The values supplied in the <code class="literal">schemaLocation</code> attribute
                  define the location of the XML schema for any XML artefacts bound to
                  the <code class="literal">http://www.castor.org/binding/solrj</code> namespace.
               </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="solrj.extensions.schema.elements.field"></a>3.1.2.3.1.&nbsp;&lt;field&gt; element</h5></div></div></div><p>
                The &lt;field&gt; element allows you to map a member of the content model 
                of a <code class="literal">&lt;complexType&gt;</code> definition to SOLRJ field.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>&gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">solrj:field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> /&gt;                                      <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/element</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>&gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">solrj:field</span> /&gt;                                                <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/element</span>&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
              </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">isbn</code>
                        be mapped against the SOLRJ field <code class="literal">id</code>.
                     </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">name</code>
                        be mapped to the SOLRJ field <code class="literal">name</code>.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">isbn</code> to
                the SOLR index field <code class="literal">id</code>, and the element 
                <code class="literal">name</code> to the identically-named SOLR index
                field. Please note that a SOLR index field name does not have 
                to be specified if the field name and the Java property name
                are identical.
            </p><p>
                Above complex type definition will be transformed to the 
                corresponding Java property definitions (within a class):
            </p><pre class="programlisting">
public class BookType {

    @Field("id")
    private String isbn;
    
    @Field
    private long pages;
    
}
            </pre><p>
                The XML schema definition for <code class="literal">&lt;field&gt;</code> is 
                defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"field"</span>&gt;
  &lt;<span class="hl-tag">xs:annotation</span>&gt;
     &lt;<span class="hl-tag">xs:documentation</span>&gt;
            Element 'field' is used to specify the use of the SOLRJ
            @Field annotation.
        &lt;<span class="hl-tag">/xs:documentation</span>&gt;
  &lt;<span class="hl-tag">/xs:annotation</span>&gt;
  &lt;<span class="hl-tag">xs:complexType</span>&gt;
     &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span>&gt;
        &lt;<span class="hl-tag">xs:annotation</span>&gt;
           &lt;<span class="hl-tag">xs:documentation</span>&gt;
                    Attribute 'name' is used to specify the name of
                    the index field to be mapped against; if not used,
                    the name of the Java property will be used as filed 
                    name.
                &lt;<span class="hl-tag">/xs:documentation</span>&gt;
        &lt;<span class="hl-tag">/xs:annotation</span>&gt;
     &lt;<span class="hl-tag">/xs:attribute</span>&gt;
  &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="solrj.extensions.schema.elements.field.grammar"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;&lt;field&gt; - Definitions</b></p><div class="table-contents"><table summary="<field&gt; - Definitions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Optional?</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the SOLR index field.</td><td align="center">Yes</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.usage"></a>3.1.2.4.&nbsp;Using the generated domain classes with SOLR</h4></div></div></div><p>
            Once you have generated domain classes (and descriptor classes 
            for the XML binding) from your set of XML schemas, you'll be 
            able to use them as are.  
        </p></div></div></div></div>

   

   

</div></body></html>