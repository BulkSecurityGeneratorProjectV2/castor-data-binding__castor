<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;6.&nbsp;Castor JDO - Support for the JPA specification</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="up" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="prev" href="Spring ORM integration.html" title="Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM"><link rel="next" href="ddlgen.html" title="Chapter&nbsp;7.&nbsp;DDL generator for Castor JDO"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top"><div id="header"><div class="projectlogo"><a href="./"><img class="logoImage" src="images/castor.gif" alt="Castor" border="0"></a></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="mhSpacer"></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jpa"></a>Chapter&nbsp;6.&nbsp;Castor JDO - Support for the JPA specification</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.why"></a>6.1.&nbsp;JPA annotations - Motivation</h2></div></div></div><p>
            It has always been a goal of the Castor JDO project to 
            eventually fully support the JPA specification and become a 
            first class JPA provider that can e.g. be easily integrated
            with Spring ORM. Whilst full compliance is still work 
            in progress, there are several small areas where sufficient 
            progress has been made, and where partial support 
            will be made available to the user community.
        </p><p>
            One such area is (partial) support for JPA annotations. This chapter 
            highlights how JPA-annotated Java classes can be used with 
            Castor JDO to persist such classes through the existing persistence 
            framework part of Castor, without little additional requirements.
        </p><p>
            The following sections describe ...
        </p><div class="orderedlist"><ol type="1"><li><p>The prerequisites.</p></li><li><p>The current limitations.</p></li><li><p>The supported JPA annotations.</p></li><li><p>How to use Castor JDO to persist JPA-annotated classes.</p></li><li><p>How to use Castor JDO as Spring ORM provider to persist JPA-annotated classes.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9475"></a>6.2.&nbsp;Prerequisites and outline</h2></div></div></div><p>
            The following sections assume that you have a (set of) JPA-annotated
            domain classes which you would like to persist using
            Castor JDO.
        </p><p>
            As such, we explain how to enlist those classes with
            Castor JDO (through the <code class="classname">JDOClassDescriptorResolver</code>
            interface, so that Castor JDO will be able to find and work with your
            JPA-annotated classes. In addition, we explain how to achieve the same
            with Spring ORM and the Spring ORM provider for Castor JDO.
        </p><p>
            By the end of this chapter is should become obvious that 
            Castor JDO is well-prepared to integrate with the annotation part of the
            JPA specification, although support for JPA annotations is 
            currently limited.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.annotations.limitations"></a>6.3.&nbsp;Limitations and Basic Information</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9483"></a>6.3.1.&nbsp;persistence.xml</h3></div></div></div><p>
                 In Castor JPA there is no use or support for a JPA
                 <code class="filename">persistence.xml</code> configuration file for 
                 now. All required configuration needs to be supplied by one 
                 of the following means:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Castor JDO configuration file.</p></li><li><p><code class="classname">JDOClassDescriptorResolver</code> configuration.</p></li><li><p>Spring configuration file for the Spring ORM provider for Castor JDO.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9495"></a>6.3.2.&nbsp;JPA access type and the placing of JPA annotations</h3></div></div></div><p>
                Because Castor does not support direct field access, this 
                feature is not supported by Castor JPA. Thus all annotations have 
                to be defined on the getter methods of the fields. If JPA related 
                annotations are found on fields, Castor will throw an 
                exception.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9498"></a>6.3.3.&nbsp;Primary Keys</h3></div></div></div><p>		
                Primary keys made of single fields are supported by Castor as defined 
                in the JPA specification (through the use of the <code class="literal">@Id</code> annotation). If 
                you need to define composite primary keys, please note that that 
                Castor does <span class="bold"><strong>not</strong></span> support relations 
                with composite primary keys.
            </p><p>
                If you still want to persist single classes with the use of 
                composite primary keys, none of the available JPA annotations 
                (<code class="literal">@EmbeddedId</code> or <code class="literal">@IdClass</code>) is supported as such. Instead Castor 
                uses a kind of ad-hoc <code class="literal">IdClass</code> mechanism. Simply 
                define multiple <code class="literal">@Id</code> annotations on the fields that make up your 
                composite primary key, and Castor JDO will internally create the 
                relevant constructs.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9508"></a>6.3.4.&nbsp;Inheritance, mapped superclasses, etc.</h3></div></div></div><p>
                These JPA annotations are currently <span class="bold"><strong>not</strong></span>
                supported by Castor JDO. For now, you can only define entities.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9512"></a>6.3.5.&nbsp;Relations</h3></div></div></div><p>
                Besides the fact, that Castor does not support composite primary keys 
                in relations, there are some limitations on the different kinds of 
                relations between entities. For detailed information, please read the 
                documentation about the different relations types further below.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.annotations"></a>6.4.&nbsp;An outline of JPA-Annotations</h2></div></div></div><p>
		</p><table class="simplelist" border="0" summary="Simple list"><tr><td>S ... Supported</td></tr><tr><td>PS ... Partially Supported</td></tr><tr><td>NS ... Not Supported</td></tr></table><p>
	</p><div class="table"><a name="jpa.annotations.table"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;JPA-Annotations</b></p><div class="table-contents"><table summary="JPA-Annotations" border="1"><colgroup><col align="left"><col><col align="left"></colgroup><thead><tr><th align="left">Annotation</th><th align="center">Supported</th><th align="left">Comment</th></tr></thead><tbody><tr><td align="left">AssociationOverride</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AssociationOverrides</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AttributeOverride</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AttributeOverrides</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Basic</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">See information on Castor fetch types!</td></tr><tr><td align="left">Column</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: column name, nullable</td></tr><tr><td align="left">ColumnResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">DiscriminatorColumn</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support Joined Table Class Hierachy.
					</td></tr><tr><td align="left">DiscriminatorValue</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support Joined Table Class Hierachy.
					</td></tr><tr><td align="left">Embeddable</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Embedded</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">EmbeddedId</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support composed primary keys embedded
						in classes of their own.</td></tr><tr><td align="left">Entity</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is needed to tell Castor that this Class
						is an entity.</td></tr><tr><td align="left">EntityListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">EntityResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Enumerated</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ExcludeDefaultListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ExcludeSuperclassListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">FieldResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">GeneratedValue</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Id</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">Use this annotation to make a field a primary key (or
						part of it).</td></tr><tr><td align="left">IdClass</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor creates IdClass-like behaviour implicity when
						you define multiple Id fields. Castor does not support composed
						primary keys in relations!</td></tr><tr><td align="left">Inheritance</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">JoinColumn</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name</td></tr><tr><td align="left">JoinColumns</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">This is not supported because Castor does not support
						composed keys in relations.</td></tr><tr><td align="left">JoinTable</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name, joincolumns, inverseJoincolumns
					</td></tr><tr><td align="left">Lob</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ManyToMany</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">this is not tested properly yet.</td></tr><tr><td align="left">ManyToOne</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, optional, cascade -
						Relations MUST BE optional! Required relations are not supported.
					</td></tr><tr><td align="left">MapKey</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">MappedSuperclass</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">NamedQuery</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is used to specify a named query in OQL.</td></tr><tr><td align="left">NamedQueries</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation specifies an array of named queries</td></tr><tr><td align="left">NamedNativeQuery</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is used to specify a native SQL named query.</td></tr><tr><td align="left">NamedNativeQueries</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation specifies an array of named native queries.</td></tr><tr><td align="left">OneToMany</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, mappedBy, cascade</td></tr><tr><td align="left">OneToOne</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, optional, cascade -
						Relations MUST BE optional! Required relations are not supported.
					</td></tr><tr><td align="left">OrderBy</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceContext</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceContexts</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceProperty</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceUnit</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceUnits</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostLoad</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostPersist</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostRemove</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostUpdate</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrePersist</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PreRemove</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PreUpdate</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrimaryKeyJoinColumn</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrimaryKeyJoinColumns</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">QueryHint</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SecondaryTable</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SecondaryTables</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SequenceGenerator</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SqlResultSetMapping</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SqlResultSetMappings</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Table</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name</td></tr><tr><td align="left">TableGenerator</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Temporal</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Transient</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">UniqueConstraint</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Version</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9790"></a>6.5.&nbsp;Usage of JPA annotations - Configuration</h2></div></div></div><p>
        This selection of HOW-TOs will show you how to persist 
        JPA-annotated classes with Castor JDO, and will outline
        the required steps for each of the following cases:
    </p><div class="itemizedlist"><ul type="disc"><li><p>Singular (stand-alone) entities</p></li><li><p>1:1 relations</p></li><li><p>1:M relations</p></li><li><p>M:N relations</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9802"></a>6.5.1.&nbsp;HOW-TO persist a single class (@Entity, @Table, @Id)</h3></div></div></div><p>
            The goal is to take an existing JPA-annotated class 
            <code class="classname">Single</code> and persist it with 
            Castor JDO. Let's first have a look at the domain class 
            itself, first without JPA annotattions.            
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Single {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id ) { ... }
   
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
}
        </pre><p>
            Here's the same class again, this time with JPA
            annotations.
        </p><pre class="programlisting">
@Entity
@Table(name=<span class="hl-string">"mySingleTable"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Single {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   
   @Id
   @Column(name=<span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
}
        </pre><p>
            As shown, the class <code class="classname">Single</code> is 
            mapped against the table <code class="literal">mySingleTable</code>,
            and its fields <code class="literal">id</code> and <code class="literal">name</code> 
            are mapped to the columns <code class="literal">id</code> and 
            <code class="literal">name</code>, where the column name for the 
            <code class="literal">id</code> property is supplied explicitly and 
            where the column name for the <code class="literal">name</code>
            property is derived from the property itself.
        </p><p>
            Next point is to create an DAO interface and 
            its implementation where we will be using 
            <code class="classname">CastorDaoSupport</code> from Castor's 
            support for Spring ORM to implement the required methods.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SingleDao {
	
    <span class="hl-keyword">void</span> save(Single single);
	
    Single get(<span class="hl-keyword">int</span> id);
	
    <span class="hl-keyword">void</span> delete(Single single);

}
   
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SingleCastorDao <span class="hl-keyword">extends</span> CastorDaoSupport <span class="hl-keyword">implements</span> SingleDao {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(Single single) {
        <span class="hl-keyword">this</span>.getCastorTemplate().remove(single);
    }

    <span class="hl-keyword">public</span> Single get(<span class="hl-keyword">int</span> id) {
        <span class="hl-keyword">return</span> (Single) <span class="hl-keyword">this</span>.getCastorTemplate().load(Single.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(id));
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> save(Single single) {
        <span class="hl-keyword">this</span>.getCastorTemplate().create(single);
    }
}
   </pre><p>
            There's one small final code change needed: For Castor to be able to work 
            with JPA-annotated classes, you have to configure an instance of 
            <code class="classname">JDOClassDescriptorResolver</code> and pass 
            it to your <code class="classname">JDOManager</code>, else Castor 
            won't be able to see those class files. Simply add 
            the individual classes one by one or the package(s)
            as shown below:
        </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = <span class="hl-keyword">new</span> JDOClassDescriptorResolverImpl();
resolver.addClass(org.castor.jpa.Single.<span class="hl-keyword">class</span>);
<span class="hl-comment">// or alternatively you can add the package:</span>
resolver.addPackage(<span class="hl-string">"org.castor.jpa"</span>);
		
InputSource jdoConfiguration = ...;
JDOManager.loadConfiguration(jdoConfiguration, null, null, resolver);
		
JDOManager jdoManager = JDOManager.createInstance(<span class="hl-string">"jpa-extensions"</span>);
...
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9825"></a>6.5.2.&nbsp;HOW-TO persist a 1:1 relation (@OneToOne)</h3></div></div></div><p>
            The goal is to take the existing JPA-annotated classes 
            <code class="classname">OneToOne_A</code> and <code class="classname">OneToOne_B</code>
            and persist them with Castor JDO. Let's first have a look 
            at the domain classes themselves, this time with JPA 
            annotations already in place.            
        </p><pre class="programlisting">
@Entity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OneToOne_A {

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String title;
   
   @Id
   @Column(name = <span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   @Column(name = <span class="hl-string">"name"</span>)
   <span class="hl-keyword">public</span> String getTitle() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTitle(String title) { ... }
}
   
@Entity
@Table(name=<span class="hl-string">"OneToOne_B"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> B {

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   <span class="hl-keyword">private</span> OneToOne_A objA;
   
   @Id
   @Column(name = <span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   @Column(name = <span class="hl-string">"name"</span>)
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
   
   @OneToOne(optional=false)
   <span class="hl-keyword">public</span> OneToOne_A getOneToOne_A() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOneToOne_a(OneToOne_A objA) { ... }
}
        </pre><p>
            As shown, the class <code class="classname">OneToOne_A</code> is 
            mapped against the table <code class="literal">OneToOne_A</code>
            (implicit mapping), and the <code class="classname">B</code> 
            against the table <code class="literal">OneToOne-B</code> (explicit 
            mapping). Please note the <code class="literal">@OneToOne</code> annotation 
            that specifies the 1:1 relation from class 
            <code class="classname">B</code> to class 
            <code class="classname">OneToOne_A</code>.
        </p><p>
            As with the example shown further above, do not forget to 
            register all classes involved with the 
            <code class="classname">JDOClassDescriptorResolver</code>
            as shown below:
        </p><p>JDOClassDescriptorResolver fragment:</p><pre class="programlisting">
resolver.addClass(org.castor.jpa.OneToOne_A.<span class="hl-keyword">class</span>);
resolver.addClass(org.castor.jpa.B.<span class="hl-keyword">class</span>);
        </pre><p>or with the <code class="methodname">addPackage</code> method:</p><pre class="programlisting">
resolver.addPackage(<span class="hl-string">"org.castor.jpa"</span>);
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9846"></a>6.5.3.&nbsp;Persist one to many relation (@OnetoMany)</h3></div></div></div><p>First we have to annotate our java classes.</p><pre class="programlisting">
    @Entity
    @Table(name=<span class="hl-string">"OneToMany_actor"</span>)
    <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {
    
        <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> svnr;
        <span class="hl-keyword">private</span> String lastname;
        <span class="hl-keyword">private</span> String firstname;
    
        @Id
        <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getSvnr() { ... }
        
	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSvnr(<span class="hl-keyword">int</span> svnr) { ... }
    
        @Column(name=<span class="hl-string">"surname"</span>)
        <span class="hl-keyword">public</span> String getLastname() { ... }
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setLastname(String lastname) { ... }
    
        @Column(name=<span class="hl-string">"firstname"</span>)
        <span class="hl-keyword">public</span> String getFirstname() { ... }
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFirstname(String firstname) { ... }
    }
    
    @Entity 
    @Table(name=<span class="hl-string">"OneToMany_broadcast"</span>) 
    <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Broadcast { 
     
        <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id; 
        <span class="hl-keyword">private</span> String name; 
        <span class="hl-keyword">private</span> Collection&lt;Actor&gt; actors; 
     
        @Id 
        <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... } 
	
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... } 
     
        <span class="hl-keyword">public</span> String getName() { ... } 
     
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... } 
     
        @OneToMany(targetEntity=Actor.<span class="hl-keyword">class</span>, mappedBy=<span class="hl-string">"actor_id"</span>) 
        <span class="hl-keyword">public</span> Collection&lt;Actor&gt;  getActors() { ... } 
     
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setActors(Collection&lt;Actor&gt; actors) { ... }
    } 
   </pre><p>What you see is that with the small modification you can persist one to many relations easily.</p><p>Last don't forget to change your JDOClassDescriptorResolver accordingly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9852"></a>6.5.4.&nbsp;HOW-TO create and use a named query (@NamedQuery)</h3></div></div></div><p>
            The <code class="literal">@NamedQuery</code> annotation is used to specify a
            named query in castor's own query language (OQL) and it is expressed
            in metadata. The annotation takes the <code class="literal">name</code> and
            an OQL <code class="literal">query</code> as parameters.
        </p><p>
            To define a named query, we first need a persistence entity where we
            can attach the <code class="literal">@NamedQuery</code> annotation.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@NamedQuery(name = <span class="hl-string">"findPersonByName"</span>, 
            query = <span class="hl-string">"SELECT p FROM your.package.Person p WHERE p.name = $1"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

	@Id
	<span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

	<span class="hl-keyword">public</span> String getName() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>
            As you can see, we defined a query using the name <code class="literal">
            findPersonByName</code>. The query itself uses
            <code class="literal">$1</code> as a placeholder in its <code class="literal">WHERE</code>-clause,
            which must be bound when executing the query.
        </p><p>
            The following code sample illustrates how to execute the named query defined
            above:
        </p><div class="programlistingco"><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findPersonByName"</span>);                           <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
query.bind(<span class="hl-string">"Max Mustermann"</span>);                                                          <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();                                     <span class="co"><img src="images/callouts/3.png" alt="(3)"></span>
<span class="hl-keyword">final</span> Person queriedPerson = (Person) queryResults.next();
queryResults.close();
db.commit();
            </pre></div><p>Let's have a closer look on some of the lines from this example.</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>... creates an OQL query using the above defined named query.</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>.. binds the placeholder <code class="literal">$1</code> to a value.</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td><td valign="top" align="left"><p>... executes the query and handle the results.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9881"></a>6.5.5.&nbsp;HOW-TO create and use multiple named queries (@NamedQueries)</h3></div></div></div><p>The <code class="literal">@NamedQueries</code> annotation is used to specifiy 
        multiple named queries.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@NamedQueries({
    @NamedQuery(name = <span class="hl-string">"findPersonByName"</span>,
                query = <span class="hl-string">"SELECT p FROM your.package.Person p WHERE p.name = $1"</span>),
    @NamedQuery(name = <span class="hl-string">"findPersonById"</span>,
                query = <span class="hl-string">"SELECT p FROM you.package.Person p WHERE p.id = $1"</span>)
})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

    @Id
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

    <span class="hl-keyword">public</span> String getName() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>In the obove example we defined two named queries, namly
        <code class="literal">findPersonByName</code> and <code class="literal">findPersonById</code>.
        The usage of each query is identical to the usasage of a single named query.
        </p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findPersonById"</span>);
query.bind(1000L);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
<span class="hl-keyword">final</span> Person queriedPerson = (Person) queryResults.next();
queryResults.close();
db.commit();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9890"></a>6.5.6.&nbsp;HOW-TO create and use a named native query (@NamedNativeQuery)</h3></div></div></div><p>A named native query is a named query using native SQL syntax
        instead of castor's own query language. The handling of the annotation
        is similar to named queries.</p><p>First we need a entity to attach a query.</p><pre class="programlisting">
@Entity
@Table(name = personTable)
@NamedNativeQuery(name = <span class="hl-string">"selectAllPersons"</span>,
                  query = <span class="hl-string">"SELECT * FROM personTable"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

	@Id
	<span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

	<span class="hl-keyword">public</span> String getName() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>Although the <code class="literal">query</code> itself is written
        in native SQL syntax, we - again - use a <code class="classname">OQLQuery</code> object
        to execute the query.</p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"selectAllPersons"</span>);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
... <span class="hl-comment">//process the results</span>
queryResults.close();
db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9899"></a>6.5.7.&nbsp;HOW-TO create and use multiple named native queries (@NamedNativeQueries)</h3></div></div></div><p>The <code class="literal">@NamedNativeQueries</code> annotation is used to specifiy
        multiple named native SQL queries.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@Table(name = personTable)
@NamedNativeQueries({
    @NamedNativeQuery(name = <span class="hl-string">"selectAllPersons"</span>,
                      query = <span class="hl-string">"SELECT * FROM personTable"</span>),
    @NamedNativeQuery(name = <span class="hl-string">"findMustermann"</span>,
                      query = <span class="hl-string">"SELECT * FROM personTable WHERE name='Max Mustermann' and id=1000"</span>)
})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

    @Id
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

    <span class="hl-keyword">public</span> String getName() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>As we have already seen, the usage of the two above defined queries
        is equivalent to the usage of a single named native query.
        </p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findMustermann"</span>);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
<span class="hl-keyword">final</span> Person maxMustermann = (Person) queryResults.next();
queryResults.close();
db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9906"></a>6.5.8.&nbsp;HOW-TO use persistence callbacks</h3></div></div></div><p>
        The following annotations can be used for handling persistence callbacks via JPA:
        </p><div class="itemizedlist"><ul type="disc"><li>PostLoad</li><li>PrePersist</li><li>PostPersist</li><li>PreUpdate</li><li>PostUpdate</li><li>PreRemove</li><li>PostRemove</li></ul></div><p>
    </p><p>
        Additionally, there are the following listener-related annotations:
        </p><div class="itemizedlist"><ul type="disc"><li>EntityListeners</li><li>ExcludeDefaultListeners</li><li>ExcludeSuperclassListeners</li></ul></div><p>
    </p><p>
        So, here's a basic usage example:
    </p><pre class="programlisting">
@Entity
public class Person {

    private final Log log = LogFactory.getLog(this.getClass());

    private long id;
    private String name;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    @PostLoad
    protected void testPostLoadCallbackHooking() {
        log.debug(String.format("Hello from `PostLoad`. My name is %s.",
                this.name));
    }

    @PrePersist
    protected void validateCreation() {
        if (this.name.equals("Max Mustermann")) {
            throw new PersistenceException(String.format(
                    "Person mustn't be called %s.", this.name));
        }
    }

    @PostPersist
    protected void validatePersistence() {
        if (this.name.equals("Manfred Mustermann")) {
            throw new PersistenceException(String.format(
                    "Person shouldn't be called %s either.", this.name));
        }
    }

    @PreRemove
    protected void validateRemoval() {
        if (this.name.equals("Max Musterfrau")) {
            throw new PersistenceException(this.name + " mustn't be removed.");
        }
    }

    @PostRemove
    protected void validateDeletion() {
        if (this.name.equals("Manfred Musterfrau")) {
            throw new PersistenceException(this.name
                    + " shouldn't be removed either.");
        }
    }

    @PreUpdate
    protected void validateModification() {
        if (this.name.equals("Max Musterfrau")) {
            throw new PersistenceException(String.format(
                    "Person mustn't be renamed to %s.", this.name));
        }
    }

    @PostUpdate
    protected void validateUpdating() {
        if (this.name.equals("Hans Wurst")) {
            throw new PersistenceException(String.format(
                    "Person shouldn't be renamed to %s either.", this.name));
        }
    }

}
    </pre><p>
        As one can see from this example, such callbacks can e.g. be used for
        handling validation based on CRUD (create, retrieve, update, delete)
        operation events.
    </p><p>
        Furthermore, there are possibilites to define listeners which allow for
        decoupling callback handling from entities.
    </p><p>
        Here's an example for that:
    </p><pre class="programlisting">
@Entity
@EntityListeners(DogListener.class)
public class Dog extends Animal {

    private long id;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

}

// Corresponding listener.
public class DogListener {

    @PostPersist
    protected void postPersistDogListener() {
        // Do something.
    }

}
    </pre><p>
        Apart from that, <code class="literal">ExcludeDefaultListeners</code> and
        <code class="literal">ExcludeSuperclassListeners</code> enable specifying
        exclusion of listeners within an inheritance chain of entities.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9931"></a>6.5.9.&nbsp;HOW-TO use @Enumerated</h3></div></div></div><p>
        <code class="literal">Enumerated</code> can be used to persist
        <code class="literal">Enum</code> types.
    </p><p>
        Here's an example:
    </p><pre class="programlisting">
@Entity
public class EnumEntity {

    private long id;
    private StringEnum stringEnum;
    private OrdinalEnum ordinalEnum;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Enumerated(STRING)
    public StringEnum getStringEnum() {
        return stringEnum;
    }

    public void setStringEnum(final StringEnum stringEnum) {
        this.stringEnum = stringEnum;
    }

    public OrdinalEnum getOrdinalEnum() {
        return ordinalEnum;
    }

    public void setOrdinalEnum(final OrdinalEnum ordinalEnum) {
        this.ordinalEnum = ordinalEnum;
    }

}
    </pre><p>
        So, by default enums are serialized to their corresponding ordinal
        value representations for persistence. In this case, it's also
        sufficient to skip explicitly defining so via
        <code class="literal">Enumerated</code>. If serialization to respective string
        name representations is preferred annotating accordingly is required.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9940"></a>6.5.10.&nbsp;HOW-TO use @Temporal</h3></div></div></div><p>
        This annotation can be used to specify properties mapped to temporal
        data structures.
    </p><p>Example:</p><pre class="programlisting">
@Entity
public class Person {

    private long id;
    private Date birthDate;
    private Date anotherDate;
    private Date yetAnotherDate;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Temporal(TIMESTAMP)
    public Date getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(final Date birthDate) {
        this.birthDate = birthDate;
    }

    @Temporal(TIME)
    public Date getAnotherDate() {
        return anotherDate;
    }

    public void setAnotherDate(final Date anotherDate) {
        this.anotherDate = anotherDate;
    }

    @Temporal(DATE)
    public Date getYetAnotherDate() {
        return yetAnotherDate;
    }

    public void setYetAnotherDate(final Date yetAnotherDate) {
        this.yetAnotherDate = yetAnotherDate;
    }

}
    </pre><p>
        So, it's possible to say which underlying DB-based field data structure
        to use (datetime, date or time).
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9946"></a>6.5.11.&nbsp;HOW-TO use @Lob</h3></div></div></div><p>
        Here's an example for that:
    </p><pre class="programlisting">
@Entity
public class LobEntity {

    private long id;
    private String clob;
    private byte[] blob;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Lob
    public String getClob() {
        return clob;
    }

    public void setClob(final String clob) {
        this.clob = clob;
    }

    @Lob
    public byte[] getBlob() {
        return blob;
    }

    public void setBlob(final byte[] blob) {
        this.blob = blob;
    }

}
    </pre><p>
        Consequently, default behavior here is to serialize to
        <code class="literal">CLOB</code> for character-based data and to
        <code class="literal">BLOB</code> for data based on byte arrays (i.e., files).
    </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9953"></a>6.6.&nbsp;Integration with Spring ORM for Castor JDO</h2></div></div></div><p>
        This guide will show you how to enable the use of JPA annotations 
        with Castor JDO in the context of Spring, Spring ORM and the
        existing Spring ORM support for Castor JDO.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9956"></a>6.6.1.&nbsp;A typical sample</h3></div></div></div><p>
            Let's look at a typical Spring configuration file
            that shows how to use Castor JDO with Spring as a 
            Spring ORM provider.
        </p><p>spring-config.xml</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> 
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span> 
       <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
          http://www.springframework.org/schema/tx 
          http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;
    
    &lt;<span class="hl-comment">!-- Enable transaction support using Annotations --</span>&gt;
    &lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span> /&gt;
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> 
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
          &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jdoManager"</span> /&gt; 
    &lt;<span class="hl-tag">/bean</span>&gt;

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"dbName"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdo-conf.xml"</span> /&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"singleDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"SingleCastorDao"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
&lt;<span class="hl-tag">/beans</span>&gt; 
        </pre><p>
            Above Spring application context configures the following
            Spring beans:
        </p><div class="itemizedlist"><ul type="disc"><li><p>A factory bean for JDOManager instantiation</p></li><li><p>A Castor-specific transaction manager.</p></li><li><p>The DAO implementation as shown above.</p></li></ul></div><p>
            As shown above, the bean definition for the 
            <code class="classname">JDOManager</code> factory bean points to
            a Castor JDO configuration file (<code class="filename">jdo-conf.xml</code>),
            whose content is shown below:
        </p><p>jdo-conf.xml</p><pre class="programlisting">
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN""http://castor.org/jdo-conf.dtd"&gt;</span>
<span class="hl-attribute">&lt;jdo-conf&gt;</span>
  <span class="hl-attribute">&lt;database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dbName"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"mysql"</span>&gt;
     &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:mysql://localhost:3306/single"</span> 
             <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span>&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"password"</span> /&gt;
     &lt;<span class="hl-tag">/driver</span>&gt;
     &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"mapping-empty.xml"</span> /&gt;
  &lt;<span class="hl-tag">/database</span>&gt;
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span> /&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
        </pre><p>
            More on how to configure the Spring ORM provider for 
            Castor JDO can be found at TBD.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9975"></a>6.6.2.&nbsp;Adding a <code class="classname">JDOClassDescriptorResolver</code> configuration</h3></div></div></div><p>
            In order to use JPA-annotated classes with the Spring ORM provider 
            for Castor JDO, you will have to use and configure a 
            <code class="classname">JDOClassDescriptorResolver</code> through an
            additional bean definition and link it to your 
            <code class="classname">JDOManager</code> bean factory definition.
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> 
          <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span> 
          <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
          <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;
    
    ...

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"classDescriptorResolver"</span>                                                 <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.ClassDescriptorResolverFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classes"</span>&gt;
            &lt;<span class="hl-tag">list</span>&gt;
                &lt;<span class="hl-tag">value</span>&gt;org.castor.jpa.test.Single&lt;<span class="hl-tag">/value</span>&gt;
            &lt;<span class="hl-tag">/list</span>&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;

    ...
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"dbName"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdo-conf.xml"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classDescriptorResolver"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"classDescriptorResolver"</span> /&gt;      <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
    &lt;<span class="hl-tag">/bean</span>&gt;
    
    ...
&lt;<span class="hl-tag">/beans</span>&gt; 
            </pre></div><p>
            where ....
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                    Defines a <code class="classname">JDOClassDescriptorResolver</code>
                    bean enlisting all the Java (domain) classes that
                    carry JPA annotations.                   
                </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                    links the <code class="classname">JDOClassDescriptorResolver</code>
                    bean to the <code class="literal">classDescriptorResolver</code> property 
                    of the <code class="classname">JDOManager</code> bean definition.                   
                </p></td></tr></table></div><p>
            If your domain classes share a set of packages, it is also 
            possible to enlist those packages with the 
            <code class="classname">JDOClassDescriptorResolver</code> bean, replacing
            the bean definition shown above as follows:
        </p><pre class="programlisting">
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"classDescriptorResolver"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.ClassDescriptorResolverFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"packages"</span>&gt;
            &lt;<span class="hl-tag">list</span>&gt;
                &lt;<span class="hl-tag">value</span>&gt;org.castor.jpa.test&lt;<span class="hl-tag">/value</span>&gt;
            &lt;<span class="hl-tag">/list</span>&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10000"></a>6.6.3.&nbsp;JPA Callbacks</h3></div></div></div><p>
            In order to enable JPA callbacks handling via Spring ORM following
            exemplary config snippet is required:
        </p><pre class="programlisting">
&lt;bean id="jdoManager" class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
    &lt;property name="databaseName" value="testSimple" /&gt;
    &lt;property name="configLocation"
        value="classpath:org/castor/jpa/scenario/callbacks/derby-jdo-conf.xml" /&gt;
    &lt;property name="classDescriptorResolver" ref="classDescriptorResolver" /&gt;
    &lt;property name="callbackInterceptor" ref="jpaCallbackHandler" /&gt;
&lt;/bean&gt;

&lt;bean id="jpaCallbackHandler" class="org.castor.jdo.jpa.info.JPACallbackHandler" /&gt;
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.extensions"></a>6.7.&nbsp;Castor JPA Extensions</h2></div></div></div><p>
        This section describes all JPA-extensions provided by Castor.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jpa.extensions.cache"></a>6.7.1.&nbsp;@Cache and @CacheProperty</h3></div></div></div><p>
            In order to get the maximum out of the chosen built-in or
            external cache engine Castor provides a generic way to
            specify properties in a vendor-independent way.
            Castor allows for cache-tuning on a per-entity basis by
            simply providing key-value pairs with the <code class="interfacename">@CacheProperty</code>
            annotation in the <span class="interface">@Cache</span> container annnotation.
        </p><pre class="programlisting">
            @Entity
            @Cache({
                @CacheProperty(key=<span class="hl-string">"type"</span>, value=<span class="hl-string">"ehcache"</span>),
                @CacheProperty(key=<span class="hl-string">"capacity"</span>, value=<span class="hl-string">"50"</span>)
            })
            @Table(name=<span class="hl-string">"Cache_limited"</span>)
            <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> LimitedCachingEntity <span class="hl-keyword">implements</span> CacheTestEntity {
            
                <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
                <span class="hl-keyword">private</span> String name;
            
                @Id
                <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {
                    <span class="hl-keyword">return</span> id;
                }
            
                <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {
                    <span class="hl-keyword">this</span>.id = id;
                }
            
                <span class="hl-keyword">public</span> String getName() {
                    <span class="hl-keyword">return</span> name;
                }
            
                <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {
                    <span class="hl-keyword">this</span>.name = name;
                }
            
            }
        </pre><p>
            <span class="interface">@Cache</span> is based on Castor JDO and uses its default
            settings: 'count-limited' as cache type with a capacity of 30 entries.
        </p></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Spring ORM integration.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ddlgen.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:85%;"><a href="http://www.castor.org/" title="The Castor community">The Castor community</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;7.&nbsp;DDL generator for Castor JDO</td></tr></table></div></body></html>