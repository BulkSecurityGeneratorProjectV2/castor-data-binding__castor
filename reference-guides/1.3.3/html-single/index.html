<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Castor 1.3.3 - Reference documentation</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d4e1"></a>Castor 1.3.3 - Reference documentation</h1></div><div><p class="releaseinfo">1.3.3</p></div><div><div class="legalnotice"><a name="d4e5"></a>
      <p>Copies of this document may be made for your own use and for
      distribution to others, provided that you do not charge any fee for such
      copies and further provided that each copy contains this Copyright
      Notice, whether distributed in print or electronically.</p>
    </div></div></div><hr></div><div class="toc"><dl><dt><span class="chapter"><a href="#XML data binding">1. Castor XML - XML data binding</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9">1.1. XML framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e11">1.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#xml.framework.data.binding.framework">1.1.2. Castor XML - The XML data binding framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e34">1.1.2.1. Introspection mode</a></span></dt><dt><span class="section"><a href="#d4e63">1.1.2.2. Mapping mode</a></span></dt><dt><span class="section"><a href="#d4e117">1.1.2.3. Descriptor mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e120">1.1.3. Sources and destinations</a></span></dt><dt><span class="section"><a href="#d4e243">1.1.4. 
			XMLContext - A consolidated way to bootstrap Castor
		</a></span></dt><dt><span class="section"><a href="#d4e259">1.1.5. Using existing Classes/Objects</a></span></dt><dt><span class="section"><a href="#xml.framework.class.descriptors">1.1.6. Class Descriptors</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping">1.2. XML Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.introduction">1.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#xml.mapping.overview">1.2.2. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.overview.marshalling">1.2.2.1. Marshalling Behavior</a></span></dt><dt><span class="section"><a href="#xml.mapping.overview.unmarshalling">1.2.2.2. Unmarshalling Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping.mappingfile">1.2.3. The Mapping File</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.mapping.mappingfile.sampledomainobjects">1.2.3.1. Sample domain objects</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.mapping">1.2.3.2. The &lt;mapping&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.class">1.2.3.3. The &lt;class&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.mapto">1.2.3.4. The &lt;map-to&gt; element</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.field">1.2.3.5. The &lt;field&gt; element</a></span></dt><dt><span class="section"><a href="#d4e787">1.2.3.6. Description of the content</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.bindxml">1.2.3.7. The &lt;bind-xml&gt; element</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.mapping.mappingfile.bindxml.usagepattern">1.2.4. Usage Pattern</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.xsitype">1.2.5. xsi:type</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.locationattribute">1.2.6. Location attribute</a></span></dt><dt><span class="section"><a href="#xml.mapping.mappingfile.tips">1.2.7. Tips</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e964">1.2.7.1. Automatically create a mapping file</a></span></dt><dt><span class="section"><a href="#d4e968">1.2.7.2. Create your own FieldHandler</a></span></dt><dt><span class="section"><a href="#d4e973">1.2.7.3. Mapping constructor arguments (since 0.9.5)</a></span></dt><dt><span class="section"><a href="#d4e982">1.2.7.4. Preventing Castor from checking for a default constructor (since 0.9.5)</a></span></dt><dt><span class="section"><a href="#d4e985">1.2.7.5. Type safe enumeration mapping (since 0.9.5)</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.configuration">1.3. Configuring Castor XML (Un)Marshaller</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e991">1.3.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e994">1.3.2. Configuring the Marshaller</a></span></dt><dt><span class="section"><a href="#d4e1019">1.3.3. Configuring the Unmarshaller</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1041">1.4. Usage of Castor and XML parsers</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1043">1.4.1. SAX/DOM</a></span></dt><dt><span class="section"><a href="#d4e1073">1.4.2. StAX</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1079">1.5. XML configuration file</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1081">1.5.1. News</a></span></dt><dt><span class="section"><a href="#d4e1103">1.5.2. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1319">1.5.3. Accessing the properties from within code</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1341">1.6. Castor XML - Tips &amp; Tricks</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1343">1.6.1. Logging and Tracing</a></span></dt><dt><span class="section"><a href="#d4e1357">1.6.2. Indentation</a></span></dt><dt><span class="section"><a href="#d4e1363">1.6.3. XML:Marshal validation</a></span></dt><dt><span class="section"><a href="#d4e1368">1.6.4. NoClassDefFoundError</a></span></dt><dt><span class="section"><a href="#d4e1371">1.6.5. Mapping: auto-complete</a></span></dt><dt><span class="section"><a href="#d4e1384">1.6.6. Create method</a></span></dt><dt><span class="section"><a href="#d4e1401">1.6.7. MarshalListener and UnmarshalListener</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1429">1.7. Castor XML: Writing Custom FieldHandlers</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1431">1.7.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1439">1.7.2. Writing a simple FieldHandler</a></span></dt><dt><span class="section"><a href="#xml.field.handler.generalized">1.7.3. Writing a GeneralizedFieldHandler</a></span></dt><dt><span class="section"><a href="#d4e1480">1.7.4. Use ConfigurableFieldHandler for more flexibility</a></span></dt><dt><span class="section"><a href="#d4e1511">1.7.5. Reuse a <code class="classname">ConfigurableFieldHandler</code> for more than one field definition</a></span></dt><dt><span class="section"><a href="#d4e1525">1.7.6. No Constructor, No Problem!</a></span></dt><dt><span class="section"><a href="#d4e1548">1.7.7. Collections and FieldHandlers</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1570">1.8. Best practice</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1575">1.8.1. General</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1577">1.8.1.1. Source Generator</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1583">1.8.2. Performance Considerations</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1585">1.8.2.1. General</a></span></dt><dt><span class="section"><a href="#d4e1594">1.8.2.2. Use of XMLContext - With and without a mapping file</a></span></dt><dt><span class="section"><a href="#d4e1660">1.8.2.3. Use of Marshaller/Unmarshaller</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d4e1720">1.9. Castor XML - HOW-TO's</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1722">1.9.1. Introduction</a></span></dt><dt><span class="section"><a href="#d4e1725">1.9.2. Documentation</a></span></dt><dt><span class="section"><a href="#d4e1740">1.9.3. Contribution</a></span></dt><dt><span class="section"><a href="#d4e1755">1.9.4. Mapping</a></span></dt><dt><span class="section"><a href="#d4e1800">1.9.5. Validation</a></span></dt><dt><span class="section"><a href="#d4e1806">1.9.6. Source generation</a></span></dt><dt><span class="section"><a href="#d4e1812">1.9.7. Others</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e1824">1.10. XML FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.faq.general">1.10.1. General</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1852">1.10.1.1. How do I set the encoding?</a></span></dt><dt><span class="section"><a href="#d4e1858">1.10.1.2. 
				I'm getting an error about 'xml' prefix already
				declared?
			</a></span></dt><dt><span class="section"><a href="#d4e1873">1.10.1.3. Why is my 'get' method called twice?</a></span></dt><dt><span class="section"><a href="#d4e1876">1.10.1.4. 
				How can I speed up marshalling/unmarshalling
				performance?
			</a></span></dt><dt><span class="section"><a href="#d4e1897">1.10.1.5. 
				How do I ignore elements during unmarshalling?
			</a></span></dt><dt><span class="section"><a href="#d4e1910">1.10.1.6. 
				Where does Castor search for the castor.properties file?
			</a></span></dt><dt><span class="section"><a href="#d4e1924">1.10.1.7. 
				Can I programmatically change the properties found in
				the castor.properties file?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.introspection">1.10.2. Introspection</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1930">1.10.2.1. Can private methods be introspected?</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.mapping">1.10.3. Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1935">1.10.3.1. My mapping file seems to have no effect!</a></span></dt><dt><span class="section"><a href="#d4e1939">1.10.3.2. 
				Are there any tools to automatically create a mapping
				file?
			</a></span></dt><dt><span class="section"><a href="#d4e1944">1.10.3.3. 
				How do I specify a namespace in the mapping file?
			</a></span></dt><dt><span class="section"><a href="#d4e1951">1.10.3.4. 
				How do I prevent a field from being marshaled?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.marshalling">1.10.4. Marshalling</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1959">1.10.4.1. 
				The XML is marshalled on one line, how do I force
				line-breaks?
			</a></span></dt><dt><span class="section"><a href="#d4e1967">1.10.4.2. What is the order of the marshalled XML elements?</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.generation">1.10.5. Source code generation</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e1973">1.10.5.1. Can I use a DTD with the source generator?</a></span></dt><dt><span class="section"><a href="#d4e1977">1.10.5.2. 
				My XML output looks incorrect, what could be wrong?
			</a></span></dt><dt><span class="section"><a href="#d4e1982">1.10.5.3. 
				The generated source code has incorrect or missing
				imports for imported schema types
			</a></span></dt><dt><span class="section"><a href="#d4e2001">1.10.5.4. 
				How can I make the generated source code more JDO
				friendly?
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.misc">1.10.6. Miscellaneous</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2012">1.10.6.1. 
				Is there a way to automatically create an XML Schema
				from an XML instance?
			</a></span></dt><dt><span class="section"><a href="#d4e2016">1.10.6.2. How to enable XML validation with Castor XML</a></span></dt><dt><span class="section"><a href="#d4e2023">1.10.6.3. 
				Why is mapping ignored when using a FieldHandlerFactory
			</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.faq.serialization">1.10.7. Serialization</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2036">1.10.7.1. 
				Is it true that the use of Castor XML mandates 
                Apache Xerces as
				XML parser?
			</a></span></dt><dt><span class="section"><a href="#d4e2043">1.10.7.2. 
				Do I still have to download Xerces when using Castor XML
				with Java 5.0?
			</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#xml.code.generator">2. XML code generation</a></span></dt><dd><dl><dt><span class="section"><a href="#introduction.why-code-generator">2.1. Why Castor XML code generator - Motivation</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction">2.2. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.introduction.news">2.2.1. News</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.introduction.news.newFieldNamingConventions">2.2.1.1. Source generation &amp; Java field naming conventions</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.news.java50">2.2.1.2. Source generation &amp; Java 5.0</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.introduction.introduction">2.2.2. Introduction</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.invocation">2.2.3. Invoking the XML code generator</a></span></dt><dt><span class="section"><a href="#xml.code.generator.introduction.xml.schema">2.2.4. XML Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.properties">2.3. Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.properties.overview">2.3.1. Overview</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.process">2.3.2. Customization - Lookup mechanism</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed">2.3.3. Detailed descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.properties.detailed.java50">2.3.3.1. org.exolab.castor.builder.javaVersion</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.enumerations">2.3.3.2. org.exolab.castor.builder.javaVersion</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.bound.properties">2.3.3.3. org.exolab.castor.builder.boundproperties</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.class.creation">2.3.3.4. org.exolab.castor.builder.javaclassmapping</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.super.class">2.3.3.5. org.exolab.castor.builder.superclass</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.namespace.mapping">2.3.3.6. org.exolab.castor.builder.nspackages</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.equals">2.3.3.7. org.exolab.castor.builder.equalsmethod</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.use.cyclebreaker">2.3.3.8. org.exolab.castor.builder.useCycleBreaker</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.primitive.wrappers">2.3.3.9. org.exolab.castor.builder.primitivetowrapper</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.name.conflict.resolution">2.3.3.10. org.exolab.castor.builder.automaticConflictResolution</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.extra.collection">2.3.3.11. org.exolab.castor.builder.extraCollectionMethods</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.class.printing">2.3.3.12. org.exolab.castor.builder.jclassPrinterFactories</a></span></dt><dt><span class="section"><a href="#xml.code.generator.properties.detailed.extra.documentation">2.3.3.13. org.exolab.castor.builder.extraDocumentationMethods</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.custom.bindings">2.4. Custom bindings</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file">2.4.1. Binding File</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.binding">2.4.1.1. &lt;binding&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.include">2.4.1.2. &lt;include&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.package">2.4.1.3. &lt;package&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.namingXML">2.4.1.4. &lt;namingXML&gt; element</a></span></dt><dt><span class="section"><a href="#xml.code.generator.custom.bindings.file.componentBinding">2.4.1.5. &lt;componentBinding&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2643">2.4.1.6. &lt;java-class&gt;</a></span></dt><dt><span class="section"><a href="#d4e2706">2.4.1.7. &lt;member&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2760">2.4.1.8. &lt;contentMember&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2790">2.4.1.9. &lt;enumBinding&gt; element</a></span></dt><dt><span class="section"><a href="#d4e2809">2.4.1.10. Not implemented yet</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e2823">2.4.2. Class generation conflicts</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e2832">2.4.2.1. Collision reporting</a></span></dt><dt><span class="section"><a href="#d4e2876">2.4.2.2. Automatic collision resolution</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations">2.5. Invoking the XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.anttask">2.5.1. Ant task definition</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.source">2.5.1.1. Specifying the source for generation</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.parameters">2.5.1.2. Parameters</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.anttask.examples">2.5.1.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations.maven">2.5.2. Maven 2 plugin</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.maven.configuration">2.5.2.1. Configuration</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.maven.life-cycle">2.5.2.2. Integration into build life-cycle</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.maven.example">2.5.2.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.invocations.cmd">2.5.3. Command line</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.invocations.cmd.first.steps">2.5.3.1. First steps</a></span></dt><dt><span class="section"><a href="#xml.code.generator.invocations.cmd.options">2.5.3.2. Source Generator - command line options</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.schema.support">2.6. XML schema support</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e3439">2.6.1. Supported XML Schema Built-in Datatypes</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.schema.support.datatypes.built-in.primitive">2.6.1.1. Primitive Datatypes</a></span></dt><dt><span class="section"><a href="#xml.code.generator.schema.support.datatypes.built-in.derived">2.6.1.2. Derived Datatypes</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.schema.support.structures">2.6.2. Supported XML Schema Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.schema.support.structures.groups">2.6.2.1. Groups</a></span></dt><dt><span class="section"><a href="#xml.code.generator.schema.support.structures.wildcard">2.6.2.2. Wildcard</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#xml.code.generator.examples">2.7. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema">2.7.1. The invoice XML schema</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.file">2.7.1.1. The schema file</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.running">2.7.1.2. Running the XML code generator</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.invoice.schema.generated">2.7.1.3. The generated code</a></span></dt></dl></dd><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial">2.7.2. Non-trivial real world example</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial.schema">2.7.2.1. The Supply Chain XSD</a></span></dt><dt><span class="section"><a href="#xml.code.generator.examples.non-trivial.binding">2.7.2.2. Binding file? -- IT IS REQUIRED!</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#jdo">3. Castor JDO</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.introduction">3.1. Castor JDO - An introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.introduction.what">3.1.1. What is Castor JDO</a></span></dt><dt><span class="section"><a href="#jdo.introduction.features">3.1.2. Features</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.first-steps">3.2. Castor JDO - First steps</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.first-steps.introduction">3.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#jdo.first-steps.sample-domain-ojects">3.2.2. Sample domain objects</a></span></dt><dt><span class="section"><a href="#jdo.first-steps.first-time-use">3.2.3. Using Castor JDO for the first time</a></span></dt><dt><span class="section"><a href="#jdo.first-steps.configuration">3.2.4. JDO configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.usage">3.3. Using Castor JDO</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.usage.database-connection">3.3.1. Opening A JDO Database</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.usage.database-connection.stand-alone">3.3.1.1. Stand-alone application</a></span></dt><dt><span class="section"><a href="#jdo.usage.database-connection.j2ee">3.3.1.2. J2EE Application</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.usage.database-persistence">3.3.2. Using A JDO Database to perform persistence operations</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.usage.database-persistence.objects">3.3.2.1. Transient And Persistent Objects</a></span></dt><dt><span class="section"><a href="#jdo.usage.database-persistence.query">3.3.2.2. Running an OQL Query</a></span></dt><dt><span class="section"><a href="#jdo.usage.database-persistence.create">3.3.2.3. Creating a persistent object</a></span></dt><dt><span class="section"><a href="#jdo.usage.database-persistence.remove">3.3.2.4. Removing a persistent object</a></span></dt><dt><span class="section"><a href="#jdo.usage.database-persistence.update">3.3.2.5. Updating a persistent object</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.usage.jdo-and-xml">3.3.3. Using JDO And XML</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.configuration">3.4. Castor JDO - Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.configuration.configuration-file">3.4.1. The Castor configuration file</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.configuration.configuration-file.transaction">3.4.1.1. Transaction demarcation</a></span></dt><dt><span class="section"><a href="#jdo.configuration.configuration-file.sample">3.4.1.2. Sample Configuration File</a></span></dt><dt><span class="section"><a href="#jdo.configuration.configuration-file.pooling">3.4.1.3. Prepared statement pooling</a></span></dt><dt><span class="section"><a href="#jdo.configuration.configuration-file.sample-files">3.4.1.4. Sample configurations for various databases</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.configuration.jdoconffactory">3.4.2. JDOConfFactory - A programmatic way of configuring Castor JDO</a></span></dt><dt><span class="section"><a href="#jdo.configuration.references">3.4.3. References</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.configuration.references.dtd">3.4.3.1. The JDO Configuration DTD</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jdo.types">3.5. Type Support</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.types.types">3.5.1. Types</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.types.types.castor-xml">3.5.1.1. Castor XML</a></span></dt><dt><span class="section"><a href="#jdo.types.types.castor-jdo">3.5.1.2. Castor JDO</a></span></dt><dt><span class="section"><a href="#jdo.types.types.castor-dax">3.5.1.3. Castor DAX</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.types.field-mapping">3.5.2. The Field Mapping</a></span></dt><dt><span class="section"><a href="#jdo.types.dates-timezones">3.5.3. SQL Dates and Default Timezones</a></span></dt><dt><span class="section"><a href="#jdo.types.type-conversion">3.5.4. SQL Type Conversion</a></span></dt><dt><span class="section"><a href="#jdo.types.type-convertors">3.5.5. Parameterized Type Convertors</a></span></dt><dt><span class="section"><a href="#jdo.types.blob-clob">3.5.6. BLOB and CLOB Types</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.mapping">3.6. Castor JDO Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.mapping.news">3.6.1. News</a></span></dt><dt><span class="section"><a href="#jdo.mapping.introduction">3.6.2. Introduction</a></span></dt><dt><span class="section"><a href="#jdo.mapping.file">3.6.3. The Mapping File</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.mapping.file.mapping-element">3.6.3.1. The &lt;mapping&gt; element</a></span></dt><dt><span class="section"><a href="#jdo.mapping.file.class-element">3.6.3.2. The &lt;class&gt; element</a></span></dt><dt><span class="section"><a href="#jdo.mapping.file.map-to-element">3.6.3.3. The &lt;map-to&gt; element</a></span></dt><dt><span class="section"><a href="#jdo.mapping.file.field-element">3.6.3.4. The &lt;field&gt; element</a></span></dt><dt><span class="section"><a href="#jdo.mapping.file.sql-element">3.6.3.5. The &lt;sql&gt; element</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jdo.faq">3.7. Castor JDO FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.other-specifications">3.7.1. Castor's relation to other specifications</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.other-specifications.sun-jsr-000012">3.7.1.1. Does Castor JDO comply with the SUN JSR-000012 specification?</a></span></dt><dt><span class="section"><a href="#jdo.faq.other-specifications.ejb-cmp">3.7.1.2. Is Castor JDO better than EJB CMP?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.xml">3.7.2. XML related questions</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.xml.marsgalling-transactional">3.7.2.1. Is it possible to make XML marshalling transactionally using Castor?</a></span></dt><dt><span class="section"><a href="#jdo.faq.xml.xml-file-queries">3.7.2.2. Is it possible to do queries on a XML file using Castor?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.technical">3.7.3. Technical questions</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.technical.examples">3.7.3.1. Where can I find some examples to start with?</a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.sub-jdbc-odbc">3.7.3.2. I have encountered problems using Sun JDBC-ODBC bridge with Castor...</a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.collection-get-method">3.7.3.3. 
              My get-method for the Collection of dependent objects returns null. 
              Why?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.implement-interfaces">3.7.3.4. Should my JDO classes implement some special interface?</a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.create-or-remove">3.7.3.5. Can Castor automatically create/remove related objects?</a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.connection-pooling">3.7.3.6. 
	            Is Castor JDO using any connection pooling mechanism to improve 
	            the overall performance?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.classnotfoundexception">3.7.3.7. 
               I am getting ClassNotFoundException for my JDO class, 
               but it is in the class path. Why?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.notpersistencecapable">3.7.3.8. 
              I am getting exception 
              'the class ... is not persistence capable...'. Why?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.db-remove">3.7.3.9. 
	            I call db.remove() on the dependent object and commit, 
	            but this doesn't work...
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.string-date-boolean-literals">3.7.3.10. 
	            How should I represent string/date/boolean literals in OQL query?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.abstractmethoderror">3.7.3.11. 
	            I get 'java.lang.AbstractMethodError: getBigDecimal' 
	            for numeric fields. Why?
             </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.bi-directional">3.7.3.12. Does Castor support both one-way and two-way relationships?</a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.self-relation">3.7.3.13. 
	            I have an object that holds a relation to itself. 
	            Does Castor support this?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.objectmodifiedexception">3.7.3.14. 
	            Why do I get an ObjectModifiedException when trying to commit 
	            a transaction?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.technical.ora-01461">3.7.3.15. I'm receiving a java.sql.SQLException: ORA-01461</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.performance-caches">3.7.4. Castor and performance caches</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.performance-caches.objectmodifiedexception">3.7.4.1. 
	            Sometimes long transaction fails: on update() it is thrown 
	            ObjectModifiedException. Why?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.performance-caches.cache-type-none">3.7.4.2. Can I use the cache-type='none' with long transactions?</a></span></dt><dt><span class="section"><a href="#jdo.faq.performance-caches.persistenceexception">3.7.4.3. 
	            What is causing a PersistenceException with long transactions and 
	            how do I fix it?
            </a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.oql">3.7.5. OQL</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.oql.document">3.7.5.1. Is there any document available for Castor OQL?</a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.phase">3.7.5.2. 
	            The OQL document describes several phases of development. 
	            Which is the current phase?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.sub-queries">3.7.5.3. Does Castor OQL support sub-queries?</a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.join">3.7.5.4. 
	            I cannot get Castor OQL to join two objects for me. Is it supported?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.pass-thru">3.7.5.5. Can I write a pass-thru OQL?</a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.struct">3.7.5.6. Does Castor OQL support struct?</a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.like">3.7.5.7. How do I structure a query using the 'LIKE' expression?</a></span></dt><dt><span class="section"><a href="#jdo.faq.oql.in">3.7.5.8. Does Castor support the SQL 'IN' expression?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.feature-requests">3.7.6. Features requests</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.feature-requests.foreign-key-multiple">3.7.6.1. Can a foreign key be part of multiple primary keys?</a></span></dt><dt><span class="section"><a href="#jdo.faq.feature-requests.polymorphic-collection">3.7.6.2. Is polymorphic collection supported?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.data-model">3.7.7. Data model issues</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.data-model.map-to-multiple-tables">3.7.7.1. Is it possible to map an object to more than one tables?</a></span></dt><dt><span class="section"><a href="#jdo.faq.data-model.remove-recreate">3.7.7.2. 
	            Can an object with the same identity be re-created after being removed 
	            in the same transaction?
            </a></span></dt><dt><span class="section"><a href="#jdo.faq.data-model.dependent-object">3.7.7.3. What is a dependent object?</a></span></dt><dt><span class="section"><a href="#jdo.faq.data-model.dependent-many-to-many">3.7.7.4. 
	            Can a data object involved in many-to-many relationship be dependent?
	        </a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.design">3.7.8. Castor JDO design</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.design.functionality">3.7.8.1. How does Castor JDO work anyway?</a></span></dt><dt><span class="section"><a href="#jdo.faq.design.two-phase-commits">3.7.8.2. 
	            Does Castor support two-phase commits? How is this implemented?
	        </a></span></dt><dt><span class="section"><a href="#jdo.faq.design.nested-transaction">3.7.8.3. Does Castor support nested transaction?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.open-source-databases">3.7.9. Working with open source databases</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.open-source-databases.postgresql">3.7.9.1. Does Castor support PosgreSQL?</a></span></dt><dt><span class="section"><a href="#jdo.faq.open-source-databases.mysql">3.7.9.2. Does Castor support MySQL?</a></span></dt><dt><span class="section"><a href="#jdo.faq.open-source-databases.which">3.7.9.3. Which Open Source database is supported better?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.rdbms-specific">3.7.10. RDBMS-specific issues</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.rdbms-specific.mysql">3.7.10.1. MySQL</a></span></dt><dt><span class="section"><a href="#jdo.faq.rdbms-specific.oracle">3.7.10.2. Oracle</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.logging">3.7.11. Castor &amp; Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.logging.log4j">3.7.11.1. 
	            How can I integrate Castor's logging with a logging infrastructure 
	            using Log4J?
	        </a></span></dt><dt><span class="section"><a href="#jdo.faq.logging.sql-statement">3.7.11.2. 
			    Can I see what SQL statement Castor issues to the database as a result 
			    of an operation?
			</a></span></dt><dt><span class="section"><a href="#jdo.faq.logging.disable-jdbc-proxy-classes">3.7.11.3. How can I disable the use of JDBC proxy classes?</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.lazy-loading">3.7.12. Lazy Loading related questions</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.lazy-loading.1-to-1">3.7.12.1. 
	           How do I configure the JDO mapping to use the lazy loading feature 
	           for 1:1 relations?
           </a></span></dt><dt><span class="section"><a href="#jdo.faq.lazy-loading.1-to-1-serialization">3.7.12.2. Lazy loading for 1:1 relations and serialization</a></span></dt><dt><span class="section"><a href="#jdo.faq.lazy-loading.1-to-m-m-to-n">3.7.12.3. 
	           How do I configure the JDO mapping to use the lazy loading feature for 
	           1:m and M:N relations?
	       </a></span></dt><dt><span class="section"><a href="#jdo.faq.lazy-loading.no-method-error">3.7.12.4. 
               I have modified my mapping to use lazy loading. Now I get the error 
               'no method to set value for field: com.xyz.ClassB in class: 
               ClassMolder com.xyz.ClassA' or 
               'org.exolab.castor.jdo.DataObjectAccessException: no method to set 
               value for field: com.xyz.ClassB in class: ClassMolder com.xyz.ClassA'. 
               What am I doing wrong?
           </a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.lob-tuning">3.7.13. Tuning for LOBs</a></span></dt><dt><span class="section"><a href="#jdo.faq.database-specific">3.7.14. Database-specific issues</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.faq.database-specific.hsql-identity-key-generators">3.7.14.1. HSQL and identity key generators</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.faq.change-configurations">3.7.15. Changing database configurations</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.code-samples">3.8. Castor JDO code samples</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.code-samples.introduction">3.8.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.code-samples.introduction.java-class-files">3.8.1.1. Java class files</a></span></dt><dt><span class="section"><a href="#jdo.code-samples.introduction.ddl">3.8.1.2. DDL</a></span></dt><dt><span class="section"><a href="#jdo.code-samples.introduction.object-mappings">3.8.1.3. Object Mappings</a></span></dt><dt><span class="section"><a href="#jdo.code-samples.relations">3.8.1.4. Relations</a></span></dt><dt><span class="section"><a href="#jdo.code-samples.extend-relation-polymorphism">3.8.1.5. Extend relation &amp; polymorphism</a></span></dt><dt><span class="section"><a href="#jdo.code-samples.oql-samples">3.8.1.6. OQL samples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jdo.howto">3.9. Castor JDO - How To's</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.introduction">3.9.1. Introduction</a></span></dt><dt><span class="section"><a href="#jdo.howto.documentation">3.9.2. Documentation</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e5642">3.9.2.1. How to author a HOW-TO document</a></span></dt><dt><span class="section"><a href="#d4e5644">3.9.2.2. How to author an FAQ entry</a></span></dt><dt><span class="section"><a href="#d4e5646">3.9.2.3. How to author a code snippet</a></span></dt><dt><span class="section"><a href="#d4e5648">3.9.2.4. How to author core documentation</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.contribution">3.9.3. Contribution</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.setup-eclipse-castor-project">3.9.3.1. How to setup Castor project in eclipse</a></span></dt><dt><span class="section"><a href="#jdo.howto.jdo-unit-tests">3.9.3.2. How to run Castor JDO's database independend unit tests</a></span></dt><dt><span class="section"><a href="#jdo.howto.jdo-test-suite">3.9.3.3. How to run Castor JDO's test suite</a></span></dt><dt><span class="section"><a href="#jdo.howto.performance-tests">3.9.3.4. How to run Castor JDO's performance tests</a></span></dt><dt><span class="section"><a href="#jdo.howto.submit-a-bug">3.9.3.5. Submitting a bug report</a></span></dt><dt><span class="section"><a href="#jdo.howto.prepare-a-patch">3.9.3.6. How to prepare a patch</a></span></dt><dt><span class="section"><a href="#d4e6447">3.9.3.7. How to Contribute a Patch via Jira</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.oql">3.9.4. OQL</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.use-limit-clause">3.9.4.1. How to use a LIMIT clause with OQL</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.core-features">3.9.5. Core features</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.use-a-cache">3.9.5.1. How to use a (performance) cache with Castor</a></span></dt><dt><span class="section"><a href="#jdo.howto.map-enums">3.9.5.2. How to map typesafe enumerations with Castor</a></span></dt><dt><span class="section"><a href="#jdo.howto.use-connection-proxies">3.9.5.3. How to use Castor JDO's connection proxies</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.cascading">3.9.6. Cascading</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.use-cascading-operations">3.9.6.1. How to use cascading operations</a></span></dt><dt><span class="section"><a href="#jdo.howto.cascade-creation">3.9.6.2. How to cascade creation</a></span></dt><dt><span class="section"><a href="#jdo.howto.cascade-deletion">3.9.6.3. How to cascade deletion</a></span></dt><dt><span class="section"><a href="#jdo.howto.cascade-update">3.9.6.4. How to cascade update</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.caches">3.9.7. Caches</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.use-castor-in-a-j2ee-cluster">3.9.7.1. How to use Castor in a J2EE cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.connection-pooling">3.9.8. Connection pooling</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.use-jakarta-dbcp">3.9.8.1. How to use Jakarta's DBCP for connection pooling</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.castor-in-j2ee-apps">3.9.9. Use of Castor in J2EE applications</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.howto.distributed-transactions">3.9.9.1. How to use Castor with(in) distributed J2EE transactions</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.howto.database-specifica">3.9.10. Database specifica</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e7420">3.9.10.1. 
                  How to connect to a Apache Derby instance in network server mode
              </a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#jdo.tips-tricks">3.10. Castor JDO - Tips &amp; Tricks</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.tips-tricks.logging-tracing">3.10.1. Logging and Tracing</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.access-mode">3.10.2. Access Mode</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.inheritence">3.10.3. Inheritence</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.views-of-the-same-object">3.10.4. Views of Same Object</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.upgrading-locks">3.10.5. Upgrading Locks</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.noclassdeffounderror">3.10.6. NoClassDefFoundError</a></span></dt><dt><span class="section"><a href="#jdo.tips-tricks.create-method">3.10.7. Create method</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.advanced-features">3.11. Castor JDO - Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.advanced-features.introduction">3.11.1. Introduction</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.caching">3.11.2. Caching</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.dependent-and-related">3.11.3. Dependent and related relationships</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.different-cardinalities">3.11.4. Different cardinalities of relationship</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.lazy-loading">3.11.5. Lazy Loading</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.advanced-features.1-to-1-relations">3.11.5.1. 1:1 relations</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.m-to-n-relations">3.11.5.2. 1:M and M:N relations</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.advanced-features.multiple-cols-primary-keys">3.11.6. Multiple columns primary keys</a></span></dt><dt><span class="section"><a href="#jdo.advanced-features.callback-interface">3.11.7. Callback interface for persistent operations</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.self-executable-examples">3.12. Running the self-executable Castor JDO examples</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.self-executable-examples.zip-archive">3.12.1. Download the castor-$RELEASE-examples.zip archive</a></span></dt><dt><span class="section"><a href="#jdo.self-executable-examples.unpack-zip">3.12.2. Unpack the ZIP file</a></span></dt><dt><span class="section"><a href="#jdo.self-executable-examples.run">3.12.3. Running the Castor JDO samples</a></span></dt><dt><span class="section"><a href="#jdo.self-executable-examples.what-happens">3.12.4. What happens</a></span></dt><dt><span class="section"><a href="#jdo.self-executable-examples.hints">3.12.5. Hints</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#advanced-jdo">4. Advanced JDO</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.caching">4.1. Castor JDO - Caching</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.caching.introduction">4.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.long-transactions">4.1.2. Caching and long transactions</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.configuration">4.1.3. Configuration</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.configuration.fifo-lru">4.1.4. fifo and lru cache providers</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.configuration.clustered-environments">4.1.5. Caching and clustered environments</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.custom-provider">4.1.6. Custom cache provider</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.caching.custom-provider.cache-implementation">4.1.6.1. Cache implementation</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.custom-provider.cachefactory-implementation">4.1.6.2. CacheFactory implementation</a></span></dt><dt><span class="section"><a href="#advanced-jdo.caching.custom-provider.configuration">4.1.6.3. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.caching.cachemanager">4.1.7. CacheManager - monitoring and clearing caches</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator">4.2. OQL to SQL translator</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.news">4.2.1. News</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.status">4.2.2. Status</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.introduction">4.2.3. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.overview">4.2.4. Overview</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.syntax">4.2.5. Syntax</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.type-and-validity-checking">4.2.6. Type and validity checking</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.sql-generation">4.2.7. SQL Generation</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.oql-faq">4.2.8. OQL FAQ</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.summary">4.2.9. Summary</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.examples">4.2.10. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.examples.java-class-files">4.2.10.1. Java class files</a></span></dt><dt><span class="section"><a href="#advanced-jdo.oql-to-sql-translator.limit-clause">4.2.10.2. Limit Clause</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#advanced-jdo.locking">4.3. Transaction And Locking Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.locking.model">4.3.1. The JDO Model</a></span></dt><dt><span class="section"><a href="#advanced-jdo.locking.modes">4.3.2. Locking Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.locking.modes.shared">4.3.2.1. Access mode: Shared</a></span></dt><dt><span class="section"><a href="#advanced-jdo.locking.modes.exclusive">4.3.2.2. Access mode: Exclusive</a></span></dt><dt><span class="section"><a href="#advanced-jdo.locking.modes.database-locked">4.3.2.3. Access mode: Database Locked</a></span></dt><dt><span class="section"><a href="#advanced-jdo.locking.modes.read-only-queries">4.3.2.4. Read-only Queries</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.locking.visibility-of-changes">4.3.3. Visibility of Changes</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.persist">4.4. Castor Persistence Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.persist.layered-architecture">4.4.1. Layered Achitecture</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api">4.4.2. Persistence API</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.persist.api.transactions">4.4.2.1. Transactions</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api.oids-and-locks">4.4.2.2. OIDs and Locks</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api.cache-engine">4.4.2.3. Cache Engine</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api.pessimistic-or-optimistic-locking">4.4.2.4. Pessimistic/Optimistic Locking</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api.relations">4.4.2.5. Relations</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.api.queryresults">4.4.2.6. QueryResults</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.persist.spi">4.4.3. Service Providers (SPI)</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.persist.spi.persistence">4.4.3.1. Persistence</a></span></dt><dt><span class="section"><a href="#advanced-jdo.persist.spi.persistencequery">4.4.3.2. PersistenceQuery</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.persist.ejb-cmp">4.4.4. Enterprise JavaBeans CMP</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.key-generator">4.5. Castor JDO Key Generator Support</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.key-generator.introduction">4.5.1. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.key-generator.max">4.5.2. MAX key generator</a></span></dt><dt><span class="section"><a href="#advanced-jdo.key-generator.high-low">4.5.3. HIGH-LOW key generator</a></span></dt><dt><span class="section"><a href="#advanced-jdo.key-generator.uuid">4.5.4. UUID key generator</a></span></dt><dt><span class="section"><a href="#advanced-jdo.key-generator.identity">4.5.5. IDENTITY key generator</a></span></dt><dt><span class="section"><a href="#advanced-jdo.key-generator.sequence">4.5.6. SEQUENCE key generator</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.long-transactions">4.6. Castor JDO Long Transactions Support</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.long-transactions.introduction">4.6.1. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.long-transactions.bounded-dirty-checking">4.6.2. Bounded dirty checking</a></span></dt><dt><span class="section"><a href="#advanced-jdo.long-transactions.no-dependance-on-cache">4.6.3. Long transactions that do not depend on cache</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.nested-attributes">4.7. Nested Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.nested-attributes.introduction">4.7.1. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.nested-attributes.application-types">4.7.2. Application types</a></span></dt><dt><span class="section"><a href="#advanced-jdo.nested-attributes.compound-attributes">4.7.3. Compound types</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.pooling">4.8. Using Pooled Database Connections</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.pooling.news">4.8.1. News</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.agents">4.8.2. Pooling Agents</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.standard-database-connections">4.8.3. Standard Database Connections</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.jdbc-datasources">4.8.4. Pooling and JDBC DataSources</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.pooling.jdbc-datasources.postgresql-7-3">4.8.4.1. PostgreSQL 7.3 and later</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.jdbc-datasources.oracle">4.8.4.2. Oracle</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.jdbc-datasources.mysql">4.8.4.3. mySQL</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.pooling.tomcat-jdbc-configuration">4.8.5. Configuring JDBC DataSources in Tomcat to be used with Castor</a></span></dt><dt><span class="section"><a href="#advanced-jdo.pooling.jakarta-commons-dbcp">4.8.6. Jakarta Commons DBCP - BasicDataSource</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.pooling.jakarta-commons-dbcp.prepared-statement">4.8.6.1. Prepared statement pooling</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#advanced-jdo.postgresql-blobs">4.9. Blobs in PostgreSQL</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.postgresql-blobs.oid-support">4.9.1. OID Support</a></span></dt><dt><span class="section"><a href="#advanced-jdo.postgresql-blobs.oid-example">4.9.2. OID Example</a></span></dt></dl></dd><dt><span class="section"><a href="#advanced-jdo.best-practice">4.10. Castor JDO - Best practice</a></span></dt><dd><dl><dt><span class="section"><a href="#advanced-jdo.best-practice.introduction">4.10.1. Introduction</a></span></dt><dt><span class="section"><a href="#advanced-jdo.best-practice.general-suggestions">4.10.2. General suggestions</a></span></dt><dt><span class="section"><a href="#advanced-jdo.best-practice.further-optimization">4.10.3. Further optimization</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Spring ORM integration">5. Castor JDO - Integration with Spring ORM</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9308">5.1. Usage</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9310">5.1.1. Getting started using Maven 2</a></span></dt><dt><span class="section"><a href="#d4e9318">5.1.2. Project dependencies</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e9327">5.2. A high-level overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9331">5.2.1. Sample domain objects</a></span></dt><dt><span class="section"><a href="#d4e9337">5.2.2. Using Castor JDO manually</a></span></dt><dt><span class="section"><a href="#d4e9347">5.2.3. Using Castor JDO with Spring ORM - Without CastorTemplate</a></span></dt><dt><span class="section"><a href="#d4e9356">5.2.4. Using Castor JDO with Spring ORM - With CastorTemplate</a></span></dt><dt><span class="section"><a href="#d4e9368">5.2.5. Using Castor JDO with Spring ORM - With CastorDaoSupport</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e9380">5.3. Data access through Castor JDO with the Spring framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9383">5.3.1. Resource management</a></span></dt><dt><span class="section"><a href="#d4e9387">5.3.2. JDOManager setup in a Spring container</a></span></dt><dt><span class="section"><a href="#d4e9394">5.3.3. The CastorTemplate</a></span></dt><dt><span class="section"><a href="#d4e9403">5.3.4. Implementing Spring-based DAOs without callbacks</a></span></dt><dt><span class="section"><a href="#d4e9408">5.3.5. Programmatic transaction demarcation</a></span></dt><dt><span class="section"><a href="#d4e9414">5.3.6. Declarative transaction demarcation</a></span></dt><dt><span class="section"><a href="#d4e9424">5.3.7. Transaction management strategies</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e9432">5.4. Build instructions</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9434">5.4.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#d4e9444">5.4.2. Building the Spring ORM module</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#jpa">6. Castor JDO - Support for the JPA specification</a></span></dt><dd><dl><dt><span class="section"><a href="#jpa.why">6.1. JPA annotations - Motivation</a></span></dt><dt><span class="section"><a href="#d4e9475">6.2. Prerequisites and outline</a></span></dt><dt><span class="section"><a href="#jpa.annotations.limitations">6.3. Limitations and Basic Information</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9483">6.3.1. persistence.xml</a></span></dt><dt><span class="section"><a href="#d4e9495">6.3.2. JPA access type and the placing of JPA annotations</a></span></dt><dt><span class="section"><a href="#d4e9498">6.3.3. Primary Keys</a></span></dt><dt><span class="section"><a href="#d4e9508">6.3.4. Inheritance, mapped superclasses, etc.</a></span></dt><dt><span class="section"><a href="#d4e9512">6.3.5. Relations</a></span></dt></dl></dd><dt><span class="section"><a href="#jpa.annotations">6.4. An outline of JPA-Annotations</a></span></dt><dt><span class="section"><a href="#d4e9790">6.5. Usage of JPA annotations - Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9802">6.5.1. HOW-TO persist a single class (@Entity, @Table, @Id)</a></span></dt><dt><span class="section"><a href="#d4e9825">6.5.2. HOW-TO persist a 1:1 relation (@OneToOne)</a></span></dt><dt><span class="section"><a href="#d4e9846">6.5.3. Persist one to many relation (@OnetoMany)</a></span></dt><dt><span class="section"><a href="#d4e9852">6.5.4. HOW-TO create and use a named query (@NamedQuery)</a></span></dt><dt><span class="section"><a href="#d4e9881">6.5.5. HOW-TO create and use multiple named queries (@NamedQueries)</a></span></dt><dt><span class="section"><a href="#d4e9890">6.5.6. HOW-TO create and use a named native query (@NamedNativeQuery)</a></span></dt><dt><span class="section"><a href="#d4e9899">6.5.7. HOW-TO create and use multiple named native queries (@NamedNativeQueries)</a></span></dt><dt><span class="section"><a href="#d4e9906">6.5.8. HOW-TO use persistence callbacks</a></span></dt><dt><span class="section"><a href="#d4e9931">6.5.9. HOW-TO use @Enumerated</a></span></dt><dt><span class="section"><a href="#d4e9940">6.5.10. HOW-TO use @Temporal</a></span></dt><dt><span class="section"><a href="#d4e9946">6.5.11. HOW-TO use @Lob</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e9953">6.6. Integration with Spring ORM for Castor JDO</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e9956">6.6.1. A typical sample</a></span></dt><dt><span class="section"><a href="#d4e9975">6.6.2. Adding a <code class="classname">JDOClassDescriptorResolver</code> configuration</a></span></dt><dt><span class="section"><a href="#d4e10000">6.6.3. JPA Callbacks</a></span></dt></dl></dd><dt><span class="section"><a href="#jpa.extensions">6.7. Castor JPA Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="#jpa.extensions.cache">6.7.1. @Cache and @CacheProperty</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ddlgen">7. DDL generator for Castor JDO</a></span></dt><dd><dl><dt><span class="section"><a href="#ddlgen.introduction">7.1. Castor DDL Generator - An Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10025">7.1.1. DDL Generator Options</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10030">7.1.1.1. Command Line Options</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e10075">7.1.2. Database Engines</a></span></dt></dl></dd><dt><span class="section"><a href="#ddlgen.ant.task">7.2. Using the Ant task for the Castor DDL Generator</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10141">7.2.1. Configuration</a></span></dt><dt><span class="section"><a href="#d4e10176">7.2.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#ddlgen.mapping">7.3. Castor DDL Generator - Type Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10509">7.3.1. JDBC Types not supported by Castor</a></span></dt></dl></dd><dt><span class="section"><a href="#ddlgen.introduction">7.4. Castor DDL Generator - Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10520">7.4.1. Overview</a></span></dt><dt><span class="section"><a href="#d4e10533">7.4.2. Global properties</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10810">7.4.2.1. Supported database engines</a></span></dt><dt><span class="section"><a href="#d4e10814">7.4.2.2. Grouping of DDL statements</a></span></dt></dl></dd><dt><span class="section"><a href="#d4e10823">7.4.3. Specific properties</a></span></dt><dd><dl><dt><span class="section"><a href="#d4e10826">7.4.3.1. Properties common for all database engines</a></span></dt><dt><span class="section"><a href="#d4e10855">7.4.3.2. Properties for db2, hsql, Oracle, Postgresql and sapdb</a></span></dt><dt><span class="section"><a href="#d4e10880">7.4.3.3. Properties for MySQL only</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#xml.code.generator.extensions">8. XML code generation - Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="#xml.code.generator.extensions.why">8.1. XML code generation extensions - Motivation</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.extensions">8.1.1. JDO extensions for the Castor XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#jdo.extensions.why">8.1.1.1. JDO extensions - Motivation</a></span></dt><dt><span class="section"><a href="#jdo.extensions.limitations">8.1.1.2. Limitations</a></span></dt><dt><span class="section"><a href="#jdo.extensions.prerequisites">8.1.1.3. Prerequisites</a></span></dt><dt><span class="section"><a href="#jdo.extensions.generation">8.1.1.4. Configuring the XML code generator</a></span></dt><dt><span class="section"><a href="#jdo.extensions.schema.elements">8.1.1.5. The JDO annotations for XML schemas</a></span></dt><dt><span class="section"><a href="#jdo.extensions.usage">8.1.1.6. Using the generated (domain) classes with Castor JDO</a></span></dt></dl></dd><dt><span class="section"><a href="#jdo.extensions">8.1.2. SOLRJ extensions for the Castor XML code generator</a></span></dt><dd><dl><dt><span class="section"><a href="#solrj.extensions.why">8.1.2.1. SOLRJ extensions - Motivation</a></span></dt><dt><span class="section"><a href="#solrj.extensions.prerequisites">8.1.2.2. Prerequisites</a></span></dt><dt><span class="section"><a href="#solrj.extensions.schema.elements">8.1.2.3. The SOLRJ annotations for XML schemas</a></span></dt><dt><span class="section"><a href="#solrj.extensions.usage">8.1.2.4. Using the generated domain classes with SOLR</a></span></dt></dl></dd></dl></dd></dl></dd></dl></div>
  

  

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="XML data binding"></a>Chapter&nbsp;1.&nbsp;Castor XML - XML data binding</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9"></a>1.1.&nbsp;XML framework</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e11"></a>1.1.1.&nbsp;Introduction</h3></div></div></div><p>
			Castor XML is an XML data binding framework. Unlike the two
			main XML APIs, DOM (Document Object Model) and SAX (Simple
			API for XML) which deal with the structure of an XML
			document, Castor enables you to deal with the data defined
			in an XML document through an object model which represents
			that data.
		</p><p>
			Castor XML can marshal almost any "bean-like" Java Object to
			and from XML. In most cases the marshalling framework uses a
			set of ClassDescriptors and FieldDescriptors to describe how
			an Object should be marshalled and unmarshalled from XML.
		</p><p>
			For those not familiar with the terms "marshal" and
			"unmarshal", it's simply the act of converting a stream
			(sequence of bytes) of data to and from an Object. The act
			of "marshalling" consists of converting an Object to a
			stream, and "unmarshalling" from a stream to an Object.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.data.binding.framework"></a>1.1.2.&nbsp;Castor XML - The XML data binding framework</h3></div></div></div><p>
			The XML data binding framework, as it's name implies, is
			responsible for doing the conversion between Java and XML.
			The framework consists of two worker classes,
			<code class="classname">org/exolab/castor/xml/Marshaller</code>	and
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			respectively, and a bootstrap class
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			used for configuration of the XML data binding framework and
			instantiation of the two worker objects.
		</p><p>
			Lets walk through a very simple example. Assume we have a
			simple
			<code class="classname">Person</code>
			class as follows:
		</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/** An simple person class */</span> 
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person <span class="hl-keyword">implements</span> java.io.Serializable {

   <span class="hl-comment">/** The name of the person */</span> 
   <span class="hl-keyword">private</span> String name = null;

   <span class="hl-comment">/** The Date of birth */</span> 
   <span class="hl-keyword">private</span> Date dob = null;

   <span class="hl-comment">/** Creates a Person with no name */</span> 
   <span class="hl-keyword">public</span> Person() {
      <span class="hl-keyword">super</span>(); 
   }

   <span class="hl-comment">/** Creates a Person with the given name */</span> 
   <span class="hl-keyword">public</span> Person(String name) { <span class="hl-keyword">this</span>.name = name; }

   <span class="hl-comment">/** 
     * @return date of birth of the person 
     */</span> 
   <span class="hl-keyword">public</span> Date getDateOfBirth() { <span class="hl-keyword">return</span> dob; }

   <span class="hl-comment">/** 
     * @return name of the person 
     */</span> 
   <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> name; }

   <span class="hl-comment">/** 
     * Sets the date of birth of the person 
     * @param name the name of the person 
     */</span> 
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDateOfBirth(Date dob) { <span class="hl-keyword">this</span>.dob = dob; }

   <span class="hl-comment">/** 
     * Sets the name of the person 
     * @param name the name of the person 
     */</span> 
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { <span class="hl-keyword">this</span>.name = name; } 
}
		</pre><p>
			To (un-)marshal data to and from XML, Castor XML can be used
			in one of three modes:
		</p><div class="itemizedlist"><ul type="disc"><li><p>introspection mode</p></li><li><p>mapping mode</p></li><li><p>descriptor mode (aka generation mode)</p></li></ul></div><p>
			The following sections discuss each of these modes at a high
			level.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e34"></a>1.1.2.1.&nbsp;Introspection mode</h4></div></div></div><p>
				The
				<span class="italic">introspection mode</span>
				is the simplest mode to use from a user perspective, as
				it does not require any configuration from the user. As
				such, the user does not have to provide any mapping
				file(s), nor point Castor to any generated descriptor
				classes (as discussed in the 'descriptor mode' section).
			</p><p>
				In this mode, the user makes use of
				<span class="bold"><strong>static</strong></span>
				methods on the
				<code class="classname">org.exolab.castor.xml.Marshaller</code> and
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				classes, providing all required data as parameters on
				these method calls.
			</p><p>
				To marshal an instance of the person class you simply
				call the
				<code class="classname">org.exolab.castor.xml.Marshaller</code>
				as follows:
			</p><pre class="programlisting">
<span class="hl-comment">// Create a new Person</span>
Person person = <span class="hl-keyword">new</span> Person(<span class="hl-string">"Ryan 'Mad Dog' Madden"</span>);
person.setDateOfBirth(<span class="hl-keyword">new</span> Date(1955, 8, 15));

<span class="hl-comment">// Create a File to marshal to</span>
writer = <span class="hl-keyword">new</span> FileWriter(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Marshal the person object</span>
Marshaller.marshal(person, writer);
			</pre><p>
				This produces the XML shown in
				<a href="#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a>
			</p><div class="example"><a name="xml.framework.introspection.ouput"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;XML produced in introspection mode</b></p><div class="example-contents"><pre class="programlisting">
XML to written
				</pre></div></div><br class="example-break"><p>
				To unmarshal an instance of the person class from XML,
				you simply call the
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				as follows:
			</p><pre class="programlisting">
<span class="hl-comment">// Create a Reader to the file to unmarshal from</span>
reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Marshal the person object</span>
Person person = (Person)
Unmarshaller.unmarshal(Person.<span class="hl-keyword">class</span>, reader);
			</pre><p>
				Marshalling and unmarshalling is basically that simple.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
				Note: The above example uses the
				<span class="italic">
					<span class="bold"><strong>static</strong></span>
				</span>
				methods of the marshalling framework, and as such no
				Marshaller and/or Unmarshaller instances need to be
				created. A common mistake in this context when using a
				<span class="bold"><strong>mapping file</strong></span>
				is to call the
				<code class="classname">org.exolab.castor.xml.Marshaller</code>	or
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				as in the above example. This won't work, as the mapping
				will be ignored.
			</td></tr></table></div><p>
				In
				<span class="italic">introspection mode</span>
				, Castor XML uses Java reflection to establish the
				binding between the Java classes (and their properties)
				and the XML, following a set of (default) naming rules.
				Whilst it is possible to change to a different set of
				naming rules, there's no way to override this (default)
				naming for individual artifacts. In such a case, a
				<span class="italic">mapping file</span>
				should be used.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e63"></a>1.1.2.2.&nbsp;Mapping mode</h4></div></div></div><p>
				In
				<span class="italic">mapping mode</span>
				, the user provides Castor XML with a user-defined
				mapping (in form of a mapping file) that allows the
				(partial) definition of a customized mapping between
				Java classes (and their properties) and XML.
			</p><p>
				When you are using a mapping file, create an instance of the
				<code class="classname">org.exolab.castor.xml.XMLContext</code> class and use the
				<code class="methodname">org.exolab.castor.xml.XMLContext.addMapping(Mapping)</code>
				method to provide Castor XML with one of more mapping files.
			</p><p>
				To start using Castor XML for marshalling and/or unmarshalling based upon your custom mapping, create
				instances of <code class="classname">org.exolab.castor.xml.Marshaller</code> and
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>as needed using one of the following methods:
			</p><div class="table"><a name="d4e73"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;
					Methods on XMLContext to create Un-/Marshaller
					objects
				</b></p><div class="table-contents"><table summary="&#xA;Methods on XMLContext to create Un-/Marshaller&#xA;objects&#xA;" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Method name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
								<p>
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
										createMarshaller
									</a>
								</p>
							</td><td align="center">
								<p>
									Creates a
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Marshaller" target="_top">
										Marshaller
									</a>
									instance.
								</p>
							</td></tr><tr><td align="center">
								<p>
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
										createUnmarshaller
									</a>
								</p>
							</td><td align="center">
								<p>
									Creates a
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Unmarshaller" target="_top">
										Unmarshaller
									</a>
									instance.
								</p>
							</td></tr></tbody></table></div></div><br class="table-break"><p>
				and call any of the
				<span class="bold"><strong>non-static</strong></span>
				(un)marshal methods to trigger data binding in either
				way.
			</p><p>
				Below code shows a full example that demonstrates
				unmarshalling a
				<code class="literal">Person</code>
				instance from XML using a
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				instance as obtained from an XMLContext previously
				configured to your needs.
			</p><div class="example"><a name="d4e102"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Unmarshalling from XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.xml.XMLContext; <span class="hl-keyword">import</span>
org.exolab.castor.mapping.Mapping; <span class="hl-keyword">import</span>
org.exolab.castor.xml.Unmarshaller;

<span class="hl-comment">// Load Mapping</span>
Mapping mapping = <span class="hl-keyword">new</span> Mapping();
mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);


	<span class="hl-comment">// initialize and configure XMLContext</span>

XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addMapping(mapping);


	<span class="hl-comment">// Create a Reader to the file to unmarshal from</span>

reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Create a new Unmarshaller</span>
Unmarshaller unmarshaller =
context.createUnmarshaller();
unmarshaller.setClass(Person.<span class="hl-keyword">class</span>);

<span class="hl-comment">// Unmarshal the person object</span>
Person person = (Person)
unmarshaller.unmarshal(reader);
				</pre></div></div><br class="example-break"><p>
				To marshal the very same
				<code class="literal">Person</code>
				instance to XML using a
				<code class="classname">org.exolab.castor.xml.Marshaller</code>
				obtained from the
				<span class="bold"><strong>same</strong></span>
				<code class="classname">org.exolab.castor.xml.XMLContext</code>, 
                use code as follows:
			</p><div class="example"><a name="d4e110"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Marshalling to XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

<span class="hl-comment">// create a Writer to the file to marshal to</span>
Writer writer = <span class="hl-keyword">new</span> FileWriter(<span class="hl-string">"out.xml"</span>);

<span class="hl-comment">// create a new Marshaller</span>
Marshaller marshaller = context.createMarshaller();
marshaller.setWriter(writer);

<span class="hl-comment">// marshal the person object</span>
marshaller.marshal(person);
				</pre></div></div><br class="example-break"><p>
				Please have a look at
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping</a>
				for a detailed discussion of the mapping file and its
				structure.
			</p><p>
				For more information on how to effectively deal with
				loading mapping file(s) especially in multi-threaded
				environments, please check the
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-best-practice.html" target="_top">best practice</a>
				section.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e117"></a>1.1.2.3.&nbsp;Descriptor mode</h4></div></div></div><p>TBD</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e120"></a>1.1.3.&nbsp;Sources and destinations</h3></div></div></div><p>
            Castor supports multiple sources and destinations from which
            objects can be marshalled and unmarshalled.
        </p><div class="table"><a name="d4e123"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;
                Marshalling destinations.
            </b></p><div class="table-contents"><table summary="&#xA;                Marshalling destinations.&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Destination</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                            <p>
                                <code class="classname">marshal(java.io.Writer)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The character stream.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.xml.sax.DocumentHandler)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The SAX document handler.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.xml.sax.ContentHandler)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The SAX content handler.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.w3c.dom.Node)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The DOM node to marshall object into.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.stream.XMLStreamWriter)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The STaX cursor API.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.stream.XMLEventWriter)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The STaX iterator API.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.transform.Result)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                <code class="literal">javax.xml.transform.dom.DOMResult</code>, 
                                <code class="literal">javax.xml.transform.sax.SAXResult</code> and 
                                <code class="literal">javax.xml.transform.stream.StreamResult</code> are supported.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e178"></a><p class="title"><b>Table&nbsp;1.3.&nbsp;
                Unmarshalling sources.
            </b></p><div class="table-contents"><table summary="&#xA;                Unmarshalling sources.&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Source</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(java.io.Reader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A character stream.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(org.xml.sax.InputSource)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A SAX input source.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(org.w3c.dom.Node)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A W3C DOM node which will be used for unmarshalling.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.stream.XMLStreamReader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A StAX cursor.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.stream.XMLEventReader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A StAX iterator.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.transform.Source)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                Supports <code class="literal">javax.xml.transform.dom.DOMSource</code>, 
                                <code class="literal">javax.xml.transform.sax.SAXSource</code>
                                and <code class="literal">javax.xml.transform.stream.StreamSource</code>.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"><p>
            Castor 1.3.2 and 1.3.3 introduced support for the STaX API for
            both for marshalling and unmarshalling. The framework fully
            supports the STaX cursor and iterator API.
        </p><p>
            An example of marshalling using STaX:
        </p><div class="example"><a name="d4e229"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Marshalling to a StAX java.xml.stream.XMLStreamWriter</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// marshalling using STaX</span>
StringWriter writer = <span class="hl-keyword">new</span> StringWriter();
XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
XMLStreamWriter xmlStreamWriter = outputFactory.createXMLStreamWriter(writer);

marshaller.setXmlStreamWriter(xmlStreamWriter);
marshaller.marshal(object);
    		</pre></div></div><br class="example-break"><p>
            Also beginning from version 1.3.3, the framework has been
            modified to support Source and Result interfaces. Now it
            is possible to use SAXSource, DOMSource and StreamSource
            for unmarshalling and corresponding classes for marshalling.
        </p><p>
            Below an example of marshalling into Result:
        </p><div class="example"><a name="d4e234"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;Marshalling to a <code class="literal">javax.xml.transform.dom.DOMResult</code></b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// instance of object to be marshalled</span>
Object obj = ...

<span class="hl-comment">// marshalling into DOM node</span>
XMLContext xmlContext = ... <span class="hl-comment">// creates the xml context</span>

<span class="hl-comment">// creates marshaller</span>
Marshaller marshaller = xmlContext.createMarshaller();

<span class="hl-comment">// creates DOM factory</span>
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();

<span class="hl-comment">// creates document</span>
Document document = builder.newDocument();

<span class="hl-comment">// sets the DOM result for the marshaller</span>
marshaller.setResult(<span class="hl-keyword">new</span> DOMResult(document));

<span class="hl-comment">// marshalls object</span>
marshaller.marshall(obj);
		  </pre></div></div><br class="example-break"><p>
            Another example of unmarshalling from Source:
        </p><div class="example"><a name="d4e239"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;Unmarshalling from a <code class="literal">javax.xml.transform.sax.SAXSource</code></b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// unmarshalling from SAX InputSource</span>
XMLContext xmlContext = ... <span class="hl-comment">// creates the xml context</span>

<span class="hl-comment">// creates unmarshaller</span>
Unmarshaller unmarshaller = xmlContext.createUnmarshaller();

<span class="hl-comment">// creates SAX input source</span>
InputSource inputSource = <span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> StringReader(xml));

<span class="hl-comment">// creates instance of SAXSource</span>
SAXSource saxSource = <span class="hl-keyword">new</span> SAXSource(inputSource);

<span class="hl-comment">// unmarshalls object</span>
Object result = unmarshaller.unmarshal(saxSource);
    		</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e243"></a>1.1.4.&nbsp;
			XMLContext - A consolidated way to bootstrap Castor
		</h3></div></div></div><p>
			With Castor 1.1.2, the
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			class has been added to the Castor marshalling framework.
			This new class provides a bootstrap mechanism for Castor
			XML, and allows easy (and efficient) instantiation of
			<code class="classname">org.exolab.castor.xml.Marshaller</code>
			and
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			instances as needed.
		</p><p>
			As shown above, the
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			class offers various factory methods to obtain a new
			<code class="classname">org.exolab.castor.xml.Marshaller</code>,
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>.
		</p><p>
			When you need more than one
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			instance in your application, please call
			<code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code>
			as required. As all
			<code class="literal">Unmarshaller</code>
			instances are created from the very same
			<code class="literal">XMLContext</code>
			instance, overhead will be minimal. Please note, though,
			that use of one
			<code class="literal">Unmarshaller</code>
			instance is not thread-safe.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e259"></a>1.1.5.&nbsp;Using existing Classes/Objects</h3></div></div></div><p>
			Castor can marshal "almost" any arbitrary Object to and from
			XML. When descriptors are not available for a specfic Class,
			the marshalling framework uses reflection to gain
			information about the object.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			Actually an in memory set of descriptors are created for the
			object and we will soon have a way for saving these
			descriptors as Java source, so that they may be modified and
			compiled with little effort.
		</td></tr></table></div><p>
			If a set of descriptors exist for the classes, then Castor
			will use those to gain information about how to handle the
			marshalling. See <a href="#xml.framework.class.descriptors" title="1.1.6.&nbsp;Class Descriptors">Section&nbsp;1.1.6, &#8220;Class Descriptors&#8221;</a>
			for more information.
		</p><p>
			There is one main restrictions to marshalling objects. These
			classes must have have a public default constructor (ie. a
			constructor with no arguments) and adequete "getter" and
			"setter" methods to be properly be marshalled and
			unmarshalled.
		</p><p>
			The example illustrated in the previous section
			<a href="#xml.framework.data.binding.framework" title="1.1.2.&nbsp;Castor XML - The XML data binding framework">Section&nbsp;1.1.2, &#8220;Castor XML - The XML data binding framework&#8221;</a>
			demonstrates how to use the framework with existing classes.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.class.descriptors"></a>1.1.6.&nbsp;Class Descriptors</h3></div></div></div><p>
			Class descriptors provide the "Castor Framework" with
			necessary information so that the Class can be marshalled
			properly. The class descriptors can be shared between the
			JDO and XML frameworks.
		</p><p>
			Class descriptors contain a set of
			<a href="#">???</a>
		</p><p>
			XML Class descriptors provide the marshalling framework with
			the information it needs about a class in order to be
			marshalled to and from XML. The XMLClassDescriptor
			<code class="classname">org.exolab.castor.xml.XMLClassDescriptor</code>.
		</p><p>
			XML Class Descriptors are created in four main ways. Two of
			these are basically run-time, and the other two are compile
			time.

			</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e276"></a>1.&nbsp;Compile-Time Descriptors</h5></div></div></div><p>
					To use "compile-time" class descriptors, one can
					either implement the
					<code class="classname">org.exolab.castor.xml.XMLClassDescriptor</code>
					interface for each class which needs to be
					"described", or have the
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/sourcegen.xml" target="_top">Source Code Generator</a>
					create the proper descriptors.
				</p><p>
					The main advantage of compile-time descriptors is
					that they are faster than the run-time approach.
				</p></div><p>
			</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e282"></a>2.&nbsp;Run-Time Descriptors</h5></div></div></div><p>
					To use "run-time" class descriptors, one can either
					simply let Castor introspect the classes, a mapping
					file can be provided, or a combination of both
					"default introspection" and a specified mapping file
					may be used.
				</p><p>
					For "default introspection" to work the class being
					introspected must have adequete setter/getter
					methods for each field of the class that should be
					marshalled and unmarshalled. If no getter/setter
					methods exist, Castor can handle direct field access
					to public fields. It does not do both at the same
					time. So if the respective class has any
					getter/setter methods at all, then no direct field
					access will take place.
				</p><p>
					There is nothing to do to enable "default
					introspection". If a descriptor cannot be found for
					a class, introspection occurs automatically.
				</p><p>
					Some behavior of the introspector may be controlled
					by setting the appropriate properties in the
					<span class="italic">castor.properties</span>
					file. Such behavior consists of changing the naming
					conventions, and whether primitive types are treated
					as attributes or elements. See
					<span class="italic">castor.properties</span>
					file for more information.
				</p><p>
					A mapping file may also be used to "describe" the
					classes which are to be marshalled. The mapping is
					loaded before any marshalling/unmarshalling takes
					place. See
					<code class="classname">org.exolab.castor.mapping.Mapping</code>
				</p><p>
					The main advantage of run-time descriptors is that
					it takes very little effort to get something
					working.
				</p></div><p>
		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.mapping"></a>1.2.&nbsp;XML Mapping</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.introduction"></a>1.2.1.&nbsp;Introduction</h3></div></div></div><p>Castor XML mapping is a way to simplify the binding of java classes to
      XML document. It allows to transform the data contained in a java object
      model into/from an XML document.</p><p>Although it is possible to rely on Castor's default behavior to marshal and
        unmarshal Java objects into an XML document, it might be necessary to have more
        control over this behavior. For example, if a Java object model already exists,
        Castor XML Mapping can be used as a bridge between the XML document and that
        Java object model.</p><p>Castor allows one to specify some of its marshalling/unmarshalling behavior
        using a mapping file. This file gives explicit information to Castor on how a
        given XML document and a given set of Java objects relate to each other.</p><p>A Castor mapping file is a good way to dissociate the changes in the structure
        of a Java object model from the changes in the corresponding XML document
        format.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.overview"></a>1.2.2.&nbsp;Overview</h3></div></div></div><p>The mapping information is specified by an XML document. This document is
        written from the point of view of the Java object and describes how the
        properties of the object have to be translated into XML. One constraint for the
        mapping file is that Castor should be able to infer unambiguously from it how a
        given XML element/attribute has to be translated into the object model during
        unmarshalling.</p><p>The mapping file describes for each object how each of its fields have to be
        mapped into XML. A field is an abstraction for a property of an object. It can
        correspond directly to a public class variable or indirectly to a property via
        some accessor methods (setters and getters).</p><p>It is possible to use the mapping and Castor default behavior in conjunction:
        when Castor has to handle an object or an XML data but can't find information
        about it in the mapping file, it will rely on its default behavior. Castor will
        use the Java Reflection API to introspect the Java objects to determine what to do.</p><p><span class="bold"><strong>Note:</strong></span> Castor can't handle all possible mappings. In some complex cases, it may be
        necessary to rely on an XSL transformation in conjunction with Castor to adapt the
        XML document to a more friendly format.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.marshalling"></a>1.2.2.1.&nbsp;Marshalling Behavior</h4></div></div></div><p>For Castor, a Java class has to map into an XML element. When Castor marshals an
          object, it will:</p><div class="itemizedlist"><ul type="disc"><li><p>use the mapping information, if any, to find the name of the element to create</p></li></ul></div><p>or</p><div class="itemizedlist"><ul type="disc"><li><p>by default, create a name using the name of the class</p></li></ul></div><p>It will then use the fields information from the mapping file to determine how a
          given property of the object has to be translated into one and only one of the
          following:</p><div class="itemizedlist"><ul type="disc"><li><p>an attribute</p></li><li><p>an element</p></li><li><p>text content</p></li><li><p>nothing, as we can choose to ignore a particular field</p></li></ul></div><p>This process will be recursive: if Castor finds a property that has a class type
          specified elsewhere in the mapping file, it will use this information to marshal
          the object.</p><p>By default, if Castor finds no information for a given class in the mapping
          file, it will introspect the class and apply a set of default rules to guess the
          fields and marshal them. The default rules are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>All primitive types, including the primitive type wrappers (Boolean,
            Short, etc...) are marshalled as attributes.</p></li><li><p>All other objects are marshalled as elements with either text content
            or element content.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.unmarshalling"></a>1.2.2.2.&nbsp;Unmarshalling Behavior</h4></div></div></div><p>When Castor finds an element while unmarshalling a document, it will try to use
          the mapping information to determine which object to instantiate. If no mapping
          information is present, Castor will use the name of the element to try to guess
          the name of a class to instantiate (for example, for an element named
          'test-element', Castor will try to instantiate a class named 'TestElement' if no
          information is given in the mapping file). Castor will then use the field
          information of the mapping file to handle the content of the element.</p><p>If the class is not described in the mapping file, Castor will instrospect the
          class using the Java Reflection API to determine if there is any function of the
          form getXxxYyy()/setXxxYyy(&lt;type&gt; x). This accessor will be associated with XML
          element/attribute named 'xxx-yyy'. In the future, we will provide a way to
          override this default behavior.</p><p>Castor will introspect object variables and use direct access _only_ if no
          get/set methods have been found in the class. In this case, Castor will look for
          public variables of the form:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; xxxYYY;
        </pre><p>and expect an element/attribute named 'xxx-yyy'. The only handled
          collections for &lt;type&gt; are java.lang.Vector and array. (up to version
          0.8.10)</p><p>For primitive &lt;type&gt;, Castor will look for an attribute first and then an
          element. If &lt;type&gt; is not a primitive type, Castor will look for an element
          first and then an attribute.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile"></a>1.2.3.&nbsp;The Mapping File</h3></div></div></div><p>
    		The following sections define the syntax for each of the mapping file artefacts
    		and their semantical meaning.
    	</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.sampledomainobjects"></a>1.2.3.1.&nbsp;Sample domain objects</h4></div></div></div><p>
    			This section defines a small domain model that will be referenced by
    			various mapping file (fragments/samples) in the following sections. The model consists 
    			of two two classes <code class="classname">Order</code> and <code class="classname">OrderItem</code>, where an order 
    			holds a list of order items.
    		</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Order {

    <span class="hl-keyword">private</span> List orderItems;
    <span class="hl-keyword">private</span> String orderNumber;
    
    <span class="hl-keyword">public</span> List getOrderItems() {
        <span class="hl-keyword">return</span> orderItems;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderItems(List orderItems) {
        <span class="hl-keyword">this</span>.orderItems = orderItems;
    }
    <span class="hl-keyword">public</span> String getOrderNumber() {
        <span class="hl-keyword">return</span> orderNumber;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderNumber(String orderNumber) {
        <span class="hl-keyword">this</span>.orderNumber = orderNumber;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderItem {
    
    <span class="hl-keyword">private</span> String id;
    <span class="hl-keyword">private</span> Integer orderQuantity;
    
    <span class="hl-keyword">public</span> String getId() {
        <span class="hl-keyword">return</span> id;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(String id) {
        <span class="hl-keyword">this</span>.id = id;
    }
    <span class="hl-keyword">public</span> Integer getOrderQuantity() {
        <span class="hl-keyword">return</span> orderQuantity;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderQuantity(Integer orderQuantity) {
        <span class="hl-keyword">this</span>.orderQuantity = orderQuantity;
    }
}</pre><p>
	        	As shown above in bold, the <code class="classname">Order</code> instance has a (private) field <code class="classname">'orderItems'</code>
				to hold a collection of <code class="classname">OrderItem</code> instances. This field is publically exposed
				by corresponding getter and setter methods.
	        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapping"></a>1.2.3.2.&nbsp;The &lt;mapping&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT mapping ( description?, include*, field-handler*, <span class="hl-keyword">class</span>*, key-generator* )&gt;
        </pre><p>The &lt;mapping&gt; element is the root element of a mapping file. It contains:</p><div class="itemizedlist"><ul type="disc"><li><p>an optional description</p></li><li><p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li><li><p>zero of more &lt;field-handler&gt; defining custom, configurable field handlers</p></li><li><p>zero or more &lt;class&gt; descriptions: one for each class we intend to give
            mapping information</p></li><li><p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li></ul></div><p>A mapping file look like this:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;

&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
      castor.org
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
	&lt;description&gt;Description of the mapping&lt;/description&gt;
	
	&lt;include href=<span class="hl-string">"other_mapping_file.xml"</span>/&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'A'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"A"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'B'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"B"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.class"></a>1.2.3.3.&nbsp;The &lt;class&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT class ( description?, cache-type?, map-to?, field+ )&gt;
&lt;!ATTLIST class
          name            ID       #REQUIRED
          extends         IDREF    #IMPLIED
          depends         IDREF    #IMPLIED
          auto-complete   ( true |false ) "false"
          identity        CDATA    #IMPLIED
          access          ( read-only | shared | exclusive | db-locked )  "shared"
          key-generator   IDREF    #IMPLIED &gt;</pre><p>The  <code class="classname">&lt;class&gt;</code> element contains all the information used to 
           map a Java class into an XML document. The content of <code class="classname">&lt;class&gt;</code>
           is mainly used to describe the fields that will be mapped.</p><div class="table"><a name="d4e382"></a><p class="title"><b>Table&nbsp;1.4.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The fuly-qualified name of the Java class that we want to map to.</td></tr><tr><td><span class="bold"><strong>extends</strong></span></td><td>The fully qualified name of a parent class. This attribute should be used <span class="bold"><strong>only</strong></span>
					if this class extends another class for which a class mapping is provided. It 
					should <span class="bold"><strong>not</strong></span> be used if there's no class maping for the extended 
					class.</td></tr><tr><td><span class="bold"><strong>depends</strong></span></td><td>Used with Castor JDO only; for more information on this field, please
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>auto-complete</strong></span></td><td>If true, the class will be introspected to determine its field and 
				    the fields specified in the mapping file will be used to overide the 
				    fields found during the introspection.</td></tr><tr><td><span class="bold"><strong>identity</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>access</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>key-generator</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr></tbody></table></div></div><br class="table-break"><p>The auto-complete attributes is interesting as it allow a fine degree
           of control of the introspector: it is possible to specifiy only the
           fields whose Castor default behavior does not suite our needs. These
           feature should simplify the handling of complexe class containing many
           fields. Please see below for an example usage of this attribute.</p><div class="table"><a name="d4e425"></a><p class="title"><b>Table&nbsp;1.5.&nbsp;Description of the content</b></p><div class="table-contents"><table summary="Description of the content" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>description</strong></span></td><td>An optional description.</td></tr><tr><td><span class="bold"><strong>cache-type</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>map-to</strong></span></td><td>
					Used if the name of the element is not the name of the class. By
					default, Castor will infer the name of the element to be mapped from
					the name of the class: a Java class named 'XxxYyy' will be transformed
					in 'xxx-yyy'. If you don't want Castor to generate the name, you need
					to use &lt;map-to&gt; to specify the name you want to use. &lt;map-to&gt; is
					only used for the root element.
				</td></tr><tr><td><span class="bold"><strong>field</strong></span></td><td>Zero or more &lt;field&gt; elements, which are used to describe the properties 
				    of the Java class being mapped.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.sampleclassmappings"></a>1.2.3.3.1.&nbsp;Sample &lt;class&gt; mappings</h5></div></div></div><p>The following mapping fragment defines a class mapping for the <code class="classname">OrderItem</code>
           class:</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem&gt;
           
   &lt;map-to xml="</span>item"/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

   &lt;/field name=<span class="hl-string">"orderQuantity"</span> type=<span class="hl-string">"integer"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling an	<code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;quantity&gt;100&lt;/quantity&gt;
&lt;/item&gt;</pre><p>The following mapping fragment defines a class mapping for the same
			   class, where for all properties but <code class="classname">id</code> introspection should
			   be used; the use of the <code class="classname">auto-complete</code> attribute instructs Castor XML
			   to use introspection for all attributes other than <code class="classname">'id'</code>, where
			   the given field mapping will be used.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;map-to xml=<span class="hl-string">"item"</span>/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/item&gt;</pre><p>
        	By removing the &lt;map-to&gt; element from above class mapping, ...
        </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	... Castor will use introspection to infer the element name from the Java 
        	class name (<code class="classname">OrderItem</code>), applying a default naming convention scheme.
        </p><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;order-item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapto"></a>1.2.3.4.&nbsp;The &lt;map-to&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT map-to EMPTY&gt;
&lt;!ATTLIST map-to
          table               NMTOKEN  #IMPLIED
          xml                 NMTOKEN  #IMPLIED
          ns-uri              NMTOKEN  #IMPLIED
          ns-prefix           NMTOKEN  #IMPLIED
          ldap-dn             NMTOKEN  #IMPLIED
          element-definition  (true|false) "false"     <span class="bold"><strong>NEW as of 1.0M3</strong></span>
          ldap-oc             NMTOKEN  #IMPLIED&gt;</pre><p><code class="classname">&lt;map-to&gt;</code> is used to specify the name of the element that should 
           be associated with the given class. <code class="classname">&lt;map-to&gt;</code> is only used for 
           the root class. If this information is not present, Castor will:</p><div class="itemizedlist"><ul type="disc"><li><p>for marshalling, infer the name of the element to be mapped from the name of
            the class: a Java class named 'XxxYyy' will be transformed into 'xxx-yyy'.</p></li><li><p>for unmarshalling, infer the name of the class from the name of the element:
            for an element named 'test-element' Castor will try to use a
            class named 'TestElement'</p></li></ul></div><p>Please note that it is possible to change the naming scheme used by Castor 
           to translate between the XML name and the Java class name in the 
           <code class="classname">castor.properties</code> file.</p><div class="table"><a name="d4e489"></a><p class="title"><b>Table&nbsp;1.6.&nbsp;Description of attributes</b></p><div class="table-contents"><table summary="Description of attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>xml</strong></span></td><td>Name of the element that the class is associated to.</td></tr><tr><td><span class="bold"><strong>ns-uri</strong></span></td><td>Namespace URI</td></tr><tr><td><span class="bold"><strong>ns-prefix</strong></span></td><td>Desired namespace</td></tr><tr><td><span class="bold"><strong>element-definition</strong></span></td><td><code class="classname">True</code> if the descriptor as created from a schema definition that 
	              was of type element (as opposed to a &lt;complexType&gt; definition). This 
	              only is useful in the context of source code generation.</td></tr><tr><td><span class="bold"><strong>ldap-dn</strong></span></td><td>Not used for Castor XML</td></tr><tr><td><span class="bold"><strong>ldap-oc</strong></span></td><td>Not used for Castor XML</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.mapto.samples"></a>1.2.3.4.1.&nbsp;&lt;map-to&gt; samples</h5></div></div></div><p>The following mapping fragment defines a &lt;map-to element for the 
			   <code class="classname">OrderItem</code> class, manually setting the element name to a value 
			   of <code class="classname">'item'</code>.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> /&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>The following mapping fragment instructs Castor to assign a namespace URI of 
			   <code class="classname">http://castor.org/sample/mapping/</code> to the &lt;item&gt; element, 
			   and use a namespace prefix of <code class="classname">'castor'</code> during un-/marshalling.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">ns-uri</span>=<span class="hl-value">"http://castor.org/sample/mapping/"</span>
           <span class="hl-attribute">ns-prefix</span>=<span class="hl-value">"castor"</span>/&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>
        	When marshalling an <code class="classname">OrderItem</code> instance, this will yield the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;castor:order-item xmlns:castor=<span class="hl-string">"http://castor.org/sample/mapping/"</span> identity=<span class="hl-string">"12"</span>&gt;
   &lt;castor:order-quantity&gt;100&lt;/castor:order-quantity&gt;
&lt;/castor:order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.field"></a>1.2.3.5.&nbsp;The &lt;field&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT field ( description?, sql?, bind-xml?, ldap? )&gt;
&lt;!ATTLIST field
    name           NMTOKEN  #REQUIRED
    type           NMTOKEN  #IMPLIED
    handler        NMTOKEN  #IMPLIED
    required       ( true | false )  "false"
    direct         ( true | false )  "false"
    lazy           ( true | false )  "false"
    transient      ( true | false )  "false"
    nillable       ( true | false )  "false"
    container      ( true | false )  "false"
    get-method     NMTOKEN  #IMPLIED
    set-method     NMTOKEN  #IMPLIED
    create-method  NMTOKEN  #IMPLIED
    collection     ( array | vector | hashtable | collection | set | map )  #IMPLIED&gt;
        </pre><p><code class="classname">&lt;field&gt;</code> is used to describe a property of a Java object 
           we want to marshal/unmarshal. It gives:</p><div class="itemizedlist"><ul type="disc"><li><p>its identity ('name')</p></li><li><p>its type (infered from 'type' and 'collection')</p></li><li><p>its access method (infered from 'direct', 'get-method', 'set-method')</p></li></ul></div><p>From this information, Castor is able to access a given property in the Java
           class.</p><p>In order to determine the signature that Castor expects, there are two easy
          rules to apply.</p><p><span class="bold"><strong>1. Determine &lt;type&gt;.</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If there is no 'collection' attribute</strong></span>, the &lt;type&gt; is just the Java type
            specified in &lt;type_attribute&gt; (the value of the 'type' attribute in the XML
            document). The value of &lt;type_attribute&gt; can be a fully qualified Java object
            like 'java.lang.String' or one of the allowed short name:</p><div class="table"><a name="d4e553"></a><p class="title"><b>Table&nbsp;1.7.&nbsp;Type shortnames</b></p><div class="table-contents"><table summary="Type shortnames" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>short name</th><th>Primitive type?</th><th>Java Class</th></tr></thead><tbody><tr><td>other</td><td>N</td><td>java.lang.Object</td></tr><tr><td>string</td><td>N</td><td>java.lang.String</td></tr><tr><td>integer</td><td>Y</td><td>java.lang.Integer.TYPE</td></tr><tr><td>long</td><td>Y</td><td>java.lang.Long.TYPE</td></tr><tr><td>boolean</td><td>Y</td><td>java.lang.Boolean.TYPE</td></tr><tr><td>double</td><td>Y</td><td>java.lang.Double.TYPE</td></tr><tr><td>float</td><td>Y</td><td>java.lang.Float.TYPE</td></tr><tr><td>big-decimal</td><td>N</td><td>java.math.BigDecimal</td></tr><tr><td>byte</td><td>Y</td><td>java.lang.Byte.TYPE</td></tr><tr><td>date</td><td>N</td><td>java.util.Date</td></tr><tr><td>short</td><td>Y</td><td>java.lang.Short.TYPE</td></tr><tr><td>char</td><td>Y</td><td>java.lang.Character.TYPE</td></tr><tr><td>bytes</td><td>N</td><td>byte[]</td></tr><tr><td>chars</td><td>N</td><td>char[]</td></tr><tr><td>strings</td><td>N</td><td>String[]</td></tr><tr><td>locale</td><td>N</td><td>java.util.Locale</td></tr></tbody></table></div></div><br class="table-break"><p>Castor will try to cast the data in the XML file in the proper Java type.</p></li><li><p><span class="bold"><strong>If there is a collection attribute</strong></span>
	, you can use the following table:</p><div class="table"><a name="d4e630"></a><p class="title"><b>Table&nbsp;1.8.&nbsp;Type implementations</b></p><div class="table-contents"><table summary="Type implementations" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>name</th><th>&lt;type&gt;</th><th>default implementation</th></tr></thead><tbody><tr><td>array</td><td>&lt;type_attribute&gt;[]</td><td>&lt;type_attribute&gt;[]</td></tr><tr><td>arraylist</td><td>java.util.List</td><td>java.util.Arraylist</td></tr><tr><td>vector</td><td>java.util.Vector</td><td>java.util.Vector</td></tr><tr><td>hashtable</td><td>java.util.Hashtable</td><td>java.util.Hashtable</td></tr><tr><td>collection</td><td>java.util.Collection</td><td>java.util.Arraylist</td></tr><tr><td>set</td><td>java.util.Set</td><td>java.util.Hashset</td></tr><tr><td>map</td><td>java.util.Map</td><td>java.util.Hashmap</td></tr><tr><td>sortedset</td><td>java.util.SortedSet</td><td>java.util.TreeSet</td></tr></tbody></table></div></div><br class="table-break"><p>The type of the object inside the collection is &lt;type_attribute&gt;. The 'default
              implementation' is the type used if the object holding the collection is found
              to be null and need to be instantiated.</p><p>For hashtable and maps (since 0.9.5.3), Castor will save both key and values.
               When marshalling output &lt;key&gt; and &lt;value&gt;
               elements. These names can be controlled by using a top-level or nested class mapping for
               the org.exolab.castor.mapping.MapItem class.
            </p><p>Note: for backward compatibility with prior versions of Castor, the <span class="italic">saveMapKeys</span>
              property can be set to false in the castor.properties file.</p><p>For versions prior to 0.9.5.3, hashtable and maps, Castor will save only the value
               during marshalling and during unmarshalling will add a map entry using the object as
               both the key and value, e.g. map.put(object, object).
            </p></li></ul></div><p>It is necessary to use a collection when the content model of the
          element expects more than one element of the specified type.</p><p><span class="bold"><strong>Determine the signature of the function</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If 'direct' is set to true</strong></span>, Castor expects to find a class variable with the
            given signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;name&gt;;
          </pre></li><li><p><span class="bold"><strong>If 'direct' is set to false or omitted</strong></span>, Castor will access the property
              though accessor methods. Castor determines the signature of the accessors as
              follow: If the 'get-method' or 'set-method' attributes are supplied, it will
              try to find a function with the following signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;get-method&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> &lt;set-method&gt;(&lt;type&gt; value);
            </pre><p>If 'get-method' and 'set-method' attributes are not provided, Castor will try to
              find the following function:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; get&lt;capitalized-name&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> set&lt;capitalized-name&gt;(&lt;type&gt; value);
            </pre><p>&lt;capitalized-name&gt; means that Castor takes the &lt;name&gt; attribute and put its first
              letter in uppercase without modifying the other letters.</p><p>The content of &lt;field&gt; will contain the information on how to map this given
              field to SQL, XML, ...</p></li><li><p><span class="bold"><strong>Exceptions concerning collection fields:</strong></span></p><p>The default is to treat the 'get-method' as a simple getter returning 
                   the collection field, and the 'set-method' as a simple getter used to set
                   a new instance on the collection field.</p><div class="table"><a name="d4e700"></a><p class="title"><b>Table&nbsp;1.9.&nbsp;Collection field access</b></p><div class="table-contents"><table summary="Collection field access" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>'get-method'</td><td>
                					<p>
                						If a 'get-method' is provided
                						for a collection field, Castor -
                						in adition to the default
                						behaviour described above - will
                						deviate from the standard case
                						for the following special
                						prefixes:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Iterator iterate...();
                					</pre>

                					<p>
                						A 'get-method' starting with the
                						prefix '
                						<code class="classname">iterate</code>
                						' is treated as Iterator method
                						for the given collection field.
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Enumeration enum...();
                					</pre>

                					<p>
                						A 'get-method' starting with '
                						<code class="classname">enum</code>
                						' is treated as Enumeration
                						method for the given collection
                						field.
                					</p>
                				</td></tr><tr><td>'set-method'</td><td>
                					<p>
                						If 'set-method' is provided for
                						a collection field, Castor - in
                						addition to the default
                						behaviour described above - will
                						accept an 'add' prefix and
                						expect the following signature:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add...(&lt;type&gt; value);
                					</pre>

                					<p>
                						This method is called for each
                						collection element while
                						unmarshalling.
                					</p>
                				</td></tr></tbody></table></div></div><br class="table-break"></li></ul></div><div class="table"><a name="d4e724"></a><p class="title"><b>Table&nbsp;1.10.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The field 'name' is required even if no such field exists in the
                    class. If 'direct' access is used, 'name' should be the name of 
                    a public instance member in the object to be mapped (the field 
                    must be public, not static and not transient). If no direct access 
                    and no 'get-/set-method' is specified, this name will be used to 
                    infer the name of the accessors methods.</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>The Java type of the field. It is used to access the field. Castor 
                    will use this information to cast the XML information (like string 
                    into integer). It is also used to define the signature of the accessor 
                    methods. If a collection is specified, this is used to specify the 
                    type of the objects held by the collection. See description
                    above for more details.</td></tr><tr><td><span class="bold"><strong>required</strong></span></td><td>A field can be optional or required.</td></tr><tr><td><span class="bold"><strong>nillable</strong></span></td><td>A field can be of content '<code class="classname">nil</code>'.</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>If true, this field will be ignored during the marshalling. This 
                    is usefull when used together with the auto-complete="true"
                    option.</td></tr><tr><td><span class="bold"><strong>direct</strong></span></td><td>If true, Castor will expect a public variable in the containing class
                    and will access it directly (for both reading and writing).</td></tr><tr><td><span class="bold"><strong>container</strong></span></td><td>Indicates whether the field should be treated as a container, 
                    i.e. only it's fields should be persisted, but not the containing
                    class itself. In this case, the container attribute should be set 
                    to true (supported in Castor XML only).</td></tr><tr><td><span class="bold"><strong>collection</strong></span></td><td>If a parent expects more than one occurrence of one of its 
                    element, it is necessary to specify which collection Castor will 
                    use to handle them. The type specified is used to define the type 
                    of the content inside the collection.</td></tr><tr><td><span class="bold"><strong>get-method</strong></span></td><td>Optional name of the 'get method' Castor should use. If this attribute 
                    is not set and the set-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>set-method</strong></span></td><td>Optional name of the 'set method' Castor should use. If this attribute 
                    is not set and the get-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>create-method</strong></span></td><td>Optionally defines a factory method for the instantiation of a FieldHandler</td></tr><tr><td><span class="bold"><strong>handler</strong></span></td><td>If present, specifies one of the following:
                    <div class="itemizedlist"><ul type="disc"><li><p>The fully-qualified class name of a custom field handler implementation, or</p></li><li><p>The (short) name of a 
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-fieldhandlers.html#Use-ConfigurableFieldHandler-for-more-flexibility" target="_top">configurable field handler</a>
                           definition.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e787"></a>1.2.3.6.&nbsp;Description of the content</h4></div></div></div><p>
             In the case of XML mapping, the content of a field element should be one and
             only one <span class="bold"><strong>&lt;bind-xml&gt;</strong></span> element describing how this given field will be mapped into the
             XML document.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.field.constructorarguments"></a>1.2.3.6.1.&nbsp;Mapping constructor arguments (since 0.9.5)</h5></div></div></div><p>
               Starting with release 0.9.5, for <span class="italic">attribute</span> 
               mapped fields, support has been added to map a constructor field using 
               the <code class="classname">set-method</code> attribute.
            </p><p>
               To specify that a field (mapped to an attribute) should be used as a constructor 
               argument during object initialization, please specify a <code class="classname">set-method</code> attribute on the
               <code class="classname">&lt;field&gt;</code> mapping and use "%X" as the value of the
               <code class="classname">set-method</code> attribute, where <code class="literal">X</code>
               is a positive integer number, e.g. <code class="literal">%1</code> or 
               <code class="literal">%21</code>.
            </p><p>For example:</p><pre class="programlisting">
&lt;field name=<span class="hl-string">"foo"</span> set-method=<span class="hl-string">"%1"</span> get-method=<span class="hl-string">"getFoo"</span> type=<span class="hl-string">"string"</span>&gt;
   &lt;bind-xml node=<span class="hl-string">"attribute"</span>/&gt;
&lt;/field&gt;</pre><p>
              Note that because the <code class="classname">set-method</code> is specified, the <code class="classname">get-method</code> also 
              must be specified.
           </p><p>
	          <span class="bold"><strong>Tip</strong></span>: the <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML HOW-TO section</span> has a HOW-TO document for 
	          mapping constructor arguments, incl. a fully working mapping.
	       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e812"></a>1.2.3.6.2.&nbsp;Sample 1: Defining a custom field handler</h5></div></div></div><p>The following mapping fragment defines a <code class="classname">&lt;field&gt;</code> element for the 
			   <code class="classname">member</code> property of the <code class="classname">org.some.package.Root</code> class, 
			   specifying a custom <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
			   implementation.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e821"></a>1.2.3.6.3.&nbsp;Sample 2: Defining a custom configurable field handler</h5></div></div></div><p>
   			   The same custom field handler as in the previous sample can be defined 
   			   with a separate configurable &lt;field-handler&gt; definition, where additional 
   			   configuration can be provided.
   			</p><pre class="programlisting">
&lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>&gt;
   &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
&lt;/field-handler&gt;</pre><p>
   				and subsequently be referred to by its <span class="bold"><strong>name</strong></span> as shown in the 
   				following field mapping:
   			</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e830"></a>1.2.3.6.4.&nbsp;Sample 3: Using the container attribute</h5></div></div></div><p>
               Assume you have a class mapping for a class <code class="classname">Order</code> which defines -
               amongst others - a field mapping as follows, where the field <code class="classname">item</code>
               refers to an instance of a class <code class="classname">Item</code>.
            </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Order"</span>&gt;
            
   ...
   &lt;field name=<span class="hl-string">"item"</span> type=<span class="hl-string">"some.example.Item"</span> &gt;
      &lt;bind-xml&gt; name=<span class="hl-string">"item"</span> node=<span class="hl-string">"element"</span> /&gt;
   &lt;/field&gt;
   ...
&lt;/<span class="hl-keyword">class</span>&gt;

&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Item"</span>&gt;
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"long"</span> /&gt;
   &lt;field name=<span class="hl-string">"description"</span> type=<span class="hl-string">"string"</span> /&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
                Marshalling an instance of <code class="classname">Order</code> would produce XML as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">item</span>&gt;
        &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
        &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
    &lt;<span class="hl-tag">/item</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre><p>
               If you do not want the <code class="classname">Item</code> instance to be marshalled,
               but only its fields, change the field mapping for the <code class="classname">item</code>
               member to be as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"some.example.Item"</span> <span class="hl-attribute">container</span>=<span class="hl-value">"false"</span> &gt;
   &lt;<span class="hl-tag">bind-xml</span>&gt; name="item" node="element" /&gt;
&lt;<span class="hl-tag">/field</span>&gt;</pre><p>
                The resulting XML would look as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.bindxml"></a>1.2.3.7.&nbsp;The &lt;bind-xml&gt; element</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.grammar"></a>1.2.3.7.1.&nbsp;Grammar</h5></div></div></div><pre class="programlisting">
&lt;!ELEMENT bind-xml (class?, property*)&gt;
&lt;!ATTLIST bind-xml
          name     NMTOKEN     #IMPLIED
          type     NMTOKEN     #IMPLIED
          location CDATA       #IMPLIED
          matches  NMTOKENS    #IMPLIED
          QName-prefix NMTOKEN #IMPLIED
          reference   ( true | false ) "false"
          node        ( attribute | element | text )    #IMPLIED
          auto-naming ( deriveByClass | deriveByField ) #IMPLIED
          transient   ( true | false ) "false"&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="xml.mapping.mappingfile.bindxml.definition"></a>1.2.3.7.1.1.&nbsp;Definiton</h6></div></div></div><p>
            The <code class="classname">&lt;bind-xml&gt;</code> element is used to describe how a given Java field 
                should appear in an XML document. It is used both for marshalling 
                and unmarshalling.
        </p></div></div><div class="table"><a name="d4e855"></a><p class="title"><b>Table&nbsp;1.11.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The name of the element or attribute.
		              <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The name is a QName, and a namespace prefix may be used to indicate the
		              element or attribute belongs to a certain namespace. Note the prefix is not
		              preserved or used during marshalling, it's simply used for
		              qualification of which namespace the element or attribute belongs.</p></td></tr></table></div></td></tr><tr><td><span class="bold"><strong>auto-naming</strong></span></td><td>If no name is specified, this attribute controls how castor will 
		    	    automatically create a name for the field. Normally, the name is 
		    	    created using the field name, however many times it is necessary 
		    	    to create the name by using the class type instead (such as
            		heterogenenous collections).</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>XML Schema type (of the value of this field) that requires specific 
            	    handling in the Castor Marshalling Framework (such as 'QName' for 
            	    instance).</td></tr><tr><td><span class="bold"><strong>location</strong></span> (since 0.9.4.4)</td><td>Allows the user to specify the "sub-path" for which the value
                    should be marshalled to and from. This is useful for "wrapping" values in 
                    elements or for mapping values that appear on sub-elements to the 
                    current "element" represented by the class mapping. For more information,
                    see the <a href="#xml.mapping.mappingfile.locationattribute" title="1.2.6.&nbsp;Location attribute">Location attribute</a> below.</td></tr><tr><td><span class="bold"><strong>QName-prefix</strong></span></td><td>When the field represents a QName value, a prefix can be provided that
                    is used when marshalling value of type QName. More information on the 
                    use of 'QName-prefix' can be found in the 
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">SourceGenerator Documentation</a></td></tr><tr><td><span class="bold"><strong>reference</strong></span></td><td>Indicates if this field has to be treated as a reference by the 
            	    unmarshaller. In order to work properly, you must specify the node 
            	    type to 'attribute' for both the 'id' and the 'reference'. In 
            	    newer versions of Castor, 'element' node for reference is allowed. 
            	    Remember to make sure that an <span class="italic">identity</span> field is specified
                    on the <code class="classname">&lt;class&gt;</code> mapping for the object type being 
                    referenced so that Castor knows what the object's identity is.</td></tr><tr><td><span class="bold"><strong>matches</strong></span></td><td>Allows overriding the matches rules for the name of the element. It 
            	    is a standard regular expression and will be used instead of the 'name'
            	    field. A '*' will match any xml name, however it will only be matched 
            	    if no other field exists that matches the xml name.</td></tr><tr><td><span class="bold"><strong>node</strong></span></td><td>Indicates if the name corresponds to an attribute, an element,
                    or text content. By default, primitive types are assumed to be 
                    an attribute, otherwise the node is assumed to be an elemen</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>Allows for making this field transient for XML. The default value is 
            	    inherited from the &lt;field&gt; element.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.nestedclassmapping"></a>1.2.3.7.2.&nbsp;Nested class mapping</h5></div></div></div><p>Since 0.9.5.3, the bind-xml element supports a nested class mapping, which 
             is often useful when needing to specify more than one mapping for a 
             particular class. A good example of this is when mapping Hashtable/HashMap/Map.</p><pre class="programlisting">
&lt;bind-xml ...&gt;
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.exolab.castor.mapping.MapItem"</span>&gt;
      &lt;field name=<span class="hl-string">"key"</span> type=<span class="hl-string">"java.lang.String"</span>&gt;
        &lt;bind-xml name=<span class="hl-string">"id"</span>/&gt;
      &lt;/field&gt;
      &lt;field name=<span class="hl-string">"value"</span> type=<span class="hl-string">"com.acme.Foo"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;
&lt;/bind-xml&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.bindxml.usagepattern"></a>1.2.4.&nbsp;Usage Pattern</h3></div></div></div><p>Here is an example of how Castor Mapping can be used. We want to map an XML
        document like the following one (called 'order.xml').
        model.</p><pre class="programlisting">
&lt;Order reference=<span class="hl-string">"12343-AHSHE-314159"</span>&gt;
  &lt;Client&gt;
    &lt;Name&gt;Jean Smith&lt;/Name&gt;
    &lt;Address&gt;2000, Alameda de las Pulgas, San Mateo, CA 94403&lt;/Address&gt;
  &lt;/Client&gt;

  &lt;Item reference=<span class="hl-string">"RF-0001"</span>&gt;
    &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
    &lt;Quantity&gt;10&lt;/Quantity&gt;
    &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-0034"</span>&gt;
    &lt;Description&gt;Chocolate&lt;/Description&gt;
    &lt;Quantity5&lt;/Quantity&gt;
    &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-3341"</span>&gt;
     &lt;Description&gt;Cookie&lt;/Description&gt;
     &lt;Quantity&gt;30&lt;/Quantity&gt;
     &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
  &lt;/Item&gt;
&lt;/Order&gt;</pre><p>Into the following object model composed of 3 classes:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>MyOrder:</strong></span> represent an order</p></li><li><p><span class="bold"><strong>Client:</strong></span> used to store information on the client</p></li><li><p><span class="bold"><strong>Item:</strong></span> used to store item in an order</p></li></ul></div><p>The sources of these classes follow.</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Vector;
<span class="hl-keyword">import</span> java.util.Enumeration;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyOrder {

    <span class="hl-keyword">private</span> String _ref;
    <span class="hl-keyword">private</span> ClientData _client;
    <span class="hl-keyword">private</span> Vector _items;
    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span> _total;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setReference(String ref) {
        _ref = ref;
    }

    <span class="hl-keyword">public</span> String getReference() {
        <span class="hl-keyword">return</span> _ref;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setClientData(ClientData client) {
        _client = client;
    }

    <span class="hl-keyword">public</span> ClientData getClientData() {
        <span class="hl-keyword">return</span> _client;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItemsList(Vector items) {
        _items = items;
    }

    <span class="hl-keyword">public</span> Vector getItemsList() {
        <span class="hl-keyword">return</span> _items;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTotal(<span class="hl-keyword">float</span> total) {
        _total = total;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotal() {
        <span class="hl-keyword">return</span> _total;
    }

    <span class="hl-comment">// Do some processing on the data</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotalPrice() {
        <span class="hl-keyword">float</span> total = 0.0f;

        <span class="hl-keyword">for</span> (Enumeration e = _items.elements() ; e.hasMoreElements() ;) {
            Item item = (Item) e.nextElement();
            total += item._quantity * item._unitPrice;
        }

        <span class="hl-keyword">return</span> total;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ClientData {

    <span class="hl-keyword">private</span> String _name;
    <span class="hl-keyword">private</span> String _address;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress(String address) {
        _address = address;
    }

    <span class="hl-keyword">public</span> String getAddress() {
        <span class="hl-keyword">return</span> _address;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item {
    <span class="hl-keyword">public</span> String _reference;
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>    _quantity;
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span>  _unitPrice;
    <span class="hl-keyword">public</span> String _description;
}</pre><p>The XML document and the java object model can be connected by using the
        following mapping file:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyOrder"</span>&gt;
    &lt;map-to xml=<span class="hl-string">"Order"</span>/&gt;

    &lt;field name=<span class="hl-string">"Reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Total"</span>
           type=<span class="hl-string">"float"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"total-price"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ClientData"</span>
           type=<span class="hl-string">"ClientData"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Client"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ItemsList"</span>
           type=<span class="hl-string">"Item"</span>
              collection=<span class="hl-string">"vector"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Item"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"ClientData"</span>&gt;
    &lt;field name=<span class="hl-string">"Name"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Name"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Address"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Address"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Item"</span>&gt;
    &lt;field name=<span class="hl-string">"_reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_quantity"</span>
           type=<span class="hl-string">"integer"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_unitPrice"</span>
           type=<span class="hl-string">"float"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"UnitPrice"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_description"</span>
           type=<span class="hl-string">"string"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Description"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre><p>The following class is an example of how to use Castor XML Mapping to
        manipulate the file 'order.xml'. It unmarshals the document 'order.xml',
        computes the total price, sets the total price in the java object and
        marshals the object model back into XML with the calculated price.</p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.Mapping;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.MappingException;

<span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
<span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> java.io.FileReader;
<span class="hl-keyword">import</span> java.io.OutputStreamWriter;

<span class="hl-keyword">import</span> org.xml.sax.InputSource;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String args[]) {

        Mapping      mapping = <span class="hl-keyword">new</span> Mapping();

        <span class="hl-keyword">try</span> {
            <span class="hl-comment">// 1. Load the mapping information from the file</span>
            mapping.loadMapping( <span class="hl-string">"mapping.xml"</span> );

            <span class="hl-comment">// 2. Unmarshal the data</span>
            Unmarshaller unmar = <span class="hl-keyword">new</span> Unmarshaller(mapping);
            MyOrder order = (MyOrder)unmar.unmarshal(<span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> FileReader(<span class="hl-string">"order.xml"</span>)));

            <span class="hl-comment">// 3. Do some processing on the data</span>
            <span class="hl-keyword">float</span> total = order.getTotalPrice();
            System.out.println(<span class="hl-string">"Order total price = "</span> + total);
            order.setTotal(total);

            <span class="hl-comment">// 4. marshal the data with the total price back and print the XML in the console</span>
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(<span class="hl-keyword">new</span> OutputStreamWriter(System.out));
            marshaller.setMapping(mapping);
            marshaller.marshal(order);

        } <span class="hl-keyword">catch</span> (Exception e) {
            System.out.println(e);
            <span class="hl-keyword">return</span>;
        }
    }
}
       </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.xsitype"></a>1.2.5.&nbsp;xsi:type</h3></div></div></div><p>Ordinarily, a mapping will only reference types that are concrete classes (i.e. not interfaces
        nor abstract classes).  The reason is that to unmarshal a type requires instantiating it and
        one cannot instantiate an interface.  However, in many real situations, object models depend
        on the use of interfaces.  Many class properties are defined to have interface types to support
        the ability to swap implementations.  This is often the case in frameworks.</p><p>The problem is that a different mapping must be used each time the same model is to be
       used to marshal/unmarshal an implementation that uses different concrete types.  This is
       not convenient.  The mapping should represent the model and the specific concrete type
       used to unmarshal a document is a configuration parameter; it should be specified in the
       instance document to be unmarshalled, not the mapping.</p><p>For example, assume a very simple object model of an engine that has one property that
      is a processor:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> IProcessor {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> process();
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Engine {
    <span class="hl-keyword">private</span> IProcessor processor;
    <span class="hl-keyword">public</span> IProcessor getProcessor() {
        <span class="hl-keyword">return</span> processor;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProcessor(IProcessor processor) {
        <span class="hl-keyword">this</span>.processor = processor;
    }
}
            </pre><p>A typical mapping file for such a design may be:</p><pre class="programlisting">  
&lt;mapping&gt;
    &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;

        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml name=<span class="hl-string">"processor"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;

     &lt;/<span class="hl-keyword">class</span>&gt;
  &lt;/mapping&gt;</pre><p>It is possible to use such a mapping and still have the marshal/unmarshal process work
       by specifying the concrete implementation of IProcessor in the document to be unmarshalled,
       using the xsi:type attribute, as follows:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;processor xsi:type=<span class="hl-string">"java:com.abc.MyProcessor"</span> /&gt;
  &lt;/engine&gt;
            </pre><p>In this manner, one is still able to maintain only a single mapping, but vary the
      manner in which the document is unmarshalled from one instance document to the next.
      This flexibility is powerful because it enables the support of polymorphism within
      the castor xml marshalling framework.</p><p>Suppose we wanted the following XML instead:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;myProcessor/&gt;
  &lt;/engine&gt;</pre><p>In the above output our XML name changed to match the type of the class used instead of
         relying on the xsi:type attribute. This can be achieved by modifying the mapping
         file as such:
      </p><pre class="programlisting">
  &lt;mapping&gt;
     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;
        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml auto-naming=<span class="hl-string">"deriveByClass"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyProcessor"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"myProcessor"</span> /&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.locationattribute"></a>1.2.6.&nbsp;Location attribute</h3></div></div></div><p>Since 0.9.5</p><p>
          The location attribute allows the user to map fields from nested
          elements or specify a wrapper element for a given field. Wrapper
          elements are simply elements which appear in the XML instance, but
          do not have a direct mapping to an object or field within the
          object model.
        </p><p>
          For example to map an instance of the following class:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Bar bar = null;

    <span class="hl-keyword">public</span> Foo();

    <span class="hl-keyword">public</span> getBar() {
        <span class="hl-keyword">return</span> bar;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBar(Bar bar) {
        <span class="hl-keyword">this</span>.bar = bar;
    }
}</pre><p>
          into the following XML instance:
    </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;;
   &lt;<span class="hl-tag">abc</span>&gt;
      &lt;<span class="hl-tag">bar</span>&gt;...&lt;<span class="hl-tag">/bar</span>&gt;
   &lt;<span class="hl-tag">/abc</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;</pre><p>
          <span class="italic">(notice that an 'abc' field doesn't exist in the Bar class)</span>
          One would use the following mapping:</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
   ...
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"Bar"</span>&gt;
         &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span>/&gt;
      &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">/class</span>&gt;
   ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
          Note the "location" attribute. The value of this attribute is the name
          of the wrapper element. To use more than one wrapper element, the name
          is separated by a forward-slash as such:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc/xyz"</span> /&gt;</pre><p>
          Note that the name of the element is not part of the location itself and
          that the location is always relative to the class in which the field is
          being defined.

          This works for attributes also:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span> /&gt;</pre><p>
          will produce the following:
</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">abc</span> <span class="hl-attribute">bar</span>=<span class="hl-value">"..."</span>/&gt;;
&lt;<span class="hl-tag">/foo</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.tips"></a>1.2.7.&nbsp;Tips</h3></div></div></div><p>Some helpful hints...</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e964"></a>1.2.7.1.&nbsp;Automatically create a mapping file</h4></div></div></div><p>
         Castor comes with a tool that can automatically create a mapping from
         class files. Please see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.faq" target="_top">XML FAQ</a> for more
         information.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e968"></a>1.2.7.2.&nbsp;Create your own FieldHandler</h4></div></div></div><p>
          Sometimes to handle complex situations you'll need to create your
          own FieldHandler. Normally a FieldHandler deals with a specific class
          and field, however generic, reusable FieldHandlers can also be created
          by extending org.exolab.castor.mapping.GeneralizedFieldHandler or
          org.exolab.castor.mapping.AbstractFieldHandler.
          The FieldHandler can be specified on the &lt;field&gt; element.
       </p><p>
          For more information on writing a custom FieldHandler please
          see the following:
          <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML FieldHandlers</span>.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e973"></a>1.2.7.3.&nbsp;Mapping constructor arguments (since 0.9.5)</h4></div></div></div><p>
          You may map any attributes to constructor arguments. For more information
          on how to map constructor arguments see the information available
          in the section on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.mapping.mappingfile.field.constructorarguments" target="_top">set-method</a>
          above.
       </p><p>Please note that mapping <span class="bold"><strong>elements</strong></span> to constructor arguments is 
          not yet supported.
       </p><p>
          <span class="bold"><strong>Tip</strong></span>: the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.how-to" target="_top">XML HOW-TO section</a> has a HOW-TO document for 
          mapping constructor arguments.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e982"></a>1.2.7.4.&nbsp;Preventing Castor from checking for a default constructor (since 0.9.5)</h4></div></div></div><p>
          Sometimes it's useful to prevent Castor from checking for a default constructor,
          such as when trying to write a mapping for an interface or type-safe enum. You can use the
          "undocumented" verify-constructable="false" attribute on the &lt;class&gt; element to
          prevent Castor from looking for the default constructor.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e985"></a>1.2.7.5.&nbsp;Type safe enumeration mapping (since 0.9.5)</h4></div></div></div><p>
          While you can always use your own custom FieldHandler for handling type-safe enumeration
          classes, Castor does have a built-in approach to dealing with these types of classes.
          If the type-safe enum class has a <span class="bold"><strong>public static &lt;type&gt; valueOf(String)</strong></span> method
          Castor will call that method so that the proper instance of the enumeration is returned.
          Note: You'll also need to disable the default constructor check in the mapping file
          (see section 7.4 above to see more on this).
       </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.configuration"></a>1.3.&nbsp;Configuring Castor XML (Un)Marshaller</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e991"></a>1.3.1.&nbsp;Introduction</h3></div></div></div><p>To be defined ...</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e994"></a>1.3.2.&nbsp;Configuring the Marshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Marshaller</code>
			class for marshalling Java objects to XML, the
			<code class="classname">Marshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e999"></a><p class="title"><b>Table&nbsp;1.12.&nbsp;Marshaller properties</b></p><div class="table-contents"><table summary="Marshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>suppressNamespaces</td><td>&nbsp;</td><td>
							<code class="literal">true</code>
							or
							<code class="literal">false</code>
						</td><td>
							<code class="literal">false</code>
						</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1019"></a>1.3.3.&nbsp;Configuring the Unmarshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Unmarshaller</code>
			class for unmarshalling Java objects from XML, the
			<code class="classname">Unmarshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e1024"></a><p class="title"><b>Table&nbsp;1.13.&nbsp;Unmarshaller properties</b></p><div class="table-contents"><table summary="Unmarshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>rootObject</td><td>&nbsp;</td><td>
							A Class instance identifying the root class
							to use for unmarshalling.
						</td><td>-</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1041"></a>1.4.&nbsp;Usage of Castor and XML parsers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1043"></a>1.4.1.&nbsp;SAX/DOM</h3></div></div></div><p>
           Being an <span class="bold"><strong>XML data binding framework</strong></span> by definition, Castor XML relies on the 
           availability of an XML parser at run-time. In Java, an XML parser is by 
           default accessed though either the DOM or the SAX APIs: that implies
           that the XML Parser used needs to comply with either (or both) of these APIs.
        </p><p>
           With the creation of the JAXP API (and its addition to the Java language 
           definition as of Java 5.0), Castor internally has been enabled to allow
           usage of the JAXP interfaces to interface to XML parsers. As such, 
           Castor XML allows the use of a JAXP-compliant XML parser as well.
        </p><p>
           By default, Castor ships with
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           2.6.2. You may, of course, upgrade to a newer version
           of
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           at your convenience, or switch to any other XML parser as long as it is
           JAXP compliant or implements a particular SAX interface. Please note that
           users of Java 5.0 and above do not need to have Xerces available 
           at run-time, as JAXP and Xerces have both been integrated into the run-time
           library of Java.
        </p><p>
           For marshalling, Castor XML can equally use any JAXP complaint XML parser (or
           interact with an XML parser that implements the SAX API), with the exception 
           of the following special case: when using 'pretty printing' during marshalling 
           (by setting the corresponding property in <code class="literal">castor.properties</code>
           to <code class="literal">true</code>) with Java 1.4 or below, 
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           has to be on the classpath, as Castor XML internally uses Xerces' <code class="literal">XMLSerializer</code>
           to implement this feature.
        </p><p>
           The following table enlists the requirements relative to the Java version
           used in your environment.
        </p><div class="table"><a name="d4e1057"></a><p class="title"><b>Table&nbsp;1.14.&nbsp;XML APIs on various Java versions</b></p><div class="table-contents"><table summary="XML APIs on various Java versions" border="1"><colgroup><col><col align="center"></colgroup><thead><tr><th>Java 1.4 and below</th><th align="center">Java 5.0 and above</th></tr></thead><tbody><tr><td>Xerces 2.6.2</td><td align="center"> - </td></tr><tr><td>XML APIs</td><td align="center"> - </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1073"></a>1.4.2.&nbsp;StAX</h3></div></div></div><p>
            As of Castor 1.3.2, Castor XML can be used with a StAX-compliant parser to unmarshal from XML. 
            Please see <a href="#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a> for StAX-specific 
            <code class="methodname">unmarshal</code> methods added to 
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>.  
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1079"></a>1.5.&nbsp;XML configuration file</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1081"></a>1.5.1.&nbsp;News</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					Added a section on how to access the properties as
					defined in the Castor properties file from within
					code.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2.1:</strong></span>
					: Added new
					<code class="classname">
						org.exolab.castor.xml.lenient.integer.validation
					</code>
					property to allow configuration of leniency for
					validation for Java properties generated from
					<code class="classname">&lt;xs:integer&gt;</code>
					types during code generation.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2:</strong></span>
					: Access to the
					<code class="classname">org.exolab.castor.util.LocalConfiguration</code>
					class has been removed completely. To access the
					properties as used by Castor from code, please refer
					to the below section.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.1.3:</strong></span>
					Added special processing of proxied classes. The
					property org.exolab.castor.xml.proxyInterfaces
					allows you to specify a list of interfaces that such
					proxied objects implement. If your object implements
					one of these interfaces Castor will not use the
					class itself but its superclass at introspection or
					to find class mappings and ClassDescriptors.
				</p></li><li><p>
					<span class="bold"><strong>Release 0.9.7:</strong></span>
					Added new org.exolab.castor.persist.useProxies
					property to allow configuration of JDBC proxy
					classes. If enabled, JDBC proxy classes will be used
					to wrap
					<code class="classname">java.sql.Connection</code>
					and
					<code class="classname">java.sql.PreparedStatement</code>
					instances, to allow for more detailed and complete
					JDBC statements to be output during logging. When
					turned off, no logging statements will be generated
					at all.
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1103"></a>1.5.2.&nbsp;Introduction</h3></div></div></div><p>
			Castor uses a configuration file for environmental
			properties that are shared across all the Castor sub
			systems. The configuration file is specified as a Java
			properties file with the name <code class="filename">castor.properties</code>.
		</p><p>
			By definition, a default configuration file is included with the
            Castor XML JAR. Custom properties can be supplied using one of the
            following methods. Please note that the custom properties specified
            will <span class="bold"><strong>override</strong></span> the default 
            configuration. 
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    anywhere on the classpath of your application.
                </p></li><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    in the working directory of your application.
                </p></li><li><p>
                    Use the system property 
                    <code class="literal">org.castor.user.properties.location</code> to
                    specify the location of your custom properties.
                </p></li></ul></div><p>
            Please note that Castor XML - upon startup - will try the methods
            given above in exactly the sequence as stated above; if it managed
            to find a custom property file using any of the given methods,
            it will cancel its search.
        </p><p>
			When running the provided examples, Castor will use the
			configuration file located in the examples directory which
			specifies additional debugging information as well as pretty
			printing of all produced XML documents.
		</p><p>
			The following properties are currently supported in the
			configuration file:
		</p><div class="table"><a name="d4e1122"></a><p class="title"><b>Table&nbsp;1.15.&nbsp;</b></p><div class="table-contents"><table border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>
						org.exolab.castor.xml.introspector.primitive.nodetype
					</td><td>
						Property specifying the type of XML node to use
						for primitive values, either
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">attribute</code>
					</td><td>-</td></tr><tr><td>org.exolab.castor.parser</td><td>
                        Property specifying the class name of the SAX
                        XML parser to use.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.parser.validation</td><td>
                        Specifies whether to perform XML document
                        validation by default.
                    </td><td>
                        <code class="classname">true</code>
                        and
                        <code class="classname">false</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.parser.namespaces</td><td>
                        Specifies whether to support XML namespaces by
                        default.
                    </td><td>
                        <code class="classname">false</code>
                        and
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.xml.nspackages</td><td>
                        Specifies a list of XML namespace to Java
                        package mappings.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.naming</td><td>
                        Property specifying the 'type' of the XML naming
                        conventions to use. Values of this property must
                        be either
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                        .
                    </td><td>
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                    </td><td>
                        <code class="classname">lower</code>
                    </td><td>-</td></tr><tr><td>org.castor.xml.java.naming</td><td>
                        Property specifying the 'type' of the Java
                        naming conventions to use. Values of this
                        property must be either
                        <code class="classname">null</code>
                        or the name of a class which extends
                        <code class="classname">link org.castor.xml.JavaNaming</code>.
                    </td><td>
                        <p>
                           <code class="classname">null</code>
                           or the name of a class which extends
                           <code class="classname">link org.castor.xml.JavaNaming</code>.
                        </p>
                    </td><td>
                        <code class="classname">null</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.marshalling.validation
                    </td><td>
                        Specifies whether to use validation during
                        marshalling.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.indent</td><td>
                        Specifies whether XML documents (as generated at
                        marshalling) should use indentation or not.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.sax.features</td><td>Specifies additional features for the XML parser.
                    </td><td>A comma separated list of SAX (parser) features (that might or might not be supported by the specified SAX parser).</td><td><code class="classname">http://apache.org/xml/features/disallow-doctype-decl</code></td><td>-</td></tr><tr><td>org.exolab.castor.sax.features-to-disable</td><td>Specifies features to be disbaled on the underlying SAX parser.</td><td>A comma separated list of SAX (parser) features to be disabled.</td><td>
                        <code class="classname">http://xml.org/sax/features/external-general-entities</code>, 
                        <code class="classname">http://xml.org/sax/features/external-parameter-entities</code>, 
                        <code class="classname">http://apache.org/xml/features/nonvalidating/load-external-dtd</code>
                    </td><td>
                        <p><span class="bold"><strong>1.0.4</strong></span></p>
                    </td></tr><tr><td>org.exolab.castor.regexp</td><td>Specifies the regular expression validator to use.</td><td>A class that implements <code class="classname">org.exolab.castor.util.RegExpValidator</code>.</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.strictelements</td><td>
                        Specifies whether to apply strictness to
                        elements when unmarshalling. When enabled, the
                        existence of elements in the XML document, which
                        cannot be mapped to a class, causes a {@link
                        SAXException} to be thrown. If set to false,
                        these 'unknown' elements are ignored.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.xml.loadPackageMappings
                    </td><td>
                        Specifies whether the ClassDescriptorResolver
                        should (automatically) search for and consult
                        with package mapping files (
                        <code class="classname">.castor.xml</code>
                        ) to retrieve class descriptor information
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>
                        <span class="bold"><strong>1.0.2</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.serializer.factory
                    </td><td>
                        Specifying what XML serializers factory to use.
                    </td><td>A class name</td><td>
                        org.exolab.castor.xml.XercesXMLSerializerFactory
                    </td><td>
                        <span class="bold"><strong>1.0</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.sequence.order
                    </td><td>
                        Specifies whether sequence order validation
                        should be lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.id.validation
                    </td><td>
                        Specifies whether id/href validation should be
                        lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.proxyInterfaces</td><td>
                        Specifies whether or not to search for an proxy
                        interface at marshalling. If property is not
                        empty the objects to be marshalled will be
                        searched if they implement one of the given
                        interface names. If the interface is
                        implemented, the superclass will be marshalled
                        instead of the class itself.
                    </td><td>A list of proxy interfaces</td><td>-</td><td>
                        <span class="bold"><strong>1.1.3</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.integer.validation
                    </td><td>
                        Specifies whether validation for Java properties
                        generated from &lt;xs:integer&gt; should be
                        lenient, i.e. allow for
                        <code class="classname">int</code>
                        s as well.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.2.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.version</td><td>
                        Specifies the XML document version number to be used 
                        during marshalling; defaults to 1.0.
                    </td><td>
                        <code class="classname">1.0</code>
                        or
                        <code class="classname">1.1</code>
                    </td><td>
                        <code class="classname">1.0</code>
                    </td><td>
                        <span class="bold"><strong>1.3.2</strong></span>
                    </td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         As of Castor 1.3.3, the default values for <code class="classname">org.exolab.castor.sax.features</code> 
         and <code class="classname">org.exolab.castor.sax.features-to-disable</code> have changed to include/disable 
         selected features.
        </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1319"></a>1.5.3.&nbsp;Accessing the properties from within code</h3></div></div></div><p>
			As of Castor 1.1, it is possible to read and set the value of properties programmatically using the
			<code class="classname">getProperty(String)</code> and <code class="classname">setProperty(String,String)</code>
			on the following classes:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.Marshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.XMLContext</code>
				</p></li></ul></div><p>
			Whilst using the setter methods on the first two classes will change the settings of the respective instances only,
			using the <code class="classname">setProperty()</code> method on the <code class="classname">org.exolab.castor.xml.XMLContext</code>
			class will change the configuration globally, and affect all <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			and <code class="classname">org.exolab.castor.xml.Marshaller</code> instances created thereafter using the
			<code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code> and
			<code class="methodname">org.exolab.castor.xml.XMLContext.createMarshaller()</code> methods.
		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1341"></a>1.6.&nbsp;Castor XML - Tips &amp; Tricks</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1343"></a>1.6.1.&nbsp;Logging and Tracing</h3></div></div></div><p>When developing using Castor, we recommend that you use the various
         <code class="literal">setLogWriter</code> methods to get detailed information and error
         messages.</p><p>Using a logger with <code class="classname">org.exolab.castor.mapping.Mapping</code> will
         provide detailed information about mapping decisions made by Castor and
         will show the SQL statements being used.</p><p>Using a logger with <code class="classname">org.exolab.castor.jdo.JDO</code> will provide
         trace messages that show when Castor is loading, storing, creating and
         deleting objects. All database operations will appear in the log; if an
         object is retrieved from the cache or is not modified, there will be no
         trace of load/store operations.</p><p>Using a logger with <code class="classname">org.exolab.castor.xml.Unmarshaller</code> will
         provide trace messages that show conflicts between the XML document and
         loaded objects.</p><p>A simple trace logger can be obtained from
         <code class="classname">org.exolab.castor.util.Logger</code>. This logger uses the
         standard output stream, but prefixes each line with a short message
         that indicates who generated it. It can also print the time and date of
         each message. Since logging is used for warning messages and simple
         tracing, Castor does not require a sophisticated logging mechanism.</p><p>Interested in integratating Castor's logging with Log4J? Then see
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-faq.html#How-can-I-integrate-Castor's-logging-with-a-logging-infrastructure-using-Log4J?" target="_top">
         this question</a> in the JDO FAQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1357"></a>1.6.2.&nbsp;Indentation</h3></div></div></div><p>By default the marshaler writes XML documents without indentation. When
         developing using Castor or when debugging an application that uses
         Castor, it might be desireable to use indentation to make the XML
         documents human-readable. To turn indentation on, modify the Castor
         properties file, or create a new properties file in the classpath
         (named <code class="literal">castor.properties</code>) with the following content:</p><pre class="programlisting">
org.exolab.castor.indent=true
      </pre><p>Indentation inflates the size of the generated XML documents, and also
         consumes more CPU. It is recommended not to use indentation in a
         production environment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1363"></a>1.6.3.&nbsp;XML:Marshal validation</h3></div></div></div><p>It is possible to disable the validation in the marshaling framework
           by modifying the Castor properties file or by creating a new
           properties file in the classpath (named <code class="literal">castor.properties</code>)
           with the following content:</p><pre class="programlisting">
 org.exolab.castor.marshalling.validation=false
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1368"></a>1.6.4.&nbsp;NoClassDefFoundError</h3></div></div></div><p>
          Check your CLASSPATH, check it often, there is no reason not to!
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1371"></a>1.6.5.&nbsp;Mapping: auto-complete</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This only works with Castor-XML.</p></td></tr></table></div><p>
          To save time when writing your mappings, try using the <span class="italic">auto-complete</span>
          attribute of <span class="italic">class</span>. When using auto-complete, Castor will introspect
          your class and automatically fill in any missing fields.
       </p><p>
          <span class="bold"><strong>Example:</strong></span>
          </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.acme.Foo"</span> <span class="hl-attribute">auto-complete</span>=<span class="hl-value">"true"</span>/&gt;
          </pre><p>
       </p><p>
          This is also compatible with generated descriptor files. You can use a mapping file
          to override some of the behavior of a compiled descriptor by using auto-complete.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Be careful to make sure you use the exact field name as specified
          in the generated descriptor file in order to modify the behavior of the field descriptor!
          Otherwise, you'll probably end up with two fields being marshaled!
          </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1384"></a>1.6.6.&nbsp;Create method</h3></div></div></div><p>
         Castor requires that classes have a public, no-argument constructor
         in order to provide the ability to marshal &amp; unmarshal objects of that type.
      </p><p>
         create-method is an optional attribute to the <code class="literal">&lt;field&gt;</code> mapping
         element that can be used to overcome this restriction in cases where you
         have an existing object model that consists of, say, singleton classes
         where public, no-argument constructors must not be present by definition.
      </p><p>
         Assume for example that a class "<code class="literal">A</code>" that you want to be able
         to unmarshal uses a singleton class as one of its properties. When
         attempting to unmarshal class "<code class="literal">A</code>", you should get an exception
         because the singleton property has no public no-arg constructor.
         Assuming that a reference to the singleton can be obtained via a static
         getInstance() method, you can add a "create method" to class <code class="literal">A</code>
         like this:
      </p><pre class="programlisting">
 <span class="hl-keyword">public</span> MySingleton getSingletonProperty() {
    <span class="hl-keyword">return</span> MySingleton.getInstance();
 }
      </pre><p>
         and in the mapping file for class <code class="classname">A</code>, you can define 
         the singleton property like this:
      </p><pre class="programlisting">
 &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySingletonProperty"</span>
       <span class="hl-attribute">type</span>=<span class="hl-value">"com.u2d.MySingleton"</span>
       <span class="hl-attribute">create-method</span>=<span class="hl-value">"getSingletonProperty"</span>&gt;
    &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my-singleton-property"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
 &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
         This illustrates how the create-method attribute is quite a useful
         mechanism for dealing with exceptional situations where you might
         want to take advantage of marshaling even when some classes do not
         have no-argument public constructors.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
           As of this writing, the specified create-method must
           exist as a method in the current class (i.e. the class being described
           by the current <code class="literal">&lt;class&gt;</code> element). In the future it may be possible
           to use external static factory methods.
        </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1401"></a>1.6.7.&nbsp;MarshalListener and UnmarshalListener</h3></div></div></div><p>
         Castor allows control on the object being marshaled or unmarshaled by
         a set of two listener interfaces: MarshalListener and UnmarshalListener.
      </p><p>
         The MarshalListener interface located in <code class="code">org.exolab.castor.xml</code> listens to
         two different events that are intercepted by the following methods:
         </p><div class="itemizedlist"><ul type="disc"><li><p>preMarshal: this method is called before an object gets marshaled.</p></li><li><p>postMarshal: this method is called once an object has been marshaled.</p></li></ul></div><p>
      </p><p>
         The UnmarshalListener located also in <code class="literal">org.castor.xml</code> listens to
         four different events that are intercepted by the following methods:
      </p><div class="itemizedlist"><ul type="disc"><li><p>initialized: this method is called once an object has been instantiated.</p></li><li><p>attributesProcessed: this method is called when the attributes have just been read and processed.</p></li><li><p>fieldAdded: this method is called when an object is added to a parent.</p></li><li><p>unmarshalled: this method is called when an object has been <span class="bold"><strong>fully</strong></span> unmarshaled</p></li></ul></div><p>
         <span class="bold"><strong>Note:</strong></span> The <code class="classname">UnmarshalListener</code> had been part of <code class="code">org.exolab.castor.xml</code>
         but as an extention of this interface had been required a new interface in <code class="code">org.castor.xml</code>
         was introduced. Currently the <code class="code">org.exolab.castor.xml.UnmarshalListener</code> interface
         can still be used but is deprecated.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1429"></a>1.7.&nbsp;Castor XML: Writing Custom FieldHandlers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1431"></a>1.7.1.&nbsp;Introduction</h3></div></div></div><p>
          Sometimes we need to deal with a data format that Castor doesn't
          support out-of-the-box, such as an unsupported Date/Time
          representation, or we want to wrap and unwrap fields in Wrapper
          objects to get the desired XML output without changing our object
          model. To handle these cases Castor allows specifying a custom
          <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
          which can do these varying conversions during calls to the fields
          setter and getter methods.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
       		The
       		<span class="italic">FieldHandler</span>
       		is the basic interface used by the Castor Framework when
       		accessing field values or setting them. By specifying a
       		custom
       		<span class="italic">FieldHandler</span>
       		in the mapping file we can basically intercept the calls
       		to retrieve or set a field's value and do whatever
       		conversions are necessary.
       	</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1439"></a>1.7.2.&nbsp;Writing a simple FieldHandler</h3></div></div></div><p>
         When a writing a FieldHandler handler we need to provide implementations
         of the various methods specified in the FieldHandler interface. The main
         two methods are the <span class="italic">getValue</span> and <span class="italic">setValue</span> methods which
         will basically handle all our conversion code. The other methods provide
         ways to create a new instance of the field's value or reset the field
         value.
       </p><p>
         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
                It's actually even easier to write custom field handlers if we use
                a GeneralizedFieldHandler. See more details in 
                <a href="#xml.field.handler.generalized" title="1.7.3.&nbsp;Writing a GeneralizedFieldHandler">Section&nbsp;1.7.3, &#8220;Writing a GeneralizedFieldHandler&#8221;</a>
            </p></td></tr></table></div><p>
       </p><p>
         Let's take a look at how to convert a date in the format YYYY-MM-DD using
         a custom FieldHandler. We want to marshal the following XML input file <code class="classname">text.xml</code>:
         </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">root</span>&gt;2004-05-10&lt;<span class="hl-tag">/root</span>&gt;</pre><p>

         The class we'll be marshalling from and unmarshalling to looks as follows:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {

    <span class="hl-keyword">private</span> Date _date;

    <span class="hl-keyword">public</span> Root() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Date getDate() {
        <span class="hl-keyword">return</span> _date;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDate(<span class="hl-keyword">final</span> Date date) {
        _date = date;
    }
         </pre><p>

        So we need to write a custom FieldHandler that takes the input String
        and converts it into the proper java.util.Date instance:

       </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">implements</span> FieldHandler
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(<span class="hl-keyword">final</span> Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value) 
       <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
       
        Root root = (Root)object;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }


    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }


    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }
}
       </pre><p>

         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The <span class="italic">newInstance</span> method should return null for immutable types.</p></td></tr></table></div><p>

       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
          There is also an
          <code class="classname">org.exolab.castor.mapping.AbstractFieldHandler</code>
          that we can extend instead of implementing FieldHandler directly.
          Not only do we not have to implement deprecated methods, but we can also
          gain access to the <span class="italic">FieldDescriptor</span> used by Castor.
        </p></td></tr></table></div><p>

       In order to tell Castor that we want to use our Custom FieldHandler
       we must specify it in the mapping file <code class="classname">mapping.xml</code>:

        </p><pre class="programlisting">

&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"MyDateHandler"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"text"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;

        </pre><p>

         We can now use a simple Test class to unmarshal our XML document:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	       <span class="hl-comment">//--load mapping</span>
	       Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	       mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

           System.out.println(<span class="hl-string">"unmarshalling root instance:"</span>);
           System.out.println();

           Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
           Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Root.<span class="hl-keyword">class</span>);
           unmarshaller.setMapping(mapping);
           Root root = (Root) unmarshaller.unmarshal(reader);
           reader.close();

           System.out.println(<span class="hl-string">"Root#getDate : "</span> + root.getDate());
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}

         </pre><p>

         Now simply compile the code and run!

         </p><pre class="programlisting">
% java Test
unmarshalling root instance:

Root#getDate : Mon May 10 00:00:00 CDT 2004
         </pre><p>

         After running our test program we can see that Castor invoked our
         custom FieldHandler and we got our properly formatted date in our
         Root.class.

       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.field.handler.generalized"></a>1.7.3.&nbsp;Writing a GeneralizedFieldHandler</h3></div></div></div><p>
         A <code class="classname">org.exolab.castor.mapping.GeneralizedFieldHandler</code>
         is an extension of FieldHandler interface
         where we simply write the conversion methods and Castor will automatically
         handle the underlying get/set operations. This allows us to re-use the
         same FieldHandler for fields from different classes that require the
         same conversion.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
         <span class="bold"><strong>Note:</strong></span>
         Currently the GeneralizedFieldHandler cannot be used from a
         <span class="italic">binding-file</span> for use with the SourceGenerator, an
         enhancement patch will be checked into SVN for this feature,
         shortly after 0.9.6 final is released.
         </p></td></tr></table></div><p>
        The same FieldHandler we used above can be written as a GeneralizedFieldHandler
        as such:
        </p><pre class="programlisting">

<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">extends</span> GeneralizedFieldHandler {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * getValue method is called. The getValue method will
     * obtain the actual field value from given 'parent' object.
     * This convert method is then invoked with the field's
     * value. The value returned from this method will be
     * the actual value returned by getValue method.
     *
     * @param value the object value to convert after
     *  performing a get operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * setValue method is called. The setValue method will
     * call this method to obtain the converted value.
     * The converted value will then be used as the value to
     * set for the field.
     *
     * @param value the object value to convert before
     *  performing a set operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        <span class="hl-keyword">return</span> date;
    }

    <span class="hl-comment">/**
     * Returns the class type for the field that this
     * GeneralizedFieldHandler converts to and from. This
     * should be the type that is used in the
     * object model.
     *
     * @return the class type of of the field
     */</span>
    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Date.<span class="hl-keyword">class</span>;
    }

    <span class="hl-comment">/**
     * Creates a new instance of the object described by
     * this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple
     *  type and cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}

        </pre><p>

        Everything else is the same. So we can re-run our test case using this
        GeneralizedFieldHandler and we'll get the same result. The main difference
        is that we implement the <span class="italic">convertUponGet</span> and <span class="italic">convertUponSet</span>
        methods.
        </p><p>
           Notice that we never reference the <span class="italic">Root</span> 
           class in our <code class="classname">GeneralizedFieldHandler</code>. This allows us 
           to use the same exact <code class="classname">FieldHandler</code> for any field 
           that requires this type of conversion.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1480"></a>1.7.4.&nbsp;Use ConfigurableFieldHandler for more flexibility</h3></div></div></div><p>
   		In some situations, the <code class="classname">GeneralizedFieldHandler</code> might not 
           provide sufficient flexibility. Suppose your XML document uses more than one 
           date format. You could solve this by creating a <code class="classname">GeneralizedFieldHandler</code> 
           subclass per date format, but that would lead to code duplication, which in 
           itself is not desirable. 
         </p><p>
         	A <code class="classname">ConfigurableFieldHandler</code> is a <code class="classname">FieldHandler</code> 
            that can be configured in the mapping file
         	with any kind and any number of parameters. You can simply configure two (or more)
         	instances of the same <code class="classname">ConfigurableFieldHandler</code> class 
            with different date format patterns.
         	Here's a mapping file that uses a <code class="classname">ConfigurableFieldHandler</code> 
            to marshal and unmarshal the
         	date field, similar to the preceding examples:
            
         	</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;mapping&gt;
   
   &lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"FieldHandlerImpl"</span>&gt;
      &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
   &lt;/field-handler&gt;
   
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Root"</span>&gt;
      &lt;field name=<span class="hl-string">"date"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;
         	</pre><p>
         	
         	The <span class="italic">field-handler</span> element defines the 
            <code class="classname">ConfigurableFieldHandler</code>. 
         	The class must be an implementation of the 
         	<span class="italic">org.exolab.castor.mapping.ConfigurableFieldHandler</span> 
            interface. This 
         	instance is configured with a date format. However, each implementation can decide
         	which, and how many parameters to use.
         </p><p>
         	The field handler instance is referenced by the 
            <span class="italic">field</span> element, using
         	the <span class="italic">handler</span> attribute.
         </p><p>
      	Here's the ConfigurableFieldHandler implementation:
      	</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.text.DateFormat;
<span class="hl-keyword">import</span> java.util.Date;
<span class="hl-keyword">import</span> java.util.Properties;

<span class="hl-keyword">import</span> org.exolab.castor.mapping.ConfigurableFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler {

    <span class="hl-keyword">private</span> DateFormat formatter;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setConfiguration(<span class="hl-keyword">final</span> Properties config) <span class="hl-keyword">throws</span> ValidityException {
    	String pattern = config.getProperty(<span class="hl-string">"date-format"</span>);
    	<span class="hl-keyword">if</span> (pattern == null) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Required parameter \"date-format\" is missing for FieldHandlerImpl."</span>);
    	}
    	<span class="hl-keyword">try</span> {
    		formatter = <span class="hl-keyword">new</span> SimpleDateFormat(pattern);
    	} <span class="hl-keyword">catch</span> (IllegalArgumentException e) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Pattern \""</span>+pattern+<span class="hl-string">"\" is not a valid date format."</span>);
    	}
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        <span class="hl-keyword">return</span> formatter.format(value);
    }

    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        Root root = (Root)object;
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }
    
    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent)
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }

}
      	</pre><p>
         
         	This implementation is similar to the first 
            <span class="italic">MyDateHandler</span> example
         	on this page, except that is adds a 
            <span class="italic">setConfiguration</span> method as
         	specified by the 
            <span class="italic">ConfigurableFieldHandler</span> interface. All parameters 
         	that are configured	in the mapping file will be passed in as a 
            <span class="italic">Properties</span>
         	object. The implementing method is responsible for processing 
            the configuration data.
         </p><p>
         	As a convenience, 
            <span class="italic">org.exolab.castor.mapping.AbstractFieldHandler</span> 
            already 
         	implements <span class="italic">ConfigurableFieldHandler</span>. However, 
            the <span class="italic">setConfiguration</span>
         	method is not doing anything. Any subclass of 
            <span class="italic">AbstractFieldHandler</span> only
         	has to override this method to leverage the configuration capabilities. Since 
            <span class="italic">
         	AbstractFieldHandler</span> and its subclass 
            <span class="italic">GeneralizedFieldHandler</span> are
         	useful abstract classes, you'd probably want to use them anyway. It eliminates the 
         	need to	implement the 
            <span class="italic">ConfigurableFieldHandler</span> interface yourself. 
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1511"></a>1.7.5.&nbsp;Reuse a <code class="classname">ConfigurableFieldHandler</code> for more than one field definition</h3></div></div></div><p>
    		Imagine a scenario where you want to use above <code class="classname">ConfigurableFieldHandler</code> 
    		instance for more than one field - a valid use case as it promotes reuse.
    	</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
   
   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myFirstHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyyMMddHHmmss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;

   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySecondHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyy-MM-ddHH:mm:ss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;
   
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"firstDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"secondDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thirdDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mySecondHandler"</span>/&gt;
   &lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">/mapping</span>&gt;
         </pre><p>
    		For this to work, there's one more thing you will have to do: your 
    		<code class="classname">ConfigurableFieldHandler</code> implementation has to implement the 
    		<code class="classname">ClonableFieldHandlerMarker</code> interface and implement
    		the <code class="methodname">copyFieldHandler()</code> method. As indicated by the name, 
    		please return a clone/copy of your <code class="classname">FieldHandler</code> instance ... and you 
    		are all set.
    	</p><p>
    		A simplified sample implementation could look as follows, extending the 
    		<code class="classname">FieldHandlerImpl</code> class from the previous section:
    	</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler, ClonableFieldHandlerMarker {

    <span class="hl-keyword">private</span> DateFormat format;

    ...

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFormat(DateFormat format) {
        <span class="hl-keyword">this</span>.format = format;
    }

    @Override
    <span class="hl-keyword">public</span> FieldHandler copyFieldHandler() {
        FieldHandlerImpl handler = <span class="hl-keyword">new</span> FieldHandlerImpl();
        handler.setFormat(<span class="hl-keyword">this</span>.getFormat());
        <span class="hl-keyword">return</span> handler;
    }
    
}    	
    	</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1525"></a>1.7.6.&nbsp;No Constructor, No Problem!</h3></div></div></div><p>
         A number of classes such as type-safe enum style classes have no constructor, but
         instead have some sort of static factory method used for converting a string value
         into an instance of the class. With a custom FieldHandler we can allow Castor to
         work nicely with these types of classes.
      </p><p>
       </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
          Castor XML automatically supports these types of classes if they have a specific
          method:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> {Type} valueOf(String)
          </pre><p>
          </p></td></tr></table></div><p>
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>We're working on the same support for Castor JDO</p></td></tr></table></div><p>
     </p><p>
     Even though Castor XML supports the "valueOf" method type-safe enum style classes, we'll
     show you how to write a custom handler for these classes anyway since it's useful for
     any type of class regardless of the name of the factory method.
     </p><p>
       Let's look at how to write a handler for the following type-safe enum style class,
       which was actually generated by Castor XML (javadoc removed for brevity):
       </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.Serializable;
<span class="hl-keyword">import</span> java.util.Enumeration;
<span class="hl-keyword">import</span> java.util.Hashtable;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Color <span class="hl-keyword">implements</span> java.io.Serializable {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> RED_TYPE = 0;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color RED = <span class="hl-keyword">new</span> Color(RED_TYPE, <span class="hl-string">"red"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> GREEN_TYPE = 1;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color GREEN = <span class="hl-keyword">new</span> Color(GREEN_TYPE, <span class="hl-string">"green"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> BLUE_TYPE = 2;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color BLUE = <span class="hl-keyword">new</span> Color(BLUE_TYPE, <span class="hl-string">"blue"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable _memberTable = init();

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> type = -1;

    <span class="hl-keyword">private</span> java.lang.String stringValue = null;


    <span class="hl-keyword">private</span> Color(<span class="hl-keyword">int</span> type, java.lang.String value) {
        <span class="hl-keyword">super</span>();
        <span class="hl-keyword">this</span>.type = type;
        <span class="hl-keyword">this</span>.stringValue = value;
    } <span class="hl-comment">//-- test.types.Color(int, java.lang.String)</span>


    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> java.util.Enumeration enumerate()
    {
        <span class="hl-keyword">return</span> _memberTable.elements();
    } <span class="hl-comment">//-- java.util.Enumeration enumerate()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getType()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.type;
    } <span class="hl-comment">//-- int getType()</span>

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable init()
    {
        Hashtable members = <span class="hl-keyword">new</span> Hashtable();
        members.put(<span class="hl-string">"red"</span>, RED);
        members.put(<span class="hl-string">"green"</span>, GREEN);
        members.put(<span class="hl-string">"blue"</span>, BLUE);
        <span class="hl-keyword">return</span> members;
    } <span class="hl-comment">//-- java.util.Hashtable init()</span>

    <span class="hl-keyword">public</span> java.lang.String toString()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.stringValue;
    } <span class="hl-comment">//-- java.lang.String toString()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> Color valueOf(java.lang.String string)
    {
        Object obj = null;
        <span class="hl-keyword">if</span> (string != null) obj = _memberTable.get(string);
        <span class="hl-keyword">if</span> (obj == null) {
            String err = <span class="hl-string">"'"</span> + string + <span class="hl-string">"' is not a valid Color"</span>;
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(err);
        }
        <span class="hl-keyword">return</span> (Color) obj;
    } <span class="hl-comment">//-- test.types.Color valueOf(java.lang.String)</span>

}
       </pre><p>

      The <span class="italic">GeneralizedFieldHandler</span> for the above <span class="italic">Color</span> class is as follows
      (javadoc removed for brevity):

      </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-comment">/**
 * The FieldHandler for the Color class
**/</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ColorHandler
    <span class="hl-keyword">extends</span> GeneralizedFieldHandler
{

    <span class="hl-keyword">public</span> ColorHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        Color color = (Color)value;
        <span class="hl-keyword">return</span> color.toString();
    }


    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        <span class="hl-keyword">return</span> Color.valueOf((String)value);
    }

    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Color.<span class="hl-keyword">class</span>;
    }

    <span class="hl-keyword">public</span> Object newInstance( Object parent )
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}
     </pre><p>
     </p><p>
      That's all there really is to it. Now we just need to hook this up to our mapping file
      and run a sample test.
     </p><p>
       If we have a root class <span class="italic">Foo</span> as such:
     </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Color _color = null;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _size = 0;
    <span class="hl-keyword">private</span> String _name = null;

    <span class="hl-keyword">public</span> Foo() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Color getColor() {
        <span class="hl-keyword">return</span> _color;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getSize() {
        <span class="hl-keyword">return</span> _size;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setColor(Color color) {
        _color = color;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSize(<span class="hl-keyword">int</span> size) {
        _size = size;
    }

}
       </pre><p>
       Our mapping file would be the following:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"size"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>/&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"color"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"ColorHandler"</span>/&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
       </pre><p>

       We can now use our custom FieldHandler to unmarshal the following xml input:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">name</span>&gt;MyFoo&lt;<span class="hl-tag">/name</span>&gt;
   &lt;<span class="hl-tag">size</span>&gt;345&lt;<span class="hl-tag">/size</span>&gt;
   &lt;<span class="hl-tag">color</span>&gt;blue&lt;<span class="hl-tag">/color</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;
       </pre><p>

       A sample test class is as follows:
       </p><pre class="programlisting">

<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	        <span class="hl-comment">//--load mapping</span>
	        Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	        mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

            System.out.println(<span class="hl-string">"unmarshalling Foo:"</span>);
            System.out.println();

            Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
            Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Foo.<span class="hl-keyword">class</span>);
            unmarshaller.setMapping(mapping);
            Foo foo = (Foo) unmarshaller.unmarshal(reader);
            reader.close();

            System.out.println(<span class="hl-string">"Foo#size : "</span> + foo.getSize());
            System.out.print(<span class="hl-string">"Foo#color: "</span>);
            <span class="hl-keyword">if</span> (foo.getColor() == null) {
                System.out.println(<span class="hl-string">"null"</span>);
            }
            <span class="hl-keyword">else</span> {
                System.out.println(foo.getColor().toString());
            }

            PrintWriter pw = <span class="hl-keyword">new</span> PrintWriter(System.out);
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(pw);
            marshaller.setMapping(mapping);
            marshaller.marshal(foo);
            pw.flush();
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}
        </pre><p>
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1548"></a>1.7.7.&nbsp;Collections and FieldHandlers</h3></div></div></div><p>
         </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                With Castor 0.9.6 and later, the <span class="italic">GeneralizedFieldHandler</span> 
                automatically supports iterating over the items of a collection and passing them 
                one-by-one to the <span class="italic">convertUponGet</span>.
            </p><p> 
                For backward compatibility or to handle the collection iteration yourself, 
                simply add the following to the constructor of your 
                <code class="classname">GeneralizedFieldHandler</code> implementation:

            </p><pre class="programlisting">
setCollectionIteration(false);
            </pre><p>
         
            </p></td></tr></table></div><p>
      </p><p>
         If you're going to be using custom field handlers for collection fields with
         a <code class="classname">GeneralizedFieldHandler</code> using versions of Castor 
         prior to 0.9.6, then you'll need to handle the collection iteration yourself in the
         <span class="italic">convertUponGet</span>  method.
       </p><p>
         If you're not using a <code class="classname">GeneralizedFieldHandler</code>, then 
         you'll need to handle the collection iteration yourself in the 
         <span class="italic">FieldHandler#getValue()</span> method.
       </p><p>
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
               Since Castor incrementally adds items to collection fields, there
               usually is no need to handle collections directly in the
               <span class="italic">convertUponSet</span> method (or the <span class="italic">setValue()</span> for those
               not using <code class="classname">GeneralizedFieldHandler</code>).
            </p></td></tr></table></div><p>
       </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1570"></a>1.8.&nbsp;Best practice</h2></div></div></div><p>
        There are many users of Castor XML who (want to) use Castor XML in in
        high-volume applications. To fine-tune Castor for such an environment,
        it is necessary to understand many of the product features in detail
        and to be able to balance their use according to the application needs.
        Even though many of these features are documented in various places,
        people frequently asked for a 'best practices' document, a document
        that brings together these technical topics in one place and that
        presents them as a set of easy-to-use recipes.
    </p><p>
        Please be aware that this document is <span class="italic">under construction</span>.  
        But still we believe that this document -- even when in its conception
        phase -- provides valuable information to users of Castor XML.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1575"></a>1.8.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1577"></a>1.8.1.1.&nbsp;Source Generator</h4></div></div></div><p>
             It is not generally recommended to generate code into the default
             package, especially since code in the default package cannot be
             referenced from code in any other package.
           </p><p>
             Additionally, we recommend that generated code go into a different
             package then the code that makes use of the generated code.  For
             example, if your application uses Castor to process an XML
             configuration file that is used by code in the package
             <code class="literal">org.example.userdialog</code> then we do not recommend that the
             generated code also go into that package.  However, it would be
             reasonable to generate source to process this XML configuration file
             into the package <code class="literal">org.example.userdialog.xmlconfig</code>.
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1583"></a>1.8.2.&nbsp;Performance Considerations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1585"></a>1.8.2.1.&nbsp;General</h4></div></div></div><p>
          Creating instances of <code class="classname">org.exolab.castor.xml.Marshaller</code> and
          <code class="classname">org.exolab.castor.xml.Unmarshaller</code> for the purpose of XML
          data binding is easy to achieve at the API usage level.  However,
          details of API use have an impact on application performance; each
          instance creation involves setup operations.
        </p><p>
          This is generally not an issue for one-off invocations; however, in a
          multi-threaded, high volume use scenario this can be become a serious
          issue. Internally, Castor uses a collection of <span class="italic">Descriptor</span>
          classes to keep information about the Java entities to be marshaled
          and unmarshaled. With each instance creation of (Un)Marshaller, this
          collection will be built from scratch (again and again).
        </p><p>
          To avoid this initial configuration 'penalty', Castor allows you to
          cache these Descriptor classes through its
          <code class="classname">org.exolab.castor.xml.ClassDescriptorResolver</code> component.
          This cache allows reuse of these Descriptor instances between
          (Un)Marshaller invocations.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1594"></a>1.8.2.2.&nbsp;Use of XMLContext - With and without a mapping file</h4></div></div></div><p>
          With the introduction of the new <code class="classname">org.exolab.castor.xml.XMLContext</code> 
          class, the use of a 
          <code class="literal">ClassDescriptorResolver</code> has been greatly simplified in that such
          an instance is managed by the XMLContext per default. As such, there's no need
          to pass a <code class="literal">ClassDescriptorResolver</code> instance to 
          <code class="literal">Marshaller</code>/
          <code class="literal">Unmarshaller</code> instances anymore, as this is done automatically
          when such instances are created through
          
          </p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createMarshaller()</code></p></li><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code></p></li></ul></div><p>
          
          For example, to create a <code class="literal">Marshaller</code> instance that is pre-configured
          with an instance of <code class="literal">ClassDescriptorResolver</code>, use the following code 
          fragment:
        </p><pre class="programlisting">
Mapping mapping = <span class="hl-keyword">new</span> Mapping();
mapping.loadMapping(<span class="hl-keyword">new</span> InputSource(...));
        
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addMapping(mapping);

Marshaller marshaller = context.createMarshaller();</pre><p>
            In the case where no mapping file is used, it is still possible 
            to instruct the <code class="classname">org.exolab.castor.xml.XMLContext</code> to
            <span class="italic">pre-load</span> class descriptors for a given 
            package via the methods enlisted below.
         </p><p>
            As above, create an instance of <code class="classname">org.exolab.castor.xml.XMLContext</code> 
            and configure it according to your needs as shown below:
         </p><pre class="programlisting">
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addPackage(<span class="hl-string">"your.package.name"</span>);

Marshaller marshaller = context.createMarshaller();</pre><p>
            The <code class="classname">org.exolab.castor.xml.XMLContext</code> class 
            provides for various methods to load class descriptors for individual classes 
            and/or packages.
         </p><div class="table"><a name="d4e1620"></a><p class="title"><b>Table&nbsp;1.16.&nbsp;Methods on XMLContext to create Un-/Marshaller objects</b></p><div class="table-contents"><table summary="Methods on XMLContext to create Un-/Marshaller objects" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th><code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(Class)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for one class.</td><td>n/a</td></tr><tr><td><code class="methodname">addClass(Class[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptors for a collection of classes.</td><td>n/a</td></tr><tr><td><code class="methodname">addPackage(String)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined package.</td><td>Required</td></tr><tr><td><code class="methodname">addPackages(String[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined packages.</td><td>Required</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
               For some of the methods, pre-loading class descriptords will only work if you provide 
               the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
               code generator). If no such file is shipped, Castor will not be able to pre-load the 
               descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1660"></a>1.8.2.3.&nbsp;Use of Marshaller/Unmarshaller</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1662"></a>1.8.2.3.1.&nbsp;Use of ClassDescriptorResolver</h5></div></div></div><p>
             When you do not use the <code class="literal">XMLContext</code> class, you will have 
             to manually manage your 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>. To do 
             so, first create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
             using the following code fragment:
           </p><pre class="programlisting">
XMLClassDescriptorResolver classDescriptorResolver = 
   (XMLClassDescriptorResolver) ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
MappingUnmarshaller mappingUnmarshaller = <span class="hl-keyword">new</span> MappingUnmarshaller();
MappingLoader mappingLoader = 
   mappingUnmarshaller.getMappingLoader(mapping, BindingType.XML);
classDescriptorResolver.setMappingLoader(mappingLoader);</pre><p>and then reuse this instance as shown below:</p><pre class="programlisting">
   Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller();
   unmarshaller.setResolver(classDescriptorResolver);
   unmarshaller.unmarshal(...);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1671"></a>1.8.2.3.2.&nbsp;Use of ClassDescriptorResolver for pre-loading compiled descriptors</h5></div></div></div><p>
               When you are not using a mapping file, but you have generated Java 
               classes and their corresponding descriptor classes using the Castor
               XML code generator, you might want to instruct the 
               <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code> to
               <span class="italic">pre-load</span> class descriptors (as enumerated explicitly 
               or for a given package) using various <code class="literal">add*</code> methods.
            </p><p>
             As above, create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver"&gt;XMLClassDescriptorResolver</code> 
             using the following code fragment:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.A"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.B"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.C"</span>);
           </pre><p>
              and then reuse this instance as shown above. Alternatively, add complete
              packages to the resolver configuration as follows:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addPackage(<span class="hl-string">"your.package.name"</span>);
           </pre><p>
              The <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
              interface provides various other methods to load class descriptors for individual
              classes and/or packages.
           </p><div class="table"><a name="d4e1684"></a><p class="title"><b>Table&nbsp;1.17.&nbsp;blah</b></p><div class="table-contents"><table summary="blah" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th>Requires <code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(String)</code></td><td>Loads the class descriptor for one class.</td><td>No</td></tr><tr><td><code class="methodname">addClass(String[])</code></td><td>Loads the class descriptors for a collection of classes.</td><td>No</td></tr><tr><td><code class="methodname">addPackage(String)</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr><tr><td><code class="methodname">addPackages(String[])</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              For some of the methods, pre-loading class descriptords will only work if you provide 
              the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
              code generator). If no such file is shipped, Castor will not be able to pre-load the 
              descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1720"></a>1.9.&nbsp;Castor XML - HOW-TO's</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1722"></a>1.9.1.&nbsp;Introduction</h3></div></div></div><p>
			This is a collection of HOW-TOs. The Castor project is
			actively seeking additional HOW-TO contributors to expand
			this collection. For information on how to do that, please
			see 'How to write a How-to'.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1725"></a>1.9.2.&nbsp;Documentation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					How to Author a How-To
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author an FAQ
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author a Code Snippet
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author Core Documentation
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1740"></a>1.9.3.&nbsp;Contribution</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-submit-an-xml-bug.html" target="_top">
						How to submit an XML-specific bug report
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prepare-a-patch.html" target="_top">
						How to prepare a patch
					</a>
				</p></li><li><p>
					How to Contribute a Patch via Jira
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-run-xml-ctf-suite.html" target="_top">
						How to run Castor XML's test suite
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1755"></a>1.9.4.&nbsp;Mapping</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-XMLContext.html" target="_top">
						How to use XMLContext for un-/marshalling
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-collection.html" target="_top">
						How to map a collection of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-hashtable.html" target="_top">
						How to map a map/hashtable of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-list-at-root.html" target="_top">
						How to map a list of elements at the root
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-class-with-constructors.html" target="_top">
						How to map constructor arguments
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-an-inner-class.html" target="_top">
						How to map an inner class
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-unmarshal-raw-xml.html" target="_top">
						How to Unmarshal raw XML segments into arbitrary
						types
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-references-in-xml.html" target="_top">
						How to use references in XML and Castor
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-wrap-a-collection-with-a-wrapper-element.html" target="_top">
						How to wrap a collection with a wrapper element
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prevent-collection-from-being-exposed.html" target="_top">
						How to prevent a collection from being exposed
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-write-a-configurablefieldhandler.html" target="_top">
						How to write a configurable field handler
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-both-structure-and-content.html" target="_top">
						How to map text content
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-work-with-wrapper-elements-around-collections.html" target="_top">
						How to work with wrapper elements around
						collections
					</a>
				</p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-marshall-version-1.1-xml.html" target="_top">
                        How to work marshal XML documents with version 1.1
                    </a>
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1800"></a>1.9.5.&nbsp;Validation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-enable-xml-validation.html" target="_top">
						How to use XML validation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1806"></a>1.9.6.&nbsp;Source generation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-a-binding-file-with-source-generation.html" target="_top">
						How to use a binding file with source generation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1812"></a>1.9.7.&nbsp;Others</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-implement-custom-serializer.html" target="_top">
						How to implement a custom serializer
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-fetch-dtds-and-schemas-from-jars.html" target="_top">
						How to fetch DTDs and XML Schemas from JAR files
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-hibernate-proxies.html" target="_top">
						How to marshal Hibernate proxies
					</a>
				</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1824"></a>1.10.&nbsp;XML FAQ</h2></div></div></div><p>
        This section provides answers to frequently answered questions, i.e.
        questions that have been asked repeatedly on one of the mailing 
        lists. Please check with these F.A.Q.s frequently, as addressing questions
        that have been answered in the past already again and again places
        an unnecessary burden on the committers/contributors. 
    </p><p>
        This section is structured along the lines of the following areas ...
        
    </p><div class="itemizedlist"><ul type="disc"><li><p><a href="#xml.faq.general" title="1.10.1.&nbsp;General">Section&nbsp;1.10.1, &#8220;General&#8221;</a></p></li><li><p><a href="#xml.faq.introspection" title="1.10.2.&nbsp;Introspection">Section&nbsp;1.10.2, &#8220;Introspection&#8221;</a></p></li><li><p><a href="#xml.faq.mapping" title="1.10.3.&nbsp;Mapping">Section&nbsp;1.10.3, &#8220;Mapping&#8221;</a></p></li><li><p><a href="#xml.faq.marshalling" title="1.10.4.&nbsp;Marshalling">Section&nbsp;1.10.4, &#8220;Marshalling&#8221;</a></p></li><li><p><a href="#xml.faq.generation" title="1.10.5.&nbsp;Source code generation">Section&nbsp;1.10.5, &#8220;Source code generation&#8221;</a></p></li><li><p><a href="#xml.faq.misc" title="1.10.6.&nbsp;Miscellaneous">Section&nbsp;1.10.6, &#8220;Miscellaneous&#8221;</a></p></li><li><p><a href="#xml.faq.serialization" title="1.10.7.&nbsp;Serialization">Section&nbsp;1.10.7, &#8220;Serialization&#8221;</a></p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.general"></a>1.10.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1852"></a>1.10.1.1.&nbsp;How do I set the encoding?</h4></div></div></div><p>
				Create a new instance of the
				<code class="classname">Marshaller</code>
				class and use the
				<code class="classname">setEncoding</code>
				method. You'll also need to make sure the encoding for
				the Writer is set properly as well:
			</p><pre class="programlisting">
 ...
 String encoding = <span class="hl-string">"ISO-8859-1"</span>;
 FileOutputStream fos = <span class="hl-keyword">new</span> FileOutputStream(<span class="hl-string">"result.xml"</span>);
 OutputStreamWriter osw = <span class="hl-keyword">new</span> OuputStreamWriter(fos, encoding);
 Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(osw);
 marshaller.setEncoding(encoding);
 ...
			</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1858"></a>1.10.1.2.&nbsp;
				I'm getting an error about 'xml' prefix already
				declared?
			</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>For Castor 0.9.5.2 only</p></td></tr></table></div><p>
				The issue occurs with newer versions of Xerces than the
				version 1.4 that ships with Castor. The older version
				works OK. For some reason, when the newer version of
				Xerces encounters an "xml" prefixed attribute, such as
				"xml:lang", it tries to automatically start a prefix
				mapping for "xml". Which, in my opinion, is technically
				incorrect. They shouldn't be doing that. According to
				the w3c, the "xml" prefix should never be declared.
			</p><p>
				The reason it started appearing in the new Castor
				(0.9.5.2), is because of a switch to SAX 2 by default
				during unmarshaling.
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>
				A built in work-around has been checked into the Castor
				SVN and will automatically exist in any post 0.9.5.2
				releases. For those who are using 0.9.5.2 and can't
				upgrade, I found a simple workaround (tested with Xerces
				2.5). At first I thought about disabling namespace
				processing in Xerces, but then realized that it's
				already disabled by default by Castor ... so I have no
				idea why they call #startPrefixMapping when namespace
				processing has been disabled. But in any event...
				explicitly enabling namespace processing seems to fix
				the problem:
			</p><p>
				in the
				<code class="classname">castor.properties</code>
				file, change the following line:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=false
			</pre><p>to:</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
			</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					This work-around has only been tested with
					Xerces 2.5 and above.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1873"></a>1.10.1.3.&nbsp;Why is my 'get' method called twice?</h4></div></div></div><p>
				The get method will be called a second time during the
				validation process. To prevent this from happening,
				simply disable validation on the Marshaller or
				Unmarshaller.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1876"></a>1.10.1.4.&nbsp;
				How can I speed up marshalling/unmarshalling
				performance?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Cache the descriptors!</p><pre class="programlisting">
 <span class="hl-keyword">import</span> org.exolab.castor.xml.ClassDescriptorResolver;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.util.ClassDescriptorResolverImpl;
 ...
 ClassDescriptorResolver cdr = <span class="hl-keyword">new</span> ClassDescriptorResovlerImpl(); 
 ...
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setResolver(cdr);
					</pre><p>
						By reusing the same <code class="classname">ClassDescriptorResolver</code> any
						time you create an Unmarshaller instance, you
						will be reusing the existing class descriptors
						previously loaded.
					</p></li><li><p>Disable validation</p><pre class="programlisting">
 unm.setValidation(false);
					</pre></li><li><p>
						Reuse objects
                    </p><p>
						To cut down on object creation, you can reuse an
						existing object model, but be careful because
						this is an experimental feature. Create an
						Unmarshaller with your existing root object and
						set object reuse to true...
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span>
 Unmarshaller(myObjectRoot);
					</pre><pre class="programlisting">
 unm.setReuseObjects(true);
					</pre></li><li><p>
						If you have enabled pretty-printing (indenting),
						then disable it. The Xerces Serializer is much
						slower with indenting enabled.
					</p></li><li><p>
						Try changing parsers to something other than
						Xerces.
					</p></li></ul></div><p>
				There are probably other approaches you can use as well,
				but those seem to be the most popular ones. Let us know
				if you have a solution that you think we should add
				here.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1897"></a>1.10.1.5.&nbsp;
				How do I ignore elements during unmarshalling?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
						Use the
						<code class="classname">
							Unmarshaller#setIgnoreExtraElements()
						</code>
						method:
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setIgnoreExtraElements(true);
					</pre><p>
						If any elements appear in the XML instance that
						Castor cannot find mappings for, they will be
						skipped.
					</p></li><li><p>
						You can also set the 
						<code class="classname">
							org.exolab.castor.xml.strictelements 
						</code>
						property in the
						<code class="classname">castor.properties</code>
						file:
					</p><pre class="programlisting">
 org.exolab.castor.xml.strictelements=true
					</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1910"></a>1.10.1.6.&nbsp;
				Where does Castor search for the castor.properties file?
			</h4></div></div></div><p>
				Castor loads the castor.properties in the following
				order:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						From classpath (usually from the jar file)
					</p></li><li><p>From {java.home}/lib (if present)</p></li><li><p>From the local working directory</p></li></ul></div><p>
				Each properties file overrides the previous. So you
				don't have to come up with a properties file with all
				the properties and values, just the ones you want to
				change. This also means you don't have to touch the
				properties file found in the jar file.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					Note: You can also use
					<code class="classname">
						LocalConfiguration.getInstance().getProperties()
					</code>
					to change the properties values programatically.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1924"></a>1.10.1.7.&nbsp;
				Can I programmatically change the properties found in
				the castor.properties file?
			</h4></div></div></div><p>
				Yes, many of these properties can be set directly on the
				Marshaller or Unmarshaller, but you can also use
				<code class="classname">
					LocalConfiguration.getInstance().getProperties()
				</code>
				to change the properties values programatically.
				
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.introspection"></a>1.10.2.&nbsp;Introspection</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1930"></a>1.10.2.1.&nbsp;Can private methods be introspected?</h4></div></div></div><p>
				Castor does not currently support introspection of
				private methods. Please make sure proper public
				accesssor methods are available for all fields that you
				wish to be handled by the Marshalling Framework.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.mapping"></a>1.10.3.&nbsp;Mapping</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1935"></a>1.10.3.1.&nbsp;My mapping file seems to have no effect!</h4></div></div></div><p>
				Make sure you are not using one of the
				<span class="italic">static</span>
				methods on the Marshaller/Unmarshaller. Any
				configuration changes that you make to the Marshaller or
				Unmarshaller are not available from the static methods.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1939"></a>1.10.3.2.&nbsp;
				Are there any tools to automatically create a mapping
				file?
			</h4></div></div></div><p>
				Yes! We provide one such tool, see
				<code class="classname">org.exolab.castor.tools.MappingTool</code>
				. There are some 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/extras.html" target="_top">3rd party</a> 
                tools as well.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1944"></a>1.10.3.3.&nbsp;
				How do I specify a namespace in the mapping file?
			</h4></div></div></div><p>
				For a specific field you can use a QName for the value
				of the bind-xml name attribute as such:
			</p><pre class="programlisting">
 &lt;bind-xml name=<span class="hl-string">"foo:bar"</span> xmlns:foo=<span class="hl-string">"http://www.acme.com/foo"</span>/&gt;
			</pre><p>
				Note: The namespace prefix is only used for
				qualification during the loading of the mapping, it is
				not used during Marshaling. To map namespace prefixes
				during marshaling you currently need to set these via
				the Marshaler directly.
			</p><p>
				For a class mapping, use the &lt;map-to&gt; element. For
				more information see the
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping documentation</a>
				.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1951"></a>1.10.3.4.&nbsp;
				How do I prevent a field from being marshaled?
			</h4></div></div></div><p>
				Set the
				<span class="bold"><strong>transient</strong></span>
				attribute on the &lt;bind-xml&gt; element to true:
			</p><pre class="programlisting">
 &lt;bind-xml <span class="hl-keyword">transient</span>=<span class="hl-string">"true"</span>/&gt;
			</pre><p>
				Note: You can also set transient="true" on the
				&lt;field&gt; element.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.marshalling"></a>1.10.4.&nbsp;Marshalling</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1959"></a>1.10.4.1.&nbsp;
				The XML is marshalled on one line, how do I force
				line-breaks?
			</h4></div></div></div><p>For all versions of Castor:</p><p>
				To enable pretty-printing (indenting, line-breaks) just
				modify the
				<span class="italic">
					<span class="bold"><strong>castor.properties</strong></span>
				</span>
				file and uncomment the following:
			</p><pre class="programlisting">
 # True <span class="hl-keyword">if</span> all documents should be indented on output by <span class="hl-keyword">default</span>
 #
 #org.exolab.castor.indent=true
			</pre><p>
				Note: This will slow down the marshalling process
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1967"></a>1.10.4.2.&nbsp;What is the order of the marshalled XML elements?</h4></div></div></div><p>
      			If you are using Castor's default introspection to
      			automatically map the objects into XML, then there is no
      			guarantee on the order. It simply depends on the order in
      			which the fields are returned to Castor using the Java
      			reflection API.
      		</p><p>
      			Note: If you use a mapping file Castor will generate the XML
      			in the order in which the mapping file is specified.
      		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.generation"></a>1.10.5.&nbsp;Source code generation</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1973"></a>1.10.5.1.&nbsp;Can I use a DTD with the source generator?</h4></div></div></div><p>
				Not directly, however you can convert your DTD to an XML
				Schema fairly easily. We provide a tool (
				<code class="classname">
					org.exolab.castor.xml.dtd.Converter
				</code>
				) to do this. You can also use any number of 3rd-party
				tools such as XML Spy or XML Authority.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1977"></a>1.10.5.2.&nbsp;
				My XML output looks incorrect, what could be wrong?
			</h4></div></div></div><p>
				Also: I used the source code generator, but all my xml
				element names are getting marshaled as lowercase with
				hyphens, what's up with that?
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>

				Are the generated class descriptors compiled? Make sure
				they get compiled along with the source code for the
				object model.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1982"></a>1.10.5.3.&nbsp;
				The generated source code has incorrect or missing
				imports for imported schema types
			</h4></div></div></div><p>
				<span class="bold"><strong>Example:</strong></span>
				Castor generates the following:
			</p><pre class="programlisting">
 <span class="hl-keyword">import</span> types.Foo;
			</pre><p>instead of:</p><pre class="programlisting">
 <span class="hl-keyword">import</span> com.acme.types.Foo;
			</pre><p>
				This usually happens when the namespaces for the
				imported schemas have not been mapped to appropriate
				java packages in the
				<span class="italic">
					castorbuilder.properties
				</span>
				file.
			</p><p><span class="bold"><strong>Solution:</strong></span>
				</p><div class="itemizedlist"><ul type="disc"><li><p>
							Make sure the
							<code class="classname">
								castorbuilder.properties
							</code>
							is in your classpath when you run the
							SourceGenerator.
						</p></li><li><p>
							Uncomment and edit the
							<code class="classname">
								org.exolab.castor.builder.nspackages
							</code>
							property. Make sure to copy the value of the
							imported namespace exactly as it's referred
							to in the schema (i.e. trailing slashes and
							case-sensitivity matter!).
						</p></li></ul></div><p>
			</p><p>
				For those using 0.9.5.1, you'll need to upgrade due to a
				bug that is fixed in later releases.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2001"></a>1.10.5.4.&nbsp;
				How can I make the generated source code more JDO
				friendly?
			</h4></div></div></div><p>For Castor 0.9.4 and above:</p><p>
				Castor JDO requires a reference to the actual collection
				to be returned from the get-method. By default the
				source generator does not provide such a method. To
				enable such methods to be created, simple add the
				following line to your
				<code class="classname">castorbuilder.properties</code>
				file:
			</p><pre class="programlisting">
 org.exolab.castor.builder.extraCollectionMethods=true
			</pre><p>
				Note: The default
				<code class="classname">castorbuilder.properties</code>
				file has this line commented out. Simply uncomment it.
			</p><p>
				Your mapping file will also need to be updated to
				include the proper set/get method names.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.misc"></a>1.10.6.&nbsp;Miscellaneous</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2012"></a>1.10.6.1.&nbsp;
				Is there a way to automatically create an XML Schema
				from an XML instance?
			</h4></div></div></div><p>
				Yes! We provide such a tool. Please see
				<code class="classname">
					org.exolab.castor.xml.schema.util.XMLInstance2Schema
				</code>
				. It's not 100% perfect, but it does a reasonable job.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2016"></a>1.10.6.2.&nbsp;How to enable XML validation with Castor XML</h4></div></div></div><p>
				To enable XML validation at the parser level, please add
				properties to your
				<code class="classname">castor.properties</code>
				file as follows:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
 org.exolab.castor.sax.features=http:<span class="hl-comment">//xml.org/sax/features/validation,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema-full-checking</span>
			</pre><p>
				Please note that the example given relies on the use of
				Apache Xerces, hence the
				<code class="classname">apache.org</code>
				properties; similar options should exist for other
				parsers.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2023"></a>1.10.6.3.&nbsp;
				Why is mapping ignored when using a FieldHandlerFactory
			</h4></div></div></div><p>
				When using a custom FieldHandlerFactory as in the
				following example
			</p><pre class="programlisting">
 Mapping mapping = ... ;
 FieldHandlerFactoyt factory = ...;
 Marshaller m = <span class="hl-keyword">new</span> Marshaller(writer);
 ClassDescriptorResolverImpl cdr = <span class="hl-keyword">new</span> ClassDescriptorResolverImpl();
 cdr.getIntrospector().addFieldHandlerFactory(factory);
 m.setResolver(cdr);
 marshaller.setMapping(mapping);
			</pre><p>
				please make sure that you set the mapping file
				<span class="bold"><strong>after</strong></span>
				you set the ClassDescriptorResolver. You will note the
				following in the Javadoc for
				<code class="classname">org.exolab.castor.xml.Marshaller.html#setResolver(org.exolab.castor.xml.ClassDescriptorResolver)</code>
				:
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					<span class="bold"><strong>Note:</strong></span>
					This method will nullify any Mapping currently being
					used by this Marshaller
				</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.serialization"></a>1.10.7.&nbsp;Serialization</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2036"></a>1.10.7.1.&nbsp;
				Is it true that the use of Castor XML mandates 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xerces.apache.org" target="_top">Apache Xerces</a> as
				XML parser?
			</h4></div></div></div><p>
				Yes and no. It actually depends. When requiring
				<span class="italic">pretty printing</span>
				during marshalling, Castor internally relies on Apache's
				Xerces to implement this feature. As such, when not
				using this feature, Xerces is not a requirement, and any
				JAXP-compliant XML parser can be used (for
				unmarshalling).
			</p><p>
				In other words, with the latter use case, you do
				<span class="bold"><strong>not</strong></span>
				have to download (and use) Xerces separetely.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2043"></a>1.10.7.2.&nbsp;
				Do I still have to download Xerces when using Castor XML
				with Java 5.0?
			</h4></div></div></div><p>
				No. Starting with release 1.1, we have added support for
				using the Xerces instance as shipped with the JRE/JDK
				for serialization. As such, for Java 5.0 users, this
				removes the requirement to download Xerces separately
				when wanting to use 'pretty printing' with Castor XML
				during marshalling.
			</p><p>
				To enable this feature, please change the following
				properties in your
				<span class="bold"><strong>local</strong></span>
				<code class="classname">castor.properties</code>
				file (thus redefining the default value) as shown below:
			</p><pre class="programlisting">
 # Defines the XML parser to be used by Castor. 
 # The parser must implement org.xml.sax.Parser.
 org.exolab.castor.parser=org.xml.sax.helpers.XMLReaderAdapter

 # Defines the (<span class="hl-keyword">default</span>) XML serializer factory to use by Castor, which must
 # implement org.exolab.castor.xml.SerializerFactory; <span class="hl-keyword">default</span> is
 # org.exolab.castor.xml.XercesXMLSerializerFactory
 org.exolab.castor.xml.serializer.factory=org.exolab.castor.xml.XercesJDK5XMLSerializerFactory

 # Defines the <span class="hl-keyword">default</span> XML parser to be used by Castor.
 org.exolab.castor.parser=com.sun.org.apache.xerces.internal.parsers.SAXParser
			</pre></div></div></div></div>
  
  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml.code.generator"></a>Chapter&nbsp;2.&nbsp;XML code generation</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction.why-code-generator"></a>2.1.&nbsp;Why Castor XML code generator - Motivation</h2></div></div></div><p>tbd</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.introduction"></a>2.2.&nbsp;Introduction</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.news"></a>2.2.1.&nbsp;News</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.introduction.news.newFieldNamingConventions"></a>2.2.1.1.&nbsp;Source generation &amp; Java field naming conventions</h4></div></div></div><p>
               Starting with <span class="bold"><strong>release 1.3.3</strong></span>, the Castor 
               source generator supports a new naming scheme for Java field names, which 
               will be enabled by default. As such, Java field names as generated will follow more closely the standard 
               Java property naming conventions. Should there be a need to keep using the old naming schema,
			   please amend the following property in your custom <code class="literal">castorbuilder.properties</code> file:
			</p><pre class="programlisting">
#
# Property specifying whether for Java field names the old naming conventions
# should be used.
#
# Possible values:
# - true
# - false (default)
# 
# &lt;<span class="hl-tag">pre</span>&gt;
# org.exolab.castor.builder.field-naming.old = false
# &lt;<span class="hl-tag">/pre</span>&gt;
#
org.exolab.castor.builder.field-naming.old=true
	        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.introduction.news.java50"></a>2.2.1.2.&nbsp;Source generation &amp; Java 5.0</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
                        Since <span class="bold"><strong>release 1.0.2</strong></span>, the Castor 
                        source generator supports the optional the generation of 
                        Java 5.0 compliant code.
                    </p></li><li><p>
                        With <span class="bold"><strong>release 1.3</strong></span>, the XML 
                        code generator will generate Java 5.0 compliant code by default.
                    </p></li></ol></div><p>
               With support for Java 5.0 enabled, the generated code will support the 
               following Java 5.0-specific artifacts:
           </p><div class="itemizedlist"><ul type="disc"><li><p>
            Use of parameterized collections, e.g.
            <code class="literal">ArrayList&lt;String&gt;</code>.
          </p></li><li><p>
            Use of <code class="literal">@Override</code> annotations with the generated methods
            that require it.
          </p></li><li><p>
            Use of <code class="literal">@SuppressWarnings</code> with "unused" method parameters
            on the generated methods that needed it.
          </p></li><li><p>Added "enum" to the list of reserved keywords.</p></li></ul></div><p>
          To disable this feature (on by default), please amend the following property 
          in your custom <code class="literal">castorbuilder.properties</code> file:
        </p><pre class="programlisting">
# Specifies whether the sources generated should be source compatible with
# Java 1.4 or Java 5.0. Legal values are "1.4" and "5.0".  When "5.0" is
# selected, generated source will use Java 5 features such as generics and
# annotations.
# Defaults to "5.0".
#
org.exolab.castor.builder.javaVersion=5.0
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.introduction"></a>2.2.2.&nbsp;Introduction</h3></div></div></div><p>
        Castor's Source Code Generator creates a set of Java classes which
        represent an object model for an XML Schema (W3C XML Schema 1.0 Second
        Edition, Recommendation), as well as the necessary Class
        Descriptors used by the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="../xml-framework.html" target="_top">marshaling
        framework</a> to obtain information about the generated classes.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
        The generated source files will need to be compiled.  A later
        release may add an Ant taskdef to handle this automatically.
        </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.invocation"></a>2.2.3.&nbsp;Invoking the XML code generator</h3></div></div></div><p>
           The XML code generator can be invoked in many ways, including by 
           command line, via an Ant task and via Maven. Please follow the 
           below links for detailed instructions on each invocation mode.
        </p><div class="itemizedlist"><ul type="disc"><li><p><a href="#xml.code.generator.invocations.cmd" title="2.5.3.&nbsp;Command line">Section&nbsp;2.5.3, &#8220;Command line&#8221;</a></p></li><li><p><a href="#xml.code.generator.invocations.anttask" title="2.5.1.&nbsp;Ant task">Section&nbsp;2.5.1, &#8220;Ant task definition&#8221;</a></p></li><li><p><a href="#xml.code.generator.invocations.maven" title="2.5.2.&nbsp;Maven 2 plugin">Maven plugin for Castor XML</a></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.introduction.xml.schema"></a>2.2.4.&nbsp;XML Schema</h3></div></div></div><p>
        The input file for the source code generator is an XML
        schema<sup>[<a name="d4e2113" href="#ftn.d4e2113">1</a>]</sup>footnote&gt;. The currently supported version is the
        <span class="bold"><strong>W3C XML Schema 1.0, Second Edition</strong></span>
        <sup>[<a name="d4e2117" href="#ftn.d4e2117">2</a>]</sup>.
        For more information about XML schema support, check 
        <a href="#xml.code.generator.schema.support" title="2.6.&nbsp;XML schema support">Section&nbsp;2.6, &#8220;XML schema support&#8221;</a>.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.properties"></a>2.3.&nbsp;Properties</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.overview"></a>2.3.1.&nbsp;Overview</h3></div></div></div><p>
           Please find below a list of properties that can be configured through 
           the builder configuration properties, as defined in either the default
           or a custom XML code generator configuration file. These properties allow you 
           to control various advanced options of the XML source generator.
        </p><div class="table"><a name="xml.code.generator.properties.overview.grammar"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Description</th><th align="center">Values</th><th align="center">Default</th><th align="center">Since version</th></tr></thead><tbody><tr><td align="center"><a href="#xml.code.generator.properties.detailed.java50" title="2.3.3.1.&nbsp;Source generation &amp; Java 5.0">org.exolab.castor.builder.javaVersion</a></td><td align="center">Compliance with Java version</td><td align="center"><code class="literal">1.4</code>/<code class="literal">5.0</code></td><td align="center">1.4</td><td align="center"><span class="bold"><strong>1.0.2</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.enumerations.3" title="2.3.3.2.3.&nbsp;Source Generation of complex enums">org.exolab.castor.builder.forceJava4Enums</a>
               </td><td align="center">Forces the code generator to create 'old' Java 1.4 enumeration classes even in Java 5 mode.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center">false</td><td align="center"><span class="bold"><strong>1.1.3</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.bound.properties" title="2.3.3.3.&nbsp;Bound Properties">org.exolab.castor.builder.boundproperties</a>
               </td><td align="center">Generation of bound properties</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.class.creation" title="2.3.3.4.&nbsp;Class Creation/Mapping">org.exolab.castor.builder.javaclassmapping</a>
               </td><td align="center">Class generation mode</td><td align="center"><code class="literal">element</code>/<code class="literal">type</code></td><td align="center"><code class="literal">element</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.super.class" title="2.3.3.5.&nbsp;Setting a super class">org.exolab.castor.builder.superclass</a>
               </td><td align="center">Global super class (for all classes generated)</td><td align="center">Any valid class name</td><td align="center">-</td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.namespace.mapping" title="2.3.3.6.&nbsp;Mapping XML namespaces to Java packages">org.exolab.castor.builder.nspackages</a>
               </td><td align="center">XML namespace to package name mapping</td><td align="center">A series of mappings</td><td align="center">-</td><td align="center">0.8.9</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.equals" title="2.3.3.7.&nbsp;Generate equals()/hashCode() method">org.exolab.castor.builder.equalsmethod</a>
               </td><td align="center">Generation of <code class="literal">equals</code>/<code class="literal">hashCode()</code> method</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.use.cyclebreaker" title="2.3.3.8.&nbsp;Use CycleBreaker for generation of equals()/hashcode() methods.">org.exolab.castor.builder.useCycleBreaker</a>
               </td><td align="center">Use of cycle breaker code in generated <code class="literal">equals</code>/<code class="literal">hashCode()</code> method</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">true</code></td><td align="center">1.3.2</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.primitive.wrappers" title="2.3.3.9.&nbsp;Maps java primitive types to wrapper object">org.exolab.castor.builder.primitivetowrapper</a>
               </td><td align="center">Generation of Object wrappers instead of primitives</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.4</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.name.conflict.resolution" title="2.3.3.10.&nbsp;Automatic class name conflict resolution">org.exolab.castor.builder.automaticConflictResolution</a>
               </td><td align="center">Specifies whether <span class="bold"><strong>automatic class name conflict resolution</strong></span> 
                   should be used or not</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center"><span class="bold"><strong>1.1.1</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.extra.collection" title="2.3.3.11.&nbsp;Extra collection methods">org.exolab.castor.builder.extraCollectionMethods</a>
               </td><td align="center">Specifies whether <span class="bold"><strong>extra</strong></span> (additional) methods should be created for  
                   collection-style fields. Set this to true if you want your code to be
                   more compatible with Castor JDO or other persistence frameworks.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center">0.9.1</td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.class.printing" title="2.3.3.12.&nbsp;Class printing">org.exolab.castor.builder.jclassPrinterFactories</a>
               </td><td align="center">Enlists the available modes for (J)Class <span class="italic">printing</span> during
                   XML code generation.</td><td align="center"><code class="literal">org.exolab.castor.builder.printing.WriterJClassPrinterFactory</code>/
                   <code class="literal">org.exolab.castor.builder.printing.TemplateJClassPrinterFactory</code></td><td align="center">n/a</td><td align="center"><span class="bold"><strong>1.2.1</strong></span></td></tr><tr><td align="center">
                    <a href="#xml.code.generator.properties.detailed.extra.documentation" title="2.3.3.13.&nbsp;Extra documentation methods">org.exolab.castor.builder.extraDocumentationMethods</a>
               </td><td align="center">specifying whether extra members/methods for extracting XML schema
                   documentation should be made available.</td><td align="center"><code class="literal">true</code>/<code class="literal">false</code></td><td align="center"><code class="literal">false</code></td><td align="center"><span class="bold"><strong>1.2</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.process"></a>2.3.2.&nbsp;Customization - Lookup mechanism</h3></div></div></div><p>By default, the Castor XML code generator will look for such a property file 
           in the following places:</p><div class="orderedlist"><ol type="1"><li><p>If no custom property file is specified, the Castor XML code
              generator will use the default builder configuration
              properties at <code class="literal">org/exolab/castor/builder/castorbuilder.properties</code>
              as shipped as part of the XML code generator JAR.</p></li><li><p>If a file named <code class="literal">castorbuilder.properties</code> is available
              on the CLASSPATH, the Castor XML code generator will use each of the
              defined property values to override the default value as defined
              in the default builder configuration properties. This file is commonly 
              referred to as a <span class="bold"><strong>custom</strong></span> builder configuration file.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.properties.detailed"></a>2.3.3.&nbsp;Detailed descriptions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.java50"></a>2.3.3.1.&nbsp;Source generation &amp; Java 5.0</h4></div></div></div><p>
                As of <span class="bold"><strong>Castor 1.0.2</strong></span>, the Castor source generator now supports the
                generation of Java 5.0 compliant code. The generated code - with the
                new feature enabled - will make use of the following Java 5.0-specific
                artifacts:
 
                </p><div class="itemizedlist"><ul type="disc"><li><p>Use of parameterized collections, e.g. ArrayList&lt;String&gt;.</p></li><li><p>Use of @Override annotations with the generated methods
                     that require it.</p></li><li><p>Use of @SupressWarnings with "unused" method parameters
                     on the generated methods that needed it.</p></li><li><p>Added "enum" to the list of reserved keywords.</p></li></ul></div><p>
            </p><p>
                To enable this feature (off by default), please uncomment the
                following property in your custom <code class="filename">castorbuilder.properties</code>
                file:
            </p><pre class="programlisting">
# This property specifies whether the sources generated
# should comply with java 1.4 or 5.0; defaults to 1.4
org.exolab.castor.builder.javaVersion=5.0</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.enumerations"></a>2.3.3.2.&nbsp;SimpleType Enumerations</h4></div></div></div><p>
                In previous versions, castor only supported (un)marshalling of "simple" 
                java5 enums, meaning enums where all facet values are valid java identifiers. 
                In these cases, every enum constant name can be mapped directly to the xml value. 
                See the following example:
            </p><div class="informalexample"><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"AlphabeticalType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"A"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"B"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"C"</span>/&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/xs:simpleType</span>&gt;</pre></div><pre class="programlisting">
<span class="hl-keyword">public</span> enum AlphabeticalType {
    A, B, C
}</pre><pre class="programlisting">
&lt;<span class="hl-tag">root</span>&gt;
  &lt;<span class="hl-tag">AlphabeticalType</span>&gt;A&lt;<span class="hl-tag">/AlphabeticalType</span>&gt;    
&lt;<span class="hl-tag">/root</span>&gt;
    </pre><p>
                So if there is at least ONE facet that cannot be mapped directly to a 
                valid java identifier, we need to extend the enum pattern. Examples for 
                these cases are value="5" or value="-s". Castor now introduces an extended 
                pattern, similar to the jaxb2 enum handling. The actual value of the 
                enumeration facet is stored in a private String property, the name of the 
                enum constant is translated into a valid identifier. Additionally, some 
                convenience methods are introduced, details about these methods are described 
                after the following example:
             </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"CompositeType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span>/&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span>/&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/xs:simpleType</span>&gt;</pre><pre class="programlisting">
<span class="hl-keyword">public</span> enum CompositeType {
    VALUE_5(<span class="hl-string">"5"</span>),
    VALUE_10(<span class="hl-string">"10"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> java.lang.String value;

    <span class="hl-keyword">private</span> CompositeType(<span class="hl-keyword">final</span> java.lang.String value) {
        <span class="hl-keyword">this</span>.value = value;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> CompositeType fromValue(<span class="hl-keyword">final</span> java.lang.String value) {
        <span class="hl-keyword">for</span> (CompositeType c: CompositeType.values()) {
            <span class="hl-keyword">if</span> (c.value.equals(value)) {
                <span class="hl-keyword">return</span> c;
            }
        }
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(value);
    }

    <span class="hl-keyword">public</span> java.lang.String value() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.value;
    }
    
    <span class="hl-keyword">public</span> java.lang.String toString() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.value;
    }
}</pre><pre class="programlisting">
&lt;<span class="hl-tag">root</span>&gt;
  &lt;<span class="hl-tag">CompositeType</span>&gt;5&lt;<span class="hl-tag">/CompositeType</span>&gt;    
&lt;<span class="hl-tag">/root</span>&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.1"></a>2.3.3.2.1.&nbsp;Unmarshalling of complex enums</h5></div></div></div><p>
                Castor uses the static void <code class="methodname">fromValue(String value)</code>
                method to retrieve the correct instance from the value in the XML 
                input file. In our example, the input is "5", fromValue returns
                <code class="literal">CompositeType.VALUE_5</code>.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.2"></a>2.3.3.2.2.&nbsp;Marshalling of complex enums</h5></div></div></div><p>
                Currently, we have to distinguish between enums with a class 
                descriptor and the ones without. If you are using class descriptors, 
                the EnumerationHandler uses the value() method to write the xml output.
             </p><p>
                If no descriptor classes are available, castor uses per default the 
                <code class="methodname">toString()</code> 
                method to marshall the value. In this case, the override of the 
                <code class="methodname">java.lang.Enum.toString()</code> method is mandatory, because 
                <code class="methodname">java.lang.Enum.toString()</code> returns the NAME of the 
                facet instead of the VALUE. So in our example, <code class="literal">VALUE_10</code>
                would be returned instead of "10". To avoid this, castor expects an 
                implementation of <code class="methodname">toString()</code> that returns 
                <code class="literal">this.value</code>.
             </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.properties.detailed.enumerations.3"></a>2.3.3.2.3.&nbsp;Source Generation of complex enums</h5></div></div></div><p>
                   If the java version is set to "5.0", the new default behavior of 
                   castor is to generate complex java5 enums for simpleType enumerations, 
                   as described above. In java 1.4 mode, nothing has changed and the old 
                   style enumeration classes using a HashMap are created.
                </p><p>
                   Users, who are in java5 mode and still want to use the old style java 
                   1.4 classes, can force this by setting the new 
                   <code class="literal">org.exolab.castor.builder.forceJava4Enums</code> property 
                   to true as follows:
                </p><pre class="programlisting">
 # Forces the code generator to create 'old' Java 1.4 enumeration classes instead 
 # of Java 5 enums for xs:simpleType enumerations, even in Java 5 mode.
 #
 # Possible values:
 # - false (default)
 # - true
org.exolab.castor.builder.forceJava4Enums=false</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.bound.properties"></a>2.3.3.3.&nbsp;Bound Properties</h4></div></div></div><p>
             Bound properties are "properties" of a class, which when
             updated the class will send out a <code class="classname">java.beans.PropertyChangeEvent</code>
             to all registered <code class="classname">java.beans.PropertyChangeListeners</code>.
          </p><p>
             To enable bound properties, please add a property definition
             to your custom builder configuration file as follows:
          </p><pre class="programlisting">
# To enable bound properties uncomment the following line. Please
# note that currently *all* fields will be treated as bound properties
# when enabled. This will change in the future when we introduce
# fine grained control over each class and it's properties.
#
org.exolab.castor.builder.boundproperties=true</pre><p>
             When enabled, <span class="bold"><strong>all</strong></span> properties will be treated as bound properties. For
             each class that is generated a <code class="literal">setPropertyChangeListener</code> method is
             created as follows:
          </p><pre class="programlisting">
<span class="hl-comment">/**
 * Registers a PropertyChangeListener with this class.
 * @param pcl The PropertyChangeListener to register.
 **/</span>

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addPropertyChangeListener (java.beans.PropertyChangeListener pcl)
{
   propertyChangeListeners.addElement(pcl);
} <span class="hl-comment">//-- void addPropertyChangeListener</span></pre><p>
             Whenever a property of the class is changed, a
             <code class="classname">java.beans.PropertyChangeEvent</code> will be sent to
             all registered listeners. The property name, the old value and
             the new value will be set in the 
             <span class="bold"><strong>java.beans.PropertyChangeEvent</strong></span>.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
             To prevent unnecessary overhead, if the property is a collection,
             the old value will be <span class="italic">null</span>.
          </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.class.creation"></a>2.3.3.4.&nbsp;Class Creation/Mapping</h4></div></div></div><p>
               The source generator can treat the XML Schema structures such as 
               <code class="literal">&lt;complexType&gt;</code> and <code class="literal">&lt;element&gt;</code> 
               in two main ways. The first, and current default method is called the
               "element" method. The other is called the "type" method.
            </p><div class="table"><a name="xml.code.generator.properties.detailed.class.creation.table"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Method</th><th align="left">Explanation</th></tr></thead><tbody><tr><td align="center">'element'</td><td align="left">
                       <p>
                           The "element" method creates classes for all elements whose type is a
                           &lt;complexType&gt;. Abstract classes are created for all top-level
                           &lt;complexType&gt;s. Any elements whose type is a top-level type will have
                           a new class create that extends the abstract class which was generated for
                           that top-level complexType.
                        </p>
                        <p>
                           Classes are not created for elements whose type is a &lt;simpleType&gt;.
                        </p>
                   </td></tr><tr><td align="center">'type'</td><td align="left">
                        <p>
                              The "type" method creates classes for all top-level &lt;complexType&gt;s, or
                              elements that contain an "anonymous" (in-lined) &lt;complexType&gt;.
                        </p>
                        <p>
                              Classes will not be generated for elements whose type is a top-level
                              type.
                        </p>
                       </td></tr></tbody></table></div></div><br class="table-break"><p>To change the "method" of class creation, please add the following property
               definition to your custom builder configuration file:</p><pre class="programlisting">
# Java class mapping of &lt;<span class="hl-tag">xsd:element</span>&gt;'s and &lt;<span class="hl-tag">xsd:complexType</span>&gt;'s
#
org.exolab.castor.builder.javaclassmapping=type</pre><p>
				Please note that setting this property will not affect class creation when the 
				<code class="literal">defaultBindingType</code> is explicitely used in a binding file. In that case,
				the value set there will take precedence.  				
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.super.class"></a>2.3.3.5.&nbsp;Setting a super class</h4></div></div></div><p>The source generator enables the user to set a super class to <span class="bold"><strong>all</strong></span> the
               generated classes (of course, class descriptors are not affected
               by this option). Please note that, though the binding file, it is possible
               to define a super class for individual classes</p><p>To set the global super class, please add the following property
               definition to your custom builder configuration file:</p><pre class="programlisting">
# This property allows one to specify the super class of *all*
# generated classes
#
org.exolab.castor.builder.superclass=com.xyz.BaseObject</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.namespace.mapping"></a>2.3.3.6.&nbsp;Mapping XML namespaces to Java packages</h4></div></div></div><p>
                An XML Schema instance is identified by a namespace. For data-binding purposes,
                especially code generation it may be necessary to map namespaces to Java packages.
            </p><p>
                This is needed for imported schema in order for Castor to generate the
                correct imports during code generation for the primary schema.
            </p><p> To allow the mapping between namespaces and Java packages , edit the castorbuilder.properties file :
            </p><pre class="programlisting">
# XML namespace mapping to Java packages
#
#org.exolab.castor.builder.nspackages=\
   http://www.xyz.com/schemas/project=com.xyz.schemas.project,\
   http://www.xyz.com/schemas/person=com.xyz.schemas.person</pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.equals"></a>2.3.3.7.&nbsp;Generate equals()/hashCode() method</h4></div></div></div><p>Since version: 0.9.1</p><p>
                The Source Generator can override the <code class="literal">equals()</code> 
                and <code class="literal">hashCode()</code> method for the generated objects.
            </p><p>
                To have <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods generated, 
                override the following property in your custom 
                castorbuilder.properties file:
            </p><pre class="programlisting">
# Set to true if you want to have an equals() and 
# hashCode() method generated for each generated class;
# false by default
org.exolab.castor.builder.equalsmethod=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.use.cyclebreaker"></a>2.3.3.8.&nbsp;Use CycleBreaker for generation of equals()/hashcode() methods.</h4></div></div></div><p>Since version: 1.3.2</p><p>
                Specifies whether cycle breaker code should be added to generated 
                methods <code class="literal">equals()</code> and <code class="literal">hashcode()</code>.
            </p><pre class="programlisting">
# Property specifying whether cycle breaker code should be added
# to generated methods 'equals' and 'hashcode'. 
#
# Possible values:
# - true (default)
# - false
#
# &lt;<span class="hl-tag">pre</span>&gt;
# org.exolab.castor.builder.useCycleBreaker
# &lt;<span class="hl-tag">/pre</span>&gt;
org.exolab.castor.builder.useCycleBreaker=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.primitive.wrappers"></a>2.3.3.9.&nbsp;Maps java primitive types to wrapper object</h4></div></div></div><p>Since version 0.9.4</p><p>
    It may be convenient to use java objects instead of primitives,
    the Source Generator provides a way to do it. Thus the following mapping can be used:
    </p><div class="itemizedlist"><ul type="disc"><li><p>boolean to java.lang.Boolean</p></li><li><p>byte to java.lang.Byte</p></li><li><p>double to java.lang.Double</p></li><li><p>float to java.lang.Float</p></li><li><p>int and integer to java.lang.Integer</p></li><li><p>long to java.lang.Long</p></li><li><p>short to java.lang.Short</p></li></ul></div><p>
       </p><p>To enable this property, edit the castor builder.properties file:
        </p><pre class="programlisting">
# Set to true if you want to use Object Wrappers instead
# of primitives (e.g Float instead of float).
# false by default.
#org.exolab.castor.builder.primitivetowrapper=false</pre><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.name.conflict.resolution"></a>2.3.3.10.&nbsp;Automatic class name conflict resolution</h4></div></div></div><p>Since version 1.1.1</p><p>With this property enabled, the XML code generator will use 
               a new automatic class name resolution mode that has special
               logic implemented to automatically resolve class name conflicts.</p><p>This new mode deals with various class name conflicts where previously
               a binding file had to be used to resolve these conflicts manually.</p><p>To enable this feature (turned off by default), please add the 
               following property definitio to your custom <code class="literal">castorbuilder.properties</code>
               file:</p><pre class="programlisting">
# Specifies whether automatic class name conflict resolution
# should be used or not; defaults to false.
#
org.exolab.castor.builder.automaticConflictResolution=true</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.extra.collection"></a>2.3.3.11.&nbsp;Extra collection methods</h4></div></div></div><p>
            Specifies whether <span class="bold"><strong>extra</strong></span> (additional) methods 
            should be created for collection-style fields. Set this to <code class="literal">true</code>
            if you want your code to be more compatible with Castor JDO (or other 
            persistence frameworks in general).
        </p><p>
            By setting this property to <code class="literal">true</code>, additional getter/setter methods 
            for the field in question, such as get/set by reference and set as copy methods, will 
            be added. In order to have these additional methods generated, please override the 
            following code generator property in a custom
            <code class="literal">castorbuilder.properties</code> as shown:
                
            </p><pre class="programlisting">
# Enables generation of extra methods for collection fields, such as get/set by
# reference and set as copy.  Extra methods are in addition to the usual
# collection get/set methods.  Set this to true if you want your code to be
# more compatible  with Castor JDO.
#
# Possible values:
# - false (default) 
# - true
org.exolab.castor.builder.extraCollectionMethods=true
            </pre><p>

        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.class.printing"></a>2.3.3.12.&nbsp;Class printing</h4></div></div></div><p>
            As of release 1.2, Castor supports the use of Velocity-based code templates
            for code generation. For the time being, Castor will support two modes
            for code generation, i.e. the new Velocity-based and an old legacy mode.
            <span class="bold"><strong>Default</strong></span> will be the <span class="italic">legacy</span> mode; this will be changed with a 
            later release of Castor.
        </p><p>
            In order to use the new Velocity-based code generation, please
            call the method <code class="methodname">setJClassPrinterType(String)</code> on 
            <code class="classname">org.exolab.castor.builder.SourceGenerator</code> 
            with a value of <code class="literal">velocity</code>.
        </p><p>
            As we consider the code stable enough for a major release, we do encourage users 
            to use the new Velocity-based mode and to provide us with (valuable) feedback.
        </p><p>
            Please note that we have changed the mechanics of changing the JClass printing
            type between releases 1.2 and 1.2.1.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.properties.detailed.extra.documentation"></a>2.3.3.13.&nbsp;Extra documentation methods</h4></div></div></div><p>
            As of release 1.2, the Castor XML code generator - if configured as shown below - now
            supports generation of additional methods to allow programmatic access to 
            &lt;xs:documentation&gt; elements for top-level type/element definitions as
            follows:
            
            </p><pre class="programlisting">
public java.lang.String getXmlSchemaDocumentation(final java.lang.String source);
public java.util.Map getXmlSchemaDocumentations();</pre><p>
        </p><p>
            In order to have these additional methods generated as shown above, 
            please override the following code generator property in a custom 
            <code class="literal">castorbuilder.properties</code> as shown:
                
            </p><pre class="programlisting">
# Property specifying whether extra members/methods for extracting XML schema
# documentation should be made available; defaults to false
org.exolab.castor.builder.extraDocumentationMethods=true</pre><p>

        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.custom.bindings"></a>2.4.&nbsp;Custom bindings</h2></div></div></div><p>
           This section defines the Castor XML binding file and describes - based upon
           the use of examples - how to use it.
         </p><p>
           The default binding used to generate the Java Object Model from an XML
           schema may not meet your expectations. For instance, the default
           binding doesn't deal with naming collisions that can appear because
           XML Schema allows an element declaration and a complexType definition
           to use the same name.  The source generator will attempt to create two
           Java classes with the same qualified name.  However, the latter class
           generated will simply overwrite the first one.
         </p><p>
           Another example of where the default source generator binding may not
           meet your expectations is when you want to change the default datatype
           binding provided by Castor or when you want to add validation rules by
           implementing your own validator and passing it to the Source Generator.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.custom.bindings.file"></a>2.4.1.&nbsp;Binding File</h3></div></div></div><p>
              The binding declaration is an XML-based language that allows the user
              to control and tweak details about source generation for the generated
              classes.  The aim of this section is to provide an overview of the
              binding file and a definition of the several XML components used to
              define this binding file.
            </p><p>
              A more in-depth presentation  will be available soon in the
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF).</a>
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.binding"></a>2.4.1.1.&nbsp;&lt;binding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">binding</span>
    <span class="hl-attribute">defaultBindingType</span> = <span class="hl-value">(element|type)</span>&gt;
    (include*,
     package*,
     namingXML?,
     elementBinding*,
     attributeBinding,
     complexTypeBinding,
     groupBinding)
&lt;<span class="hl-tag">/binding</span>&gt;</pre><p>
                    The binding element is the root element and contains the binding
                    information.
                </p><div class="table"><a name="xml.code.generator.custom.binding.element"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Default</th><th align="center">Required ?</th></tr></thead><tbody><tr><td align="center">defaultBindingType</td><td align="center">Controls the <a href="#xml.code.generator.properties.detailed.class.creation" title="2.3.3.4.&nbsp;Class Creation/Mapping">class creation mode</a>
                              for details on the available modes. Please note that the mode 
                              specified in this attribute will override the binding type specified 
                              in the <code class="literal">castorbuilder.properties</code> file.</td><td align="center"><code class="literal">element</code></td><td align="center">No</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.include"></a>2.4.1.2.&nbsp;&lt;include&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">include</span>
    <span class="hl-attribute">URI</span> = <span class="hl-value">xsd:anyURI</span>/&gt;</pre><p>
                    This element allows you to include a binding declaration defined in
                    another file. This allows reuse of binding files defined for various
                    XML schemas.
                </p><div class="variablelist"><p class="title"><b>Attributes of &lt;include&gt;</b></p><dl><dt><span class="term"><span class="bold"><strong>URI:</strong></span></span></dt><dd><p>The URI of the binding file to include.</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.package"></a>2.4.1.3.&nbsp;&lt;package&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">package</span>&gt;
    name = xsd:string
    (namespace|schemaLocation) = xsd:string&gt;
&lt;<span class="hl-tag">/package</span>&gt;</pre><div class="table"><a name="d4e2534"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;&lt;package&gt; - Definitions</b></p><div class="table-contents"><table summary="<package&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">A fully qualified java package name.</td></tr><tr><td align="center">namespace</td><td align="left">
                                An XML namespace that will be mapped to the package name defined 
                                by the <span class="italic">name</span> element.
                            </td></tr><tr><td align="center">schemaLocation</td><td align="left">
                                A URL that locates the schema to be mapped to the package name 
                                defined by the <span class="italic">name</span> element.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                    The <code class="literal">targetNamespace</code> attribute of an XML schema 
                    identifies the namespace in which the XML schema elements are defined. This
                    language namespace is defined in the generated Java source as a package 
                    declaration. The <code class="literal">&lt;package/&gt;</code> element allows you to define
                    the mapping between an XML namespace and a Java package.
                </p><p>
                    Moreover, XML schema allows you to factor the definition of an XML
                    schema identified by a unique namespace by including several XML
                    schemas instances to build one XML schema using the
                    <code class="literal">&lt;xsd:include/&gt;</code> element. Please make sure you understand
                    the difference between <code class="literal">&lt;xsd:include/&gt;</code> and
                    <code class="literal">&lt;xsd:import/&gt;</code>. <code class="literal">&lt;xsd:include/&gt;</code> #
                    relies on the URI of the included XML schema. This element allows you to keep the
                    structure hierarchy defined in XML schema in a single generated Java
                    package. Thus the binding file allows you to define the mapping
                    between a <code class="literal">schemaLocation</code> attribute and a Java package.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.namingXML"></a>2.4.1.4.&nbsp;&lt;namingXML&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">namingXML</span>&gt;
   (elementName,complexTypeName,modelGroupName)
&lt;<span class="hl-tag">/namingXML</span>&gt;

&lt;<span class="hl-tag">elementName|complexTypeName|modelGroupName</span>&gt;
    (prefix?, suffix?) = xsd:string
&lt;<span class="hl-tag">/elementName|complexTypeName|modelGroupName</span>&gt;</pre><div class="table"><a name="d4e2567"></a><p class="title"><b>Table&nbsp;2.5.&nbsp;&lt;namingXML&gt; - Definitions</b></p><div class="table-contents"><table summary="<namingXML&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><span class="italic">prefix</span></td><td align="left">The prefix to add to the names of the generated classes.</td></tr><tr><td align="center"><span class="italic">suffix</span></td><td align="left">The suffix to append to the the names of the generated classes.</td></tr></tbody></table></div></div><br class="table-break"><p>
                    One of the aims of the binding file is to avoid naming collisions.
                    Indeed, XML schema allows &lt;element&gt;s and &lt;complexType&gt;s to share the
                    same name, resulting in name collisions when generating sources.
                    Defining a binding for each element and complexType that share the
                    same name is not always a convenient solution (for instance the BPML
                    XML schema and the UDDI v2.0 XML schema use the same names for
                    top-level complexTypes and top-level elements).
                </p><p>
                    The main aim of the <code class="literal">&lt;namingXML/&gt;</code> element is to define 
                    default prefices and suffices for the names of the classes generated for an 
                    &lt;element&gt;, a &lt;complexType&gt; or a model group definition.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                        It is not possible to control the names of the classes
                        generated to represent nested model groups (all, choice,
                        and sequence).
                    </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.custom.bindings.file.componentBinding"></a>2.4.1.5.&nbsp;&lt;componentBinding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding|attributeBinding|complexTypeBinding|groupBinding</span>
    <span class="hl-attribute">name</span> = <span class="hl-value">xsd:string</span>&gt;
   ((java-class|interface|member|contentMember),
     elementBinding*,
     attributeBinding*,
     complexTypeBinding*,
     groupBinding*)
&lt;<span class="hl-tag">/elementBinding|attributeBinding|complexTypeBinding|groupBinding</span>&gt;</pre><div class="table"><a name="d4e2593"></a><p class="title"><b>Table&nbsp;2.6.&nbsp;&lt;componentBinding&gt; - Definitions</b></p><div class="table-contents"><table summary="<componentBinding&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">
                                The name of the XML schema component for which we
                                are defining a binding.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                   These elements are the tenets of the binding file since they contain
                   the binding definition for an XML schema element, attribute,
                   complex type and model group definition. The first child element
                   (<code class="literal">&lt;java-class/&gt;</code>, <code class="literal">&lt;interface&gt;</code>, 
                   <code class="literal">&lt;member&gt;</code> or <code class="literal">&lt;contentMember/&gt;</code>) 
                   will determine the type of binding one is defining. Please note that 
                   defining a <code class="literal">&lt;java-class&gt;</code> binding on an XML schema 
                   attribute will have absolutely no effect.
                 </p><p>
                   The binding file is written from an XML schema point of view; there
                   are two distinct ways to define the XML schema component for which
                   we are defining a binding.
                 </p><div class="orderedlist"><ol type="1"><li><p>(XPath-style) name</p></li><li><p>Embedded definitions</p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2618"></a>2.4.1.5.1.&nbsp;Name</h5></div></div></div><p>  
                      First we can define it through the <code class="literal">name</code> attribute.
                    </p><p>
                      The value of the name attribute uniquely identifies the XML schema
                      component. It can refer to the top-level component using the NCName
                      of that component or it can use a location language based on
                      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath" target="_top">XPath</a>. The
                      grammar of that language can be defined by the following
                      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/Backus-Naur_form" target="_top">BNF</a>:
                    </p><pre class="programlisting">
[1]Path         ::= '/'LocationPath('/'LocationPath)*
[2]LocationPath ::= (Complex|ModelGroup|Attribute|Element|Enumeration)
[3]Complex      ::= 'complexType:'(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>)
[4]ModelGroup   ::= 'group:'<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[5]Attribute    ::= '@'<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[6]Element      ::= <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>
[7]Enumeration  ::= 'enumType':(<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/datatypes.html#NCName" target="_top">NCName</a>)
                    </pre><p>
                      Please note that all values for the <code class="literal">name</code> attribute 
                      have to start with a <code class="literal">'/'</code>.
                    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2634"></a>2.4.1.5.2.&nbsp;Embedded definitions</h5></div></div></div><p>
                      The second option to identify an XML schema component is to embed
                      its binding definition inside its parent binding definition.
                    </p><p>
                        Considering below XML schema fragment ...
                    </p><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fooType"</span>&gt;
    &lt;<span class="hl-tag">sequence</span>&gt;
        &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"foo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> /&gt;
    &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;</pre><p>
                      the following binding definitions are equivalent and
                      identify the &lt;element&gt; <code class="literal">foo</code> defined in the top-level
                      &lt;complexType&gt; <code class="literal">fooType</code>.
                    </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:fooType/foo&gt;
   &lt;member name="</span><span class="hl-attribute">MyFoo"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mypackage.myHandler"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;

&lt;<span class="hl-tag">complexTypeBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/fooType"</span>&gt;
   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/foo&gt;
      &lt;member name="</span><span class="hl-attribute">MyFoo"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mypackage.myHandler"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;
&lt;<span class="hl-tag">complexTypeBinding</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2643"></a>2.4.1.6.&nbsp;&lt;java-class&gt;</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">java-class</span>
    <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
    <span class="hl-attribute">package?</span> = <span class="hl-value">xsd:string</span>
    <span class="hl-attribute">final?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">abstract?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">equals?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">bound?</span> = <span class="hl-value">xsd:boolean</span>
    <span class="hl-attribute">(implements*,extends?)</span>
<span class="hl-attribute">&lt;/java-class&gt;</span></pre><p>
                   This element defines all the options for the class to be generated,
                   including common properties such as class name, package name, and
                   so on.
                 </p><div class="variablelist"><p class="title"><b>Attributes of &lt;java-class&gt;</b></p><dl><dt><span class="term"><span class="bold"><strong>name:</strong></span></span></dt><dd><p>The name of the class that will be generated.</p></dd><dt><span class="term"><span class="bold"><strong>package:</strong></span></span></dt><dd><p>The package of the class to be generated. if set,
              this option overrides the mapping defined in the
              <code class="literal">&lt;package/&gt;</code> element.</p></dd><dt><span class="term"><span class="bold"><strong>final:</strong></span></span></dt><dd><p>If true, the generated class will be final.</p></dd><dt><span class="term"><span class="bold"><strong>abstract:</strong></span></span></dt><dd><p>If true, the generated class will be abstract.</p></dd><dt><span class="term"><span class="bold"><strong>equals:</strong></span></span></dt><dd><p>If true, the generated class will implement the
              <code class="literal">equals()</code> and <code class="literal">hashCode()</code> method.</p></dd><dt><span class="term"><span class="bold"><strong>bound:</strong></span></span></dt><dd><p>If true, the generated class will implement bound
              properties, allowing property change notification.</p></dd></dl></div><p>
                   For instance, the following binding definition instructs the source
                   generator to generate a class <code class="literal">CustomTest</code> for a global
                   element named 'test', replacing the default class name <code class="literal">Test</code>
                   with <code class="literal">CustomTest</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"CustomTest"</span> <span class="hl-attribute">final</span>=<span class="hl-value">"true"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   In addition to the properties listed above, it is possible to define
                   that the class generated will extend a class given and/or implement
                   one or more interfaces.
                 </p><p>
                   For instance, the following binding definition instructs the source
                   generator to generate a class <code class="literal">TestWithInterface</code> that
                   implements the interface <code class="literal">org.castor.sample.SomeInterface</code> in
                   addition to <code class="literal">java.io.Serializable</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TestWithInterface"</span>&gt;
      &lt;<span class="hl-tag">implements</span>&gt;org.castor.sample.SomeInterface&lt;<span class="hl-tag">/implements</span>&gt;
   &lt;<span class="hl-tag">/java-class</span>&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;
                 </pre><p>
                   The subsequent binding definition instructs the source generator to
                   generate a class <code class="literal">TestWithExtendsAndInterface</code> that
                   implements the interface <code class="literal">org.castor.sample.SomeInterface</code> in
                   addition to <code class="literal">java.io.Serializable</code>, and extends from a
                   (probably abstract) base class <code class="literal">SomeAbstractBaseClass</code>.
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/test"</span>&gt;
   &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TestWithExtendsAndInterface"</span>&gt;
      &lt;<span class="hl-tag">extends</span>&gt;org.castor.sample.SomeAbstractBaseClass&lt;<span class="hl-tag">/extends</span>&gt;
      &lt;<span class="hl-tag">implements</span>&gt;org.castor.sample.SomeInterface&lt;<span class="hl-tag">/implements</span>&gt;
   &lt;<span class="hl-tag">/java-class</span>&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;
                 </pre><p>
                   The generated class <code class="literal">SomeAbstractBaseClass</code> will have a class
                   signature as shown below:
                 </p><pre class="programlisting">
...

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TestWithExtendsAndInterface
   <span class="hl-keyword">extends</span> SomeAbstractBaseClass
   <span class="hl-keyword">implements</span> SomeInterface, java.io.Serializable {
   ...
                 </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2706"></a>2.4.1.7.&nbsp;&lt;member&gt; element</h4></div></div></div><pre class="programlisting">
 &lt;<span class="hl-tag">member</span>
  <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">java-type?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">wrapper?</span> = <span class="hl-value">xsd:boolean</span>
  <span class="hl-attribute">handler?</span> = <span class="hl-value">xsd:string</span>
  <span class="hl-attribute">visibility?</span> = <span class="hl-value">(public|protected|private)</span>
  <span class="hl-attribute">collection?</span> = <span class="hl-value">(array|vector|arraylist|hashtable|collection|odmg|set|map|sortedset)</span>
  <span class="hl-attribute">validator?</span> = <span class="hl-value">xsd:string</span>/&gt;</pre><p>
                   This element represents the binding for class member. It allows the
                   definition of its name and java type as well as a custom implementation of
                   <span class="interface">FieldHandler</span> to help the Marshaling framework in handling that
                   member. Defining a validator is also possible. The names given for
                   the validator and the fieldHandler must be fully qualified.
                 </p><div class="table"><a name="d4e2711"></a><p class="title"><b>Table&nbsp;2.7.&nbsp;&lt;member&gt; - Definitions</b></p><div class="table-contents"><table summary="<member&gt; - Definitions" border="1"><colgroup><col><col align="left"></colgroup><thead><tr><th align="center">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="left">
                                The name of the class member that will be
                                generated.
                            </td></tr><tr><td align="center">java-type</td><td align="left">Fully qualified name of the java type.</td></tr><tr><td align="center">wrapper</td><td align="left">
                                If true, a wrapper object will be generated in
                                case the Java type is a java primitive.
                            </td></tr><tr><td align="center">handler</td><td align="left">
                                Fully qualified name of the custom FieldHandler to
                                use.
                            </td></tr><tr><td align="center">collection</td><td align="left">
                                If the schema component can occur more than
                                once then this attribute allows specifying the collection to use
                                to represent the component in Java.
                            </td></tr><tr><td align="center">validator</td><td align="left">
                                Fully qualified name of the <span class="interface">FieldValidator</span>
                                to use.
                            </td></tr><tr><td align="center">visibility</td><td align="left">
                                A custom visibility of the content class member generated, 
                                with the default being <code class="literal">public</code>.
                            </td></tr></tbody></table></div></div><br class="table-break"><p>
                    For instance, the following binding definition:
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/root/members"</span>&gt;
   &lt;<span class="hl-tag">member</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"set"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                      instructs the source generator to generate -- within a class
                      <code class="classname">Root</code> -- a Java member named 
                      <code class="literal">members</code> using the
                      collection type <code class="classname">java.util.Set</code> instead of the default
                      <code class="classname">java.util.List</code>:
                 </p><pre class="programlisting">
         <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {
         
            <span class="hl-keyword">private</span> java.util.Set members;
         
            ...
         
         }</pre><p>
                    The following (slightly amended) binding element:
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/root/members"</span>&gt;
   &lt;<span class="hl-tag">member</span> <span class="hl-attribute">name</span>=<span class="hl-value">"memberSet"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"set"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   instructs the source generator to generate -- again within a class
                   <code class="classname">Root</code> -- a Java member named 
                   <code class="literal">memberSet</code> (of the same
                   collection type as in the previous example), overriding the name of
                   the member as specified in the XML schema:
                 </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {

   <span class="hl-keyword">private</span> java.util.Set memberSet;

   ...

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2760"></a>2.4.1.8.&nbsp;&lt;contentMember&gt; element</h4></div></div></div><pre class="programlisting">
          &lt;<span class="hl-tag">contentMember</span>
           <span class="hl-attribute">name?</span> = <span class="hl-value">xsd:string</span>
           <span class="hl-attribute">visiblity?</span> = <span class="hl-value">(public|protected|private)</span></pre><p>
                   This element represents the binding for <span class="italic">content</span> 
                   class member generated as a result of a mixed mode declaration of a 
                   complex type definition. It allows the definition of its name and 
                   its visibility
                 </p><div class="variablelist"><dl><dt><span class="term"><span class="bold"><strong>name:</strong></span></span></dt><dd><p>The name of the class member that will be
              generated, overriding the default name of
<code class="literal">_content</code>.</p></dd><dt><span class="term"><span class="bold"><strong>visibility:</strong></span></span></dt><dd><p>A custom visibility of the content class member generated, with 
              the default being
<code class="literal">public</code>.</p></dd></dl></div><p>
                   For a complex type definition declared to be <span class="italic">mixed</span>
                   such as follows ...
                 </p><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"RootType"</span> <span class="hl-attribute">mixed</span>=<span class="hl-value">"true"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      ...
   &gt;/sequence&gt;
&gt;/complexType&gt;</pre><p>... the following binding definition ...</p><pre class="programlisting">
&lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:RootType"</span>&gt;
   &lt;<span class="hl-tag">contentMember</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customContentMember"</span>/&gt;
&lt;<span class="hl-tag">/elementBinding</span>&gt;</pre><p>
                   instructs the source generator to generate -- within a class
                   <code class="classname">RootType</code> -- a Java member named 
                   <code class="literal">customContentMember</code> of type 
                   <code class="classname">java.lang.String</code>:
                 </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RootType {

   <span class="hl-keyword">private</span> java.util.String customContentMember;

   ...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2790"></a>2.4.1.9.&nbsp;&lt;enumBinding&gt; element</h4></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">enumBinding</span>&gt;
   (enumDef)
&lt;<span class="hl-tag">/enumBinding</span>&gt;

&lt;<span class="hl-tag">enumDef</span>&gt;
   (enumClassName = xsd:string, enumMember*)
&lt;<span class="hl-tag">/enumDef</span>&gt;

&lt;<span class="hl-tag">enumMember</span>&gt;
   (name = xsd:string, value = xsd:string)
&lt;<span class="hl-tag">/enumMember</span>&gt;</pre><p>
                      The <code class="literal">&lt;enumBinding&gt;</code> element allows more control on the
                      code generated for type-safe enumerations, which are used to
                      represent an XML Schema <code class="literal">&lt;simpleType&gt;</code> enumeration.
                    </p><p>
                     For instance, given the following XML schema enumeration definition:
                   </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"durationUnitType"</span>&gt;
  &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">'xs:string'</span>&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'Y'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'M'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'D'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'h'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'m'</span> /&gt;
    &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">'s'</span> /&gt;
  &lt;<span class="hl-tag">/xs:restriction</span>&gt;
&lt;<span class="hl-tag">/simpleType</span>&gt;</pre><p>
                     the Castor code generator would generate code where the default
                     naming convention used during the generation would overwrite the
                     first constant definition for value '<code class="literal">M</code>' with the one
                     generated for value '<code class="literal">m</code>'.
                   </p><p>
                     The following binding definition defines -- through the means of
                     an <code class="literal">&lt;enumMember&gt;</code> definition for the enumeration
                     value '<code class="literal">M</code>' -- a special binding for this value:
                   </p><pre class="programlisting">
&lt;<span class="hl-tag">enumBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/enumType:durationUnitType"</span>&gt;
  &lt;<span class="hl-tag">enum-def</span>&gt;
    &lt;<span class="hl-tag">enumMember</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;M&lt;<span class="hl-tag">/value</span>&gt;
      &lt;<span class="hl-tag">javaName</span>&gt;CUSTOM_M&lt;<span class="hl-tag">/javaName</span>&gt;
    &lt;<span class="hl-tag">/enumMember</span>&gt;
  &lt;<span class="hl-tag">/enum-def</span>&gt;
&lt;<span class="hl-tag">/enumBinding</span>&gt;</pre><p>
                     and instructs the source generator to generate -- within a class
                     <code class="literal">DurationUnitType</code> -- a constant definition named
                     <code class="literal">CUSTOM_M</code> for the enumeration value <code class="literal">M</code>.
                   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2809"></a>2.4.1.10.&nbsp;Not implemented yet</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2811"></a>2.4.1.10.1.&nbsp;&lt;javadoc&gt;</h5></div></div></div><p>
                           The <code class="literal">&lt;javadoc&gt;</code> element allows one to enter the
                           necessary JavaDoc representing the generated classes or members.
                        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2815"></a>2.4.1.10.2.&nbsp;&lt;interface&gt; element</h5></div></div></div><pre class="programlisting">
&lt;<span class="hl-tag">interface</span>&gt;
  name = xsd:string
&lt;<span class="hl-tag">/interface</span>&gt;</pre><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>name:</strong></span>The name of the interface to generate.</p></li></ul></div><p>
                           This element specifies the name of the interface to be generated
                           for an XML schema component.
                        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e2823"></a>2.4.2.&nbsp;Class generation conflicts</h3></div></div></div><p>As mentioned previously, you use a binding file for two main reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>
                                To customize the Java code generated
                            </p></li><li><p>To avoid class generation conflicts.</p></li></ul></div><p>
                       For the latter case, you'll (often) notice such collisions by looking at 
                       generated Java code that frequently does not compile. Whilst this is relatively
                       easy for small(ish) XML schema(s), this task gets tedious for more elaborate 
                       XML schemas. To ease your life in the context of this 'collision detection', 
                       the Castor XML code generator provides you with a few advanced features. The 
                       following sections cover these features in detail.
                    </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2832"></a>2.4.2.1.&nbsp;Collision reporting</h4></div></div></div><p>
                           During code generation, the Castor XML code generator will run into
                           situations where a class (about to be generated, and as such about to be 
                           written to the file system) will overwrite an already existing class. This,
                           for example, is the case if within one XML schema there's two (local)
                           element definitions within separate complex type definitions with the same
                           name. In such a case, Castor will emit warning messages that inform the
                           user that a class will be overwritten.
                        </p><p>
                           As of release 1.1, the Castor XML code generator supports two 
                           <span class="italic">reporting modes</span> that allow different levels of control in the event 
                           of such collisions, <code class="literal">warnViaConsoleDialog</code> and <code class="literal">informViaLog</code> 
                           mode.
                        </p><div class="table"><a name="???"></a><p class="title"><b>Table&nbsp;2.8.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Mode</th><th align="center">Description</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><code class="literal">warnViaConsoleDialog</code></td><td align="center">Emits warning messages to <code class="literal">stdout</code> and ask the 
                                    users whether to continue.</td><td align="center">0.9</td></tr><tr><td align="center"><code class="literal">informViaLog</code></td><td align="center">Emits warning messages only via the standard logger.</td><td align="center">1.1</td></tr></tbody></table></div></div><br class="table-break"><p>
                           Please select the reporting mode of your choice according to your needs, the 
                           default being <code class="literal">warnViaConsoleDialog</code>. Please note that the
                           <code class="literal">informViaLog</code> reporting mode should be the preferred choice
                           when using the XML code generator in an automated environment.
                        </p><p>
                           In general, the warning messages produced are very useful in assisting
                           you in your creation of the binding file, as shown in below example
                           for the <code class="literal">warnViaConsoleDialog</code> mode:
                        </p><pre class="programlisting">
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
 Warning: A class name generation conflict has occurred between element
         'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
         Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
                         </pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2868"></a>2.4.2.1.1.&nbsp;Reporting mode 'warnViaConsoleDialog'</h5></div></div></div><p>
                              As already mentioned, this mode emits warning messages to <code class="literal">stdout</code>, and 
                              asks you whether you want to continue with the code generation or not. This 
                              allows for very fine grained control over the extent of the code generation.
                            </p><p>
                               Please note that there is several <span class="italic">setter</span> methods on the 
                               <code class="classname">org.exolab.castor.builder.SourceGenerator</code> that allow you to fine-tune
                               various settings for this reporting mode. Genuinely, we believe that for 
                               automated code generation through either Ant or Maven, the new <code class="literal">informViaLog</code>
                               is better suited for these needs.
                            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2876"></a>2.4.2.2.&nbsp;Automatic collision resolution</h4></div></div></div><p>
                           As of Castor 1.1.1, support has been added to the Castor XML code generator 
                           for a (nearly) automatic conflict resolution. To enable this new mode,
                           please override the following property in your custom property file
                           as shown below:
                        </p><pre class="programlisting">
 # Specifies whether automatic class name conflict resolution
 # should be used or not; defaults to false.
 #
 org.exolab.castor.builder.automaticConflictResolution=true</pre><p>
                           As a result of enabling automatic conflict resolution, Castor will try
                           to resolve such name collisions automatically, using one of the following 
                           two strategies:
                        </p><div class="table"><a name="???Y?"></a><p class="title"><b>Table&nbsp;2.9.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Since</th><th align="center">Default</th></tr></thead><tbody><tr><td align="center"><code class="literal">xpath</code></td><td align="center">Prepends an XPATH fragment to make the suggested Java name unique.</td><td align="center">1.1.1</td><td align="center">Yes</td></tr><tr><td align="center"><code class="literal">type</code></td><td align="center">Appends type information to the suggested Java name.</td><td align="center">1.1.1</td><td align="center">No</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2907"></a>2.4.2.2.1.&nbsp;Selecting the strategy</h5></div></div></div><p>
                               For selecting one of the two strategies during XML code
                               generation, please see the documentation for the following 
                               code artifacts:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="methodname">setClassNameConflictResolver</code> on <code class="classname">org.exolab.castor.builder.SourceGenerator</code></p></li><li><p><code class="classname">org.exolab.castor.builder.SourceGeneratorMain"</code></p></li><li><p><a href="#xml.code.generator.invocations.anttask" title="2.5.1.&nbsp;Ant task">Ant task definition</a></p></li><li><p><a href="#xml.code.generator.invocations.maven" title="2.5.2.&nbsp;Maven 2 plugin">Maven plugin for Castor XML</a></p></li></ul></div></div><p>
                           In order to explain the <span class="italic">modus operandi</span> of these two modes, please
                           assume two complex type definitions <code class="literal">AType</code> and <code class="literal">BType</code> 
                           in an XML schema, with both of them defining a local element named <code class="literal">c</code>.</p><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"AType"</span>&gt;
    &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"c"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"CType1"</span> /&gt;
    &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;            

&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"BType"</span>&gt;
    &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"c"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"CType2"</span> /&gt;
    &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;</pre><p>
                           Without automatic collision resolution enabled, Castor will create 
                           identically named classes <code class="literal">C.java</code> for both members, and one
                           will overwrite the other. Please note the different types for the
                           two <code class="literal">c</code> element definitions, which requires two class files to be 
                           generated in order not to lose this information.
                        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2933"></a>2.4.2.2.2.&nbsp;'XPATH' strategy</h5></div></div></div><p>
                               This strategy will prepend an XPATH fragment to the default Java name 
                               as derived during code generation, the default name (frequently) being the name 
                               of the XML schema artifact, e.g. the element name of the complex type name. The
                               XPATH fragment being prepended is minimal in the sense that the resulting
                               rooted XPATH is unique for the XML schema artifact being processed.
                            </p><p>
                                With automatic collision resolution enabled and the strategy 'XPATH' 
                                selected, Castor will create the following two classes, simply prepending 
                                the name of the complex type to the default element name:
                            </p><div class="itemizedlist"><ul type="disc"><li><p>ATypeC.java</p></li><li><p>BTypeC.java</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2942"></a>2.4.2.2.3.&nbsp;'TYPE' strategy</h5></div></div></div><p>
                               This strategy will append 'type' information to the default Java name 
                               as derived during code generation, the default name (frequently) being the name 
                               of the XML schema artifact, e.g. the element name of the complex type name.
                            </p><p>
                                With automatic collision resolution enabled and
                                the strategy 'TYPE' selected, Castor will create the following two 
                                classes, simply appending the name of the complex type to the default
                                element name (with a default '<code class="literal">By</code>' inserted):
                            </p><div class="itemizedlist"><ul type="disc"><li><p>CByCType1.java</p></li><li><p>CByCType2.java</p></li></ul></div><p>
                               To override the default '<code class="literal">By</code>' inserted between the default
                               element name and the type information, please override the following 
                               property in your custom property file as shown below:
                            </p><pre class="programlisting">
# Property specifying the 'string' used in type strategy to be inserted 
# between the actual element name and the type name (during automatic class name 
# conflict resolution); defaults to 'By'.
org.exolab.castor.builder.automaticConflictResolutionTypeSuffix=ByBy</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e2955"></a>2.4.2.2.4.&nbsp;Conflicts covered</h5></div></div></div><p>
                               The Castor XML code generator, with automatic collision resolution
                               enabled, is capable of resolving the following collisions
                               automatically:
                            </p><div class="itemizedlist"><ul type="disc"><li><p>Name of local element definition same as name of a global element</p></li><li><p>Name of local element definition same as name of another local element definition.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                                  Please note that <span class="italic">collision resolution</span> for a local to local collision
                                  will only take place for the second local element definition encountered (and 
                                  subsequent ones).
                               </p></td></tr></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.invocations"></a>2.5.&nbsp;Invoking the XML code generator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.anttask"></a>2.5.1.&nbsp;Ant task</h3></div></div></div><p>
           An alternative to using the command line as shown in the previous section,
           the Castor Source Generator Ant Task can be used to call the source
           generator for class generation. The only requirement is that the
           castor-&lt;version&gt;-codegen-antask.jar must additionally be on 
           the CLASSPATH.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.source"></a>2.5.1.1.&nbsp;Specifying the source for generation</h4></div></div></div><p>
             As shown in the subsequent table, there's multiple ways of specifying the input
             for the Castor code generator. <span class="bold"><strong>At least one</strong></span> input source
             has to be specified. 
           </p><div class="table"><a name="xml.code.generator.invocations.anttask.source.table"></a><p class="title"><b>Table&nbsp;2.10.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Description</th><th align="center">Required</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><span class="bold"><strong>file</strong></span></td><td align="center">The XML schema, to be used as input for the source code generator.</td><td align="center">No.</td><td align="center"> - </td></tr><tr><td align="center"><span class="bold"><strong>dir</strong></span></td><td align="center">Sets a directory such that all XML schemas in this directory will have 
                      code generated for them.</td><td align="center">No</td><td align="center"> - </td></tr><tr><td align="center"><span class="bold"><strong>schemaURL</strong></span></td><td align="center">URL to an XML schema, to be used as input for the source code generator.</td><td align="center">No.</td><td align="center"><span class="bold"><strong>1.2</strong></span></td></tr></tbody></table></div></div><br class="table-break"><p>
            In addition, a nested <span class="bold"><strong>&lt;fileset&gt;</strong></span> can be specified as the source of input. 
            Please refer to the samples shown below.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.parameters"></a>2.5.1.2.&nbsp;Parameters</h4></div></div></div><p>
          Please find below the complete list of parameters that can be set on the Castor
          source generator to fine-tune the execution behavior.
        </p><div class="table"><a name="xml.code.generator.invocations.anttask.parameters.table"></a><p class="title"><b>Table&nbsp;2.11.&nbsp;Ant task properties</b></p><div class="table-contents"><table summary="Ant task properties" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Description</th><th align="center">Required</th><th align="center">Since</th></tr></thead><tbody><tr><td align="center"><span class="bold"><strong>package</strong></span></td><td align="center">The default package to be used during source code generation.</td><td align="center">No; if not given, all classes will be placed in the root package.</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>todir</strong></span></td><td align="center">The destination directory to be used during source code generation. In
                      this directory all generated Java classes will be placed.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>bindingfile</strong></span></td><td align="center">A Castor source generator binding file.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>lineseparator</strong></span></td><td align="center">Defines whether to use Unix- or Windows- or Mac-style line separators during source code generation. Possible values are: 'unix', 'win' or 'mac'.</td><td align="center">No; if not set, system property 'line.separator' is used instead.</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>types</strong></span></td><td align="center">Defines what collection types to use (Java 1 vs. Java 2). Possible values: 'vector', 'arraylist' (aka 'j2') or 'odmg'.</td><td align="center">No; if not set, the default collection used will be Java 1 type</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>verbose</strong></span></td><td align="center">Whether to output any logging messages as emitted by the source generator</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>warnings</strong></span></td><td align="center">Whether to suppress any warnings as otherwise emitted by the source generator</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nodesc</strong></span></td><td align="center">If used, instructs the source generator not to generate *Descriptor classes.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>generateMapping</strong></span></td><td align="center">If used, instructs the source generator to (additionally) generate a mapping
                      file.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nomarshal</strong></span></td><td align="center">If specified, instructs the source generator not to create (un)marshalling
                      methods within the Java classes generated.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>caseInsensitive</strong></span></td><td align="center">If used, instructs the source generator to generate code for enumerated type
                      lookup in a case insensitive manner.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>sax1</strong></span></td><td align="center">If used, instructs the source generator to generate SAX-1 compliant code.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>generateImportedSchemas</strong></span></td><td align="center">If used, instructs the source generator to generate code for imported
                      schemas as well.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>nameConflictStrategy</strong></span></td><td align="center">If used, sets the name conflict strategy to use during XML code generation; 
                      possible values are '<code class="literal">warnViaConsoleDialog</code>' and 
                      '<code class="literal">informViaLog</code>'.</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>properties</strong></span></td><td align="center">Location of file defining a set of properties to be used during source code
                      generation. This overrides the default mechanisms of configuring the source
                      generator through a <code class="literal">castorbuilder.properties</code> (that has to be
                      placed on the CLASSPATH)</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>automaticConflictStrategy</strong></span></td><td align="center">If used, sets the name conflict resolution strategy used during XML 
                      code generation; possible values are '<code class="literal">type</code>' and '<code class="literal">xpath</code>'
                      (default being '<code class="literal">xpath</code>').</td><td align="center">No</td><td align="center">-</td></tr><tr><td align="center"><span class="bold"><strong>jClassPrinterType</strong></span></td><td align="center">Sets the mode for printing JClass instances during XML 
                      code generation; possible values are '<code class="literal">standard</code>' and '<code class="literal">velocity</code>'
                      (default being '<code class="literal">standard</code>').</td><td align="center">No</td><td align="center"><span class="bold"><strong>1.2.1</strong></span></td></tr><tr><td align="center"><span class="bold"><strong>generateJdoDescriptors</strong></span></td><td align="center">If used, instructs the source generator to generate JDO class
                      descriptors as well; default is false.</td><td align="center">No</td><td align="center"><span class="bold"><strong>1.3</strong></span></td></tr><tr><td align="center"><span class="bold"><strong>resourceDestination</strong></span></td><td align="center">
                    Sets the destination directory for (generated) resources, 
                    e.g. <code class="literal">.castor.cdr</code> files.
                  </td><td align="center">No</td><td align="center"><span class="bold"><strong>1.3.1</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.anttask.examples"></a>2.5.1.3.&nbsp;Examples</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.file"></a>2.5.1.3.1.&nbsp;Using a file</h5></div></div></div><p>
              Below is an example of how to use this task from within an Ant target
              definition named 'castor:gen:src':
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">file</span>=<span class="hl-value">"src/schema/sample.xsd"</span>
                   <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.url"></a>2.5.1.3.2.&nbsp;Using an URL</h5></div></div></div><p>
              Below is the same sample as above, this time using the <span class="bold"><strong>url</strong></span> attribute
              as the source of input instead:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">schemaURL</span>=<span class="hl-value">"http://some.domain/some/path/sample.xsd"</span>
                   <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.anttask.examples.fileset"></a>2.5.1.3.3.&nbsp;Using a nested &lt;fileset&gt;</h5></div></div></div><p>
              Below is the same sample as above, this time using the <span class="bold"><strong>url</strong></span> attribute
              as the source of input instead:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:gen:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
         <span class="hl-attribute">description</span>=<span class="hl-value">"Generate Java source files from XSD."</span>&gt;

    &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-srcgen"</span>
             <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorCodeGenTask"</span>
             <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
    &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
    &lt;<span class="hl-tag">castor-srcgen</span> <span class="hl-attribute">todir</span>=<span class="hl-value">"generated-source"</span>
                   <span class="hl-attribute">package</span>=<span class="hl-value">"org.castor.example.schema"</span>
                   <span class="hl-attribute">types</span>=<span class="hl-value">"j2"</span>
                   <span class="hl-attribute">warnings</span>=<span class="hl-value">"true"</span> &gt;
       &lt;<span class="hl-tag">fileset</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"${basedir}/src/schema"</span>&gt;
          &lt;<span class="hl-tag">include</span> <span class="hl-attribute">name</span>=<span class="hl-value">"**/*.xsd"</span>/&gt;
       &lt;<span class="hl-tag">/fileset</span>&gt;
    &lt;<span class="hl-tag">/castor-srcgen</span>&gt;
&lt;<span class="hl-tag">/target</span>&gt;
            </pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.maven"></a>2.5.2.&nbsp;Maven 2 plugin</h3></div></div></div><p>
              For those of you working with Maven 2 instead of Ant, the Maven 2 plugin for Castor 
              can be used to integrate source code generation from XML schemas with the Castor XML
              code generator as part of the standard Maven build life-cycle. The following sections
              show how to configure the Maven 2 Castor plugin and hwo to instruct Maven 2
              to generate sources from your XML schemas.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.configuration"></a>2.5.2.1.&nbsp;Configuration</h4></div></div></div><p>To be able to start source code generation from XML schema from within Maven, 
                  you will have to configure the Maven 2 Castor plugin as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/plugin</span>&gt;
</pre><p>Above configuration will trigger source generation using the default
                  values as explained at the 
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://mojo.codehaus.org/castor-maven-plugin/howto.html" target="_top">Castor plugin page</a>, 
                  assuming that the XML schema(s) are located at <code class="literal">src/main/castor</code>, and code will 
                  be saved at <code class="literal">target/generated-sources/castor</code>. When generating sources
                  for multiple schemas at the same time, you can put namespace to 
                  package mappings into <code class="literal">src/main/castor/castorbuilder.properties</code>.</p><p>To e.g. change some of these default locations, please add a 
                  &lt;configuration&gt; section to the plugin configuration as 
                  follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">configuration</span>&gt;
      &lt;<span class="hl-tag">schema</span>&gt;src/main/resources/org/exolab/castor/builder/binding/binding.xsd&lt;<span class="hl-tag">/schema</span>&gt;
      &lt;<span class="hl-tag">packaging</span>&gt;org.exolab.castor.builder.binding&lt;<span class="hl-tag">/packaging</span>&gt;
      &lt;<span class="hl-tag">properties</span>&gt;src/main/resources/org/exolab/castor/builder/binding.generation.properties&lt;<span class="hl-tag">/properties</span>&gt;
   &lt;<span class="hl-tag">/configuration</span>&gt;
 &lt;<span class="hl-tag">/plugin</span>&gt;      
</pre><p>
                Details on the available configuration properties can be found 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://mojo.codehaus.org/castor-maven-plugin/generate-mojo.html" target="_top">here</a>.
               </p><p>By default, the Maven Castor plugin has been built and tested against 
                  a particular version of Castor. To switch to a newer version of Castor (not the
                  plugin itself), please use a &lt;dependencies&gt; section as shown below
                  to point the plugin to e.g. a newer version of Castor:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">dependencies</span>&gt;
     &lt;<span class="hl-tag">dependency</span>&gt; 
       &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.castor&lt;<span class="hl-tag">/groupId</span>&gt;
       &lt;<span class="hl-tag">artifactId</span>&gt;castor&lt;<span class="hl-tag">/artifactId</span>&gt;
       &lt;<span class="hl-tag">version</span>&gt;1.3.1-SNAPSHOT&lt;<span class="hl-tag">/version</span>&gt;
     &lt;<span class="hl-tag">/dependency</span>&gt;
   &lt;<span class="hl-tag">/dependencies</span>&gt;
 &lt;<span class="hl-tag">/plugin</span>&gt;      
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.life-cycle"></a>2.5.2.2.&nbsp;Integration into build life-cycle</h4></div></div></div><p>To integrate source code generation from XML schema into your standard
                  build life-cycle, you will have to add an &lt;executions&gt; section 
                  to your standard plugin configuration as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">plugin</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.mojo&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;castor-maven-plugin&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;2.0&lt;<span class="hl-tag">/version</span>&gt;
   &lt;<span class="hl-tag">executions</span>&gt;
      &lt;<span class="hl-tag">execution</span>&gt;
         &lt;<span class="hl-tag">goals</span>&gt;
            &lt;<span class="hl-tag">goal</span>&gt;generate&lt;<span class="hl-tag">/goal</span>&gt;
         &lt;<span class="hl-tag">/goals</span>&gt;
      &lt;<span class="hl-tag">/execution</span>&gt;
   &lt;<span class="hl-tag">/executions</span>&gt;            
&lt;<span class="hl-tag">/plugin</span>&gt;       
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.maven.example"></a>2.5.2.3.&nbsp;Example</h4></div></div></div><p>Below command shows how to instruct Maven (manually) to generate Java sources
                  from the XML schemas as configured above.</p><pre class="programlisting">
&gt; mvn castor:generate</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.invocations.cmd"></a>2.5.3.&nbsp;Command line</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.cmd.first.steps"></a>2.5.3.1.&nbsp;First steps</h4></div></div></div><pre class="programlisting">
java org.exolab.castor.builder.SourceGeneratorMain -i foo-schema.xsd \
    -<span class="hl-keyword">package</span> com.xyz
            </pre><p>
              This will generate a set of source files from the the XML Schema
              <code class="literal">foo-schema.xsd</code> and place them in the package
              <code class="literal">com.xyz</code>.
            </p><p>
              To compile the generated classes, simply run <span><strong class="command">javac</strong></span> or your favorite
              compiler:
            </p><pre class="programlisting">
javac com/xyz/*.java</pre><p>
              Created class will have <code class="methodname">marshal</code> and 
              <code class="methodname">unmarshal</code> methods which are used to
              go back and forth between XML and an Object instance.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.invocations.cmd.options"></a>2.5.3.2.&nbsp;Source Generator - command line options</h4></div></div></div><p>
              The source code generator has a number of different options which may
              be set. Some of these are done using the command line and others are
              done using a properties file located by default at 
              <code class="filename">org/exolab/castor/builder/castorbuilder.properties</code>.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.cmd.options.source"></a>2.5.3.2.1.&nbsp;Specifying the input source</h5></div></div></div><p>
                   There's more than one way of specifying the input for the Castor code 
                   generator. <span class="bold"><strong>At least one</strong></span> input source must be specified. 
                </p><div class="table"><a name="xml.code.generator.invocations.cmd.options.source.table"></a><p class="title"><b>Table&nbsp;2.12.&nbsp;Input sources</b></p><div class="table-contents"><table summary="Input sources" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Args</th><th align="center">Description</th><th align="center">Version</th></tr></thead><tbody><tr><td align="center">i</td><td align="center"><span class="italic">filename</span></td><td align="center">The input XML Schema file</td><td align="center"> - </td></tr><tr><td align="center">is</td><td align="center"><span class="italic">URL</span></td><td align="center">URL of an XML Schema</td><td align="center"><span class="bold"><strong>1.2 and newer</strong></span></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.invocations.cmd.options.others"></a>2.5.3.2.2.&nbsp;Other command Line Options</h5></div></div></div><div class="table"><a name="xml.code.generator.invocations.cmd.options.others.table"></a><p class="title"><b>Table&nbsp;2.13.&nbsp;Other command line options</b></p><div class="table-contents"><table summary="Other command line options" border="1"><colgroup><col><col><col align="left"><col></colgroup><thead><tr><th align="center">Option</th><th align="center">Arguments</th><th align="left">Description</th><th align="center">Optional?</th></tr></thead><tbody><tr><td align="center"><code class="option">-package</code></td><td align="center">package-name</td><td align="left">The package for the generated source.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-dest</code></td><td align="center">path</td><td align="left">
                    The destination directory in which to create the generated source
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-line-separator</code></td><td align="center">unix | mac | win</td><td align="left">
                    Sets the line separator style for the desired platform. This is
                    useful if you are generating source on one platform, but will
                    be compiling/modifying on another platform.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-types</code></td><td align="center">type-factory</td><td align="left">
                    Sets which type factory to use. This is useful if you want JDK
                    1.2 collections instead of JDK 1.1 or if you want to pass in your
                    own FieldInfoFactory (see <a href="#xml.code.generator.invocations.cmd.options.collection.types" title="2.5.3.2.2.1.&nbsp;Collection Types">Section&nbsp;2.5.3.2.2.1, &#8220;Collection Types&#8221;</a>).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-h</code></td><td align="center">&nbsp;</td><td align="left">Shows the help/usage information.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-f</code></td><td align="center">&nbsp;</td><td align="left">
                    Forces the source generator to suppress all non-fatal errors,
                    such as overwriting pre-existing files.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nodesc</code></td><td align="center">&nbsp;</td><td align="left">Do not generate the class descriptors</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-gen-mapping</code></td><td align="center">&nbsp;</td><td align="left">(Additionally) Generate a mapping file.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nomarshall</code></td><td align="center">&nbsp;</td><td align="left">
                    Do not generate the marshaling framework methods (marshal,
                    unmarshal, validate)</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-testable</code></td><td align="center">&nbsp;</td><td align="left">
                    Generate the extra methods used by the CTF (Castor Testing
                    Framework)
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-sax1</code></td><td align="center">&nbsp;</td><td align="left">
                    Generate marshaling methods that use the SAX1 framework
                    (default is false).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-binding-file</code></td><td align="center">&lt;&lt;binding file name&gt;&gt;.</td><td align="left">
                    Configures the use of a Binding File to allow finely-grained
                    control of the generated classes
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-generateImportedSchemas</code></td><td align="center">&nbsp;</td><td align="left">
                    Generates sources for imported XML Schemas in addition to the
                    schema provided on the command line (default is false).
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-case-insensitive</code></td><td align="center">&nbsp;</td><td align="left">
                    The generated classes will use a case insensitive method for
                    looking up enumerated type values.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-verbose</code></td><td align="center">&nbsp;</td><td align="left">Enables extra diagnostic output from the source generator</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-nameConflictStrategy</code></td><td align="center">&lt;&lt;conflict strategy name&gt;&gt;</td><td align="left">Sets the name conflict strategy to use during XML code generation</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-fail</code></td><td align="center">&nbsp;</td><td align="left">
                    Instructs the source generator to fail on the first error. When
                    you are trying to figure out what is failing during source
                    generation, this option will help.
                  </td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-classPrinter</code></td><td align="center">&lt;&lt;JClass printing mode&gt;&gt;.</td><td align="left">Specifies the JClass printing mode to use during XML code generation; possible
                      values are<code class="literal">standard</code> (default) and <code class="literal">velocity</code>; if no value
                      is specified, the default mode is <code class="literal">standard</code>.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-gen-jdo-desc</code></td><td align="center">&nbsp;</td><td align="left">(Additionally) generate JDO class descriptors.</td><td align="center">Optional</td></tr><tr><td align="center"><code class="option">-resourcesDestination</code></td><td align="center">&lt;destination&gt;</td><td align="left">An (optional) destination for (generated) resources</td><td align="center">Optional</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="xml.code.generator.invocations.cmd.options.collection.types"></a>2.5.3.2.2.1.&nbsp;Collection Types</h6></div></div></div><p>
                  The source code generator has the ability to use the following
                  types of collections when generating source code, using the 
                  <code class="option">-type</code> option:
                </p><div class="table"><a name="xml.code.generator.invocations.cmd.options.collection.types.table"></a><p class="title"><b>Table&nbsp;2.14.&nbsp;Collection types</b></p><div class="table-contents"><table summary="Collection types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Option value</th><th align="center">Type</th><th align="center">Default</th></tr></thead><tbody><tr><td align="center"><code class="option">-types j1</code></td><td align="center">Java 1.1</td><td align="center"><code class="classname">java.util.Vector</code></td></tr><tr><td align="center"><code class="option">-type j2</code></td><td align="center">Java 1.2</td><td align="center"><code class="classname">java.util.Collection</code></td></tr><tr><td align="center"><code class="option">-types odmg</code></td><td align="center">ODMG 3.0</td><td align="center"><code class="classname">odmg.DArray</code></td></tr></tbody></table></div></div><br class="table-break"><p>
                        The Java class name shown in above table indicates the default 
                        collection type that will be emitted during generation.
                    </p><p>
                     You can also write your own FieldInfoFactory to handle specific
                     collection types. All you have to do is to pass in the fully
                     qualified name of that FieldInfoFactory as follows:
                   </p><pre class="programlisting">-types com.personal.MyCoolFactory</pre></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top">
              For additional information about the Source Generator and its options,
              you can download the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF)</a>. Please note that the use of a
              binding file is not dicussed in that document.
            </td></tr></table></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.schema.support"></a>2.6.&nbsp;XML schema support</h2></div></div></div><p>
           Castor XML supports the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xmlschema-1/" target="_top">W3C
           XML Schema 1.0 Second Edition Recommendation document (10/28/2004)</a>
           The Schema Object Model (located in the package
           <span class="package">org.exolab.castor.xml.schema</span>)
           provides an in-memory representation of a given XML schema whereas the
           XML code generator provides a binding
           between XML schema data types and structures into the corresponding ones
           in Java.
        </p><p>
           The Castor Schema Object Model can read
           (<span class="package">org.exolab.castor.xml.schema.reader</span>)
           and write
           (<span class="package">org.exolab.castor.xml.schema.writer</span>)
           an XML Schema as defined by the W3C recommandation. It allows you to
           create and manipulate an in-memory view of an XML Schema.
        </p><p>
           The Castor Schema Object Model supports the W3C XML Schema
           recommendation with no limitation. However the Source Generator does
           currently not offer a one to one mapping from an XML Schema component
           to a Java component for every XML Schema components; some limitations
           exist. The aim of the following sections is to provide a list of
           supported features in the Source Generator. Please keep in mind that
           the Castor Schema Object Model again can handle any XML Schema without
           limitations.
        </p><p>
           Some Schema types do not have a corresponding type in Java.  Thus the
           Source Generator uses Castor implementation of these specific types
           (located in the <span class="package">org.exolab.castor.types</span> package).
           For instance the <code class="literal">duration</code> type is implemented directly in
           Castor. Remember that the representation of XML Schema datatypes does
           not try to fit the W3C XML Schema specifications exactly. The aim is to
           map an XML Schema type to the Java type that is the best fit to the XML
           Schema type.
        </p><p>
           You will find next a list of the supported XML Schema data types and
           structures in the Source Code Generator. For a more detailed support of
           XML Schema structure and more information on the Schema Object Model,
           please refer to  
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
           User Document (PDF).</a>
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e3439"></a>2.6.1.&nbsp;Supported XML Schema Built-in Datatypes</h3></div></div></div><p>
              The following is a list of the supported datatypes with the
              corresponding facets and the Java mapping type.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.datatypes.built-in.primitive"></a>2.6.1.1.&nbsp;Primitive Datatypes</h4></div></div></div><div class="table"><a name="xml.code.generator.schema.support.datatypes.built-in.primitive.table"></a><p class="title"><b>Table&nbsp;2.15.&nbsp;Supported primitive data types</b></p><div class="table-contents"><table summary="Supported primitive data types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">XML Schema Type</th><th align="center">Supported Facets</th><th align="center">Java mapping type</th></tr></thead><tbody><tr><td align="center">anyURI</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">base64Binary</td><td align="center">&nbsp;</td><td align="center"><code class="classname">byte[]</code></td></tr><tr><td align="center">boolean</td><td align="center">pattern</td><td align="center">
                       <code class="literal">boolean</code> or <code class="classname">java.lang.Boolean</code><sup>[<a name="footnote.primitive.types" href="#ftn.footnote.primitive.types">a</a>]</sup>
                     </td></tr><tr><td align="center">date</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a name="footnote.types.primitive.1" href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Date</code></td></tr><tr><td align="center">dateTime</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.util.Date</code></td></tr><tr><td align="center">decimal</td><td align="center">
                       totalDigits, fractionDigits, pattern, whiteSpace, enumeration, maxInclusive, 
                       maxExclusive, minInclusive, minExclusive, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.math.BigDecimal</code></td></tr><tr><td align="center">double</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center">
                       <code class="classname">double</code> or <code class="classname">java.lang.Double</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">duration</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Duration</code></td></tr><tr><td align="center">float</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center">
                       <code class="classname">float</code> or <code class="classname">java.lang.Float</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">gDay</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GDay</code></td></tr><tr><td align="center">gMonth</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GMonth</code></td></tr><tr><td align="center">gMonthDay</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GMonthDay</code></td></tr><tr><td align="center">gYear</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GYear</code></td></tr><tr><td align="center">gYearMonth</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.GYearMonth</code></td></tr><tr><td align="center">hexBinary</td><td align="center">&nbsp;</td><td align="center"><code class="classname">byte[]</code></td></tr><tr><td align="center">QName</td><td align="center">length, minLength, maxLength, pattern, enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">string</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">time</td><td align="center">enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace<sup>[<a href="#ftn.footnote.types.primitive.1">b</a>]</sup></td><td align="center"><code class="classname">org.exolab.castor.types.Time</code></td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a name="ftn.footnote.primitive.types" href="#footnote.primitive.types">a</a>] </sup>For the various numerical types, the
                default behavior is to generate primitive types.  However, if the
                use of wrappers is enabled by the following line in the
                <code class="literal">castorbuilder.properties</code> file:
                <code class="code">org.exolab.castor.builder.primitivetowrapper=true</code> then
                the <code class="literal">java.lang.*</code> wrapper objects (as specified above) will be
                used instead.
                       </p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive.1" href="#footnote.types.primitive.1">b</a>] </sup>
                             For the date/time and numeric types, the only supported value for whitespace 
                             is "collapse".
                         </p></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.datatypes.built-in.derived"></a>2.6.1.2.&nbsp;Derived Datatypes</h4></div></div></div><div class="table"><a name="xml.code.generator.schema.support.datatypes.built-in.derived.table"></a><p class="title"><b>Table&nbsp;2.16.&nbsp;Supported derived data types</b></p><div class="table-contents"><table summary="Supported derived data types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Type</th><th align="center">Supported Facets</th><th align="center">Java mapping type</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">totalDigits, fractionDigits<sup>[<a name="footnote.types.derived.4" href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, 
                            minExclusive, whitespace<sup>[<a name="footnote.types.derived.1" href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">byte</code>/<code class="classname">java.lang.Byte</code>
                       <sup>[<a name="footnote.types.primitive" href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">ENTITY</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">ENTITIES</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">ID</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">IDREF</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.lang.Object</code></td></tr><tr><td align="center">IDREFS</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.util.Vector</code> of <code class="classname">java.lang.Object</code></td></tr><tr><td align="center">int</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">int</code>/<code class="classname">java.lang.Integer</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">integer</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">language</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center">
                       treated as a <code class="literal">xsd:string</code><sup>[<a name="footnote.types.primitive.3" href="#ftn.footnote.types.primitive.3">d</a>]</sup>
                     </td></tr><tr><td align="center">long</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">Name</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">NCName</td><td align="center">enumeration</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">negativeInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn."></a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">NMTOKEN</td><td align="center">enumeration, length, maxlength, minlength</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">NMTOKENS</td><td align="center">&nbsp;</td><td align="center"><code class="classname">java.util.Vector</code> of <code class="classname">java.lang.String</code></td></tr><tr><td align="center">NOTATION</td><td align="center">&nbsp;</td><td align="center"><span class="bold"><strong>Not implemented</strong></span></td></tr><tr><td align="center">nonNegativeInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">nonPositiveInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>, 
                            pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                            whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup></td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">normalizedString</td><td align="center">enumeration, length, minLength, maxLength, pattern</td><td align="center"><code class="classname">java.lang.String</code></td></tr><tr><td align="center">positiveInteger</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">short</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="literal">short</code>/<code class="literal">java.lang.Short</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">token</td><td align="center">length, minLength, maxLength, pattern, enumeration, whiteSpace</td><td align="center">
                       treated as a <code class="literal">xsd:string</code><sup>[<a href="#ftn.footnote.types.primitive.3">d</a>]</sup>,
                     </td></tr><tr><td align="center">unsignedByte</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       maxExclusive, minExclusive, maxInclusive, minInclusive, pattern, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">short</code>/<code class="classname">java.lang.Short</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">unsignedInt</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       maxExclusive, minExclusive, maxInclusive, minInclusive, pattern,
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">long</code>/<code class="classname">java.lang.Long</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr><tr><td align="center">unsignedLong</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center"><code class="classname">java.math.BigInteger</code></td></tr><tr><td align="center">unsignedShort</td><td align="center">totalDigits, fractionDigits<sup>[<a href="#ftn.footnote.types.derived.4">a</a>]</sup>,
                       pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, 
                       whitespace<sup>[<a href="#ftn.footnote.types.derived.1">b</a>]</sup>
                     </td><td align="center">
                       <code class="classname">int</code> or <code class="classname">java.lang.Integer</code><sup>[<a href="#ftn.footnote.types.primitive">c</a>]</sup>
                     </td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a name="ftn.footnote.types.derived.4" href="#footnote.types.derived.4">a</a>] </sup>For 
                            the integral types, the only allowed value for fractionDigits is 0.</p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.derived.1" href="#footnote.types.derived.1">b</a>] </sup>
                               For the date/time and numeric types, the only supported value for whitespace 
                               is "collapse".
                            </p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive" href="#footnote.types.primitive">c</a>] </sup>For the various numerical types, the
                default behavior is to generate primitive types.  However, if the
                use of wrappers is enabled by the following line in the
                <code class="literal">castorbuilder.properties</code> file:
                <code class="code">org.exolab.castor.builder.primitivetowrapper=true</code> then
                the <code class="literal">java.lang.*</code> wrapper objects (as specified above) will be
                generated instead.</p></div><div class="footnote"><p><sup>[<a name="ftn.footnote.types.primitive.3" href="#footnote.types.primitive.3">d</a>] </sup>
                          Currently, <code class="literal">&lt;xsd:language&gt;</code> and 
                          <code class="literal">&lt;xsd:token&gt;</code> are treated as if they 
                          were <code class="literal">&lt;xsd:string&gt;</code>.
                      </p></div></td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.schema.support.structures"></a>2.6.2.&nbsp;Supported XML Schema Structures</h3></div></div></div><p>
              Supporting XML schema structures is a constant work. The main
              structures are already supported with some limitations. The
              following will give you a rough list of the supported structures. For a
              more detailed support of XML Schema structure in the Source Generator or
              in the Schema Object Model, please refer to
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">Source Generator
              User Document (PDF)</a>.
            </p><p>Supported schema components:</p><div class="itemizedlist"><ul type="disc"><li><p>Attribute declaration (<code class="literal">&lt;attribute&gt;</code>)</p></li><li><p>Element declaration (<code class="literal">&lt;element&gt;</code>)</p></li><li><p>Complex type definition (<code class="literal">&lt;complexType&gt;</code>)</p></li><li><p>Attribute group definition (<code class="literal">&lt;attributeGroup&gt;</code>)</p></li><li><p>Model group definition (<code class="literal">&lt;group&gt;</code>)</p></li><li><p>Model group (<code class="literal">&lt;all&gt;</code>, <code class="literal">&lt;choice&gt;</code> and <code class="literal">&lt;sequence&gt;</code>)</p></li><li><p>Annotation (<code class="literal">&lt;annotation&gt;</code>)</p></li><li><p>Wildcard (<code class="literal">&lt;any&gt;</code>)</p></li><li><p>Simple type definition (<code class="literal">&lt;simpleType&gt;</code>)</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.structures.groups"></a>2.6.2.1.&nbsp;Groups</h4></div></div></div><p>
                Grouping support covers both <span class="bold"><strong>model group definitions</strong></span>
                (<code class="literal">&lt;group&gt;</code>) and <span class="bold"><strong>model groups</strong></span> 
                (<code class="literal">&lt;all&gt;</code>, <code class="literal">&lt;choice&gt;</code> and  
                <code class="literal">&lt;sequence&gt;</code>). In this section
                we will label as a 'nested group' any model group whose first parent
                is another model group.
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                  For each top-level model group definition, a class is generated
                  either when using the 'element' mapping property or the 'type' one.
                </p></li><li><p>
                  If a group -- nested or not -- appears to have <code class="literal">maxOccurs &gt; 1</code> 
                  , then a class is generated to represent the items contained in the group.
                </p></li><li><p>
                  For each nested group, a class is generated. The name of the
                  generated class will follow this naming convention:
                  <code class="literal">Name,Compositor+,Counter?</code> where
                  </p><div class="itemizedlist"><ul type="circle"><li><p>
                      'Name' is name of the top-level component (element, complexType or group).
                    </p></li><li><p>
                      'Compositor' is the compositor of the nested group.  For
                      instance, if a 'choice' is nested inside a sequence, the value
                      of Compositor will be <code class="literal">SequenceChoice</code> ('Sequence'+'Choice').
                      Note: if the 'choice' is inside a Model Group and that Model
                      Group <span class="bold"><strong>parent</strong></span> is a Model Group Definition or a
                      complexType then the value of'Compositor' will be only 'Choice'.
                    </p></li><li><p>'Counter' is a number that prevents naming collision.</p></li></ul></div><p>
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.schema.support.structures.wildcard"></a>2.6.2.2.&nbsp;Wildcard</h4></div></div></div><p>
                    <code class="literal">&lt;any&gt;</code> is supported and will be mapped to an 
                    <code class="classname">AnyNode</code> instance. However, full namespace 
                    validation is not yet implemented, even though an <code class="classname">AnyNode</code>
                    structure is fully namespace aware.
                </p><p>
                   <code class="literal">&lt;anyAttribute&gt;</code> is currently not supported. It is a
                   work in progress.
                </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.examples"></a>2.7.&nbsp;Examples</h2></div></div></div><p>
             In this section we illustrate the use of the XML code generator by 
             discussing the classes generated from given XML schemas. The XML code 
             generator is going to be used with the &#8220;java class mapping&#8221; property 
             set to <span class="italic">element</span> (default value).
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.examples.invoice.schema"></a>2.7.1.&nbsp;The invoice XML schema</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.file"></a>2.7.1.1.&nbsp;The schema file</h4></div></div></div><p>The input file is the schema file given with the XML code generator 
               example in the distribution of Castor 
               (under /src/examples/SourceGenerator/invoice.xsd).</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">xsd:schema</span> <span class="hl-attribute">xmlns:xsd</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://castor.exolab.org/Test/Invoice"</span>&gt;

    &lt;<span class="hl-tag">xsd:annotation</span>&gt;
        &lt;<span class="hl-tag">xsd:documentation</span>&gt;
            This is a test XML Schema for Castor XML.
        &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
    &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

    &lt;<span class="hl-comment">!--
        A simple representation of an invoice. This is simply an example
        and not meant to be an exact or even complete representation of an invoice.
    --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"invoice"</span>&gt;
        &lt;<span class="hl-tag">xsd:annotation</span>&gt;
            &lt;<span class="hl-tag">xsd:documentation</span>&gt;
                A simple representation of an invoice
            &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
        &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ship-to"</span>&gt;
                    &lt;<span class="hl-tag">xsd:complexType</span>&gt;
                        &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customer"</span> /&gt;
                    &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
                &lt;<span class="hl-tag">/xsd:element</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"item"</span>
                    <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-method"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-date"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Description of a customer --</span>&gt;
    &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">name</span>=<span class="hl-value">"customer"</span>&gt;
        &lt;<span class="hl-tag">xsd:sequence</span>&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"address"</span> /&gt;
            &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"phone"</span>
                <span class="hl-attribute">type</span>=<span class="hl-value">"TelephoneNumberType"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
    &lt;<span class="hl-tag">/xsd:group</span>&gt;

    &lt;<span class="hl-comment">!-- Description of an item --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Quantity"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:integer"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"PriceType"</span>
                    <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
            &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"ItemAttributes"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Shipping Method --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"shipping-method"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"carrier"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"option"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"estimated-delivery"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:duration"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- Shipping date --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"shipping-date"</span>&gt;
        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:date"</span> /&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:time"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- A simple U.S. based Address structure --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"address"</span>&gt;
        &lt;<span class="hl-tag">xsd:annotation</span>&gt;
            &lt;<span class="hl-tag">xsd:documentation</span>&gt;
                Represents a U.S. Address
            &lt;<span class="hl-tag">/xsd:documentation</span>&gt;
        &lt;<span class="hl-tag">/xsd:annotation</span>&gt;

        &lt;<span class="hl-tag">xsd:complexType</span>&gt;
            &lt;<span class="hl-tag">xsd:sequence</span>&gt;
                &lt;<span class="hl-comment">!-- street address 1 --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"street1"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-comment">!-- optional street address 2 --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"street2"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"0"</span> /&gt;
                &lt;<span class="hl-comment">!-- city--</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"city"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> /&gt;
                &lt;<span class="hl-comment">!-- state code --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"state"</span>
                    <span class="hl-attribute">type</span>=<span class="hl-value">"stateCodeType"</span> /&gt;
                &lt;<span class="hl-comment">!-- zip-code --</span>&gt;
                &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"zip-code"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
        &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- A U.S. Zip Code --</span>&gt;
    &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"zip-code"</span>&gt;
        &lt;<span class="hl-tag">xsd:simpleType</span>&gt;
            &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
                &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[0-9]{5}(-[0-9]{4})?"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
        &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;
    &lt;<span class="hl-tag">/xsd:element</span>&gt;

    &lt;<span class="hl-comment">!-- State Code
        obviously not a valid state code....but this is just
        an example and I don't feel like creating all the valid
        ones.
    --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"stateCodeType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
            &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[A-Z]{2}"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- Telephone Number --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"TelephoneNumberType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:string"</span>&gt;
            &lt;<span class="hl-tag">xsd:length</span> <span class="hl-attribute">value</span>=<span class="hl-value">"12"</span> /&gt;
            &lt;<span class="hl-tag">xsd:pattern</span> <span class="hl-attribute">value</span>=<span class="hl-value">"[0-9]{3}-[0-9]{3}-[0-9]{4}"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- Cool price type --</span>&gt;
    &lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PriceType"</span>&gt;
        &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:decimal"</span>&gt;
            &lt;<span class="hl-tag">xsd:fractionDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
            &lt;<span class="hl-tag">xsd:totalDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span> /&gt;
            &lt;<span class="hl-tag">xsd:minInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span> /&gt;
            &lt;<span class="hl-tag">xsd:maxInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span> /&gt;
        &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
    &lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

    &lt;<span class="hl-comment">!-- The attributes for an Item --</span>&gt;
    &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ItemAttributes"</span>&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:ID"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span>
            <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InStock"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:boolean"</span>
            <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span> /&gt;
        &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Category"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span>
            <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
    &lt;<span class="hl-tag">/xsd:attributeGroup</span>&gt;
&lt;<span class="hl-tag">/xsd:schema</span>&gt;</pre><p>The structure of this schema is simple: it is composed of a
            top-level element which is a complexType with references to
            other elements inside. This schema represents a simple
            invoice: an invoice is a customer (<code class="literal">customer</code> top-level
            group), an article (<code class="literal">item</code> element), a shipping method
            (<code class="literal">shipping-method</code> element) and a shipping date
            (<code class="literal">shipping-date</code> element). Notice that the <code class="literal">ship-to</code> element
            uses a reference to an <code class="literal">address</code> element. This <code class="literal">address</code>
            element is a top-level element that contains a reference to
            a non-top-level element (the <code class="literal">zip-cod</code> element). At the end
            of the schema we have two simpleTypes for representing a
            telephone number and a price. The Source Generator is used
            with the <code class="literal">element</code> property set for class creation
            so a class is going to be generated for all top-level elements. No classes 
            are going to be generated for complexTypes and simpleTypes since the
            simpleType is not an enumeration.</p><p>To summarize, we can expect 7 classes : <code class="literal">Invoice</code>, <code class="literal">Customer</code>, 
            <code class="literal">Address</code>, <code class="literal">Item</code>, <code class="literal">ShipTo</code>, <code class="literal">ShippingMethod</code> 
            and <code class="literal">ShippingDate</code> and the 7 corresponding class descriptors. Note 
            that a class is generated for the top-level group <code class="literal">customer</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.running"></a>2.7.1.2.&nbsp;Running the XML code generator</h4></div></div></div><p>To run the source generator and create the source from the 
            <code class="literal">invoice.xsd</code> file in a package <code class="literal">test</code>, we just call 
            in the command line:</p><pre class="programlisting">
java -cp %CP% org.exolab.castor.builder.SourceGeneratorMain -i invoice.xsd -package test</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.invoice.schema.generated"></a>2.7.1.3.&nbsp;The generated code</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.generated.item"></a>2.7.1.3.1.&nbsp;The Item.java class</h5></div></div></div><p>To simplify this example we now focus on the <code class="literal">item</code> element.</p><pre class="programlisting">
&lt;<span class="hl-comment">!-- Description of an item --</span>&gt;
&lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span>&gt;
  &lt;<span class="hl-tag">xsd:complexType</span>&gt;
    &lt;<span class="hl-tag">xsd:sequence</span>&gt;
      &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Quantity"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:integer"</span>
                   <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
      &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"PriceType"</span>
                   <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
    &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
    &lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"ItemAttributes"</span> /&gt;
  &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
&lt;<span class="hl-tag">/xsd:element</span>&gt;

&lt;<span class="hl-comment">!-- Cool price type --</span>&gt;
&lt;<span class="hl-tag">xsd:simpleType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PriceType"</span>&gt;
  &lt;<span class="hl-tag">xsd:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xsd:decimal"</span>&gt;
    &lt;<span class="hl-tag">xsd:fractionDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
    &lt;<span class="hl-tag">xsd:totalDigits</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span> /&gt;
    &lt;<span class="hl-tag">xsd:minInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1"</span> /&gt;
    &lt;<span class="hl-tag">xsd:maxInclusive</span> <span class="hl-attribute">value</span>=<span class="hl-value">"100"</span> /&gt;
  &lt;<span class="hl-tag">/xsd:restriction</span>&gt;
&lt;<span class="hl-tag">/xsd:simpleType</span>&gt;

&lt;<span class="hl-comment">!-- The attributes for an Item --</span>&gt;
&lt;<span class="hl-tag">xsd:attributeGroup</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ItemAttributes"</span>&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:ID"</span> <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"1"</span> /&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InStock"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:boolean"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span> /&gt;
  &lt;<span class="hl-tag">xsd:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Category"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xsd:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
&lt;<span class="hl-tag">/xsd:attributeGroup</span>&gt;</pre><p>To represent an <code class="literal">Item</code> object, we need to know its <code class="literal">Id</code>, the
            <code class="literal">Quantity</code> ordered and the <code class="literal">Price</code> for one item. So we can
            expect to find a least three private variables: a string for
            the <code class="literal">Id</code> element, an <code class="literal">int</code> for the <code class="literal">quantity</code> element (see the
            section on XML Schema support if you want to see the mapping
            between a W3C XML Schema type and a java type), but what type
            for the <code class="literal">Price</code> element?</p><p>While processing the <code class="literal">Price</code>
            element, Castor is going to process the type of <code class="literal">Price</code> i.e.
            the simpleType <code class="literal">PriceType</code> which base is <code class="literal">decimal</code>. Since
            derived types are automatically mapped to parent types and
            W3C XML Schema <code class="literal">decimal</code> type is mapped to a
            <code class="literal">java.math.BigDecimal</code>, the price element will be a
            <code class="literal">java.math.BigDecimal</code>. Another private variable is created
            for <code class="literal">quantity</code>: quantity is mapped to a primitive java type,
            so a boolean <code class="literal">has_quantity</code> is created for monitoring the
            state of the quantity variable. The rest of the code is the
            <span class="italic">getter/setter</span> methods and the Marshalling framework
            specific methods. Please find below the complete <code class="literal">Item</code> class
            (with Javadoc comments stripped off): </p><pre class="programlisting">
<span class="hl-comment">/** 
 * This class was automatically generated with 
 * Castor 1.0.4,
 * using an XML Schema.
 */</span>

<span class="hl-keyword">package</span> test;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item <span class="hl-keyword">implements</span> java.io.Serializable {

   <span class="hl-comment">//--------------------------/ </span>
   <span class="hl-comment">//- Class/Member Variables -/</span>
   <span class="hl-comment">//--------------------------/</span>

   <span class="hl-keyword">private</span> java.lang.String _id; 

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _quantity;

   <span class="hl-comment">/** 
    * keeps track of state for field: _quantity 
    */</span> 
   <span class="hl-keyword">private</span> <span class="hl-keyword">boolean</span> _has_quantity;

   <span class="hl-keyword">private</span> java.math.BigDecimal _price;

   <span class="hl-comment">//----------------/ </span>
   <span class="hl-comment">//- Constructors -/ </span>
   <span class="hl-comment">//----------------/</span>

   <span class="hl-keyword">public</span> Item() { 
      <span class="hl-keyword">super</span>(); 
   } <span class="hl-comment">//-- test.Item()</span>


   <span class="hl-comment">//-----------/ </span>
   <span class="hl-comment">//- Methods -/ </span>
   <span class="hl-comment">//-----------/</span>

   <span class="hl-keyword">public</span> java.lang.String getId() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._id; $
   } <span class="hl-comment">//-- java.lang.String getId()</span>

   <span class="hl-keyword">public</span> java.math.BigDecimal getPrice() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._price;
   } <span class="hl-comment">//-- java.math.BigDecimal getPrice()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getQuantity() {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._quantity;
   } <span class="hl-comment">//-- int getQuantity()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> hasQuantity() { 
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._has_quantity;
   } <span class="hl-comment">//-- boolean hasQuantity()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isValid() {
      <span class="hl-keyword">try</span> { 
         validate();
      } <span class="hl-keyword">catch</span> (org.exolab.castor.xml.ValidationException vex) { 
         <span class="hl-keyword">return</span> false;
      }
      <span class="hl-keyword">return</span> true;
   } <span class="hl-comment">//-- boolean isValid()</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> marshal(java.io.Writer out) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException,org.exolab.castor.xml.ValidationException {
      Marshaller.marshal(<span class="hl-keyword">this</span>, out);
   } <span class="hl-comment">//-- void marshal(java.io.Writer)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> marshal(org.xml.sax.DocumentHandler handler) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException, org.exolab.castor.xml.ValidationException {
      Marshaller.marshal(<span class="hl-keyword">this</span>, handler);
   } <span class="hl-comment">//-- void marshal(org.xml.sax.DocumentHandler)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(java.lang.String _id) {
      <span class="hl-keyword">this</span>._id = _id;
   } <span class="hl-comment">//-- void setId(java.lang.String)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice(java.math.BigDecimal _price) {
      <span class="hl-keyword">this</span>._price = _price;
   } <span class="hl-comment">//-- void setPrice(java.math.BigDecimal)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setQuantity(<span class="hl-keyword">int</span> _quantity) {
      <span class="hl-keyword">this</span>._quantity = _quantity;
      <span class="hl-keyword">this</span>._has_quantity = true;
   } <span class="hl-comment">//-- void setQuantity(int)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> test.Item unmarshal(java.io.Reader reader) 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.MarshalException,org.exolab.castor.xml.ValidationException {
      <span class="hl-keyword">return</span> (test.Item) Unmarshaller.unmarshal(test.Item.<span class="hl-keyword">class</span>, reader);
   } <span class="hl-comment">//-- test.Item unmarshal(java.io.Reader)</span>

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> validate() 
   <span class="hl-keyword">throws</span> org.exolab.castor.xml.ValidationException {
      org.exolab.castor.xml.Validator.validate(<span class="hl-keyword">this</span>, null);
   } <span class="hl-comment">//-- void validate()</span>

}
</pre><p>The ItemDescriptor class is a bit more complex. This class
            is containing inner classes which are the XML field
            descriptors for the different components of an &#8216;Item&#8217;
            element i.e. id, quantity and price.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.pricyType"></a>2.7.1.3.2.&nbsp;The PriceType.java class</h5></div></div></div><p>TODO ...</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.code.generator.examples.invoice.schema.invoice"></a>2.7.1.3.3.&nbsp;The Invoice.java class</h5></div></div></div><p>In this section, we focus on the 'invoice' element as
                   shown again below:</p><pre class="programlisting">
&lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"invoice"</span>&gt;
   &lt;<span class="hl-tag">xsd:complexType</span>&gt;
      &lt;<span class="hl-tag">xsd:sequence</span>&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ship-to"</span>&gt;
            &lt;<span class="hl-tag">xsd:complexType</span>&gt;
               &lt;<span class="hl-tag">xsd:group</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"customer"</span> /&gt;
            &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
         &lt;<span class="hl-tag">/xsd:element</span>&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"item"</span>    <span class="hl-attribute">minOccurs</span>=<span class="hl-value">"1"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-method"</span> /&gt;
         &lt;<span class="hl-tag">xsd:element</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"shipping-date"</span> /&gt;
      &lt;<span class="hl-tag">/xsd:sequence</span>&gt;
   &lt;<span class="hl-tag">/xsd:complexType</span>&gt;
&lt;<span class="hl-tag">/xsd:element</span>&gt;</pre><p>Amongst other things, an <code class="literal">&lt;invoice&gt;</code> is made up of at least
                   one, but potentially many <code class="literal">&lt;item&gt;</code> elements. The Castor XML code
                   generator creates a Java collection named 'itemList' for this
                   unbounded element declaration, of type <code class="literal">java.util.List</code>
                   if the scode generator is used with the '<code class="literal">arraylist</code>'
                   field factory.</p><pre class="programlisting">
    <span class="hl-keyword">private</span> java.util.List _itemList;</pre><p>If the '<code class="literal">j1</code>' field factory is used, this will be replaced 
                   with ...</p><pre class="programlisting">
    <span class="hl-keyword">private</span> java.util.Vector _itemList;</pre><p>The complete class as generated (with irrelevant code
                   parts removed) in '<code class="literal">j2</code>' (aka '<code class="literal">arraylist</code>') 
                   mode is shown below:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Invoice <span class="hl-keyword">implements</span> java.io.Serializable {


    ...
    
    <span class="hl-keyword">private</span> java.util.List _itemList;
    
    ...

    <span class="hl-keyword">public</span> Invoice() 
     {
        <span class="hl-keyword">super</span>();
        <span class="hl-keyword">this</span>._itemList = <span class="hl-keyword">new</span> java.util.ArrayList();
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Invoice()</span>

    ...

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addItem(xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-keyword">this</span>._itemList.add(vItem);
    } <span class="hl-comment">//-- void addItem(xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addItem(<span class="hl-keyword">int</span> index, xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-keyword">this</span>._itemList.add(index, vItem);
    } <span class="hl-comment">//-- void addItem(int, xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> java.util.Enumeration enumerateItem()
    {
        <span class="hl-keyword">return</span> java.util.Collections.enumeration(<span class="hl-keyword">this</span>._itemList);
    } <span class="hl-comment">//-- java.util.Enumeration enumerateItem() </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item getItem(<span class="hl-keyword">int</span> index)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-comment">// check bounds for index</span>
        <span class="hl-keyword">if</span> (index &lt; 0 || index &gt;= <span class="hl-keyword">this</span>._itemList.size()) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IndexOutOfBoundsException(<span class="hl-string">"getItem: Index value '"</span> + index 
               + <span class="hl-string">"' not in range [0.."</span> + (<span class="hl-keyword">this</span>._itemList.size() - 1) + <span class="hl-string">"]"</span>);
        }
        
        <span class="hl-keyword">return</span> (xml.c1677.invoice.generated.Item) _itemList.get(index);
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item getItem(int) </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item[] getItem()
    {
        <span class="hl-keyword">int</span> size = <span class="hl-keyword">this</span>._itemList.size();
        xml.c1677.invoice.generated.Item[] array = <span class="hl-keyword">new</span> xml.c1677.invoice.generated.Item[size];
        <span class="hl-keyword">for</span> (<span class="hl-keyword">int</span> index = 0; index &lt; size; index++){
            array[index] = (xml.c1677.invoice.generated.Item) _itemList.get(index);
        }
        
        <span class="hl-keyword">return</span> array;
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item[] getItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getItemCount()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._itemList.size();
    } <span class="hl-comment">//-- int getItemCount() </span>

    <span class="hl-keyword">public</span> java.util.Iterator iterateItem()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>._itemList.iterator();
    } <span class="hl-comment">//-- java.util.Iterator iterateItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> removeAllItem()
    {
        <span class="hl-keyword">this</span>._itemList.clear();
    } <span class="hl-comment">//-- void removeAllItem() </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> removeItem(xml.c1677.invoice.generated.Item vItem)
    {
        <span class="hl-keyword">boolean</span> removed = _itemList.remove(vItem);
        <span class="hl-keyword">return</span> removed;
    } <span class="hl-comment">//-- boolean removeItem(xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> xml.c1677.invoice.generated.Item removeItemAt(<span class="hl-keyword">int</span> index)
    {
        Object obj = <span class="hl-keyword">this</span>._itemList.remove(index);
        <span class="hl-keyword">return</span> (xml.c1677.invoice.generated.Item) obj;
    } <span class="hl-comment">//-- xml.c1677.invoice.generated.Item removeItemAt(int) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItem(<span class="hl-keyword">int</span> index, xml.c1677.invoice.generated.Item vItem)
        <span class="hl-keyword">throws</span> java.lang.IndexOutOfBoundsException
    {
        <span class="hl-comment">// check bounds for index</span>
        <span class="hl-keyword">if</span> (index &lt; 0 || index &gt;= <span class="hl-keyword">this</span>._itemList.size()) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IndexOutOfBoundsException(<span class="hl-string">"setItem: Index value '"</span> 
               + index + <span class="hl-string">"' not in range [0.."</span> + (<span class="hl-keyword">this</span>._itemList.size() - 1) + <span class="hl-string">"]"</span>);
        }
        
        <span class="hl-keyword">this</span>._itemList.set(index, vItem);
    } <span class="hl-comment">//-- void setItem(int, xml.c1677.invoice.generated.Item) </span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItem(xml.c1677.invoice.generated.Item[] vItemArray)
    {
        <span class="hl-comment">//-- copy array</span>
        _itemList.clear();
        
        <span class="hl-keyword">for</span> (<span class="hl-keyword">int</span> i = 0; i &lt; vItemArray.length; i++) {
                <span class="hl-keyword">this</span>._itemList.add(vItemArray[i]);
        }
    } <span class="hl-comment">//-- void setItem(xml.c1677.invoice.generated.Item) </span>

}</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.code.generator.examples.non-trivial"></a>2.7.2.&nbsp;Non-trivial real world example</h3></div></div></div><p>
          Two companies wish to trade with each other using a Supply Chain
          messaging system. This system sends and receives Purchase Orders and
          Order Receipt messages. After many months of discussion they have
          finally decided upon the structure of the Version 1.0 of their
          message XSD and both are presently developing solutions for it. One
          of the companies decides to use Java and Castor XML support for
          (un)marshaling and Castor's code generator to accelerate their
          development process.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.non-trivial.schema"></a>2.7.2.1.&nbsp;The Supply Chain XSD</h4></div></div></div><pre class="programlisting">
            &lt;<span class="hl-tag">title</span>&gt;supplyChainV1.0.xsd&lt;<span class="hl-tag">/title</span>&gt;
&lt;<span class="hl-tag">?xml version="1.0" encoding="UTF-8"?</span>&gt;
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
           <span class="hl-attribute">elementFormDefault</span>=<span class="hl-value">"qualified"</span>
           <span class="hl-attribute">attributeFormDefault</span>=<span class="hl-value">"unqualified"</span>&gt;

    &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Data"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;
          This section contains the supply chain message data
        &lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:complexType</span>&gt;
        &lt;<span class="hl-tag">xs:choice</span>&gt;
          &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrder"</span>&gt;
            &lt;<span class="hl-tag">xs:complexType</span>&gt;
              &lt;<span class="hl-tag">xs:sequence</span>&gt;
                &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItem"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"LineItemType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span>/&gt;
              &lt;<span class="hl-tag">/xs:sequence</span>&gt;
              &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
            &lt;<span class="hl-tag">/xs:complexType</span>&gt;
          &lt;<span class="hl-tag">/xs:element</span>&gt;
          &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceipt"</span>&gt;
            &lt;<span class="hl-tag">xs:complexType</span>&gt;
              &lt;<span class="hl-tag">xs:sequence</span>&gt;
                &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItem"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"ReceiptLineItemType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span>/&gt;
              &lt;<span class="hl-tag">/xs:sequence</span>&gt;
              &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
            &lt;<span class="hl-tag">/xs:complexType</span>&gt;
          &lt;<span class="hl-tag">/xs:element</span>&gt;
        &lt;<span class="hl-tag">/xs:choice</span>&gt;
      &lt;<span class="hl-tag">/xs:complexType</span>&gt;
    &lt;<span class="hl-tag">/xs:element</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SkuType"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;Contains Product Identifier&lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ID"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ReceiptSkuType"</span>&gt;
      &lt;<span class="hl-tag">xs:annotation</span>&gt;
        &lt;<span class="hl-tag">xs:documentation</span>&gt;Contains Product Identifier&lt;<span class="hl-tag">/xs:documentation</span>&gt;
      &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
        &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"SkuType"</span>&gt;
          &lt;<span class="hl-tag">xs:sequence</span>&gt;
            &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"InternalID"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
          &lt;<span class="hl-tag">/xs:sequence</span>&gt;
        &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"LineItemType"</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Sku"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"SkuType"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Value"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:double"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"BillingInstructions"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"DeliveryDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:date"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;

    &lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ReceiptLineItemType"</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Sku"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"ReceiptSkuType"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Value"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:double"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PackingDescription"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ShipDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:dateTime"</span>/&gt;
        &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Number"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
    &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:schema</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.code.generator.examples.non-trivial.binding"></a>2.7.2.2.&nbsp;Binding file? -- IT IS REQUIRED!</h4></div></div></div><p>
          If you run the Castor CodeGenerator on the above XSD you end up
          with the following set of classes. (You also get lots of warning
          messages with the present version.)
        </p><pre class="programlisting">
Data.java
DataDescriptor.java
LineItem.java
LineItemDescriptor.java
LineItemType.java
LineItemTypeDescriptor.java
OrderReceipt.java
OrderReceiptDescriptor.java
PurchaseOrder.java
PurchaseOrderDescriptor.java
ReceiptLineItemType.java
ReceiptLineItemTypeDescriptor.java
ReceiptSkuType.java
ReceiptSkuTypeDescriptor.java
Sku.java
SkuDescriptor.java
SkuType.java
SkuTypeDescriptor.java</pre><p>
          The problem here is that there are two different elements with the
          same name in different locations in the XSD. This causes a Java code
          generation conflict. By default, Castor uses the element name as the name 
          of the class. So the second class generated for the LineItem definition,
          which is different than the first, overwrites the first class
          generated.
        </p><p>
          A binding file is therefore necessary to help the Castor code
          generator differentiate between these generated classes and as such avoid
          such generation conflicts. That is, you can 'bind' an element in the XML schema 
          to a differently named class file that you want to generate. This keeps different 
          elements separate and ensures that source is properly generated for 
          each XML Schema object.
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
            The warning messages for Castor 0.99+ are very useful in assisting
            you in your creation of the binding file. For the example the
            warning messages for the example are:
          </p><pre class="programlisting">
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            '/Data/OrderReceipt/LineItem' and element '/Data/PurchaseOrder/LineItem'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
    Warning: A class name generation conflict has occurred between element
            'complexType:ReceiptLineItemType/Sku' and element 'complexType:LineItemType/Sku'.
            Please use a Binding file to solve this problem.Continue anyway [not recommended] (y|n|?)y
          </pre></td></tr></table></div><p>
          The following binding file definition will overcome the naming
          issues for the generated classes:
        </p><pre class="programlisting">
            
&lt;<span class="hl-tag">binding</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.castor.org/SourceGenerator/Binding"</span>
         <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/SourceGenerator/Binding C:\\Castor\\xsd\\binding.xsd"</span>
         <span class="hl-attribute">defaultBinding</span>=<span class="hl-value">"element"</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/Data/PurchaseOrder/LineItem"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrderLineItem"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/Data/OrderReceipt/LineItem"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceiptLineItem"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:ReceiptLineItemType/Sku"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"OrderReceiptSku"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

   &lt;<span class="hl-tag">elementBinding</span> <span class="hl-attribute">name</span>=<span class="hl-value">"/complexType:LineItemType/Sku"</span>&gt;
      &lt;<span class="hl-tag">java-class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"PurchaseOrderSku"</span>/&gt;
   &lt;<span class="hl-tag">/elementBinding</span>&gt;

&lt;<span class="hl-tag">/binding</span>&gt;</pre><p>
          One thing to notice in the above <code class="literal">binding.xml</code> file is that
          the name path used is relative to the root of the XSD <span class="bold"><strong>and not</strong></span>
          the root of the target XML. Also notice that the two complex types
          have the "complexType:" prefix to identify them followed by the name
          path relative to the root of the XSD.
        </p><p>The new list of generated classes is:</p><pre class="programlisting">
Data.java
DataDescriptor.java
LineItem.java
LineItemDescriptor.java
LineItemType.java
LineItemTypeDescriptor.java
OrderReceipt.java
OrderReceiptDescriptor.java
<span class="bold"><strong><span class="bold"><strong>OrderReceiptLineItem.java</strong></span></strong></span>
OrderReceiptLineItemDescriptor.java
<span class="bold"><strong><span class="bold"><strong>OrderReceiptSku.java</strong></span></strong></span>
OrderReceiptSkuDescriptor.java
PurchaseOrder.java
PurchaseOrderDescriptor.java
<span class="bold"><strong><span class="bold"><strong>PurchaseOrderLineItem.java</strong></span></strong></span>
PurchaseOrderLineItemDescriptor.java
<span class="bold"><strong><span class="bold"><strong>PurchaseOrderSku.java</strong></span></strong></span>
PurchaseOrderSkuDescriptor.java
ReceiptLineItemType.java
ReceiptLineItemTypeDescriptor.java
ReceiptSkuType.java
ReceiptSkuTypeDescriptor.java
Sku.java
SkuDescriptor.java
SkuType.java
SkuTypeDescriptor.java</pre><p>
          The developers can now use these generated classes with Castor to
          (un)marshal the supply chain messages sent by their business
          partner.
        </p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e2113" href="#d4e2113">1</a>] </sup>XML Schema is a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org" target="_top">W3C</a>
        Recommendation</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e2117" href="#d4e2117">2</a>] </sup>Castor supports the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/XMLschema-1" target="_top">XML Schema 1.0 Second
        Edition</a></p></div></div></div>

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jdo"></a>Chapter&nbsp;3.&nbsp;Castor JDO</h2></div></div></div>
  
  
  
 
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.introduction"></a>3.1.&nbsp;Castor JDO - An introduction</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.introduction.what"></a>3.1.1.&nbsp;What is Castor JDO</h3></div></div></div><p>
       Castor JDO is an Object-Relational Mapping and Data-Binding Framework, which is 
       written in 100% pure Java[tm]. Castor can map relational database data into 
       Java Data Object based on user-defined mapping schema. In the other point-of-view, 
       it provides java data objects a persistence layer.
     </p><p>
       It frees programmer from dealing with database directly and replacing the entire 
       burden of composing updating the database. Proper SQL statements are automatically 
       generated for loading, updating, creating and deleting. Changes to objects in transaction 
       are automatically done to data source at commit time. Thus programmer can stay in pure-Java
       without remember all the details in the backing database, after the creation of 
       database tables and the mapping schema. The separation of persistence and programming 
       logic also enable much clearer object-oriented design, which is important in larger 
       projects.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.introduction.features"></a>3.1.2.&nbsp;Features</h3></div></div></div><p>
       JDO is <span class="bold"><strong>transactional</strong></span>. Data objects loaded in Castor 
       are properly locked and isolated from other transactions. Castor supports full 
       2-phase commit via xa.Synchronzation. Castor supports several locking modes, 
       including "shared", "exclusive", "database locked", and "read-only".
     </p><p>
       </p><div class="itemizedlist"><ul type="disc"><li><p>
             <span class="bold"><strong>Shared access</strong></span>, the default, is useful for 
             situations in which it is common for two or more transactions to read the 
             same objects, and/or update different objects.
           </p></li><li><p>
             <span class="bold"><strong>Exclusive access</strong></span> uses in-memory locks 
             implemented by Castor to force competing transactions to serialize access 
             to an object. This is useful for applications in which it is common for more 
             than one transaction to attempt to update the same object, and for which most, 
             if not all access to the database is performed through Castor.
           </p></li><li><p>
             <span class="bold"><strong>Database-Locked access</strong></span> is often used for 
             applications in which exclusive locking is required, but in which the database 
             is frequently accessed from applications outside of Castor, bypassing Castor's 
             memory-based locking mechanism used by "exclusive access" locking.
           </p></li><li><p>
             <span class="bold"><strong>Read-Only access</strong></span> performs no locking at all. 
             Objects read using this access mode are not locked, and those objects do not 
             participate in transaction commit/rollback.
           </p></li></ul></div><p>
     </p><p>
       In addition, Castor supports <span class="bold"><strong>"long transactions"</strong></span>, 
       whichs allow objects to be read in one transaction, modified, and then committed 
       in a second transaction, with built-in dirty-checking to prevent data that has been 
       changed since the initial transaction from being overwritten.
     </p><p>
       Through <span class="bold"><strong>automatic dirty-checking</strong></span> 
       and <span class="bold"><strong>deadlock detection</strong></span>, Castor can be 
       used to ensure data integrity and reduce unnecessary database updates.
     </p><p>
       A subset of OQL, defined in the Object Management Group (OMG) 3.0 
       <span class="bold"><strong>Object Query Language</strong></span> Specification, 
       is supported for interacting with the database. OQL is 
       similar to SQL, though operations are performed directly on Java objects instead 
       of database tables, making the language more appropriate for use within a 
       Java-based application.
     </p><p>
       Castor implements a <span class="bold"><strong>data cache</strong></span> to reduce database 
       accesses, providing several alternative LRU-based caching strategies.
     </p><p>
       Castor supports different cardinalities of <span class="bold"><strong>relationship</strong></span>, 
       including <span class="bold"><strong>one-to-one</strong></span>, 
       <span class="bold"><strong>one-to-many</strong></span> 
       and <span class="bold"><strong>many-to-many</strong></span>. It also supports both object 
        and database record <span class="bold"><strong>inheritance</strong></span>. It distinguishes 
       between <span class="bold"><strong>related</strong></span> (i.e. association) 
       and <span class="bold"><strong>dependent</strong></span> 
       (i.e. aggregation) relationships during an object's life cycle, automatically creating 
       and deleting dependent objects at appropriate times in the independent object's 
       life cycle.
     </p><p>
       Multiple-column primary keys, and a variety of key generators are supported.
     </p><p>
       Castor automatically manages persistence for objects that contain Java collection 
       types, including Vector, Hashtable, Collection, Set, and Map. 
       <span class="bold"><strong>Lazy loading</strong></span> 
       (of collections as well as simple 1:1 relations) is implemented to reduce unnecessary 
       database loading. Lazy loading can be turned on or off for each individual field (of 
       any supported collection type for 1-to-many and many-to-many relations).
     </p><p>
       Other features include a type converter for all Java primitive types (see the 
       info on supported <a href="#jdo.types" title="3.5.&nbsp;Type Support">types</a>).
     </p><p>
       No pre-processor (aka pre-compiler), class enhancer (bytecodes modification) is needed 
       or used for data-binding and object persistence.
     </p><p>
       Castor JDO works in an application that uses multiple ClassLoaders, making it possible to 
       use in an EJB container or servlet, for example. A Castor-defined callback interface, 
       "Persistent", can be implemented if the objects wants to be notified on Castor 
       events: jdoLoad(), jdoCreate(), jdoRemove() and jdoTransient(). This makes it possible 
       to create user-defined actions to take at various times in an object's life cycle.
     </p><p>
        The Java-XML Data-Binding Framework (Castor XML) has been merged with Castor JDO for 
        users who need both O/R Mapping and Java-XML Data-Binding together.
      </p><p>
        The following relational databases are supported: 
            
        </p><div class="itemizedlist"><ul type="disc"><li><p>DB2</p></li><li><p>Derby</p></li><li><p>Generic DBMS</p></li><li><p>Hypersonic SQL</p></li><li><p>Informix</p></li><li><p>InstantDB</p></li><li><p>Interbase</p></li><li><p>MySQL</p></li><li><p>Oracle</p></li><li><p>PostgreSQL</p></li><li><p>Progress</p></li><li><p>SAP DB / MaxDB</p></li><li><p>SQLServer</p></li><li><p>Sybase</p></li></ul></div><p>
      </p><p>
        Database support includes Oracle 8.1.x and different versions of Sybase Enterprise and 
        Anywhere. Users can implement the Driver interface to adapt Castor to the differences in 
        SQL syntax supported by different relational DBMS's, as long as the DBMS supports JDBC 
        2.0, multiple ResultSet, and transactions. Thanks to many individual open source 
        contributors, drivers for different database are available.
      </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.first-steps"></a>3.2.&nbsp;Castor JDO - First steps</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.introduction"></a>3.2.1.&nbsp;Introduction</h3></div></div></div><p>
          This guide assumes that you do not have any experience with CASTOR JDO, but would 
          like to make your first steps into the world of persistence and object/relation 
          mapping tools. The following sections show how to setup and configure Castor JDO so that
          it is possible to perform persistence operations on the domain objects presented.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.sample-domain-ojects"></a>3.2.2.&nbsp;Sample domain objects</h3></div></div></div><p>
          The sample domain objects used in here basically define a 
          <code class="literal">Catalogue</code>, 
          which is a collection of <code class="literal">Product</code>s.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Catalogue {

   <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
   <span class="hl-keyword">private</span> List products = <span class="hl-keyword">new</span> ArrayList();
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">long</span> id) { ... }

   <span class="hl-keyword">public</span> String getProducts() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProducts(List products) { ... }
   
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {

   <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
   
   <span class="hl-keyword">private</span> String description;

   <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">long</span> id) { ... }
   
   <span class="hl-keyword">public</span> String getDescription() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDescription(String description) { ... }
   
}</pre><p>
          In order to be able to perform any persistence operation (such as loading products, deleting 
          products from a catalogue, ...) on these domain objects through Castor JDO, a Castor 
          JDO mapping has to be provided, defining class and field level mappings for the Java classes given
          and their members:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Catalogue"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"catalogue"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.sample.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"arraylist"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"c_id"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Product"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"product"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"desc"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.first-time-use"></a>3.2.3.&nbsp;Using Castor JDO for the first time</h3></div></div></div><p>
          To e.g. load a given <code class="literal">Catalogue</code> instance as defined 
          by its identity, and all its associated <code class="literal">Product</code> instances, 
          the following code could be used, based upon the Castor-specific interfaces 
          <code class="literal">JDOManager</code> and <code class="literal">Database</code>.
        </p><pre class="programlisting">
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdoManager = JDOmanager.createInstance(<span class="hl-string">"sample"</span>);

Database database = jdoManager.getDatabase();       
database.begin();
Catalogue catalogue = database.load(catalogue.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Long(1));
database.commit();
database.close();</pre><p>
          For brevity, exception handling has been ommitted completely. But is is quite obvious
          that - when using such code fragments again and again, to e.g. implement various 
          methods of a DAO - there's a lot of redundant code that needed to be written again 
          and again - and exception handling is adding some additional complexity here as well.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.configuration"></a>3.2.4.&nbsp;JDO configuration</h3></div></div></div><p>
          As shown in above code example, before you can perform any persistence operations on 
          your domain objects, Castor JDO has to be configured by the means of a JDO 
          configuration file. as part of this JDO configuration, the user defines one or more 
          databases and everything required to connect to this database (user credentials, JDBC
          connection string, ....).
        </p><p>
          A valid JDO configuration file for HSQL looks as follows:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0" ?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span> <span class="hl-attribute">"http://castor.org/jdo-conf.dtd"&gt;</span>
<span class="hl-attribute">&lt;jdo-conf&gt;</span>
  <span class="hl-attribute">&lt;database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hsqldb"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"hsql"</span>&gt;
    &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span> <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9002/dbname"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span>/&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span>/&gt;
    &lt;<span class="hl-tag">/driver</span>&gt;
    &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"mapping.xml"</span>/&gt;
  &lt;<span class="hl-tag">/database</span>&gt;
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span>/&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
        </pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.usage"></a>3.3.&nbsp;Using Castor JDO</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.database-connection"></a>3.3.1.&nbsp;Opening A JDO Database</h3></div></div></div><p>
        Castor JDO supports two type of environments, client applications and J2EE servers.
        <a href="#jdo.usage.database-connection.stand-alone" title="3.3.1.1.&nbsp;Stand-alone application">Client applications</a> 
        are responsible for configuring the database connection and managing transactions 
        explicitly. 
        <a href="#jdo.usage.database-connection.j2ee" title="3.3.1.2.&nbsp;J2EE Application">J2EE applications</a>
         use JNDI to obtain a pre-configured database connection, and use
        <code class="literal">UserTransaction</code> or container managed transactions (CMT) to 
        manage transactions. If you have been using JDBC in these two environments, 
        you will be readily familiar with the two models and the differences between 
        them. 
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-connection.stand-alone"></a>3.3.1.1.&nbsp;Stand-alone application</h4></div></div></div><p>
          Client applications are responsible for defining the JDO configuration, and managing 
          the transaction explicitly. The database is by default configured through a separate
          XML file which links to the mapping file. Alternatively, it can be configured using the
          utility class <code class="classname">org.exolab.castor.jdo.util.JDOConfFactory</code>.
        </p><p>
		  In the example code I refer to the JDO configuration file as 
		  <code class="literal">jdo-conf.xml</code>, but any name can be used. See 
		  <a href="#jdo.configuration" title="3.4.&nbsp;Castor JDO - Configuration">Castor JDO Configuration</a> 
		  for more information.
		</p><p>
          As of release 0.9.6, a new JDOManager class is provided, that replaces the former JDO
		   class. Any new features will be implemented against the new JDOManager class only.
		</p><p>As with its predecessor, <code class="classname">org.exolab.castor.jdo.JDOManager</code> defines the database 
		   name and properties and is used to open a database connection. An instance of this class 
		   is constructed with a two-step approach:
		</p><div class="orderedlist"><ol type="1"><li><p>
              Statically load the JDO configuration file through one of the 
              loadConfiguration() methods, e.g. 
			  <code class="methodname">org.exolab.castor.jdo.JDOManager.loadConfiguration(java.lang.String)</code>.
			</p></li><li><p>
              Create an instance of the JDO engine using the factory method 
              <code class="methodname">org.exolab.castor.jdo.JDOManager.createInstance(java.lang.String)</code>
			  where you supply one of the database names defined in the configuration 
			  file loaded in step 1).
			</p></li></ol></div><p>
          The <code class="classname">org.exolab.castor.jdo.Database</code> object represents 
          an open connection to the database. By definition the database object is not 
          thread safe and should not be used from concurrent threads. There is little 
          overhead involved in opening multiple <code class="literal">Database</code>
          objects, and a JDBC connection is acquired only per open transaction.
        </p><p>
          The following code fragment creates an instance of JDOManager for a database 'mybd',
	      opens a database, performs a transaction, and closes the database - as it will typically 
		  appear in client applications (for brevity, we have ommitted any required exception 
		  handling):
	    </p><pre class="programlisting"> 
JDOManager jdoManager;
Database db;
 
<span class="hl-comment">// load the JDO configuration file and construct a new JDOManager for the database 'mydb'</span>
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
jdoManager = JDOManager.createInstance(<span class="hl-string">"mydb"</span>);

<span class="hl-comment">// Obtain a new database</span>
Database db = jdoManager.getDatabase();
    
<span class="hl-comment">// Begin a transaction</span>
db.begin();

<span class="hl-comment">// Do something</span>
. . .

<span class="hl-comment">// Commit the transaction and close the database</span>
db.commit();
db.close();
        </pre><p>
		  For an example showing how to set up a database configuration on the fly without
		  the need of a preconfigured XML configuration file) see
		  <a href="#jdo.configuration.jdoconffactory" title="3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO">JdoConfFactory</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-connection.j2ee"></a>3.3.1.2.&nbsp;J2EE Application</h4></div></div></div><p>
          J2EE applications depend on the J2EE container (Servlet, EJB, etc) to configure
          the database connection and use JNDI to look it up. This model allows the application
          deployer to configure the database properties from a central place, and gives the J2EE
          container the ability to manage distributed transactions across multiple data sources.
        </p><p>
          Instead of constructing a 
          <code class="classname">org.exolab.castor.jdo.JDOManager</code>
          the application uses the JNDI namespace to look it up. 
          We recommend enlisting the <code class="literal">JDOManager</code> 
          object under the <code class="literal">java:comp/env/jdo</code> namespace, 
          compatible with the convention for listing JDBC resources.
        </p><p>
          The following code fragment uses JNDI to lookup a database, and uses the JTA 
		  <code class="literal">UserTransaction</code> interface to manage the transaction:
		</p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup databse in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Begin a transaction</span>
ut = (UserTransaction) ctx.lookup( <span class="hl-string">"java:comp/UserTransaction"</span> );
ut.begin();
<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Commit the transaction, close database</span>
ut.commit();
db.close();
        </pre><p>
          If the transaction is managed by the container, a common case with EJB beans and
          in particular entity beans, there is no need to begin/commit the transaction explicitly.
          Instead the application server takes care of enlisting the database in the ongoing
          transaction and executes commit/rollback at the proper time.
        </p><p>
          The following code snippet relies on the container to manage the transaction
        </p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup database in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Close the database</span>
db.close();
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.database-persistence"></a>3.3.2.&nbsp;Using A JDO Database to perform persistence operations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.objects"></a>3.3.2.1.&nbsp;Transient And Persistent Objects</h4></div></div></div><p>
          All JDO operations occur within the context of a transaction. JDO works by loading
          data from the database into an object in memory, allowing the application to modify
          the object, and then storing the object's new state when the transaction commits.
          All objects can be in one of two states: transient or persistent.
        </p><p>
          <span class="bold"><strong>Transient:</strong></span> Any object whose state will not be saved 
          to the database when the transaction commits. Changes to transient objects will not 
          be reflected in the database.
        </p><p>
          <span class="bold"><strong>Persistent:</strong></span> Any object whose state will be saved 
          to the database when the transaction commits. Changes to persistent objects will 
          be reflected in the database.
        </p><p>
          An object becomes persistent in one of two ways: it is the result of a query,
          (and the query is not performed in read-only mode) or it is added to the database 
          using 
          <code class="methodname">org.exolab.castor.jdo.Database.create(java.lang.Object)</code>
          or 
          <code class="methodname">org.exolab.castor.jdo.Database.update(java.lang.Object)</code>.
          All objects that are not persistent are transient. When the transaction commits 
          or rolls back, all persistent objects become transient.
        </p><p>
         In a client application, use 
         <code class="methodname">org.exolab.castor.jdo.Database.begin()</code>,
         <code class="methodname">org.exolab.castor.jdo.Database.commit()</code> and
         <code class="methodname">org.exolab.castor.jdo.Database.rollback()</code> 
         to manage transactions. In a J2EE application, JDO relies on the container 
         to manage transactions either implicitly (based on the transaction attribute 
         of a bean) or explicitly using the
         <code class="literal">javax.transaction.UserTransaction</code> interface.
       </p><p>
         If a persistent object was modified during the transaction, at commit time the 
         modifications are stored back to the database. If the transaction rolls back, 
         no modifications will be made to the database. Once the transaction completes, 
         the object is once again transient. To use the same object in two different 
         transactions, you must query it again.
       </p><p>
         An object is transient or persistent from the view point of the database to which
         the transaction belongs. An object is generally persistent in a single database,
         and calling 
         <code class="methodname">org.exolab.castor.jdo.Database"&gt;isPersistent(java.lang.Object)</code>
         from another database will return false. It is possible to make an object persistent
         in two database, e.g. by querying it in one, and creating it in the other.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.query"></a>3.3.2.2.&nbsp;Running an OQL Query</h4></div></div></div><p>
          OQL queries are used to lookup and query objects from the database. OQL queries are
          similar to SQL queries, but use object names instead of SQL names and do not require
          join clauses. For example, if the object being loaded is of type <code class="literal">TestObject</code>,
          the OQL query will load <code class="literal">FROM TestObject</code>, whether the actual table name in
          the database is <code class="literal">test</code>, <code class="literal">test_object</code>, or any other name. 
          If a join is required to load related objects, Castor will automatically perform the join.
        </p><p>
          The following code snippet uses an OQL query to load all the objects in a given group.
          Note that product and group are related objects, the JDBC query involves a join:
        </p><pre class="programlisting">
OQLQuery     oql;
QueryResults results;

<span class="hl-comment">// Explicitly begin transaction</span>
db.begin();

<span class="hl-comment">// Construct a new query and bind its parameters</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT p FROM Product p WHERE Group=$1"</span>);
oql.bind(groupId);

<span class="hl-comment">// Retrieve results and print each one</span>
results = oql.execute();
<span class="hl-keyword">while</span> (results.hasMore()) {
  System.out.println(results.next());
}

<span class="hl-comment">// Explicitly close the QueryResults</span>
results.close();

<span class="hl-comment">// Explicitly close the OQLQuery</span>
oql.close();

<span class="hl-comment">// Explicitly commit transaction</span>
db.commit();
db.close();
        </pre><p>
          The following code snippet uses the previous query to obtain products, mark down
          their price by 25%, and store them back to the database (in this case using
          a client application transaction):
        </p><pre class="programlisting">
OQLQuery     oql;
QueryResults results;

<span class="hl-comment">// Explicitly begin transaction</span>
db.begin();

<span class="hl-comment">// Construct a new query and bind its parameters</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT p FROM Product p WHERE Group=$1"</span>);
oql.bind(groupId);

<span class="hl-comment">// Retrieve results and mark up each one by 25%</span>
Product prod;
<span class="hl-keyword">while</span> (results.hasMore()) {
  prod = (Product) results.next();
  prod.markDown(0.25);
  prod.setOnSale(true);
}

<span class="hl-comment">// Explicitly close the QueryResults</span>
results.close();

<span class="hl-comment">// Explicitly close the OQLQuery</span>
oql.close();

<span class="hl-comment">// Explicitly commit transaction</span>
db.commit();
db.close();
        </pre><p>
          As illustrated above, a query is executed in three steps. First a query object is
          created from the database using an OQL statement. If there are any parameters, the
          second step involves binding these parameters. Numbered parameters are bound using
		  the order specified in their names. (e.g. first $1, after that $2, and so on...)
		  The third step involves executing the query and obtaining a result set of type
          <code class="classname">org.exolab.castor.jdo.QueryResults</code>.
        </p><p>
          A query can be created once and executed multiple times. Each time it is executed
          the bound parameters are lost, and must be supplied a second time. The result of
          a query can be used while the query is being executed a second time.
        </p><p>
          There is also a special form of query that gives a possibility to call stored
          procedures:
        </p><p>   
            <code class="code">
oql = db.getOQLQuery("CALL sp_something($) AS myapp.Product");
            </code>
        </p><p>
          Here sp_something is a stored procedure returning one or more
          ResultSets with the same sequence of fields as Castor-generated
          SELECT for the OQL query "SELECT p FROM myapp.Product p"
          (for objects without relations the sequence is: identity, then all
          other fields in the same order as in mapping.xml).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.create"></a>3.3.2.3.&nbsp;Creating a persistent object</h4></div></div></div><p>
          The method 
          <code class="methodname">org.exolab.castor.jdo.Database.create(java.lang.Object)</code>
          creates a new object in the database, or in JDO terminology makes a transient
          object persistent. An object created with the <code class="literal">create</code> method 
          will remain in the database if the transaction commits; 
          if the transaction rolls back the object will be removed from the database. 
          An exception is thrown if an object with the same identity already exists in 
          the database.
        </p><p>
          The following code snippet creates a new product with a group that was previously
          queried:
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">//load product group</span>
ProductGroup furnitures = db.load(...);

<span class="hl-comment">// Create the Product object</span>
Product prod;
prod = <span class="hl-keyword">new</span> Product();
prod.setSku(5678);
prod.setName(<span class="hl-string">"Plastic Chair"</span>);
prod.setPrice(55.0 );
prod.setGroup(furnitures);

<span class="hl-comment">// Make it persistent</span>
db.create(prod);

db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.remove"></a>3.3.2.4.&nbsp;Removing a persistent object</h4></div></div></div><p>
          The method 
          <code class="methodname">org.exolab.castor.jdo.Database.remove(java.lang.Object)</code>
          has the reverse effect, deleting a persistent object. Once removed the object is no
          longer visible to any transaction. If the transaction commits, the object will be removed
          from the database, however, if the transaction rolls back the object will remain in
          the database. An exception is thrown when attempting to remove an object that is not
          persistent.
        </p><p>
          The following code snippet deletes the previously created Product instance:
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">// load the Product instance with sku = 5678</span>
Product prod = db.load (Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(5678);

<span class="hl-comment">// delete the Product instance</span>
db.remove(prod);

db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.update"></a>3.3.2.5.&nbsp;Updating a persistent object</h4></div></div></div><p>
          There's no special method offering on the 
          <code class="classname">org.exolab.castor.jdo.Database</code> 
          to update an existing persistent object. Simply load the object to be updated, change
          one or more of its properties, and commit the transaction. Castor JDO will automatically
          figure that that the object in question has changed and will persist these changes
          to the underlying database.
        </p><p>
          The following code snippet loads a previously created Product instance, changes its
          description property and commits the transaction.
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">// load the Product instance with sku = 5678</span>
Product prod = db.load (Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(5678);

<span class="hl-comment">// change the object properties</span>
prod.setDescription(<span class="hl-string">"New plastic chair"</span>);

<span class="hl-comment">//commit the transaction</span>
db.commit();
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.jdo-and-xml"></a>3.3.3.&nbsp;Using JDO And XML</h3></div></div></div><p>
        Castor JDO and Castor XML can be combined to perform transactional database operations
        that use XML as the form of input and output. The following code snippet uses a combination
        of persistent and transient objects to describe a financial operation.
      </p><p>
        This example retrieves two account objects and moves an amount from one account to the
        other. The transfer is described using a transient object (i.e. no record in the database),
        which is then used to generate an XML document describing the transfer. An extra step
        (not shown here), uses XSLT to transform the XML document into an HTML page.
      </p><pre class="programlisting">
Transfer tran;
Account  from;
Account  to;
OQLQuery oql;

tran = <span class="hl-keyword">new</span> Transfer();

<span class="hl-comment">// Construct a query and load the two accounts</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT a FROM Account a WHERE Id=$"</span>);
oql.bind(fromId);
from = oql.execute().nextElement();
oql.bind(toId);
to = oql.execute().nextElement();

<span class="hl-comment">// Move money from one account to the other</span>
<span class="hl-keyword">if</span> (from.getBalance() &gt;= amount) {
  from.decBalance(amount);
  to.incBalance(amount);
  trans.setStatus(Transfer.COMPLETE);
  trans.setAccount(from);
  trans.setAmount(amount);
} <span class="hl-keyword">else</span> {
  <span class="hl-comment">// Report an overdraft</span>
  trans.setStatus( Transfer.OVERDRAFT );
}

<span class="hl-comment">// Produce an XML describing the transfer</span>
Marshaller.marshal(trans, outputStream);
      </pre><p>The XML produced by the above code might look like:</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">report</span>&gt;
  &lt;<span class="hl-tag">status</span>&gt;Completed&lt;<span class="hl-tag">/status</span>&gt;
  &lt;<span class="hl-tag">account</span> <span class="hl-attribute">id</span>=<span class="hl-value">"1234-5678-90"</span> <span class="hl-attribute">balance</span>=<span class="hl-value">"50"</span>/&gt;
  &lt;<span class="hl-tag">transfer</span> <span class="hl-attribute">amount</span>=<span class="hl-value">"49.99"</span>/&gt;
&lt;<span class="hl-tag">/report</span>&gt;
</pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.configuration"></a>3.4.&nbsp;Castor JDO - Configuration</h2></div></div></div><p>
       Castor JDO allows for two simple ways of specifying its required configuration, e.g. 
       by the means of supplying Castor JDO with an XML-based configuration file, and by 
       specifying its configuration programmatically via the 
       <code class="classname">org.exoalb.castor.util.jdo.JDOConfFactory</code> class.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.configuration-file"></a>3.4.1.&nbsp;The Castor configuration file</h3></div></div></div><p>
         The default way to configure how Castor interacts with a specific database system 
         is by using a configuration file. It specifies the means to obtain a connection
         to the database server, the mapping between Java classes and tables in that 
         database server, and the service provider to use for talking to that server 
         (For a more flexible, programmatic way without configuration files see section 
         <a href="#jdo.configuration.jdoconffactory" title="3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO">JDOConfFactory</a>).
      </p><p>
         The application will access the database(s) by its given name
         (<code class="literal">database/name</code>) and will be able to persist all objects 
         specified in the included mapping file(s).
      </p><p>
         The <code class="literal">engine</code> attribute specifies the persistence engine for this
         database server. Different database servers vary in the SQL syntax and
         capabilites they support, and this attribute names the service provider to use.
      </p><p>The following names are supported in Castor:</p><div class="table"><a name="d4e4205"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Supported engine names</b></p><div class="table-contents"><table summary="Supported engine names" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">engine name</th><th align="left">RDBMS</th></tr></thead><tbody><tr><td>db2</td><td>DB/2</td></tr><tr><td>derby</td><td>Derby</td></tr><tr><td>generic</td><td>Generic JDBC support</td></tr><tr><td>hsql</td><td>Hypersonic SQL</td></tr><tr><td>informix</td><td>Informix</td></tr><tr><td>instantdb</td><td>InstantDB</td></tr><tr><td>interbase</td><td>Interbase</td></tr><tr><td>mysql</td><td>MySQL</td></tr><tr><td>oracle</td><td>Oracle 7 - Oracle 9i</td></tr><tr><td>postgresql</td><td>PostgreSQL 7.1</td></tr><tr><td>sapdb</td><td>SAP DB / MaxDB</td></tr><tr><td>sql-server</td><td>Microsoft SQL Server</td></tr><tr><td>sybase</td><td>Sybase 11</td></tr><tr><td>pointbase</td><td>Borland Pointbase</td></tr><tr><td>progress</td><td>Progress RDBMS</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
            Castor doesn't work with JDBC-ODBC bridge from Sun.
            In particular, MS Access is not supported.
         </p></td></tr></table></div><p>
         The means to acquire a database connection is specified in one of three
         ways: as a JDBC driver URL, as a JDBC DataSource, or as a DataSource
         to lookup through JNDI. When Castor is used inside a J2EE application server
         it is recommended to use JNDI lookup (see the <code class="literal">jndi</code> element),
         allowing the application server to manage connection pooling and distributed
         transactions.
      </p><p>
         The class mapping is included from an external mapping file, allowing
         multiple mappings to be included in the same database configuration, or two
         databases to share the same mappings. For concurrency and integrity reasons,
         two database configurations should never attempt to use overlapping mappings.
         It is recommended to use one database configuration per database server.
      </p><p>
         The mapping file is specified using a URL, typically a <code class="literal">file:</code> URL.
         If the database configuration file and mapping file reside in the same
         directory, use a relative URL. Relative URLs also work if the database
         configuration and mapping files are obtained from the application JAR and
         reside in the same classpath.
      </p><p>
         The <code class="literal">driver</code> element specifies the JDBC driver for obtaining
         new connections to the database server. The driver is obtained from the JDBC
         <code class="literal">DriverManager</code> and must be located in the class path. The JDBC URL
         locates the driver and provides the access properties. Additional properties
         may be specified using <code class="literal">param</code> elements (e.g. buffer size, network
         protocol, etc).
      </p><p>
         Use the <code class="literal">class-name</code> attribute to specify the driver class for
         automatic registration with the JDBC <code class="literal">DriverManager</code>. If missing,
         the driver must be registered in any other means, including properties file,
         <code class="literal">Class.forName()</code>, etc.
      </p><p>
         For example, to configure an Oracle 8 thin driver, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;         
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@host:port:SID"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
        &lt;<span class="hl-tag">/driver</span>&gt;
        ...
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><p>
         The <code class="literal">data-source</code> element specifies the JDBC DataSource for
         obtaining new connections to the database server. DataSources are defined
         in the JDBC 2.0 standard extension API which is included with Castor, and
         implement the interface <code class="literal">javax.sql.DataSource</code>.
      </p><p>
         The DataSource implementation class name is specified by the 
         <code class="literal">class-name</code> attribute and configured through Bean-like accessor 
         methods specified for the <code class="literal">param</code> element. 
         The DTD for the <code class="literal">param</code> element is undefined
         and depends on the DataSource being used.
      </p><p>
         For example, to configure a PostgreSQL 7.1 DataSource, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5432"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password="</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
        &lt;<span class="hl-tag">/data-source</span>&gt;
        ...
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><p>
         The <code class="literal">jndi</code> element specifies the JDBC DataSource for obtaining
         new connections to the database server through a JNDI lookup. The JNDI environment
         naming context (ENC) is used to obtain a suitable DataSource..
      </p><p>
         When running inside a J2EE application server, this is the preferred method
         for obtaining database connections. It enables the J2EE application server to
         configure the connection, maintain a connection pool, and manage distributed
         transactions.
      </p><p>
         For example, to specify a J2EE DataSource, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/mydb"</span> /&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.transaction"></a>3.4.1.1.&nbsp;Transaction demarcation</h4></div></div></div><p>
           As opposed to release pre 0.9.6, transaction demarcation is now configured 
           in the JDO configuration file. As such, the user has to specify which transaction
           demarcation to use. Transactions when used with Castor JDO can either be 
           <span class="bold"><strong>local</strong></span> or <span class="bold"><strong>global</strong></span>, 
           and you instruct Castor to use a specific mode by supplying 
           a <code class="literal">&lt;transaction-demarcation&gt;</code> element.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.transaction.local-mode"></a>3.4.1.1.1.&nbsp;Local Mode</h5></div></div></div><p>
              When using Castor JDO stand-alone and you want Castor to control
              transaction demarcation, please use the 
              <code class="literal">&lt;transaction-demarcation&gt;</code> element as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span> /&gt;
           </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.transaction.global-mode"></a>3.4.1.1.2.&nbsp;Global Mode</h5></div></div></div><p>
              When running inside a J2EE application server, and you want to use
              global (XA) transactions, please make use the 
              <code class="literal">&lt;transaction-demarcation&gt;</code> element as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
   &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span> /&gt;
&lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
           </pre><p>
              In this mode, the <code class="literal">&lt;transaction-manager&gt;</code> 
              element specifies the transaction manager that is used by your 
              J2EE container to control these transactions.
           </p><p>The following transaction managers are supported in Castor:</p><div class="table"><a name="d4e4308"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Supported transaction managers</b></p><div class="table-contents"><table summary="Supported transaction managers" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td>jndi</td><td>TM looked up in the JNDI ENC</td></tr><tr><td>websphere</td><td>IBM WebSphere 4 and previous releases</td></tr><tr><td>websphere5</td><td>IBM WebSphere 5</td></tr><tr><td>websphere51</td><td>IBM WebSphere 5.1</td></tr><tr><td>jotm</td><td>JOTM</td></tr><tr><td>atomikos</td><td>Atomikos</td></tr></tbody></table></div></div><br class="table-break"><p>
               In addition to specifying the transaction manager name, it is possible
               to pass arbitrary name/value pairs to the transaction manager instance.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	               At the moment, only the JNDI transaction manager factory supports 
	               such an attribute. In this context, the jndiEnc attribute can be 
	               used to specify what JNDI ENC to use to lookup the transaction 
	               manager as shown below:
               </p></td></tr></table></div><pre class="programlisting">
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
     &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span>&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiEnc"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/TransactionManager"</span>/&gt;
     &lt;<span class="hl-tag">/transaction-manager</span>&gt;
  &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.sample"></a>3.4.1.2.&nbsp;Sample Configuration File</h4></div></div></div><p>
         The following configuration file instructs Castor JDO to execute against 
         an Oracle RDBMS using the thin (type 4) JDBC driver, and refers to 
         three mapping files that define mappings for product, order and customer related 
         data.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">jdo-conf</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order-system"</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@machine:post:SID"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span>/&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span>/&gt;
        &lt;<span class="hl-tag">/driver</span>&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"products.xml"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"orders.xml"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"customers.xml"</span>/&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span>/&gt;
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
         The following configuration file uses a connection obtained from the
         J2EE application server and a single mapping file:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/mydb"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"ebiz.xml"</span>/&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
        &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiEnc"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/TransactionManager"</span>/&gt;
        &lt;<span class="hl-tag">/transaction-manager</span>&gt;
     &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.pooling"></a>3.4.1.3.&nbsp;Prepared statement pooling</h4></div></div></div><p>
           Castor JDO uses <span class="italic">JDBC prepared statements</span> 
           to execute SQL statements against the specified RDBMS of your choice. 
           Per definition, Castor JDO does <span class="bold"><strong>not</strong></span>
           provide any prepared statement pooling. As such, Castor relies on prepared
           statement pooling being provided by different means.
        </p><p>
           One such way is to use 
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/dbcp/" target="_top">Jakarta's Commons DBCP</a> 
           as database connection pool, and to turn prepared statement pooling on by 
           configuring DBCP accordingly.
        </p><p>
           Please check with 
           <a href="#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Using Pooled Database Connections</a>
           for general information about hot to use DBCP with Castor.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.sample-files"></a>3.4.1.4.&nbsp;Sample configurations for various databases</h4></div></div></div><p>
           Besides the examples listed above, more configuraton examples can be found in the
           configuration files for the Castor JDO tests, which can be found in 
           <span class="package">src/tests/jdo</span> once you have downloaded and expanded the Castor 
           source package. For each database (vendor) supported, you are going to find a 
           database-specific JDO configuration file in this directory, e.g. 
           <code class="filename">src/tests/jdo/mysql.xml</code> for 
           <span class="productname">mySQL</span>&#8482; or 
           <code class="filename">src/tests/jdo/oracle.xml</code>
           for <span class="productname">Oracle</span>&#8482;.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.sybase-jconnect"></a>3.4.1.4.1.&nbsp;Sybase JConnect (JDBC data source)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for Sybase using jConnect --</span>&gt;
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.sybase.jdbc2.jdbc.SybDataSource"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password value="</span><span class="hl-attribute">secret"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4100"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
  &lt;<span class="hl-tag">/data-source</span>&gt;
  ...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.postgresql"></a>3.4.1.4.2.&nbsp;PostgreSQL (JDBC data source)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for PostgreSQL --</span>&gt;
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5432"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
   &lt;<span class="hl-tag">/data-source</span>&gt;
   ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.oracle"></a>3.4.1.4.3.&nbsp;Oracle (JDBC Driver)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC driver definition for Oracle --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@host:post:SID"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.mysql"></a>3.4.1.4.4.&nbsp;mySQL (JDBC Driver)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for mySQL --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:mysql:/localhost:2206/test"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.instantdb"></a>3.4.1.4.5.&nbsp;InstantDB</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for InstantDB --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.enhydra.instantdb.jdbc.idbDriver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:idb:C:\\castor-1.0\\db\\test\\test.prp"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.jdoconffactory"></a>3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO</h3></div></div></div><p>
          Many applications need to connect to a database using varying
          user accounts or database instances. To accomplish this, the utility class 
          <code class="classname">org.exolab.castor.jdo.util.JDOConfFactory"&gt;JDOConfFactory</code>
          and a 
          <code class="methodname">JDOManager.loadConfiguration(org.exolab.castor.jdo.conf.JdoConf)</code>
          method has been added to Castor.
       </p><p>
          The following code snippet shows an example how to create a JDO configuration without 
          the use of a default XML-based database configuration file:
       </p><pre class="programlisting">
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DRIVER = <span class="hl-string">"oracle.jdbc.driver.OracleDriver"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CONNECT = <span class="hl-string">"jdbc:oracle:thin:localhost:1521:SID"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String USERNAME = <span class="hl-string">"scott"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String PASSWORD = <span class="hl-string">"tiger"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String MAPPING = <span class="hl-string">"mapping.xml"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DATABASE = <span class="hl-string">"mydb"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String ENGINE = <span class="hl-string">"oracle"</span>;
  
  <span class="hl-comment">// create driver configuration</span>
  org.castor.jdo.conf.Driver driverConf =
      JDOConfFactory.createDriver(DRIVER, CONNECT, USERNAME, PASSWORD);
      
  <span class="hl-comment">// create mapping configuration</span>
  org.castor.jdo.conf.Mapping mappingConf =
      JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString());

  <span class="hl-comment">// create database configuration</span>
  org.castor.jdo.conf.Database dbConf =
      JDOConfFactory.createDatabase(DATABASE, ENGINE, driverConf, mappingConf);
     
  <span class="hl-comment">// create and load jdo configuration</span>
  JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf));
  
  <span class="hl-comment">// Construct a new JDOManager for the database</span>
  jdoManager = JDOManager.createInstance(DATABASE);
  
  <span class="hl-comment">// Obtain a new database</span>
  Database db = jdoManager.getDatabase();
       </pre><p>
          As an alternative to using a org.exolab.castor.jdo.conf.Driver,
          you can also configure Castor to use a JDBC 2.0 DataSource:
       </p><pre class="programlisting">
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DS = <span class="hl-string">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CONNECT = <span class="hl-string">"jdbc:oracle:thin:localhost:1521:SID"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String USERNAME = <span class="hl-string">"scott"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String PASSWORD = <span class="hl-string">"tiger"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String MAPPING = <span class="hl-string">"mapping.xml"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DATABASE = <span class="hl-string">"mydb"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String ENGINE = <span class="hl-string">"oracle"</span>;
  
  <span class="hl-comment">// setup properties for datasource configuration</span>
  Properties props = <span class="hl-keyword">new</span> Properties();
  props.put(<span class="hl-string">"URL"</span>, CONNECT);
  props.put(<span class="hl-string">"user"</span>, USERNAME);
  props.put(<span class="hl-string">"password"</span>, PASSWORD);
            
  <span class="hl-comment">// create datasource configuration</span>
  org.castor.jdo.conf.DataSource dsConf =
      JDOConfFactory.createDataSource(DS, props);
              
  <span class="hl-comment">// create mapping configuration</span>
  org.castor.jdo.conf.Mapping mappingConf =
      JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString());
        
  <span class="hl-comment">// create database configuration</span>
  org.castor.jdo.conf.Database dbConf =
      JDOConfFactory.createDatabase(DATABASE, ENGINE, dsConf, mappingConf);
  
  <span class="hl-comment">// create and load jdo configuration</span>
  JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf));
  
  <span class="hl-comment">// Construct a new JDOManager for the database</span>
  jdoManager = JDOManager.createInstance(DATABASE);
  
  <span class="hl-comment">// Obtain a new database</span>
  Database db = jdoManager.getDatabase();
       </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.references"></a>3.4.3.&nbsp;References</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.references.dtd"></a>3.4.3.1.&nbsp;The JDO Configuration DTD</h4></div></div></div><p>
             For validation, the configuration file should include the following
             document type definition. For DTD validation use:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                            <span class="hl-attribute">"http://castor.org/jdo-conf.dtd"&gt;</span>

             </pre><p>
             For XML Schema validation use:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">Schema</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                             <span class="hl-attribute">"http://castor.org/jdo-conf.xsd"&gt;</span>

             </pre><p>
             The Castor namespace URI is <code class="uri">http://castor.org/</code>.
          </p><p>
             The Castor JDO database configuration DTD is:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">(</span> <span class="hl-attribute">database+,</span> <span class="hl-attribute">transaction-demarcation</span> <span class="hl-attribute">)&gt;</span>

  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">jdo-conf</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">"jdo-conf"&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">database</span> <span class="hl-attribute">(</span> <span class="hl-attribute">(</span> <span class="hl-attribute">driver</span> <span class="hl-attribute">|</span> <span class="hl-attribute">data-source</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jndi</span> <span class="hl-attribute">)?,</span> <span class="hl-attribute">mapping+</span> <span class="hl-attribute">)&gt;</span>
                       
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">database</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">ID</span>      <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">engine</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">"generic"&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">mapping</span>
            <span class="hl-attribute">href</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">driver</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">driver</span>
            <span class="hl-attribute">url</span>        <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">class-name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">data-source</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">data-source</span>
            <span class="hl-attribute">class-name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">jndi</span> <span class="hl-attribute">ANY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">jndi</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">transaction-demarcation</span> <span class="hl-attribute">(</span> <span class="hl-attribute">transaction-manager?</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">transaction-demarcation</span>
            <span class="hl-attribute">mode</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">transaction-manager</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">transaction-manager</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>
            
  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">param</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">param</span>
            <span class="hl-attribute">name</span>  <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">value</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>


             </pre><p>
          </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.types"></a>3.5.&nbsp;Type Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.types"></a>3.5.1.&nbsp;Types</h3></div></div></div><p>
        The Castor type mechanism assures proper conversion between Java types
        and external types.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-xml"></a>3.5.1.1.&nbsp;Castor XML</h4></div></div></div><p>
          Castor XML converts all Java fields into XML element and attribute
          values.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-jdo"></a>3.5.1.2.&nbsp;Castor JDO</h4></div></div></div><p>
          Castor JDO converts Java fields into SQL columns which are persisted
          through the JDBC driver. Due to implementation details, the field
          type expected by the JDBC driver is not always the field type defined
          for the mapped object.
        </p><p>
          The most common occurrences of mistyping is when using fields of type
          <span class="type">FLOAT</span>, <span class="type">DOUBLE</span>, <span class="type">NUMERIC</span>, 
          and <span class="type">DECIMAL</span>. SQL type <span class="type">FLOAT</span> actually 
          maps to Java type <span class="type">java.lang.Double</span>. SQL types 
          <span class="type">NUMERIC</span> and <span class="type">DECIMAL</span> map to Java 
          type <span class="type">java.math.BigDecimal</span>.
        </p><p>
          When such an inconsistency occurs, Castor JDO will throw an
          <code class="literal">IllegalArgumentException</code> during object persistence with a
          message indicating the two conflicting types.
        </p><p>
          In order to avoid runtime exceptions, we recommend explicitly
          specifying types in the mapping file using the SQL typing convention.
          See <a href="#jdo.types.type-conversion" title="3.5.4.&nbsp;SQL Type Conversion">SQL Type Conversion</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-dax"></a>3.5.1.3.&nbsp;Castor DAX</h4></div></div></div><p>
          Castor DAX converts all Java fields into LDAP attribute values. LDAP
          attribute values are always textual and are represented as the string
          value of the field, e.g. "5" or "true".
        </p><p>
          LDAP attributes may also contain binary values. When storing byte
          arrays or serialized Java objects, DAX will store them as byte arrays.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.field-mapping"></a>3.5.2.&nbsp;The Field Mapping</h3></div></div></div><p>
        The field element includes an optional attribute called 
        <code class="literal">type</code> which can be used to specify 
        the Java type of the field. This attribute is optional since Castor 
        can always derive the exact Java type from the class definition.
      </p><p>
        We highly recommend that developers use the type field in their mapping
        file as a means to provide static type checking. When loading a mapping
        file, Castor will compare the actual Java type with the type specified
        in the mapping and will complain about inconsistencies.
      </p><p>
        The field type can be specified either given the full class name 
        (e.g. <span class="type">java.lang.Integer</span>) or using a short name. 
        The following table lists all the acceptable short names and the Java 
        types they represent:
      </p><div class="table"><a name="d4e4431"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Acceptable short names</b></p><div class="table-contents"><table summary="Acceptable short names" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">short name</th><th align="left">Primitive type?</th><th align="left">Java Class</th></tr></thead><tbody><tr><td>big-decimal</td><td>N</td><td>java.math.BigDecimal</td></tr><tr><td>boolean</td><td>Y</td><td>java.lang.Boolean.TYPE</td></tr><tr><td>byte</td><td>Y</td><td>java.lang.Byte.TYPE</td></tr><tr><td>bytes</td><td>N</td><td>byte[]</td></tr><tr><td>char</td><td>Y</td><td>java.lang.Character.TYPE</td></tr><tr><td>chars</td><td>N</td><td>char[]</td></tr><tr><td>clob</td><td>N</td><td>java.sql.Clob</td></tr><tr><td>date</td><td>N</td><td>java.util.Date</td></tr><tr><td>double</td><td>Y</td><td>java.lang.Double.TYPE</td></tr><tr><td>float</td><td>Y</td><td>java.lang.Float.TYPE</td></tr><tr><td>integer</td><td>Y</td><td>java.lang.Integer.TYPE</td></tr><tr><td>locale</td><td>N</td><td>java.util.Locale</td></tr><tr><td>long</td><td>Y</td><td>java.lang.Long.TYPE</td></tr><tr><td>other</td><td>N</td><td>java.lang.Object</td></tr><tr><td>short</td><td>Y</td><td>java.lang.Short.TYPE</td></tr><tr><td>string</td><td>N</td><td>java.lang.String</td></tr><tr><td>strings</td><td>N</td><td>String[]</td></tr><tr><td>stream</td><td>N</td><td>java.io.InputStream</td></tr></tbody></table></div></div><br class="table-break"><p>
        In addition, support for the following Castor-internal field types
        has been added:
      </p><div class="table"><a name="d4e4513"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Castor-internal field types</b></p><div class="table-contents"><table summary="Castor-internal field types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">short name</th><th align="left">Primitive type?</th><th align="left">Java Class</th></tr></thead><tbody><tr><td>duration</td><td>N</td><td>org.exolab.castor.types.Duration</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.dates-timezones"></a>3.5.3.&nbsp;SQL Dates and Default Timezones</h3></div></div></div><p>
        Castor will use the JDBC 
        <code class="methodname">ResultSet.getDate(int, Calendar)</code> 
        and related methods which take a Calendar object to specify the timezone of
        the data retrieved from the database when the timezone information is not
        already specified in the data; this ensures that the "current"
        timezone is applied.
      </p><p>
        The default time zone can be configured in the castor.properties file;
        see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/conf-lib.html" target="_top">configuration section</a> for details
        on how to configure Castor with information about your default time zone.
      </p><p>
        To change the timezone to a different timezone than the default, please
        set a (different) value on the 
        <code class="literal">org.exolab.castor.jdo.defaultTimeZone</code> property:
      </p><pre class="programlisting">
# Default time zone to apply to dates/times fetched from database fields,
# if not already part of the data.  Specify same format as in
# java.util.TimeZone.getTimeZone, or an empty string to use the computer's
# local time zone.
org.exolab.castor.jdo.defaultTimeZone=
#org.exolab.castor.jdo.defaultTimeZone=GMT+8:00
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.type-conversion"></a>3.5.4.&nbsp;SQL Type Conversion</h3></div></div></div><p>
        Castor JDO uses the JDBC <code class="literal">getObject/setObject</code> methods 
        in order to retrieve and set fields. These methods do not perform 
        automatic type conversion, often resulting in unexpected behavior. 
        For example, when using a NUMERIC field with direct JDBC access, 
        application developers tend to call <code class="literal">getInteger()</code> 
        or <code class="literal">getFloat()</code>, but the Java object returned from 
        a call to <code class="literal">getObject</code> is often a 
        <code class="literal">java.math.BigDecimal</code>.
      </p><p>
        Castor JDO implements automatic type conversion between Java and SQL.
        For this mechanism to work, the mapping file must specify the SQL type
        being used for Castor to employ the proper convertor. If no SQL type
        is specified, no conversion will occur, possibly resulting in an
        <code class="literal">IllegalArgumentException</code> being thrown.
      </p><p>
        SQL types are specified with the 
        <span class="italic">sql-type</span> attribute using either
        the default Java type returned by the JDBC driver 
        (e.g. <code class="literal">java.lang.Integer</code> or the proper SQL type name 
        (without precision). The following table lists the supported SQL type 
        names and the corresponding Java types:
      </p><div class="table"><a name="d4e4548"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Supported SQL type names</b></p><div class="table-contents"><table summary="Supported SQL type names" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">SQL Type</th><th align="left">Java Type</th></tr></thead><tbody><tr><td>bigint</td><td>java.lang.Long</td></tr><tr><td>binary</td><td>byte[]</td></tr><tr><td>bit</td><td>java.lang.Boolean</td></tr><tr><td>blob</td><td>java.io.InputStream</td></tr><tr><td>char</td><td>java.lang.String</td></tr><tr><td>clob</td><td>java.sql.Clob</td></tr><tr><td>decimal</td><td>java.math.BigDecimal</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>float</td><td>java.lang.Double</td></tr><tr><td>integer</td><td>java.lang.Integer</td></tr><tr><td>longvarbinary</td><td>byte[]</td></tr><tr><td>longvarchar</td><td>java.lang.String</td></tr><tr><td>numeric</td><td>java.math.BigDecimal</td></tr><tr><td>real</td><td>java.lang.Float</td></tr><tr><td>smallint</td><td>java.lang.Short</td></tr><tr><td>time</td><td>java.sql.Time</td></tr><tr><td>timestamp</td><td>java.sql.Timestamp</td></tr><tr><td>tinyint</td><td>java.lang.Byte</td></tr><tr><td>varbinary</td><td>byte[]</td></tr><tr><td>varchar</td><td>java.lang.String</td></tr><tr><td>other</td><td>java.lang.Object</td></tr><tr><td>javaobject</td><td>java.lang.Object</td></tr></tbody></table></div></div><br class="table-break"><p>
        The following example illustrates how to specify SQL type in field mapping:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prodId"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        Please note that java.util.Date is not automatically converted into a
        java.sql.Date object; while it is in theory possible to do so, there
        are three different possible storage formats for date information:
        as a java.sql.Date, java.sql.Time, and java.sql.Timestamp.  Rather than
        impose a possibly inappropriate data mapping on an entry, no automatic
        transformation will take place.
      </p><p>
        JDBC drivers which do not, themselves, perform a mapping between
        java.util.Date and the sql format specified on the database will throw
        an error when java.util.Date is passed to them on the prepared
        statement.  Moreover, auto-conversion of java.util.Date is outside of
        the JDBC specification; it is not a supported auto-convert format.
      </p><p>
        Users wishing to store date information into the database should ensure
        that they set date, time, or timestamp as the sql type on the
        <code class="literal">sql-type</code> attribute.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.type-convertors"></a>3.5.5.&nbsp;Parameterized Type Convertors</h3></div></div></div><p>
        Some of the type convertors may have a string parameter, which changes
        the conversion algorithm. The parameter is specified in square
        brackets after the SQL type, for example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"active"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"boolean"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"acc_active"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char[01]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
         where "0" is the character value for 
         <span class="bold"><strong>false</strong></span> and "1" is
         the character value for <span class="bold"><strong>true</strong></span>.
      </p><p>
        In the above example the first of a bunch of parameterized type convertors
        is used, "boolean --&gt; char" convertor.  The parameter must have length 2,
        the first character is the value for <span class="bold"><strong>false</strong></span>, 
        the second character is the value for <span class="bold"><strong>true</strong></span>. 
        The default value is "FT". The actual SQL type should be char(1).
      </p><p>
        The second and third convertors are "boolean --&gt; integer" and
        "boolean --&gt; numeric". Its parameter must be 
        <span class="bold"><strong>+</strong></span> for +1 or 
        <span class="bold"><strong>-</strong></span> for -1 representing true. 
        False is always converted to 0. For example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"flagWithMinusOneForTrue"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"boolean"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"flag"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer[-]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>If the parameter is not specified, true is converted to +1.</p><p>
        The fourth convertor is "date --&gt; char". Its parameter must be a correct
        pattern for SimpleDateFormat. For example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dateOfBirth"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pers_dob"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char[MMM d, yyyy]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        If the parameter is not specified, the conversion is performed
        using toString() method of the Date class.
      </p><p>
        The fifth and the sixth convertors are "date --&gt; integer" and
        "date --&gt; numeric".  Their parameters are also patterns having syntax
        based on the SimpleDateFormat syntax, but repeated characters are
        eliminated. The following table shows the substitution rules that are
        used to obtain the SimpleDateFormat pattern from the parameter.
      </p><div class="table"><a name="d4e4647"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Substitution rules</b></p><div class="table-contents"><table summary="Substitution rules" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Y,y</td><td>yyyy</td><td>year</td></tr><tr><td>M</td><td>MM</td><td>month in year</td></tr><tr><td>D,d</td><td>dd</td><td>day in month</td></tr><tr><td>h,H</td><td>HH</td><td>hour in day (0~23)</td></tr><tr><td>m</td><td>mm</td><td>minute in hour</td></tr><tr><td>s</td><td>ss</td><td>second in minute</td></tr><tr><td>S</td><td>SSS</td><td>millisecond</td></tr></tbody></table></div></div><br class="table-break"><p>
        For example, "YMD" parameter is expanded to "yyyyMMdd" SimpleDateFormat
        pattern, "YMDhmsS" parameter is expanded to "yyyyMMddHHmmssSSS"
        SimpleDateFormat pattern.  The length of the expanded parameter gives
        the minimal number of decimal digits that the actual SQL type must
        support. The default value of the parameter is "YMD".
      </p><p>
        The date and time types of 
        <span class="package">org.exolab.castor.types</span> package 
        support 2 timelines as defined by XML schema specification. One for timezoned 
        values and one for non-timezoned values which are treated to be local. 
        When converting such types to long the timezone information is lost. 
        In most cases it is no problem to loose for which timezone the value was 
        specified if the value get converted to UTC time before. But we also loose 
        if the value had a timezone or not. This causes that we do not know to which 
        timeline the value belongs. If we just treat it as non-timezoned value while 
        it has been a timezoned one we have changed the value.
      </p><p>
        Therefore we have added support for another parameterized type converter. This one
        allows you to specify if the date and time values created out of a persisted long
        value are meant to be timezoned or not. By default, without a parameter, local
        date or time instances are created without a timezone. If you specify the parameter
        <code class="code">utc</code> in mapping the date or time values are created based on UTC timezone.
        It need to be noted that such a mapping can only handle date and time values of one
        of the 2 timelines defined by XML schema specification. Having said that this only
        applies to the conversion of such values to long and does not cause issues when
        converting to string and back.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timeOfBirth"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.exolab.castor.types.Time"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pers_tob"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"bigint[utc]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.blob-clob"></a>3.5.6.&nbsp;BLOB and CLOB Types</h3></div></div></div><p>
        BLOB and CLOB stand for binary and character large objects (or in
        Sybase, IMAGE and TEXT types, respectively).  This means that most
        likely you don't want to load the whole objects into memory, but
        instead want to read and write them as streams. Usually these types are
        not comparable via the <code class="literal">WHERE</code> clause of a SQL statement. 
        That is why you should disable dirty checking for such fields, e.g.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        In this example CLOB field will be read as a String. This may cause
        OutOfMemoryError if the text is really large, but in many cases mapping
        CLOB to String is acceptable.  The advantage of mapping to String is
        that we obtain a Serializable value that can be passed via RMI.
        Similarly you can map BLOB and CLOB to <code class="literal">byte[]</code> and
        <code class="literal">char[]</code> types, respectively:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"photo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"bytes"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"photo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resume"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"chars"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resume"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        Now, assume that mapping to String is not acceptable. The natural Java
        type mapping for the BLOB type is <code class="literal">java.io.InputStream</code>, 
        and this mapping is supported by Castor:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"cdImage"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"stream"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"cd_image"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        The natural Java type mapping for the CLOB type is
        <code class="literal">java.io.Reader</code>, but this mapping is 
        <span class="bold"><strong>not</strong></span> supported by Castor because 
        <code class="literal">java.io.Reader</code> doesn't provide information
        about the length of the stream and this information is necessary
        for JDBC driver (at least for the Oracle driver) to write the value to
        the database. This is why the CLOB type is mapped to
        <code class="literal">java.sql.Clob</code>:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        When you read data from the database, you can use the
        <code class="literal">getCharacterStream()</code> method to obtain a
        <code class="literal">java.io.Reader</code> from <code class="literal">java.sql.Clob</code>. 
        When you write data to the database, you can either use the helper class
        <code class="literal">org.exolab.castor.jdo.engine.ClobImpl</code> to construct
        <code class="literal">java.sql.Clob</code> from <code class="literal">java.io.Reader</code> 
        and the length:
      </p><pre class="programlisting">
  object.setClob(<span class="hl-keyword">new</span> ClobImpl(<span class="hl-keyword">new</span> FileReader(file), file.length());</pre><p>
        or implement the <code class="literal">java.sql.Clob</code> interface yourself.
      </p><p>
        But be aware of the followng restriction: if you map BLOB to
        <code class="literal">java.io.InputStream</code> or CLOB to 
        <code class="literal">java.sql.Clob</code>, then you should turn caching 
        off for the Java class containing those values, e.g.:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">&lt;cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span>/&gt;
      ...
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
      &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
        Blob and Clob values cannot be cached, because they are alive only while
        the ResultSet that produced them is open. In particular, this means
        that you cannot use dirty checking for long transactions with such
        classes.
      </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.mapping"></a>3.6.&nbsp;Castor JDO Mapping</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Bruce</span> <span class="surname">Snyder</span> 
            ()
            </span>, <span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.news"></a>3.6.1.&nbsp;News</h3></div></div></div><p>
          <span class="bold"><strong>Release 1.0 M3</strong></span>:
          </p><div class="itemizedlist"><ul type="disc"><li><p>Added collection type 'iterator'.</p></li><li><p>Added collection type 'enumerate'.</p></li><li><p>Added additional syntax for specifying the identity of a class.</p></li></ul></div><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.introduction"></a>3.6.2.&nbsp;Introduction</h3></div></div></div><p>
         The Castor mapping file also provides a mechanism for binding a Java
         object model to a relational database model. This is usually referred to
         as object-to-relational mapping (O/R mapping). O/R mapping bridges the gap
         between an object model and a relational model.
      </p><p>
         The mapping file provides a description of the Java object model to
         Castor JDO. Via Castor XML, Castor JDO uses the information in the mapping
         file to map Java objects to relational database tables. The
         following is a high-level example of a mapping file:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">mapping</span>&gt;
      &lt;<span class="hl-tag">class</span> <span class="hl-attribute">...</span> &gt;
          &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">...</span> /&gt;
          &lt;<span class="hl-tag">field</span> <span class="hl-attribute">...</span> &gt;
              &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">...</span> /&gt;
          &lt;<span class="hl-tag">/field</span>&gt;
          ...
      &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
         Each Java object is represented by a &lt;class&gt; element composed of attributes,
         a &lt;map-to&gt; element and &lt;field&gt; elements. The &lt;map-to&gt; element
         contains a reference to the relational table to which the Java object maps.
         Each &lt;field&gt; element represents either a public class variable or the
         variable's accessor/mutator methods (depending upon the mapping info). Each
         &lt;field&gt; element is composed of attributes and one &lt;sql&gt; element.
         The &lt;sql&gt; element represents the field in the relational table to which
         the &lt;field&gt; element maps.
      </p><p>
         It is possible to use the mapping file and Castor's default behavior in
         conjunction. When Castor handles an object but is unable to locate
         information about it in the mapping file, it will rely upon its default
         behavior. Castor makes use of the Java programming language
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/reflect/package-summary.html" target="_top">
         Reflection API</a> to introspect the Java objects to determine the methods
         to use. This is the reason some attributes are not required in the mapping
         file.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.file"></a>3.6.3.&nbsp;The Mapping File</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.mapping-element"></a>3.6.3.1.&nbsp;The &lt;mapping&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">include*,</span> <span class="hl-attribute">class*,</span> <span class="hl-attribute">key-generator*</span> <span class="hl-attribute">)&gt;</span></pre><p>
           The &lt;mapping&gt; element is the root element of a mapping file. It contains:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an optional description</p></li><li><p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li><li><p>
                zero or more &lt;class&gt; descriptions: one for each class we intend to give
                mapping information
             </p></li><li><p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li></ul></div><p>A mapping file look like this:</p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Object</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                           <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>

  <span class="hl-attribute">&lt;mapping&gt;</span>
     <span class="hl-attribute">&lt;description&gt;Description</span> <span class="hl-attribute">of</span> <span class="hl-attribute">the</span> <span class="hl-attribute">mapping&lt;/description&gt;</span>
     <span class="hl-attribute">&lt;include</span> <span class="hl-attribute">href</span>=<span class="hl-value">"other_mapping_file.xml"</span>/&gt;

     &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"A"</span>&gt;
         ...
     &lt;<span class="hl-tag">/class</span>&gt;

     &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"B"</span>&gt;
        ...
     &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">/mapping</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.class-element"></a>3.6.3.2.&nbsp;The &lt;class&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">class</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">cache-type?,</span> <span class="hl-attribute">map-to?,</span> <span class="hl-attribute">field+</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">class</span>
            <span class="hl-attribute">name</span>            <span class="hl-attribute">ID</span>       <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">extends</span>         <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">depends</span>         <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">auto-complete</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|false</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">identity</span>        <span class="hl-attribute">CDATA</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">access</span>          <span class="hl-attribute">(</span> <span class="hl-attribute">read-only</span> <span class="hl-attribute">|</span> <span class="hl-attribute">shared</span> <span class="hl-attribute">|</span> <span class="hl-attribute">exclusive</span> <span class="hl-attribute">|</span> <span class="hl-attribute">db-locked</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"shared"</span>
            <span class="hl-attribute">key-generator</span>   <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span> &gt;</pre><p>
           The  &lt;class&gt; element contains all the information used to map a Java object
           to a relational database. The content of &lt;class&gt; is mainly used to describe
           the fields that will be mapped.
        </p><p>Description of the attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>
	             <span class="bold"><strong>name:</strong></span> The fully qualified package name of the 
	             Java object to map to.
             </p></li><li><p>
	             <span class="bold"><strong>extends:</strong></span> Should be used 
	             <span class="bold"><strong>only</strong></span> if this Java object extends another Java
	             object for which mapping information is provided. It should 
	             <span class="bold"><strong>not</strong></span> be used if the extended 
	             Java object is not referenced in the mapping file.
             </p></li><li><p>
	             <span class="bold"><strong>depends:</strong></span> For more information on this field, 
	             please see
	             <a href="#jdo.advanced-features.dependent-and-related" title="3.11.3.&nbsp;Dependent and related relationships">
	             Dependent and related relationships</a>.
             </p></li><li><p>
	             <span class="bold"><strong>identity:</strong></span> For more information on this field, 
	             please see 
	             <a href="#advanced-jdo.persist.spi.persistence" title="4.4.3.1.&nbsp;Persistence">Design -&gt; Persistence</a>.
             </p></li><li><p>
	             <span class="bold"><strong>access:</strong></span> For more information on this field, 
	             please see <a href="#advanced-jdo.locking.modes" title="4.3.2.&nbsp;Locking Modes">Locking Modes</a>.
             </p></li><li><p>
	             <span class="bold"><strong>key-generator</strong></span>: For more information on 
	             this field, please see <a href="#advanced-jdo.key-generator" title="4.5.&nbsp;Castor JDO Key Generator Support">KeyGen</a>.
             </p></li></ul></div><p>Description of the elements:</p><div class="itemizedlist"><ul type="disc"><li><p>
		             <span class="bold"><strong>&lt;description&gt;</strong></span>: 
		             An optional description.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;cache-type&gt;</strong></span>: 
		             For more information on this field please see
		             <a href="#advanced-jdo.long-transactions.bounded-dirty-checking" title="4.6.2.&nbsp;Bounded dirty checking">Bounded 
		             Dirty Checking</a> and 
		             <a href="#jdo.advanced-features.caching" title="3.11.2.&nbsp;Caching">Caching</a>.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;map-to&gt;</strong></span>: 
		             Used to tell Castor the name of the relational
		             table to which to map.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;field&gt;</strong></span>: Zero or more 
		             &lt;field&gt; elements are used to describe properties
		             of each Java object.
	             </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.map-to-element"></a>3.6.3.3.&nbsp;The &lt;map-to&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;!ELEMENT map-to EMPTY&gt;
  &lt;!ATTLIST map-to
            table      NMTOKEN  #IMPLIED
            xml        NMTOKEN  #IMPLIED
            ns-uri     NMTOKEN  #IMPLIED
            ns-prefix  NMTOKEN  #IMPLIED
            ldap-dn    NMTOKEN  #IMPLIED
            ldap-oc    NMTOKEN  #IMPLIED&gt;</pre><p>&lt;map-to&gt; is used to specify the name of the item that should be associated
          with the given Java object. The &lt;map-to&gt; element is only used for the root
          Java object.</p><p>Description of the attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>
	            <span class="bold"><strong>table:</strong></span> 
	            The name of the relational database table to which the
	            Java object is associated.
	         </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.field-element"></a>3.6.3.4.&nbsp;The &lt;field&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">field</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">sql?,</span> <span class="hl-attribute">xml?,</span> <span class="hl-attribute">ldap?</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">field</span>
            <span class="hl-attribute">name</span>           <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">type</span>           <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">required</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">direct</span>         <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">lazy</span>           <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">transient</span>      <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">identity</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">get-method</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">set-method</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">create-method</span>  <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">collection</span>     <span class="hl-attribute">(</span> <span class="hl-attribute">array</span> <span class="hl-attribute">|</span> <span class="hl-attribute">enumerate</span> <span class="hl-attribute">|</span> <span class="hl-attribute">collection</span> <span class="hl-attribute">|</span> <span class="hl-attribute">set</span> <span class="hl-attribute">|</span> 
                             <span class="hl-attribute">arraylist</span> <span class="hl-attribute">|</span> <span class="hl-attribute">vector</span> <span class="hl-attribute">|</span> <span class="hl-attribute">map</span> <span class="hl-attribute">|</span> <span class="hl-attribute">hashtable</span> <span class="hl-attribute">|</span> <span class="hl-attribute">sortedset</span> <span class="hl-attribute">|</span> <span class="hl-attribute">iterator</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">comparator</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED&gt;</span></pre><p>
           The &lt;field&gt; element is used to describe a property of a Java object. It provides:
        </p><div class="itemizedlist"><ul type="disc"><li><p>the identity ('name') of the property</p></li><li><p>the type of the property (inferred from 'type' and 'collection')</p></li><li><p>
                the access method of the property 
                (inferred from 'direct', 'get-method', 'set-method')
             </p></li></ul></div><p>
          From this information, Castor is able to access a given property in the Java
          object.
        </p><p>
          In order to determine the signature that Castor expects, there are two easy
          rules to apply.
        </p><p><span class="bold"><strong>1. Determine &lt;type&gt;.</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
	              <span class="bold"><strong>If there is no 'collection' attribute</strong></span>, 
	              the object type is the value of the 'type' attribute. 
	              The value of the type attribute can be a fully qualified Java object 
	              like 'java.lang.String' or one of the allowed aliases:
	           </p><table border="0" cellspacing="1" cellpadding="2"><tr xmlns:xi="http://www.w3.org/2001/XInclude">
	               <td rowspan="1" colspan="1">
	                  <table border="0" cellspacing="0" cellpadding="6"><tr>
	                        <th align="left" rowspan="1" colspan="1">short name</th>
	                        <th align="left" rowspan="1" colspan="1">Primitive type?</th>
	                        <th align="left" rowspan="1" colspan="1">Java Class</th>
	                     </tr><tr><td rowspan="1" colspan="1">big-decimal</td> <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.math.BigDecimal</td>    </tr><tr><td rowspan="1" colspan="1">big-integer</td> <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.math.BigInteger</td>    </tr><tr><td rowspan="1" colspan="1">boolean</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Boolean.TYPE</td>  </tr><tr><td rowspan="1" colspan="1">byte</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Byte.TYPE</td>     </tr><tr><td rowspan="1" colspan="1">bytes</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">byte[]</td>                  </tr><tr><td rowspan="1" colspan="1">char</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Character.TYPE</td></tr><tr><td rowspan="1" colspan="1">chars</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">char[]</td>                  </tr><tr><td rowspan="1" colspan="1">clob</td>        <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.sql.Clob</td>           </tr><tr><td rowspan="1" colspan="1">date</td>        <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.util.Date</td>          </tr><tr><td rowspan="1" colspan="1">double</td>      <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Double.TYPE</td>   </tr><tr><td rowspan="1" colspan="1">float</td>       <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Float.TYPE</td>    </tr><tr><td rowspan="1" colspan="1">int</td>         <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Integer.TYPE</td>  </tr><tr><td rowspan="1" colspan="1">integer</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Integer</td>       </tr><tr><td rowspan="1" colspan="1">locale</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.util.Locale</td>        </tr><tr><td rowspan="1" colspan="1">long</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Long.TYPE</td>     </tr><tr><td rowspan="1" colspan="1">other</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.lang.Object</td>        </tr><tr><td rowspan="1" colspan="1">serializable</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.io.Serializable</td>    </tr><tr><td rowspan="1" colspan="1">short</td>       <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Short.TYPE</td>    </tr><tr><td rowspan="1" colspan="1">sqldate</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.sql.Date</td>           </tr><tr><td rowspan="1" colspan="1">sqltime</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.sql.Date</td>           </tr><tr><td rowspan="1" colspan="1">string</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.lang.String</td>        </tr><tr><td rowspan="1" colspan="1">strings</td>     <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">String[]</td>                </tr><tr><td rowspan="1" colspan="1">stream</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.io.InputStream</td>     </tr><tr><td rowspan="1" colspan="1">timestamp</td>   <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.sql.Timestamp</td>      </tr></table>
	               </td>
	            </tr></table><p>
	            Castor will try to cast the data in the mapping file to the proper Java 
	            type.
	         </p></li><li><p>
	            <span class="bold"><strong>If there is a collection attribute</strong></span>, 
	            the items in the following table can be
	            used:
	         </p><table border="0" cellspacing="1" cellpadding="2"><tr xmlns:xi="http://www.w3.org/2001/XInclude">
	               <td rowspan="1" colspan="1">
	                  <table border="0" cellspacing="0" cellpadding="6"><tr>
	                        <th align="left" rowspan="1" colspan="1">name</th>
	                        <th align="left" rowspan="1" colspan="1">type</th>
	                        <th align="left" rowspan="1" colspan="1">default implementation</th>
	                        <th align="left" rowspan="1" colspan="1">added in release</th>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">array</td>
	                       <td rowspan="1" colspan="1">&lt;type_attribute&gt;[]</td>
	                       <td rowspan="1" colspan="1">&lt;type_attribute&gt;[]</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">enumerate</td>
	                       <td rowspan="1" colspan="1">java.util.Enumeration</td>
	                       <td rowspan="1" colspan="1">-</td>
	                       <td style="color:red;" rowspan="1" colspan="1">1.0 M3</td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">collection</td>
	                       <td rowspan="1" colspan="1">java.util.Collection</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList </td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">set</td>
	                       <td rowspan="1" colspan="1">java.util.Set</td>
	                       <td rowspan="1" colspan="1">java.util.HashSet</td>
	                       <td rowspan="1" colspan="1"></td>
	                       </tr><tr>
	                       <td rowspan="1" colspan="1">arraylist</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList </td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">vector</td>
	                       <td rowspan="1" colspan="1">java.util.Vector</td>
	                       <td rowspan="1" colspan="1">java.util.Vector</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">map</td>
	                       <td rowspan="1" colspan="1">java.util.Map</td>
	                       <td rowspan="1" colspan="1">java.util.HashMap</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">hashtable</td>
	                       <td rowspan="1" colspan="1">java.util.Hashtable</td>
	                       <td rowspan="1" colspan="1">java.util.Hashtable</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">sortedset</td>
	                       <td rowspan="1" colspan="1">java.util.SortedSet</td>
	                       <td rowspan="1" colspan="1">java.util.TreeSet</td>
	                       <td rowspan="1" colspan="1">1.0 M2</td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">iterator</td>
	                       <td rowspan="1" colspan="1">java.util.Iterator</td>
	                       <td rowspan="1" colspan="1"> n/a </td>
	                       <td style="color:red" rowspan="1" colspan="1">1.0 M3</td>
	                     </tr></table>
	               </td>
	            </tr></table><p>
	            The type of the object inside the collection is the 'type' attribute. The 'default
	            implementation' is the type used if the object holding the collection is found
	            to be null and needs to be instantiated.
	         </p><p>
	            For hashtable and map, Castor will add an object using the put(object, object) 
	            method - the object is both the key and the value. This will be improved in the future.
	         </p></li></ul></div><p>
           It is necessary to use a collection when the content model of the element expects more 
           than one element of the specified type. This is how the 'to-many' portion of a relationship 
           is described.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              It is not possible to use a collection of type 'iterator' or 'enumerate' 
              with lazy loading enabled.
           </p></td></tr></table></div><p>
           <span class="bold"><strong>2. Determine the signature of the method</strong></span>
        </p><div class="itemizedlist"><ul type="disc"><li><p>
	              <span class="bold"><strong>If 'direct' is set to true</strong></span>, 
	              Castor expects to find a public Java object variable with the 
	              given signature:
	           </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; &lt;name&gt;;</pre></li><li><p>
	               <span class="bold"><strong>If 'direct' is set to false or omitted</strong></span>, 
	               Castor will access the property though accessor methods. 
	               Castor determines the signature of the accessors and mutators as follows: 
	               If the 'get-method' or 'set-method' attributes are supplied, it will
		           try to find a function with the following signature:
	           </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; &lt;get-method&gt;();</pre><p>or</p><pre class="programlisting">  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> &lt;set-method&gt;(&lt;type&gt; value);</pre><p>
	           If 'get-method' or 'set-method' attributes are not provided, Castor will try to
	           find the following functions:
	        </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; is&lt;capitalized-name&gt;();</pre><p>or</p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; get&lt;capitalized-name&gt;();</pre><p>
			   the former for boolean types, the latter for all other types (or if the 
	           'is&lt;capitalized-name&gt;()' method is not defined for a boolean type), and 
	           a standard set method of
	        </p><pre class="programlisting">  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> set&lt;capitalized-name&gt;(&lt;type&gt; value);</pre><p>
		       If there are more than one set&lt;capitalized-name&gt; method it first tries to find the one
	           that exactly matches &lt;type&gt;. If no such method is available and &lt;type&gt; is a java
	           primitive type it tries to find a method with the corresponing java object type.
	        </p><p>
	           &lt;capitalized-name&gt; means that Castor uses the &lt;name&gt; attribute by changing its first
	           letter to uppercase without modifying the other letters.
	        </p><p>
	           The content of the &lt;field&gt; element will contain the information about how to map 
	           this field to the relational table.
	        </p></li></ul></div><p>Description of the attributes: </p><div class="itemizedlist"><ul type="disc"><li><p>
	             <span class="bold"><strong>name:</strong></span> If 'direct' access is used, 
	             'name' should be the name of a public variable in the object we are 
	             mapping (the field must be public, not static and not transient). 
	             If no direct access and no 'get-/set-method' is specified, 
	             this name will be used to infer the name of the accessor and 
	             mutator methods.
             </p></li><li><p>
                 <span class="bold"><strong>type:</strong></span> The Java type of the field. 
                 This is used to access the field. Castor will use this information 
                 to cast the data type(e.g. string into integer). It is also used 
                 to define the signature of the accessor and mutator methods. 
                 If a collection is specified, this is used to specify the type of 
                 the object inside the collection. See description above for more 
	             details.
             </p></li><li><p>
                <span class="bold"><strong>required:</strong></span> If true, the field is not optional.
             </p></li><li><p>
                 <span class="bold"><strong>transient:</strong></span> If true, the field will 
                 be ignored during persistence (and XML un-/marshalling). 
                 If you want this field to be ignored during any persistence-related 
                 operations only, please use the 'transient' attribute at the &lt;sql&gt; 
                 level.
             </p></li><li><p>
              <span class="bold"><strong>identity:</strong></span> If true, the field is part of 
              the class identity. Please use this as an alternative way of specifying 
              the identity of an object.
            </p></li><li><p>
                <span class="bold"><strong>direct:</strong></span> If true, Castor expects a public 
                variable in the object and will modify it directly.
             </p></li><li><p>
                <span class="bold"><strong>collection:</strong></span> If a parent object expects
                more than one occurrence of one of its fields, it is necessary to specify 
                which collection type Castor will use to handle them. The type specified 
                is used to define the type of the content inside the collection.
             </p></li><li><p>
                <span class="bold"><strong>comparator:</strong></span> If the collection type equals 
                'sortedset', it is possible to specify a 
                <code class="classname">java.util.Comparator</code> instance that will be used with 
                the <code class="classname">java.util.SortedSet</code> (implementation) to specify 
                a custom sort order. Please use this attribute to specify the class name 
                of the Comparator instance to be used. Alternatively, it is possible to not 
                specify a Comparator instance and have the Java objects stored in the 
                SortedSet implement <code class="classname">java.util.Comparable</code> 
                to specify the sort order.
            </p></li><li><p>
                 <span class="bold"><strong>get-method:</strong></span> An optional name of the 
                 accessor method Castor should use. If this attribute is not set, 
                 Castor will try to guess the name with the algorithm described above.
             </p></li><li><p>
	             <span class="bold"><strong>set-method:</strong></span> An optional name of the 
	             mutator method Castor should use. If this attribute is not set, 
	             Castor will try to guess the name with the algorithm described above.
             </p></li><li><p>
                <span class="bold"><strong>create-method:</strong></span> Factory method 
                for instantiation of the object.
             </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.sql-element"></a>3.6.3.5.&nbsp;The &lt;sql&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">sql</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">sql</span>
            <span class="hl-attribute">name</span>        <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">type</span>        <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">many-key</span>    <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">many-table</span>  <span class="hl-attribute">NMTOKEN</span>   <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">transient</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>    <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">read-only</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>    <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">dirty</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">check</span> <span class="hl-attribute">|</span> <span class="hl-attribute">ignore</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"check"&gt;</span>
            <span class="hl-attribute">cascading</span>	<span class="hl-attribute">(</span> <span class="hl-attribute">create</span> <span class="hl-attribute">|</span> <span class="hl-attribute">delete</span> <span class="hl-attribute">|</span> <span class="hl-attribute">update</span> <span class="hl-attribute">|</span> <span class="hl-attribute">all</span> <span class="hl-attribute">|</span> <span class="hl-attribute">none</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"none"</span></pre><p>
           The &lt;sql&gt; element is used to denote information about the database 
           column to which a Java object is mapped. It should be declared for all 
           &lt;field&gt; elements. Each &lt;field&gt; element contains one &lt;sql&gt; 
           element. The &lt;sql&gt; element correlates directly to the &lt;map-to&gt; 
           element for the containing &lt;class&gt; element. The &lt;sql&gt; elements 
           contains the following attributes:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                 <span class="bold"><strong>name:</strong></span> The name of the column in the 
                 database table.
              </p></li><li><p>
	              <span class="bold"><strong>type:</strong></span> The JDBC type of the column. 
	              It is inferred from the object when the type of this field is a 
	              persistent Java class that is defined elsewhere in the mapping. 
	              The complete list of automatic type conversions, and which values 
	              require manual mapping (e.g, java.util.Date) is listed in the
	              <a href="#jdo.types.type-conversion" title="3.5.4.&nbsp;SQL Type Conversion">SQL Type Conversion 
	              section of the Type Support</a> document.
	          </p></li><li><p>
	              <span class="bold"><strong>read-only:</strong></span> If true, the column in 
	              the relational database table will only be read, not updated or deleted.
	          </p></li><li><p>
	              <span class="bold"><strong>transient (as of 0.9.9):</strong></span> If true, the 
	              field will be ignored during persistence only. If you want this field 
	              to be ignored during XML un-/marshalling as well, please use the 
	              'transient' attribute at the &lt;field&gt; level.
	          </p></li><li><p>
	              <span class="bold"><strong>dirty:</strong></span> If the value is 'ignore', the 
	              field will not be checked against the database for modification.
	          </p></li><li><p>
	               <span class="bold"><strong>cascading:</strong></span> If the field is a relation, 
	               this attribute specifies which operations to cascade. Possible values 
	               are: 'all', none', 'create', 'update' or 'delete'; when not specifying
	               'none' or 'all', it is possibel to specify more than one value, using 
	               whitespace as a delimiter (e.g. 'create update'). For further 
	               information see 
                   <a href="#jdo.howto.use-cascading-operations" title="3.9.6.1.&nbsp;How to use cascading operations">HOW-TO</a> 
	               on using cascading operation.
              </p></li></ul></div><p>
           There are two more attributes used <span class="bold"><strong>only</strong></span> 
           with 'to-many' relations.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
		            <span class="bold"><strong>many-key:</strong></span> Specifies the name 
		            of the column that holds the foreign key to this object. 
		            That column is in the database table that stores objects 
		            of the Java type of this field.
	            </p></li><li><p>
		            <span class="bold"><strong>many-table:</strong></span> Specifies the 
		            name of the bridge table that contains the primary keys of 
		            the object on each side of the relationship. This is 
		            <span class="emphasis"><em>only</em></span> used for many-to-many relationships.
	            </p></li></ul></div></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.faq"></a>3.7.&nbsp;Castor JDO FAQ</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.other-specifications"></a>3.7.1.&nbsp;Castor's relation to other specifications</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.other-specifications.sun-jsr-000012"></a>3.7.1.1.&nbsp;Does Castor JDO comply with the SUN JSR-000012 specification?</h4></div></div></div><p>
	            No, Castor JDO doesn't comply with the SUN's JDO specification.
            </p><p>
	            Although Castor JDO carries very similar goals as SUN's JDO, it has 
	            been developed independently from the JSR.
            </p><p>
	            Although it is not impossible to shape (perhaps "hammer" is a more 
	            descriptive verb) Castor JDO into the SUN's JDO specification, there 
	            are several major technical differences which make it unfavorable to 
	            do so. Castor is RDBMS centric. Each persistence object loaded by 
	            Castor is locked. Locks in Castor are observable, meaning that locks 
	            may not be granted because of timeout or deadlock. On the other 
	            hand, the SUN's JDO hides details about locks.
            </p><p>
	            Internally, Castor JDO maintains a single copy of lock (and cache) 
	            for each active persistence object for all transaction. SUN's JDO 
	            specification implicitly requires a copy of cache per object per 
	            transaction. SUN's JDO also implicitly requires a bytecode modifier 
	            which Castor doesn't require.
            </p><p>
	            Castor also provides other features, such as key generators, long 
	            transaction support and OQL query which cannot be found in SUN's JSR.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.other-specifications.ejb-cmp"></a>3.7.1.2.&nbsp;Is Castor JDO better than EJB CMP?</h4></div></div></div><p>
	            The relation between JDO and EJB Container-Managed
	            Persistence is more complicated than simply saying, "one
	            is better than the other".
            </p><p>
	            An Entity Bean may manage persistence itself - the EJB
	            specification calls this Bean Managed Persistence
	            (BMP). Alternatively, the Entity Bean may rely on an EJB
	            container to manage all peersistence automatically - the
	            EJB specification calls this Container Managed Persistence
	            (CMP). When implementing BMP, an Entity Bean may use
	            Castor JDO as its persistence mechanism, or it may use
	            others methods, such as dealing with JDBC directly.
	            During CMP, an EJB Container vendor may implement their
	            CMP on top of Castor JDO.  In such an implementation,
	            Castor JDO will be used to persist the Entity Bean.
            </p><p>
	            If a developer would like to take advantage of an EJB's
	            life-cycle management, security, the "write once deploy
	            anywhere" promise and other distributed business
	            application facilities, then EJB will be the right
	            choice. Otherwise, the fact that Castor is simple, is Open
	            Source (you can always include Castor in your application
	            or product), has much less overhead, provides more design
	            freedom, and is integrated with Castor XML may be enough
	            of a reason to choose Castor JDO.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.xml"></a>3.7.2.&nbsp;XML related questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.xml.marsgalling-transactional"></a>3.7.2.1.&nbsp;Is it possible to make XML marshalling transactionally using Castor?</h4></div></div></div><p>
	            No. The decision of putting XML and JDO together is NOT intended to 
	            make XML marshalling transactional. Instead, the integration is done 
	            to help developers of a typical client-server situation whereby an 
	            application server receives incoming XML messages, process the 
	            messages and replies to the client.
            </p><p>
	            With Castor, incoming XML messages can be unmarshaled into data 
	            objects. Required information can be obtained from a database using 
	            JDO in form of data objects. With this approach, all data 
	            manipulation can be done in an object-oriented way. Changes to JDO 
	            data objects can be committed transactionally, and result data 
	            objects can be marshaled into XML and returned to the client. 
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.xml.xml-file-queries"></a>3.7.2.2.&nbsp;Is it possible to do queries on a XML file using Castor?</h4></div></div></div><p>
	            No, Castor does not provide an OQL query facility on a XML file. If 
	            querying is important for you, you should consider using a DBMS to store 
	            your data instead of using XML files, especially if querying performance 
	            is a concern.
            </p><p>
	            Another alternative is parse an XML Document directly and use XPath to
	            retrieve Nodes and/or NodeSets from an XML Document.  Other open source
	            tools which provide this functionality are:
	            </p><div class="itemizedlist"><ul type="disc"><li><p>
	                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://sourceforge.net/projects/saxpath/" target="_top">SAXPath</a>
	                </p></li><li><p>
	                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/jxpath/index.html" target="_top">Jakarta Commons JXPath</a>
	                </p></li></ul></div><p>
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.technical"></a>3.7.3.&nbsp;Technical questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.examples"></a>3.7.3.1.&nbsp;Where can I find some examples to start with?</h4></div></div></div><p>
	            Download the full SVN snapshot and look into the src/tests/jdo 
	            directory.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.sub-jdbc-odbc"></a>3.7.3.2.&nbsp;I have encountered problems using Sun JDBC-ODBC bridge with Castor...</h4></div></div></div><p>
	            It cannot be used with Castor, because it doesn't allow more than one
	            open <code class="literal">ResultSet</code> at the same time. 
	            Either use JDBC driver of type &gt; 1, or use some other JDBC-ODBC 
	            bridge without such a restriction
	            (for example, from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.easysoft.com" target="_top">Easysoft</a>).
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.collection-get-method"></a>3.7.3.3.&nbsp;
              My get-method for the Collection of dependent objects returns null. 
              Why?
            </h4></div></div></div><p>You should initialize the Collection yourself:
            </p><pre class="programlisting">
<span class="hl-keyword">private</span> Collection _children = <span class="hl-keyword">new</span> ArrayList();

<span class="hl-keyword">public</span> Collection getChildren() {
    <span class="hl-keyword">return</span> _children;
}
            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.implement-interfaces"></a>3.7.3.4.&nbsp;Should my JDO classes implement some special interface?</h4></div></div></div><p>
	            In general, no. If you need some behavior that is not directly 
	            supported by Castor, you can implement interface 
	            <span class="interface">org.exolab.castor.jdo.Persistent</span>. 
	            In order to use dirty checking for long transaction you should 
	            implement interface 
	            <span class="interface">org.exolab.castor.jdo.TimeStampable</span>. 
	            If you need an example of use of these interfaces, see Persistent.java 
	            and TestPersistent.java among Castor JDO tests.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.create-or-remove"></a>3.7.3.5.&nbsp;Can Castor automatically create/remove related objects?</h4></div></div></div><p>
	            First of all, let's agree upon terminology. We distinguish dependent 
	            and independent objects:
	
	            </p><div class="itemizedlist"><ul type="disc"><li><p>
	                     <span class="bold"><strong>dependent</strong></span> objects are bounded 
	                     to the parent object's lifecycle
	                   </p></li><li><p>
	                     <span class="bold"><strong>independent</strong></span> objects have 
	                     independent lifecycle
	                   </p></li></ul></div><p>
	
	            Thus, dependent objects are created/removed automatically, when 
	            their parent object is created/removed, while all operations on 
	            independent objects should be performed explicitly.
            </p><p>
	            However, with Castor 0.8.x you cannot describe explicitly the kind 
	            of object. Instead, the following rule applies: if you have 
	            one-to-many relation, and each side of the relation refers to 
	            another (Collection attribute on "one" side, simple attribute on 
	            "many" side), then "many" side is a dependent object. All other 
	            objects are independent. In particular, related objects via 
	            one-to-one relation are not created/removed automatically.
            </p><p>
	            With Castor 0.9 dependent objects should be described via "depends" 
	            attribute of "class" element in mapping configuration file.
            </p><p>
	            If you wish some independent object was created and/or removed 
	            automatically on operations on other independent object, you may 
	            use interface <span class="interface">Persistent</span> to code the desired 
	            behavior.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.connection-pooling"></a>3.7.3.6.&nbsp;
	            Is Castor JDO using any connection pooling mechanism to improve 
	            the overall performance?
            </h4></div></div></div><p>
	            No, Castor JDO doesn't have any built-in JDBC resource pooling. 
	            However the framework can transparently use any resource pooling 
	            facilities provided through DataSource implementation or 
	            -even better- through JDNI. In fact we even recommend people to use 
	            some Connection and PreparedStatement pool with Castor as this can
	            increase Castor's performance 3-5 fold.
            </p><p>
	            For example the following set of statements:
	            </p><pre class="programlisting">
db.begin();
db.execute(...)
db.commit()
	            </pre><p>
	            will be executed in much less time with the resource pooling because it 
	            will avoid creating a new physical JDBC connection at every execution.
            </p><p>
	            With Oracle, instead of specifying the usual JDBC driver you can use a
	            DataSource that specifically provides some Connection caching/pooling.
            </p><p>
		        Thus if your jdo config file looks like :
		        </p><pre class="programlisting">
        &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span> &gt;
            &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                    <span class="hl-attribute">URL</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span> &gt;
                &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SYSTEM"</span>/&gt;
                &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"manager"</span>/&gt;
            &lt;<span class="hl-tag">/driver</span>&gt;
            ...
        &lt;<span class="hl-tag">/database</span>&gt;
		        </pre><p>
		        then it can be changed into (for example):
		        </p><pre class="programlisting">
        &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span> &gt;
            &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>&gt;
                &lt;<span class="hl-tag">params</span> <span class="hl-attribute">URL</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span>
                        <span class="hl-attribute">user</span>=<span class="hl-value">"scott"</span> 
                        <span class="hl-attribute">password</span>=<span class="hl-value">"tiger"</span>
                /&gt;
            &lt;<span class="hl-tag">/data-source</span>&gt;
            ...
        &lt;<span class="hl-tag">/database</span>&gt;
		        </pre><p>
	        </p><p>
	            When Castor is used inside a Container such as an EJB container 
	            (within BMP or Session Bean), then the Container usually provides 
	            the JDBC resource through the JNDI ENC, which implicitely includes 
	            pooling facilities.
	        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.classnotfoundexception"></a>3.7.3.7.&nbsp;
               I am getting ClassNotFoundException for my JDO class, 
               but it is in the class path. Why?
            </h4></div></div></div><p>
	            Probably castor.jar file is in jre/lib/ext directory. In this case 
	            you should call:
	            </p><pre class="programlisting">
      jdo.setClassLoader(getClass().getClassLoader());
	            </pre><p>
	           before jdo.getDatabase().
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.notpersistencecapable"></a>3.7.3.8.&nbsp;
              I am getting exception 
              'the class ... is not persistence capable...'. Why?
            </h4></div></div></div><p>
	            In this case as well as in many others you can get more information 
	            with the help of logging. Call:
            </p><pre class="programlisting">
  jdo.setLogWriter(Logger.getSystemLogger());
	        </pre><p>and seek in the output for warnings and errors.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.db-remove"></a>3.7.3.9.&nbsp;
	            I call db.remove() on the dependent object and commit, 
	            but this doesn't work...
            </h4></div></div></div><p>
	            You should not add/remove dependent objects directly. In order to 
	            add/remove the dependent object you should just add/remove it from the 
	            collection in the master object and call db.commit()
            </p><p>
	            Dependent objects cannot be created/removed explicitly. It's created 
	            automatically when it is added to a master object, and removed 
	            automatically when it de-linked/dereferenced from a master object.
            </p><p>
	            Otherwise, we will be encounter into problem where a dependent object 
	            created explicitly but removed implicitly (delinked from a master object), 
	            or vice versa. It can also lead to other problems that are harder to 
	            detect.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.string-date-boolean-literals"></a>3.7.3.10.&nbsp;
	            How should I represent string/date/boolean literals in OQL query?
            </h4></div></div></div><p>
	            It is recommended to replace literals with parameters and to set them 
	            via <code class="methodname">OQLQuery.bind()</code>, for example:
            </p><pre class="programlisting">
OQLQuery query = db.getOQLQuery(
        <span class="hl-string">"SELECT p FROM Person p "</span>
      + <span class="hl-string">"WHERE name LIKE $1 AND dob&gt;$2 AND married=$3"</span>);
query.bind(<span class="hl-string">"John %"</span>);
query.bind((<span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-string">"yyyy-MM-dd"</span>))
       .parse(<span class="hl-string">"1960-01-01"</span>));
query.bind(false);
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.abstractmethoderror"></a>3.7.3.11.&nbsp;
	            I get 'java.lang.AbstractMethodError: getBigDecimal' 
	            for numeric fields. Why?
             </h4></div></div></div><p>
	            Your JDBC driver is not JDBC 2.0 compliant, upgrade it or find another one.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.bi-directional"></a>3.7.3.12.&nbsp;Does Castor support both one-way and two-way relationships?</h4></div></div></div><a name="bi-directional"></a><p>
	            Typcially a relationship between two objects is either one-way 
	            (aka uni-directional) or two-way (aka bi-directional). 
	            Officially, Castor currently only supports bi-directional relationships. 
	            For example, if an <code class="classname">Order</code> object contains a 
	            reference to a <code class="classname">LineItem</code> object, the 
	            <code class="classname">LineItem</code> object must contain a reference to the 
	            Order object. However, this requirement is not enforced in all 
	            situations. 
            </p><p>
	            This is a very complex problem to solve. So until Castor is expanded 
	            the support uni-directional relationships, the best policy is to 
	            implement the bi-directionalality for all relationships. This will 
	            ensure proper functionality.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.self-relation"></a>3.7.3.13.&nbsp;
	            I have an object that holds a relation to itself. 
	            Does Castor support this?
            </h4></div></div></div><p>
	            This is a very common occurrence in an object model and is known as 
	            a self-referenential relationship. Unfortunately, Castor does not 
	            currently support self-referential relationships. An example of such 
	            a relationship occurs when a <code class="literal">Folder</code> object contains
	            a reference to another <code class="literal">Folder</code> object. 
	            Castor does not currently support this. However, there are ways 
	            around this limitation. 
            </p><p>
	            One way is to manage this type of relationship manually. For example, 
	            let's say that a parent object <code class="literal">FolderA</code> needs to hold 
	            references to child objects <code class="literal">FolderB</code>, 
	            <code class="literal">FolderC</code> and <code class="literal">FolderD</code>. 
	            The <code class="literal">Folder</code> object contains not only a property 
	            to hold its own id, but also a property to hold its parent id 
	            (we'll call this <code class="literal">parentId</code>). 
	            The <code class="literal">parentId</code> property is used to determine 
	            if there is a relationship to another <code class="literal">Folder</code> object. 
	            If <code class="literal">parentId</code> is null, there is no relationship. 
	            If <code class="literal">parentId</code> is populated, there is a relationship 
	            and the object tree can be walked by comparing the object id to the 
	            <code class="literal">parentId</code>. When the two properties are equal, 
	            you're at the top of the tree. 
            </p><p>
	            Another say to solve this problem is to make use of an intermediary 
	            object. For example, a <code class="literal">Folder</code> object contains a 
	            <code class="literal">Reference</code> object in lieu of the actual 
	            <code class="literal">Folder</code> object. The <code class="literal">Reference</code> 
	            object is somewhat of a proxy object whereby it only contains enough 
	            information to identify the object to which the 
	            <code class="literal">Reference</code> object refers. Then the 
	            <code class="literal">Folder</code> object can be easily instantiated via the 
	            information contained in the <code class="literal">Reference</code> object. 
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.objectmodifiedexception"></a>3.7.3.14.&nbsp;
	            Why do I get an ObjectModifiedException when trying to commit 
	            a transaction?
            </h4></div></div></div><p>
	            The dirty checking engine will throw an 
	            <code class="literal">ObjectModifiedException</code> when the values in the
	            cache and in the database are different. This can happen when 
	            someone else changed the database content, but also when type 
	            mapping is not reversible.
            </p><p>
	            For example, if a java timestamp (<code class="literal">java.util.Date</code>) 
	            is stored as a DATE, the time part is lost and the dirty checking 
	            will fail. Oracle cannot tell the difference between an empty String
	            and a null value: if an attribute value is an empty String, dirty 
	            checking will also fail. Some precision loss sometimes occur with 
	            floating point numbers.
            </p><p>
	            To avoid this, always use reversible mapping conversions. If this 
	            is not possible, mark the fields with <code class="literal">dirty="ignore"</code> 
	            in the mapping file.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.ora-01461"></a>3.7.3.15.&nbsp;I'm receiving a java.sql.SQLException: ORA-01461</h4></div></div></div><p>
	            When using Weblogic Portal 4.0 with Oracle I am receiving the following 
	            error:
	            </p><pre class="programlisting">
java.sql.SQLException: ORA-01461: can bind a LONG value only for insert into a LONG column
	            </pre><p>
	            According to Weblogic Release Notes, this error can remedied by setting 
	            a Weblogic environment variable. 
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.performance-caches"></a>3.7.4.&nbsp;Castor and performance caches</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.objectmodifiedexception"></a>3.7.4.1.&nbsp;
	            Sometimes long transaction fails: on update() it is thrown 
	            ObjectModifiedException. Why?
            </h4></div></div></div><p>
	            Most probably the object that is being updated has more than 100 related 
	            objects of one class and the cache size for this class is not enough. 
	            You should either increase the size of the cache or change the cache type 
	            to time-limited (the default cache type is count-limited, the default 
	            size is 100), for example:
		        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">...&gt;</span>
  <span class="hl-attribute">&lt;cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"1000"</span>/&gt;
  ...
&lt;<span class="hl-tag">/class</span>&gt;
		        </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.cache-type-none"></a>3.7.4.2.&nbsp;Can I use the cache-type='none' with long transactions?</h4></div></div></div><p>
	            As of release 0.9.5.3, you cannot. When using a cache of type 'none' 
	            with your 'Timestampable' objects, a MappingException is thrown when 
	            performing long transactions. Currently, Castor requires a (performance) 
	            cache of type other than 'none' to be used with classes  that implement 
	            the <span class="interface">TimeStampable</span> interface. In other words, 
	            if you want to use long transactions, please make sure that you use one 
	            of these cache types: 'unlimited', 'count-limited' or 'time-limited'. 
            </p><p>
	            The next entry has some more information about a potential cause of 
	            confusion in the context of long transactions and a cache type other 
	            than 'unlimited'.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.persistenceexception"></a>3.7.4.3.&nbsp;
	            What is causing a PersistenceException with long transactions and 
	            how do I fix it?
            </h4></div></div></div><p>
	            With long transactions, sometimes update() throws a PersistenceException. 
	            As of release 0.9.5.3, Castor requires a (performance) cache (of type 
	            other than 'none') to be used with classes that implement the 
	            <span class="interface">TimeStampable</span> interface. 
            </p><p>
	            Please note that if you are using a cache type other than 'unlimited', 
	            it is possible that objects expire from the cache. This case will be 
	            highlighted to you by a PersistenceException being thrown.
            </p><p>
	            In this cases, please consider switching to cache type 'unlimited' 
	            (if possible) or increase the size of the cache according to your 
	            needs when using 'count-limited' (which has a default capacity of 100). 
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.oql"></a>3.7.5.&nbsp;OQL</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.document"></a>3.7.5.1.&nbsp;Is there any document available for Castor OQL?</h4></div></div></div><p>
	            Yes. It is available from the Castor website: 
                <a href="#advanced-jdo.oql-to-sql-translator" title="4.2.&nbsp;OQL to SQL translator">Advanced JDO &#8212;&gt; OQL</a>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.phase"></a>3.7.5.2.&nbsp;
	            The OQL document describes several phases of development. 
	            Which is the current phase?
            </h4></div></div></div><p>We are currently working on Phase 3.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.sub-queries"></a>3.7.5.3.&nbsp;Does Castor OQL support sub-queries?</h4></div></div></div><p>Not yet</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.join"></a>3.7.5.4.&nbsp;
	            I cannot get Castor OQL to join two objects for me. Is it supported?
            </h4></div></div></div><p>
	            Yes or no. Castor OQL supports implicit joins. And, in most case, 
	            you simply don't need explicit join.
            </p><p>
	            Consider the following example, 
	            </p><pre class="programlisting">
SELECT o FROM Order o, LineItem i WHERE o.id = i.id AND i.price &gt; 100
	            </pre><p>
            </p><p>
	            It is simply equivalent to the following OQL
	            </p><pre class="programlisting">
SELECT o FROM Order o WHERE o.lineItem.price &gt; 100
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.pass-thru"></a>3.7.5.5.&nbsp;Can I write a pass-thru OQL?</h4></div></div></div><p>
	            Yes. Just put "CALL SQL" keywords in front of your SQL statement. For example,
	            </p><pre class="programlisting">
OQLQuery oql = castorDb.getOQLQuery(
    <span class="hl-string">"CALL SQL SELECT id, name, date "</span>
   +<span class="hl-string">"FROM user WHERE upper(name) like $1 AS myapp.Product"</span>);
	            </pre><p>
            </p><p>
	            <span class="bold"><strong>
	            But remember that the order of the fields listed must match what is 
	            defined in the mapping file.
	            </strong></span>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.struct"></a>3.7.5.6.&nbsp;Does Castor OQL support struct?</h4></div></div></div><p>
	            No, Castor OQL doesn't support struct. For example, the following 
	            query CANNOT be done:
	            </p><pre class="programlisting">
select c.name, c.age from Client c
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.like"></a>3.7.5.7.&nbsp;How do I structure a query using the 'LIKE' expression?</h4></div></div></div><p>
	            A query using the 'LIKE' expression includes the use of the SQL 
	            wildcard '%'. The wildcard must be included in the 
	            <code class="code">bind()</code> statement:
	            </p><pre class="programlisting">
        OQLQuery oql = castorDb.getOQLQuery(
                <span class="hl-string">"SELECT p FROM Product p WHERE p.name LIKE $1"</span> );
        oql.bind( <span class="hl-string">"%widget%"</span> );
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.in"></a>3.7.5.8.&nbsp;Does Castor support the SQL 'IN' expression?</h4></div></div></div><p>
	            Yes. However, the full expression is a bit different using the LIST 
	            keyword. The following example provides a demonstration:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.id IN LIST ( 123, 456, 789 )
	            </pre><p>
            </p><p>
	            If identifiers other than numbers are used, those identifiers must be 
	            quoted:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.name IN LIST ( "abc", "jkl", "xyz" )
	            </pre><p>
            </p><p>
	            To include NULL values in the 'IN' list, use the 'nil' keyword:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.name IN LIST( "ABC", nil )
	            </pre><p>
            </p><p>
	            It is even possible to include bind values in the 'IN' lists 
	            using the following syntax:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.id IN LIST( $(int)1, $2, $3 )
	            </pre><p>
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.feature-requests"></a>3.7.6.&nbsp;Features requests</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.feature-requests.foreign-key-multiple"></a>3.7.6.1.&nbsp;Can a foreign key be part of multiple primary keys?</h4></div></div></div><p>
	            Unfortunately, the answer is no. We're aware that many users need 
	            this feature so it is a very high priority in our todo list.
            </p><p>
	            If foreign key is the primary key, as a workaround you may consider 
	            using the 'extends' relationship.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.feature-requests.polymorphic-collection"></a>3.7.6.2.&nbsp;Is polymorphic collection supported?</h4></div></div></div><p>Unfortunately, the answer is no.</p><p>
	            In version 0.8.11, we tried to enable polymorphic collection by 
	            introducing the notation of Object Reloading. Object Reloading 
	            delegates the determination of the class to a data object. However, 
	            it is proved that reloading can only be done before any instance of 
	            the target object is returned to user, and we have no way to determine 
	            that. As a result, we removed the support in version 0.9.x.
            </p><p>
	            In the near future, we are going to use a new mechanism to provide 
	            extends. The new mechanism loads a table with an SQL statement that 
	            outer-joins all of the extending tables with the base. The existence 
	            of an extended table row can be used to determine the class of a data 
	            object. Notice that all extended table rows of the same entity should 
	            always be stored in the same data-store.
            </p><p>
	            In the further future, we also want to let users to define a 
	            discriminator column (or determinance field). Basing on the value of 
	            discriminator columns in the base table, the bridge layer fetches the 
	            additional information and returns the combined entity with the 
	            appropriate list of entity classes.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.data-model"></a>3.7.7.&nbsp;Data model issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.map-to-multiple-tables"></a>3.7.7.1.&nbsp;Is it possible to map an object to more than one tables?</h4></div></div></div><p>
	            Yes, if the two tables share the same identity, you can specify one 
	            data object to "extends" the other. When the extended data object is 
	            loaded, its table (specified in &lt;map-to/&gt; will be joined 
	            with all the tables of its super classes'.
            </p><p>
	            Another solution (in my opinion more flexible) is having two set 
	            of methods in the main object. One for Castor JDO and another for 
	            application.
            </p><p>
	            Consider the following example:
	            </p><pre class="programlisting">
<span class="hl-keyword">class</span> Employee {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _employeeNumber;
   <span class="hl-keyword">private</span> Address _address;
   <span class="hl-keyword">private</span> Collection _workGroup;

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getEmployeeNumber() {
        <span class="hl-keyword">return</span> _employeeNumber;
   }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setEmployeeNumber( <span class="hl-keyword">int</span> id ) {
        _employeeNumber = id;
   }

   <span class="hl-comment">// methods for Castor JDO</span>
   <span class="hl-keyword">public</span> Address getAddress() {
       <span class="hl-keyword">return</span> _address;
   }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress( Address address ) {
        _address = address;
   }
   <span class="hl-keyword">public</span> Collection getWorkGroup() {
        <span class="hl-keyword">return</span> _workGroup;
   }
   <span class="hl-keyword">public</span> Collection setWorkGroup( Collection workGroup ) {
        _workGroup = workGroup;
   }

   <span class="hl-comment">// methods for application</span>
   <span class="hl-keyword">public</span> String getAddressCity() {
       <span class="hl-keyword">return</span> _address.getCity();
   }
   <span class="hl-keyword">public</span> String getAddressZip() {
       <span class="hl-keyword">return</span> _address.getZip();
   }
   <span class="hl-comment">// ...</span>
}
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.remove-recreate"></a>3.7.7.2.&nbsp;
	            Can an object with the same identity be re-created after being removed 
	            in the same transaction?
            </h4></div></div></div><p>
	            Yes, as long as the deleted object is the same instance as the one 
	            being recreated.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.dependent-object"></a>3.7.7.3.&nbsp;What is a dependent object?</h4></div></div></div><p>
	            Dependent object is actually a concept from the object-oriented 
	            database world.  A dependent object's lifetime depends on its master 
	            object. So, create/delete/update of the master object will trigger 
	            the proper actions, newly linked dependent object will be 
	            automatically created and de-referenced dependent object will be 
	            removed.
            </p><p>
	            The concept was also used in the earlier CMP 2.0 draft, although 
	            it is later removed.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.dependent-many-to-many"></a>3.7.7.4.&nbsp;
	            Can a data object involved in many-to-many relationship be dependent?
	        </h4></div></div></div><p>No</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.design"></a>3.7.8.&nbsp;Castor JDO design</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.functionality"></a>3.7.8.1.&nbsp;How does Castor JDO work anyway?</h4></div></div></div><p>Let's use object loading as an example.</p><p>
	            When an application invoke db.load, the underneath 
	            <code class="literal">TransactionContext</code> is invoked. 
	            If the object with the requested identity exists in the 
	            <code class="literal">TransactionContext</code>, previously loaded object in the 
	            <code class="literal">TransactionContext</code> is returned. Otherwise, 
	            <code class="literal">TransactionContext</code> creates a new instance 
	            of the interested type and invokes LockEngine to "fill" the object.
            </p><p>
	            <code class="literal">LockEngine</code> acquires a lock of the object, 
	            and it makes sure <code class="literal">ClassMolder</code> has a thread-safe 
	            environment when it invokes <code class="literal">ClassMolder</code>. 
	            In <code class="literal">ClassMolder</code>, if the interested set of fields 
	            representing the object is not existed in the cache yet, 
	            <code class="literal">SQLEngine</code> will be invoked and the set of fields 
	            from the underneath data store will be returned. 
	            <code class="literal">ClassMolder</code> binds the loaded or cached fields into 
	            the new instance. <code class="literal">ClassMolder</code> requests the 
	            <code class="literal">TransactionContext</code> to load the related and the 
	            dependent objects. Eventually, the object is returned after all of 
	            the relationships are resolved.
            </p><p>
	            The process of commit has several states. The first state is 
	            preStore. In preStore state, objects existing in the 
	            <code class="literal">TransactionContext</code> are checked for modification 
	            one by one, including dependent and related objects. 
	            De-referenced dependent objects are marked as delete-able, 
	            and reachable dependent objects are added into 
	            <code class="literal">TransactionContext</code>. An object is marked 
	            "dirty" if it is modified. Also, if any modification should cause 
	            any related or dependent to be dirty, the related or dependent object 
	            is marked as dirty as well.
            </p><p>
	            After the preStore state, all dirty object is properly stored. And, 
	            all marked delete object will be removed. Then, the connection is 
	            committed. If succeed, all cache with be updated. Finally, all lock 
	            is released.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.two-phase-commits"></a>3.7.8.2.&nbsp;
	            Does Castor support two-phase commits? How is this implemented?
	        </h4></div></div></div><p>
	            Yes, via <span class="interface">javax.transaction.Synchronization</span> interface.
            </p><p>
	            For Castor to work with global transactions, Castor must be configured
	            to use global transaction demarcation in its main configuration file:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">jdo-conf</span>&gt;
   ...
   &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span> &gt;
      &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span> /&gt;
   &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
            </pre><p>When retrieving a Database instance via</p><pre class="programlisting">
...
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdo = JDOManager.createInstance(<span class="hl-string">"mydb"</span>);
...
Database db = jdo.getDatabase();
            </pre><p>
	            the <code class="literal">Database</code> implementation will authomatically 
	            be registered with the transaction manager, as it implements 
	            <span class="interface">javax.jta.Synchronization</span> interface. 
	            Subsequently, the transaction manager communicates with Castor 
	            via the beforeCompletion() and afterCompletion() calls.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.nested-transaction"></a>3.7.8.3.&nbsp;Does Castor support nested transaction?</h4></div></div></div><p>No</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.open-source-databases"></a>3.7.9.&nbsp;Working with open source databases</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.postgresql"></a>3.7.9.1.&nbsp;Does Castor support PosgreSQL?</h4></div></div></div><p>
	            Yes, starting from PostgreSQL 7.1, where outer joins support has 
	            been added.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.mysql"></a>3.7.9.2.&nbsp;Does Castor support MySQL?</h4></div></div></div><p>
	            Yes, starting from MySQL version 3.23, where transaction support has 
	            been added. Note: if you use Mark Matthews MySQL JDBC driver, then 
	            you need version 2.0.3 or higher.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.which"></a>3.7.9.3.&nbsp;Which Open Source database is supported better?</h4></div></div></div><p>
	            For now only with 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.postgresql.org" target="_top">PostgreSQL 7.1</a> 
	            and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.sapdb.org" target="_top">SAP DB</a> you get a full 
	            set of Castor features. Other Open Source databases don't support 
	            select with write lock, so db-locked locking mode doesn't work 
	            properly (it works in the same way as exclusive locking mode).
            </p><p>
	            All other Castor features are supported with 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mysql.com" target="_top">MySQL</a>, 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.interbase2000.org" target="_top">Interbase</a>, 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://instantdb.enhydra.org" target="_top">InstantDB</a> and 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hypersonicsql.com" target="_top">Hypersonic SQL</a>.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.rdbms-specific"></a>3.7.10.&nbsp;RDBMS-specific issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.rdbms-specific.mysql"></a>3.7.10.1.&nbsp;MySQL</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.datetime"></a>3.7.10.1.1.&nbsp;Use of DATETIME fields in general</h5></div></div></div><p>
    			   MySQL in it's current releases (4.0.x and 4.1.x) does not store fractions of a 
    			   second in fields of type DATETIME that are mapped to java.sql.TimeStamp fields.
    			   As a result, Castor will throw ObjectModifiedExceptions during commits as Castor 
    			   internally maintains fractions of a seconds. 
    			</p><p>
    			   Instead, Please use a column type that can be mapped to a long value, as Castor 
                   internally handles conversion between java.util.Date and long values with 
                   the required precision.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.timestamp-null"></a>3.7.10.1.2.&nbsp;Use of TIMESTAMP fields &amp; NULLs in long transactions</h5></div></div></div><p>
    			   In MySQL, fields of type 'Timestamp' exhibit special behaviour wih 
    			   regards to NULLs. When inserting a "NULL" into such a field, it 
    			   actually inserts the current date and time. This causes problems 
    			   for Castor's caching mechanism since Castor internally believes the 
    			   field is still NULL. If you subsequently perform an update on the 
    			   entry whilst it is still in the cache, an ObjectModifiedException 
    			   will be thrown, because Castor believes that the database record 
    			   has changed in the meantime.
    			</p><p>The workaround is to use a DATETIME field instead of TIMESTAMP.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.upgrade-issues"></a>3.7.10.1.3.&nbsp;MySQL 4.1.x and upgrade issues</h5></div></div></div><p>
 				   As with many other open source products, MySQL seems to be changing 
 				   slightly from version to version. There seems to be a problem with 
 				   concurrency in MySQL 4.1.5 that can be resolved by upgrading to 
 				   4.1.7 or higher.
				</p><p>
				   At Castor we frequently use Connector/J 3.0.16, 3.1.13 and nowadays 5.1.6 to
				   execute our test farmework. If you use one of this versions of Connector/J 
				   you should be on the safe side. If you are hit by any problems using one of 
				   these versions, please let us know.
				</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.rdbms-specific.oracle"></a>3.7.10.2.&nbsp;Oracle</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.oracle.clob-blob-lob-fields"></a>3.7.10.2.1.&nbsp;Oracle &amp; (C|B)LOB fields</h5></div></div></div><p>
    			   As of Oracle release 10g, the problem of Castor to handle BLOBs 
    			   with a size greater than 2kB and CLOBs with a size greater than 
    			   4 kB correctly has been resolved. With the 10 release of Oracle's 
    			   JDBC driver, both driver types (type 2 and type 4) can be used. 
    			   With earlier releases, only the OCI driver (type 2) seems to work.
    			</p><p>
    			   The 10g release of the Oracle JDBC Driver can be downloaded
    			   <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/index.html" target="_top">here</a>.
    			</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.logging"></a>3.7.11.&nbsp;Castor &amp; Logging</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.log4j"></a>3.7.11.1.&nbsp;
	            How can I integrate Castor's logging with a logging infrastructure 
	            using Log4J?
	        </h4></div></div></div><p>
	            Please see 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mail-archive.com/castor-dev@exolab.org/msg02710.html" target="_top">
	            this message</a> from the mailing list. It includes an adapter class 
	            that will provide this functionality. (Thanks John!)
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.sql-statement"></a>3.7.11.2.&nbsp;
			    Can I see what SQL statement Castor issues to the database as a result 
			    of an operation?
			</h4></div></div></div><p>
			   Yes, you can. By default, Castor uses JDBC proxy classes (wrapping
			   <code class="literal">java.sql.Connection</code> and 
			   <code class="literal">java.sql.PreparedStatement</code>) that capture the 
			   core SQL statements as generated by Castor and the user-supplied 
			   parameters at execution timeof the various persistence operations, 
			   and outputs them to the standard logger used by Castor. 
			   By default, these output statements are not visible, 
			   as the log level is set to level 'info'. To see these SQL statements, 
			   please increase the log level to level 'debug' in 
			   <code class="literal">log4j.xml</code>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.disable-jdbc-proxy-classes"></a>3.7.11.3.&nbsp;How can I disable the use of JDBC proxy classes?</h4></div></div></div><p>
			   As of <span class="bold"><strong>release 0.9.7</strong></span>, a new property
			   </p><pre class="programlisting">org.exolab.castor.persist.useProxies</pre><p>
			   has been added to <code class="literal">castor.properties</code> to allow 
			   configuration of the JDBC proxy classes mentioned above. 
			   If enabled, JDBC proxy classes will be used for logging SQL statements. 
			   When turned off, no logging statements will be generated at all.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.lazy-loading"></a>3.7.12.&nbsp;Lazy Loading related questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-1"></a>3.7.12.1.&nbsp;
	           How do I configure the JDO mapping to use the lazy loading feature 
	           for 1:1 relations?
           </h4></div></div></div><p>
              Let us convert one of the classes from the 
              
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top">JDO examples</a> to use 
              lazy-loading.
           </p><p>
              In the example model, every Product belongs to one ProductGroup. 
              This is reflected in the conventional mapping as below. 
              Here's the mapping for Product:
           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product  --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">description</span>&gt;Product definition&lt;<span class="hl-tag">/description</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"product"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
 
   &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;

    &lt;<span class="hl-comment">!--  Product has reference to ProductGroup,
          many products may reference same group  --</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
      &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    
&lt;<span class="hl-tag">/class</span>&gt;
</pre><p>
              Let us now make the relationship between Product and ProductGroup use 
              lazy loading. The relevant field in Product can be re-written like so:
           </p><pre class="programlisting">
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
      &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
           </pre><p>
              There have been one change only. We have placed the attribute lazy="true" in 
              the field element. Note that no change is required in the ProductDetail 
              mapping.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-1-serialization"></a>3.7.12.2.&nbsp;Lazy loading for 1:1 relations and serialization</h4></div></div></div><p>
       	      Please note that Castor does not support full serialization of lazy-loaded 
       	      objects at this time. Rather than serializing just the information 
       	      required to re-build the underlying proxy implementation during 
       	      deserialization, Castor will materialize (read: load from the persistence 
       	      store) all objects before serialization. As this can lead to a lot of 
       	      database accesses, please use this feature carefully. A full working 
       	      solution will be provided with the next release.
       	   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-m-m-to-n"></a>3.7.12.3.&nbsp;
	           How do I configure the JDO mapping to use the lazy loading feature for 
	           1:m and M:N relations?
	       </h4></div></div></div><p>
	           Let us convert one of the classes from the 
	           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top"> JDO examples</a> 
	           to use lazy-loading.
           </p><p>
	           In the example model, one Product can contain many ProductDetails. 
	           This is reflected in the conventional mapping as below. 
	           First, the mapping for Product:
	           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product  --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">description</span>&gt;Product definition&lt;<span class="hl-tag">/description</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"product"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
 
   &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;

   &lt;<span class="hl-comment">!-- Product has reference to ProductDetail
            many details per product  --</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span>
           <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detail"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
	            </pre><p>
           </p><p>
	           Now let us examine ProductDetail. Note, the relationship is mapped 
	           <a href="#jdo.faq.technical.bi-directional" title="3.7.3.12.&nbsp;Does Castor support both one-way and two-way relationships?">bi-directionally</a> as must be 
	           all relationships when using Castor JDO.
	           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product Detail --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"myapp.Product"</span> &gt;
   &lt;<span class="hl-tag">description</span>&gt;Product detail&lt;<span class="hl-tag">/description</span>&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_detail"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"detail"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
   
       &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;
   
&lt;<span class="hl-tag">/class</span>&gt;
	           
	           </pre><p>
           </p><p>
	           Let us now make the relationship between Product and ProductDetail use 
	           lazy loading. We need only change the way that the relationship to 
	           ProductDetail is specified in the mapping of Product. The relevant 
	           field in Product can be re-written like so: 
	           </p><pre class="programlisting">
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">collection</span>=<span class="hl-value">"collection"</span>&gt;
   &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
   &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detail"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
           
           </pre><p>
           </p><p>
	           There have been two changes.
	           </p><div class="itemizedlist"><ul type="disc"><li><p>
		               We have placed the attribute lazy="true" in the field element
		             </p></li><li><p>
		               We have changed the type of the underlying collection type to be 
		               a <code class="literal">java.util.Collection</code> by changing the field 
		               element attribute to collection="collection".
		             </p></li></ul></div><p>   
           </p><p> 
           Note that no change is required in the ProductDetail mapping.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.no-method-error"></a>3.7.12.4.&nbsp;
               I have modified my mapping to use lazy loading. Now I get the error 
               'no method to set value for field: com.xyz.ClassB in class: 
               ClassMolder com.xyz.ClassA' or 
               'org.exolab.castor.jdo.DataObjectAccessException: no method to set 
               value for field: com.xyz.ClassB in class: ClassMolder com.xyz.ClassA'. 
               What am I doing wrong?
           </h4></div></div></div><p>
	           To use lazy loading you must also change the persistent class that 
	           will hold the related objects. At the very highest level, you need 
	           to provide a set method that accepts a java.util.Collection for the 
	           field in question. This is demonstrated by changing the 
	           
	           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top">JDO examples</a> below.
           </p><p>
	           In the original Product class we have the following code:
	           </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Vector;
...
<span class="hl-keyword">private</span> Vector _details = <span class="hl-keyword">new</span> Vector();
...
<span class="hl-keyword">public</span> Vector getDetails()
{
   <span class="hl-keyword">return</span> _details;
}


<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addDetail( ProductDetail detail )
{
   _details.add( detail );
   detail.setProduct( <span class="hl-keyword">this</span> );
}
	           </pre><p>
           </p><p>
	           Let us now make the necessary changes to set up lazy loading. 
	           As stated above we now require a special set method for the related 
	           ProductDetails (stored originally as a 
	           <code class="literal">java.util.Vector</code>) that accepts a 
	           <code class="literal">java.util.Collection</code> as an argument. This mandates 
	           that we must also use a <code class="literal">java.util.Collection</code> to 
	           hold our ProductDetails. If this is not added, you will receive the 
	           errors above.
	           </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Collection;
...
<span class="hl-keyword">private</span> Collection _details;
...
<span class="hl-keyword">public</span> Collection getDetails()
{
   <span class="hl-keyword">return</span> _details;
}


<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDetails( Collection details )
{
   _details = details;
}

	           </pre><p>
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.lob-tuning"></a>3.7.13.&nbsp;Tuning for LOBs</h3></div></div></div><p>
	        Castor JDO provides a property in <code class="literal">castor.properties</code> 
	        for adjusting the size of the JDBC driver's buffer for reading LOBs 
	        (BLOBs and CLOBs) from the database. The propery is named 
	        <code class="literal">org.exolab.castor.jdo.lobBufferSize</code> and its default 
	        is 5120 bytes (5k). The size of this buffer can be tuned for larger LOBs, 
	        but is dependent upon the JDBC driver implementation being used and what 
	        it supports. 
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.database-specific"></a>3.7.14.&nbsp;Database-specific issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.database-specific.hsql-identity-key-generators"></a>3.7.14.1.&nbsp;HSQL and identity key generators</h4></div></div></div><p>
               Due to a product limitation, AUTO_INCREMENT sequences in HSQL begin 
               with 0 rather 1, as is the case with most other RDBMS. As a result 
               of this, long transactions will not work for the object with the 
               identity 0, and a ObjectModifiedException will be thrown.
            </p><p>
               To avoid this issue, we recommend inserting a temp object into the 
               database in question, and removing thereafter so that no object with 
               identity 0 is stored.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.change-configurations"></a>3.7.15.&nbsp;Changing database configurations</h3></div></div></div><p>
           Some applications need to change the database connection or switch 
           between different mapping files on the fly. Because Castor caches 
           database configurations per name, you would have to register a new 
           JDO configuration using a distinct name for any of the different 
           configurations.
        </p><p>
		   Instead you can call 
		   <code class="methodname">org.exolab.castor.jdo.engine.DatabaseRegistry.clear()</code>
		   to reset the database registry before registering the new configuration as 
		   follows:
		</p><pre class="programlisting">
<span class="hl-comment">// Reset database registry</span>
org.exolab.castor.jdo.engine.DatabaseRegistry.clear();
		</pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.code-samples"></a>3.8.&nbsp;Castor JDO code samples</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.code-samples.introduction"></a>3.8.1.&nbsp;Introduction</h3></div></div></div><p>
         This document provides object mapping examples and the corresponding
         Java objects and DDL for the database table.
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.java-class-files"></a>3.8.1.1.&nbsp;Java class files</h4></div></div></div><p>
            The following fragment shows the Java class declaration for the
            <code class="classname">Product</code> class:
          </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price;

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}</pre><p>
        The following fragment shows the Java class declaration for the
        <code class="classname">ProductGroup</code> class:
      </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.ddl"></a>3.8.1.2.&nbsp;DDL</h4></div></div></div><p>
            The following sections show the DDL for the relational database
            tables <span class="database">PROD</span>, 
            <span class="database">PROD_GROUP</span>, 
            and <span class="database">PROD_DETAIL</span>:
          </p><p>
            <span class="bold"><strong><code class="literal">PROD</code></strong></span>:
          </p><pre class="programlisting">
create table prod (
  id        int           not null,
  name      varchar(200)  not null,
  price     numeric(18,2) not null,
  group_id  int           not null
);</pre><p>
            <span class="bold"><strong><code class="literal">PROD_GROUP</code></strong></span>:
          </p><pre class="programlisting">
create table prod_group (
  id        int           not null,
  name      varchar(200)  not null
);</pre><p>
            <span class="bold"><strong><code class="literal">PROD_DETAIL</code></strong></span>:
          </p><pre class="programlisting">
create table prod_detail (
  id        int           not null,
  prod_id   int           not null,
  name      varchar(200)  not null
);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.object-mappings"></a>3.8.1.3.&nbsp;Object Mappings</h4></div></div></div><p>
          The following code fragment shows the object mapping for the
          <code class="classname">ProductGroup</code> class:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Object</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                         <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>
<span class="hl-attribute">&lt;mapping&gt;</span>

  <span class="hl-attribute">&lt;class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    &lt;<span class="hl-tag">description</span>&gt;Product group&lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_group"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"group"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> &gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
         As a result of that declaration, Castor JDO will create the following
         SQL statements for creating, deleting, loading and updating instances
         of <code class="classname">ProductGroup</code>:
       </p><pre class="programlisting">
create: INSERT INTO prod_group (id, name) VALUES (?,?)
delete: DELETE FROM prod_group WHERE id=?
load:   SELECT prod_group.id, prod_group.name FROM prod_group WHERE prod_group.id=?;
update: UPDATE prod_group SET name=? WHERE id=?
       </pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.introduction.read-only-fields"></a>3.8.1.3.1.&nbsp;Read-only fields</h5></div></div></div><p>
            To declare the <span class="database">name</span> field 
            <span class="bold"><strong>read-only</strong></span>, the field definition 
            above for the field <span class="database">name</span> needs 
            to be changed to:
          </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    ...
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
            As a result of that declaration, Castor JDO creates the following
            SQL statements for creating, deleting, loading and updating
            instances of <code class="classname">ProductGroup</code>:
          </p><pre class="programlisting">
create: INSERT INTO prod_group (id) VALUES (?)
delete: DELETE FROM prod_group WHERE id=?
load:   SELECT prod_group.id, prod_group.name FROM prod_group WHERE prod_group.id=?;
update: /* no statement will be generated */
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.transient-fields"></a>3.8.1.3.2.&nbsp;Transient fields</h5></div></div></div><p>
            To declare the <span class="database">name</span> field 
            <span class="bold"><strong>transient</strong></span> with regards to
            persistence, above field definition for the field 
            <span class="database">name</span> needs to be changed to:
          </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    ...
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> &gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> <span class="hl-attribute">transient</span>=<span class="hl-value">"true"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.relations"></a>3.8.1.4.&nbsp;Relations</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.1-to-1"></a>3.8.1.4.1.&nbsp;1:1 relation</h5></div></div></div><p>
            The following code fragment shows the mapping file for the Product
            class.  Apart from the simple field declarations, this includes a
            simple 1:1 relation between <code class="literal">Product</code> and
            <code class="literal">ProductGroup</code>, where every product instance 
            is associated with a <code class="literal">ProductGroup</code>:
          </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span>
               <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.1-to-m"></a>3.8.1.4.2.&nbsp;1:M relation</h5></div></div></div><p>
               The following code fragment shows (again) the mapping file for
               the <code class="classname">Product</code> class. The field definition highlighted
               shows how to declare a 1:M relation between <code class="literal">Product</code> 
               and <code class="literal">ProductDetail</code>, where every product instance is 
               made up of many <code class="literal">ProductDetails</code>:
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
               The following code fragment shows the corresponding mapping
               entry for the <code class="classname">ProductDetail</code> class that defines the
               second leg of the 1:M relation between <code class="literal">Product</code> and
               <code class="literal">ProductDetail</code>.
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"myapp.Product"</span> &gt;

    &lt;<span class="hl-tag">description</span>&gt;Product detail&lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_detail"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"detail"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.m-to-n"></a>3.8.1.4.3.&nbsp;M:N relation</h5></div></div></div><p>
               The following code fragment shows (again) the mapping file for
               the <code class="classname">Product</code> class.  The field definition highlighted
               shows how to declare a M:N relation between <code class="literal">Product</code> 
               and <code class="literal">ProductCategory</code>, where many products can be 
               mapped to many product categories:
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>&gt;/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
               The following code fragment shows the corresponding mapping
               entry for the <code class="classname">ProductCategory</code> class that defines the
               second leg of the M:N relation between <code class="literal">Product</code> and
               <code class="literal">Category</code>.
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    &lt;<span class="hl-tag">description</span>&gt;
        A product category, any number of products can belong to
        the same category, a product can belong to any number of
        categories.
    &lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"category"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"category"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span>
           <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"category_id"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.extend-relation-polymorphism"></a>3.8.1.5.&nbsp;Extend relation &amp; polymorphism</h4></div></div></div><p>
           As of release 0.9.9, Castor supports polymorphic queries on extend
           hierarchies.  (That is, hierarchies where some entities "extend"
           other entities.)  To highlight this new feature, let's add two new
           classes to what we have currently.
         </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Computer <span class="hl-keyword">extends</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _make;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getmake() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMake( String aMake ) { ... }

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Car <span class="hl-keyword">extends</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> Date    _registeredIn;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> Date getRegisteredIn() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setRegisteredIn( Date aRegisteredIn ) { ... }
}</pre><p>
            The corresponding DDL statements for the relational database tables
            <span class="database">COMP</span> and 
            <span class="database">CAR</span> would look as follows:
          </p><p><span class="bold"><strong><code class="literal">COMP</code></strong></span>:</p><pre class="programlisting">
create table comp (
  id        int           not null,
  make      varchar(200)  not null
);</pre><p><span class="bold"><strong><code class="literal">CAR</code></strong></span>:</p><pre class="programlisting">
create table car (
  id        int           not null,
  regIn     int           not null
);</pre><p>
               Based upon the mapping defined for the <code class="classname">Product</code> 
               class as shown above, the following code fragment shows the mapping 
               for the <code class="literal">Computer</code> and <code class="literal">Car</code> classes.
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Computer"</span> <span class="hl-attribute">extends</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"COMP"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"make"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"make"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;

    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Car"</span> <span class="hl-attribute">extends</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"CAR"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"registeredIn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"regIn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
          Based upon this mapping, it is possible to execute the following OQL
          queries against this class model:
        </p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT c FROM myapp.Computer c"</span>);
        </pre><p>To return all computers:</p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT c FROM myapp.Computer c WHERE c.make = $"</span>);
        </pre><p>To return all computers of a particular make:</p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT p FROM myapp.Product p"</span>);
        </pre><p>
          To return all products (where Castor will return the actual object
          instances, i.e. a <code class="literal">Computer</code> instance if the object 
          returned by the query is of type <code class="literal">Computer</code> or a 
          <code class="literal">Car</code> instance if the object returned by the query is 
          of type <code class="literal">Car</code>):
        </p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT p FROM myapp.Product p WHERE p.group.name = $"</span>);
        </pre><p>
          To return all products that belong to the specified product group
          (where Castor will return the actual object instances, i.e. a
          <code class="literal">Computer</code> instance if the object returned by the query 
          is of type <code class="literal">Computer</code> or a <code class="literal">Car</code> instance 
          if the object returned by the query is of type <code class="literal">Car</code>):
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.oql-samples"></a>3.8.1.6.&nbsp;OQL samples</h4></div></div></div><p>
          Based upon above definitions, here are a few OQL sample queries that
          highlight various artifacts of the OQL support of Castor JDO.
        </p><p>
          <span class="bold"><strong><span class="italic">To Be Written</span></strong></span>
        </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.howto"></a>3.9.&nbsp;Castor JDO - How To's</h2></div></div></div>

      

      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.introduction"></a>3.9.1.&nbsp;Introduction</h3></div></div></div>
	      
	
	      <p>
	          This is a collection of HOW-TOs. The Castor project is actively seeking 
	          additional HOW-TO contributors to expand this collection. For information 
	          on how to do that, please see 'How to author a HOW-TO'.
	      </p>
      </div>
	
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.documentation"></a>3.9.2.&nbsp;Documentation</h3></div></div></div>
	      
		
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5642"></a>3.9.2.1.&nbsp;How to author a HOW-TO document</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5644"></a>3.9.2.2.&nbsp;How to author an FAQ entry</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5646"></a>3.9.2.3.&nbsp;How to author a code snippet</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5648"></a>3.9.2.4.&nbsp;How to author core documentation</h4></div></div></div></div>
	  </div>
		
		
	  <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.contribution"></a>3.9.3.&nbsp;Contribution</h3></div></div></div>
	      
	      
	      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.setup-eclipse-castor-project"></a>3.9.3.1.&nbsp;How to setup Castor project in eclipse</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.introduction"></a>3.9.3.1.1.&nbsp;Introduction</h5></div></div></div><p>
        Are you just interested in how Castor source looks like, want to report a bug 
        or enhancement request or like to contribute to the project? The first step we 
        suggest you to do is to setup a Castor project with eclipse IDE. As we use 
        eclipse to work at Castor, there is everything in place to work with eclipse. 
        While you are free to use other IDE's, you will need to configure things 
        yourself with them.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.prerequisites"></a>3.9.3.1.2.&nbsp;Prerequisites</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            Download and install 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/javase/downloads/index.jsp" target="_top">JDK 1.5
            or newer</a>
          </p></li><li><p>
            Download and install 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/downloads/index.php" target="_top">Eclipse 
            3.x</a>
          </p></li><li><p>
            Install the latest 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subclipse.tigris.org/download.html" target="_top">Subclipse 
            eclipse plugin</a>
          </p></li><li><p>
            Optionally install the latest 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://eclipse-cs.sourceforge.net/" target="_top">CheckStyle eclipse 
            plugin</a>
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.create-project"></a>3.9.3.1.3.&nbsp;Create Project</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            Create a New Project in eclipse from 
            <code class="literal">File -&gt; New -&gt; Projects</code>
          </p></li><li><p>
            Select <code class="literal">"Checkout Projects from SVN"</code>
            in <code class="literal">"SVN"</code> from 
            <code class="literal">"Select a wizard"</code> window 
            and click <code class="literal">Next</code> 
            (this option will only come if you have installed the subclipse plugin)
          </p></li><li><p>
            Select <code class="literal">"Create a new repository location"</code>
            and click <code class="literal">Next</code>
          </p></li><li><p>
            Enter the URL 
            <code class="literal">"https://svn.codehaus.org/castor/castor"</code>
            and click <code class="literal">Next</code>
          </p></li><li><p>
            Select the folder <code class="literal">"trunk"</code> 
            from the list and click <code class="literal">Next</code>
          </p></li><li><p>
            In <code class="literal">"Check Out As"</code> 
            window the name of the project will be 
            <code class="literal">"castor"</code> then click 
            <code class="literal">Next</code>
          </p></li><li><p>
            At last, you can choose the workspace and click 
            <code class="literal">Finish</code>
          </p></li><li><p>
            You can see castor project in your 
            <code class="literal">"Project Navigator" of eclipse</code>
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.troubleshooting"></a>3.9.3.1.4.&nbsp;Troubleshooting</h5></div></div></div><p>
        <span class="bold"><strong>If you have trouble with Subclipse behind a proxy 
        server:</strong></span> In Windows development environment, open the file: 
        <code class="filename">C:\Documents and 
        Settings\MyUserId\Application Data\Subversion\servers</code> 
        in text editor. Near the bottom of that file is a [global] section with 
        http-proxy-host and http-proxy-port (user and password also) settings. 
        Uncommented those lines, modified them for your proxy server and go back 
        to the SVN Repository view in Eclipse. This should solve the problem.
      </p></div></div>
	      
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.jdo-unit-tests"></a>3.9.3.2.&nbsp;How to run Castor JDO's database independend unit tests</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.overview"></a>3.9.3.2.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite that is used to test various functional areas 
            against different database engines to give developers/committers some 
            reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite to evaluate impact of changes on performance.
          </p></li></ul></div><p>
        This document provides general information about running Castor JDO's database 
        independend unit tests.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.prerequisites"></a>3.9.3.2.2.&nbsp;Prerequisites</h5></div></div></div><p>
        See: <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
        project in eclipse</a>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.execute-in-eclipse"></a>3.9.3.2.3.&nbsp;Execute tests in eclipse</h5></div></div></div><p>
        To execute tests in eclipse, go and right click on 
        <code class="filename">cpa/src/test/java</code> source folder and select 
        <code class="literal">"Run As -&gt; JUnit Test"</code>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.references"></a>3.9.3.2.4.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.jdo-test-suite"></a>3.9.3.3.&nbsp;How to run Castor JDO's test suite</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.overview"></a>3.9.3.3.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite (CTF) that is used to test various functional 
            areas against different database engines to give developers/committers 
            some reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite (PTF) to evaluate impact of changes on performance.
          </p></li></ul></div><p>
        This document provides general information about running Castor JDO's test 
        suite (CTF).
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.intended-audience"></a>3.9.3.3.2.&nbsp;Intended Audience</h5></div></div></div><p>
        Anyone who wants to run the CTF test suite. This document outlines 
        the basic steps to get people unfamiliar with this area started.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.prerequisites"></a>3.9.3.3.3.&nbsp;Prerequisites</h5></div></div></div><p>
        Anybody wishing to run the CTF test suite should have access to the 
        source code of Castor. This can be obtained in one of the following ways:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Download the sources distribution from the 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/download.html" target="_top">download page</a>
          </p></li><li><p>
            Download the latest snapshot from SVN from
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://svn.castor.codehaus.org/viewrep/castor/castor/trunk" target="_top">Fisheye</a>
            (see links on the bottom left corner)
          </p></li><li><p>
            Check out the latest code from SVN into your prefered developement environment. 
            For instructions on this task, take a look at 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/scm.html#Subversion-access" target="_top">Subversion 
            access</a>. For eclipse
            <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How 
            to setup Castor project in eclipse</a> provides a detailed description 
            of this task.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.2-versions-of-ctf"></a>3.9.3.3.4.&nbsp;2 versions of CTF</h5></div></div></div><p>
        At the moment we are in the middle of replacing the old CTF with a new one. 
        While the old CTF still is our reference for refactorings of Castor does the 
        new CTF contain some tests which could not be added to the old one due to its 
        limitations. On the other hand are not all tests ported to the new CTF yet.
      </p><p>
        In the next sections we describe how to setup the environment to execute both 
        CTF versions. While both versions of CTF are designed to be executed against 
        every supported database engine, we will describe things with regard to mysql. 
        Having said that there are only scripts for mysql at the new CTF at the moment. 
        At a later step of the CTF refactoring we will add scripts for other databases 
        as well. In addition we intend to allow its execution with an embedded derby 
        database out of the box, but this have not been implemented yet.
      </p><p>
        For those who might be wondering about the numbering of tests, 
        the numbers of the old tests are just random. 
        The numbers of the new tests are the jira issue numbers.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.setup-environment-for-old-ctf"></a>3.9.3.3.5.&nbsp;Steps to setup environment for old CTF</h5></div></div></div><p>
        To execute tests against mysql database you probably need access to a 
        mysql server. To create a database for CTF, you have to execute the following 
        commands on mysql consol.
      </p><pre class="programlisting">
# create database test;
# grant all on test.* at "localhost" to "test" identified by "test";
# use test;
# source [path-to-script];</pre><p>
          If the server is not installed on your local machine (the one you execute
          the tests on) you have to replace "<code class="literal">localhost</code>" with the 
          IP of the machine the tests get executed on. The script to execute can be 
          found in "<code class="filename">cpactf/src/old/ddl/</code>" 
          directory. For mysql it's "<code class="filename">mysql.sql</code>". 
          If you like to use a different name for the database or use 
          other user credential you can adjust them at 
          "<code class="filename">cpactf/src/old/resources/jdo/mysql.xml</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically. Another option is to modify 
        "<code class="filename">bin/test.sh</code>" or "<code class="filename">bin/test.bat</code>" 
        script depended on your operating system.
      </p><p>
        For <span class="productname">mysql</span>&#8482; we still use 
        "<code class="filename">mysql-connector-java-3.1.13-bin</code>", also for 
        <span class="productname">mysql server</span>&#8482; of version 5. 
        This version has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p><p>
        As already explained you will find JDO configurations for every supported 
        database in 
        "<code class="filename">cpactf/src/old/resources/jdo</code>".
        The JDO configurations are named <code class="filename">mysql.xml</code>, 
        <code class="filename">oracle.xml</code> etc. In the same directory you will also 
        find main mapping file "<code class="filename">mapping.xml</code>" that includes all 
        other mappings which are located in the 
        "<code class="filename">cpactf/src/old/resources/ctf/jdo/...</code>" 
        directories. There is one more important file for the old tests 
        "<code class="filename">cpactf/src/old/resources/tests.xml</code>", 
        it is the main config file which defines which test should be executed 
        against which database engine. As mentioned previously not every test 
        works with every database engine as some missing some features or castor 
        does not support everything of every engine.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-old-ctf-from-commandline"></a>3.9.3.3.6.&nbsp;Steps to run old CTF from commandline</h5></div></div></div><p>
        From a command line (e.g a shell), please execute the following commands 
        to run the whole test suite against mysql (where 
        <code class="literal">&lt;castor-root&gt;</code> points to the directory 
        where you installed the Castor sources:
      </p><pre class="programlisting">
cd <span class="emphasis"><em>&lt;castor-root&gt;</em></span>/bin
build clean
build tests
test castor.mysql</pre><p>
        To execute just one of the many tests of the complete test suite, 
        please change this to:
      </p><pre class="programlisting">
cd <span class="emphasis"><em>&lt;castor-root&gt;</em></span>/bin
build clean
build tests
test castor.mysql.TC30</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	      You have to execute "<span><strong class="command">build clean</strong></span>" and 
	      "<span><strong class="command">build tests</strong></span>" again if you have changed anything within 
	      eclipse (e.g. a configuration file or a class).
	    </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-old-ctf-out-of-eclipse"></a>3.9.3.3.7.&nbsp;Steps to run old CTF out of eclipse</h5></div></div></div><p>Now, let's see how we can run these old CPACTF tests through eclipse.</p><div class="itemizedlist"><ul type="disc"><li><p>
            Go to "<span class="package">/cpacft/src/old/java</span>" and right click
          </p></li><li><p>Select <code class="literal">Run As -&gt; Run...</code></p></li><li><p>
            Select <code class="literal">"Java Application"</code> from the left side menu 
            and double click on it to create <code class="literal">"New_configuration"</code>.
          </p></li><li><p>Select <code class="literal">Project -&gt; castor</code></p></li><li><p>Enter <code class="literal">Main class -&gt; MainApp</code></p></li><li><p>Select Arguments Tab</p></li><li><p>
            Enter <code class="literal">Program Arguments</code> for example: 
            "<code class="literal">castor.mysql.TC31</code>" or "<code class="literal">castor.mysql</code>"
          </p></li><li><p>Now "Run"</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.description-of-old-ctf"></a>3.9.3.3.8.&nbsp;Short description of the old CTF tests</h5></div></div></div><p>As some features are not supported by all database engines (e.g. sequence keygenerator) or a test have not been
        verified against a database, only a subset of the following tests will be executed if you run CTF.</p><div class="itemizedlist"><ul type="disc"><li><p>TC01 Duplicate key detection tests.</p></li><li><p>TC02 Concurrent access tests.</p></li><li><p>TC03 Read only tests.</p></li><li><p>TC04 Deadlock detection tests.</p></li><li><p>TC05 Update rollback tests.</p></li><li><p>TC06 Race tests.</p></li><li><p>TC07 Cache leakage tests.</p></li><li><p>TC08 Cache expiry measure.</p></li><li><p>TC09 TxSynchronizable interceptor tests.</p></li><li><p>TC10 Type handling tests.</p></li><li><p>TC11 Type handling of LOB tests.</p></li><li><p>TC12 Type Conversion tests.</p></li><li><p>TC13 Serializable object tests.</p></li><li><p>TC14 Rollback primitive tests.</p></li><li><p>TC15 Multiple columns primary keys tests.</p></li><li><p>TC15a Multiple columns primary keys only tests.</p></li><li><p>TC16 Nested fields tests.</p></li><li><p>TC17 Timestamp tests.</p></li><li><p>TC18 Persistence interface tests.</p></li><li><p>TC19 InstanceFactory interface tests.</p></li><li><p>TC20 Key generators: MAX, HIGH-LOW.</p></li><li><p>TC23 Key generator: IDENTITY.</p></li><li><p>TC24 Key generator: UUID.</p></li><li><p>TC25 Dependent objects tests.</p></li><li><p>TC26 Dependent objects tests.</p></li><li><p>TC27 Dependent update objects tests.</p></li><li><p>TC28 Dependent update objects tests.</p></li><li><p>TC30 OQL-supported syntax.</p></li><li><p>TC31 OQL queries for extends.</p></li><li><p>TC32 Test limit clause.</p></li><li><p>TC33 Test limit clause with offset.</p></li><li><p>TC34 Test limit clause with offset at extended object.</p></li><li><p>TC36 SizeOracle.</p></li><li><p>TC37 Absolute.</p></li><li><p>TC38 CALL SQL with parameters.</p></li><li><p>TC38a Named query support.</p></li><li><p>TC70 Collections.</p></li><li><p>TC71 Test special collections.</p></li><li><p>TC72 Test sorted collections.</p></li><li><p>TC73 ManyToMany.</p></li><li><p>TC74 ManyToManyKeyGen.</p></li><li><p>TC75 Expire Many-To-Many.</p></li><li><p>TC76 Cached OID with db-locked.</p></li><li><p>TC77 Query garbage collected.</p></li><li><p>TC78 JDBC connection.</p></li><li><p>TC79 Test the use of Database.isLocked().</p></li><li><p>TC79a Test auto-store attribute.</p></li><li><p>TC79aa Test auto-store attribute for 1:M relations.</p></li><li><p>TC79b Test the use of Database.isPersistent().</p></li><li><p>TC80 self-referential relation test with extend hierarchies.</p></li><li><p>TC81 Dependent relation test.</p></li><li><p>TC82 Dependent relation test (using no key generators).</p></li><li><p>TC83 Identity definition through identity attribute in field mapping.
        </p></li><li><p>TC84 Transient attribute.</p></li><li><p>TC85 TestEnum.</p></li><li><p>TC87 TestLazy1to1.</p></li><li><p>TC88 Lazy Loading.</p></li><li><p>TC89 Expire Lazy Employee.</p></li><li><p>TC93 Polymorphism Degenerated tests.</p></li><li><p>TC94 Polymorphism tests.</p></li><li><p>TC95 Polymorphism tests with key generator.</p></li><li><p>TC96 Polymorphism tests for depend relations.</p></li><li><p>TC97 Polymorphism tests.</p></li><li><p>TC98 Polymorphism tests in a threaded environment.</p></li><li><p>TC99 Polymorphism tests (many 2 many).</p></li><li><p>TC200 Self-referential relation tests.</p></li><li><p>TC201 Self-referential relation tests with extend hierarchy.
        </p></li><li><p>TC202 ForeignKeyFirst tests.</p></li><li><p>TC203 Timezone tests.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.setup-environment-for-new-ctf"></a>3.9.3.3.9.&nbsp;Steps to setup environment for new CTF</h5></div></div></div><p>
        To execute tests against mysql database you probably need access to a 
        mysql server. To create a database for CTF, you have to execute the 
        following commands on mysql console.
      </p><pre class="programlisting">
# create database cpactf;
# grant all on cpactf.* at "localhost" to "test" identified by "test";
# use cpactf;
# source <span class="emphasis"><em>&lt;path-to-script&gt;</em></span>;</pre><p>
        If the server is not installed on your local maschine (the one you execute the 
        tests on) you have to replace "<code class="literal">localhost</code>" with the IP 
        of the maschine the tests get executed on. For mysql execute every 
        "<code class="filename">mysql.sql</code>" script found in subdirectories of 
        "<code class="filename">cpactf/src/test/ddl/</code>" directory. 
        If you like to use a different name for the database or use other user 
        credential you can adjust them at 
        "<code class="filename">cpactf/src/test/resources/cpactf-conf.xml</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically. Another option is to modify 
        "<code class="filename">bin/test.sh</code>" or "<code class="filename">bin/test.bat</code>" 
        script depended on your operating system.
      </p><p>
        For mysql we still use "<code class="literal">mysql-connector-java-3.1.13-bin</code>", 
        also for <span class="productname">mysql server</span>&#8482; of version 5. This version 
        has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-new-ctf-out-of-eclipse"></a>3.9.3.3.10.&nbsp;Steps to run new CTF out of eclipse</h5></div></div></div><p>
        Execution of the new test suite from within eclipse against 
        <span class="productname">mysql</span>&#8482; is very simple.
      </p><div class="itemizedlist"><ul type="disc"><li><p>Select "<span class="package">cpactf/src/test/java</span>" and right click</p></li><li><p>
            Select "<code class="literal">Run as</code>" -&gt; "<code class="literal">JUnit tests</code>"
          </p></li></ul></div><p>
        In in the configuration file "cpactf-conf.xml" mysql is configuerd as default 
        database. To execute tests against another database engine or to force 
        execution of tests that have been excluded you can pass VM parameter to the 
        test framework. VM Arguments can also be specified in eclipse.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Select "<code class="literal">Run as</code>" -&gt; "<code class="literal">Run..</code>"
            from main menu
          </p></li><li><p>Select Arguments Tab</p></li><li><p>
            Enter <code class="literal">VM Arguments</code> for example: 
            "<code class="literal">-Dname=value</code>"
          </p></li><li><p>Now "<code class="literal">Run</code>"</p></li></ul></div><p>The following VM parameters are supported by CTF.</p><div class="variablelist"><dl><dt><span class="term">config</span></dt><dd><p>Path to an alternate configuration file.</p></dd><dt><span class="term">database</span></dt><dd><p>Name of the database configuration.</p></dd><dt><span class="term">transaction</span></dt><dd><p>Name of the transaction manager configuration.</p></dd><dt><span class="term">force</span></dt><dd><p>Force execution of excluded tests (true/false).</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.troubleshooting"></a>3.9.3.3.11.&nbsp;Troubleshooting</h5></div></div></div><p>
        <span class="bold"><strong>For those who face the following problem in eclipse 
        while executing the tests</strong></span>
      </p><pre class="programlisting">
#An unexpected error has been detected by HotSpot Virtual Machine:
#
#EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x7c918fea, pid=2460, tid=3712
#
#Java VM: Java HotSpot(TM) Client VM (1.5.0-b64 mixed mode)
#Problematic frame:
#C [ntdll.dll+0x18fea]
#
#An error report file with more information is saved as hs_err_pid2460.log
#
#            If you would like to submit a bug report, please visit:
#              http://java.sun.com/webapps/bugreport/crash.jsp
#</pre><p>
        It is a problem with memory configured for eclipse. It can be changed in 
        <code class="filename">eclipse.ini</code> file which can be found in installation 
        directory of Eclipse. By default it is <code class="literal">-Xmx256m</code>, 
        just increase it and problem go away.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.references"></a>3.9.3.3.12.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li><li><p>
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/scm.html#Subversion-access" target="_top">Subversion 
            access</a>
          </p></li><li><p>
            
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/test-framework.html" target="_top">The testing 
            framework</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.performance-tests"></a>3.9.3.4.&nbsp;How to run Castor JDO's performance tests</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.overview"></a>3.9.3.4.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite that is used to test various functional areas 
            against different database engines to give developers/committers some 
            reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite to evaluate impact of changes on performance.
          </p></li></ul></div><p>This document provides general information about running Castor JDO's performance tests.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.prerequisites"></a>3.9.3.4.2.&nbsp;Prerequisites</h5></div></div></div><p>
        See: <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How 
        to setup Castor project in eclipse</a>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.setup-environment-for-old-ctf"></a>3.9.3.4.3.&nbsp;Steps to setup environment for old CTF</h5></div></div></div><p>
        To execute performance tests against mysql database you probably need access 
        to a mysql server. To create a database for PTF, you have to execute the 
        following commands on mysql console.
      </p><pre class="programlisting">
# create database cpaptf;
# grant all on cpaptf.* at "localhost" to "test" identified by "test";
# use cpaptf;
# source <span class="emphasis"><em>[path-to-script]</em></span>;</pre><p>
        If the server is not installed on your local machine (the one you execute 
        the tests on) you have to replace "<code class="literal">localhost</code>" with the IP 
        of the machine the tests get executed on. The script to execute is
        "<code class="filename">cpaptf/src/test/ddl/mysql.sql</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically.
      </p><p>
        For mysql we still use "<code class="literal">mysql-connector-java-3.1.13-bin</code>", 
        also for <span class="productname">mysql server</span>&#8482; of version 5. 
        This version has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.execute-in-eclipse"></a>3.9.3.4.4.&nbsp;Steps to execute performance tests in eclipse</h5></div></div></div><p>
        Execution of the performance test suite from within eclipse is very simple.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Select "<code class="literal">cpaptf/src/test/java</code>" 
            -&gt; "<code class="literal">org.castor.cpaptf</code>" 
            -&gt; "<code class="filename">TestAll.java</code>" and right click
          </p></li><li><p>
            Select "<code class="literal">Run As</code>" -&gt; "<code class="literal">JUnit Test</code>"
          </p></li></ul></div><p>
        By default the test uses 2000 service objects that get created, loaded with 
        various configurations and deleted afterwards. Obviously this will take quite 
        some time. Please be patient for normal termination of the tests as you will 
        need to clean test tables by hand otherwise. To execute tests with a different 
        number of objects you can adjust "<code class="constant">FACTOR</code>" constant in 
        "<code class="filename">TestCreate.java</code>". For example, if you set 
        "<code class="constant">Factor</code>" to 1.0 the tests will be executed with 10000 
        service objects. When using more test objects be aware that you may need to 
        increase heap size of the virtual machine for the test to finish.
      </p><p>
        By default you won't see any output of results on the console as logging level 
        of log4j is set to "warn" by default. But if you change log level of 
        "<span class="package">org.castor.cpaptf</span>" package to "<code class="literal">info</code>" 
        you will see detailed execution times for every test on the console. 
        Be aware that there are quite some <code class="filename">log4j.xml</code> 
        configurations in the whole Castor project at the moment of which the one 
        first one on classpath will be used.
      </p><p>
        If you like to review some older test results you will find them under 
        "<code class="filename">cpaptf/src/site/resources/results/</code>" 
        but they depend heavy on the machine you are running the tests on.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.references"></a>3.9.3.4.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.submit-a-bug"></a>3.9.3.5.&nbsp;Submitting a bug report</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.submit-a-bug.problem-report"></a>3.9.3.5.1.&nbsp;Submitting a problem report</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.driver"></a>3.9.3.5.1.1.&nbsp;Driver</h6></div></div></div><p>
			   Most of the traffic on the Castor Users mailing list is about people 
			   asking for help on various features of Castor (whether JDO or XML). 
			   Whilst there is nothing wrong about asking questions and looking for 
			   help if you are stuck, it seems that there is room to improve the 
			   structure of this 'conversation'.
			</p><p>
			   If you have a look at some of these threads (e.g. at the 
			   <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mail-archive.com/castor-dev%40exolab.org" target="_top">searchable 
			   mailing list archive</a>), it's quite easy to see that most 
			   of the time ...
			</p><div class="orderedlist"><ol type="1"><li><p>An initial question is posted.</p></li><li><p>
				    An initial reply is posted with some follow-up questions, 
				    e.g. request for code fragments, mapping files, etc.
				  </p></li><li><p>
				    One or more code fragments, mapping files, etc. are being posted.
				  </p></li><li><p>etc.</p></li></ol></div><p>
			  This document will establish guidelines with regards to step 3) above.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.introduction"></a>3.9.3.5.1.2.&nbsp;Introduction</h6></div></div></div><p>
			    This document provides step-by-step instructions on how to submit a 
			    problem report (when being asked to do so). It does so by walking you 
			    through a fictive problem and its resulting bug report, and providing 
			    instructions based upon this scenario.
			</p><p>
			    Per definition, any problem report submitted (in other words, most 
			    likely attached to a bug report at 
			    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jira.codehaus.org/browse/CASTOR" target="_top">http://jira.codehaus.org/browse/CASTOR</a>)
			    by the means of a patch has to include the following artefacts:
			</p><div class="itemizedlist"><ul type="disc"><li><p>A JUnit test case that 'showcases' your problem.</p></li><li><p>Castor JDO configuration file.</p></li><li><p>Castor JDO mapping file.</p></li><li><p>
				    One or more 'entity' classes required to run your test case.
				  </p></li><li><p>
				    A SQL schema file (to help in the creation of required tables).
				  </p></li><li><p>
				    A <code class="literal">README</code> file (with any additional 
				    information/instructions required to understand /run your test case.
				  </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			    Whilst we can and will not impose these guidelines in their strictest 
			    sense, I think that the use of technologies such as JUnit will simplify problem 
			    resolution and as a result lead to shorter turn-around times. Which is ultimately where 
			    you, the user, gains..
			  </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.templates"></a>3.9.3.5.1.3.&nbsp;Templates</h6></div></div></div><p>
		        To facilitate creation of a fully featured patch as discussed above, 
		        we have provided you with an already existing bug template at 
		        '<code class="filename">src/bugs/jdo/template</code>'.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			        Please note that this directory is distributed only as part of the 
				    source archive(s).
				</p></td></tr></table></div><p>
			    This directory holds all artefacts mentioned above, as is structured 
			    as follows:
			</p><div class="table"><a name="d4e6184"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;bug template artefacts</b></p><div class="table-contents"><table summary="bug template artefacts" border="1"><colgroup><col><col></colgroup><tbody><tr><td><code class="filename">src</code></td><td>Source code</td></tr><tr><td><code class="filename">src/bugs</code></td><td>Common root for bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo</code>
                        </td><td>Common root for JDO bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template</code>
                        </td><td>Patch template</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/TestTemplate.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/EntityOne.java</code>
                        </td><td>Entity required by the test case</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/create.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td><code class="filename">src/bugs/jdo/template/README</code></td><td>Test instructions</td></tr></tbody></table></div></div><br class="table-break"><p>
			    To create you own bug report, please copy 
			    '<code class="filename">template</code>'
			    to e.g. <code class="filename">bug1820</code>, 
			    assuming that 1820 is the number assigned to your BugZilla 
			    problem report). Subsequently, please amend the files provided to 
			    match your own requirements. After you have consolidated your changes, 
			    the original directory structure in 
			    <code class="filename">src/bugs</code> could look as follows:
			</p><div class="table"><a name="d4e6232"></a><p class="title"><b>Table&nbsp;3.8.&nbsp;
			        directory structure of 
			        <code class="filename">src/bugs</code>
			    </b></p><div class="table-contents"><table summary="&#xA;        directory structure of &#xA;        src/bugs&#xA;    " border="1"><colgroup><col><col></colgroup><tbody><tr><td>
                            <code class="filename">src</code>
                        </td><td>Source code</td></tr><tr><td>
                            <code class="filename">src/bugs</code>
                        </td><td>Common root for bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo</code>
                        </td><td>Common root for JDO bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template</code>
                        </td><td>Patch template</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/TestTemplate.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/EntityOne.java</code>
                        </td><td>Entity required by the test case</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/create.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/README</code>
                        </td><td>Test instructions</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820</code>
                        </td><td>Your specific bug (as per BugZilla bug number)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/TestCase.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/Entity1.java</code>
                        </td><td>Entity required</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/Entity2.java</code>
                        </td><td>Entity required</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/schema.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/README</code>
                        </td><td>Test instructions</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.add-test-case"></a>3.9.3.5.1.4.&nbsp;Add your test case to the master test suite</h6></div></div></div><p>
		        Once you have successfully executed your JUnit test case, please add 
		        this test to the master test suite available in 
		        <code class="filename">src/bugs/AllTests.java</code> as follows. To add 
			    a test to this suite, please duplicate the line
			</p><pre class="programlisting">
			
    suite.addTestSuite(template.TestTemplate.<span class="hl-keyword">class</span>);
			</pre><p>
			    and replace the term 
			    '<code class="literal">jdo.template.TestTemplate.class</code>' with 
			    '<code class="literal">jdo.bug1820.TestCase</code>'.
			</p><p>
		        This will allow us to run all tests related to all open bugs in one go by executing
			    just this test suite.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.creating-the-patch"></a>3.9.3.5.1.5.&nbsp;Creating the patch</h6></div></div></div><p>
		        As explained in 
		        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/contributing.html#Guidelines-For-Code-Contribution" target="_top"> 
		        Guidelines For Code Contribution</a>, we ask you to submit your code
                changes in the form of a unified patch by attaching it to the relevant
                bug report.
            </p><p>
		        To create a <span class="bold"><strong>unified</strong></span> patch for 
		        submission, you can either use the command line SVN client 
		        (which you find instructions to download for at 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">http://subversion.tigris.org/</a> 
                or any IDE that offers support or SVN 
                (such as Eclipse with Subclipse plugin)
            </p><p>
		        In any case, please note that we are trying to standardize on the use
                of <span class="bold"><strong>unified</strong></span> patches only, and that 
                you should <span class="bold"><strong>always</strong></span> update your code 
                (against the SVN repository) before creating the patch. 
                If you have never used SVN before, there will be ways to
                convince us to accept e.g. a Zip file includig your changes.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.references"></a>3.9.3.5.1.6.&nbsp;References</h6></div></div></div><p>
		        Whilst we cannot assume that every Castor (JDO) user is an expert in
                the use of JUnit, we do believe that they are quite easy to get
                acquainted with. As a starting point, please find below some
                references:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
				        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.junit.org/" target="_top">JUnit</a> - A well-known
                        framework for writing integration-level and functional tests.
                    </p></li><li><p>
				        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">SVN Home</a>
				         - many usefulSVN related items
                    </p></li></ul></div></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.prepare-a-patch"></a>3.9.3.6.&nbsp;How to prepare a patch</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.overview"></a>3.9.3.6.1.&nbsp;Overview</h5></div></div></div><p>
           A "<code class="literal">patch</code>" is the set of differences between two versions of the same file. 
           Patches are used to send someone the exact changes that you have made to 
           your version of a program or a document. They can then apply that patch 
           to their version to merge the changes and bring their version up-to-date 
           with your version.
        </p><p>
           As our example we use the contribution of a simple documentation patch for 
           the Castor project. The principles apply to any project and to any type of 
           file, e.g. <code class="filename">*.xml</code>, 
           <code class="filename">*.java</code>, 
           <code class="filename">*.xsd</code>, etc.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.intended-audience"></a>3.9.3.6.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to contribute to a project. This document addresses the 
            basics, so as to get new people started.
        </p><p>
            Our example describes the use of command-line tools for a UNIX system. 
            Other tools can be used, as long as they produce a 
            "<code class="literal">unified diff</code>".
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.prerequisites"></a>3.9.3.6.3.&nbsp;Prerequisites</h5></div></div></div><p>Contributers should have:</p><div class="itemizedlist"><ul type="disc"><li><p>
                    The source code of the documents as a local working copy of the 
                    SVN repository. If you are working with the current SVN HEAD then 
                    you will have already done a 
                    '<span><strong class="command">svn checkout castor</strong></span>'. However, see below for 
                    other ways of obtaining source for diff comparison.
                </p></li><li><p>
                    The tools with which to prepare a patch. On UNIX the "svn" program 
                    has the <span><strong class="command">svn diff</strong></span> command.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.steps"></a>3.9.3.6.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.steps.understand"></a>3.9.3.6.4.1.&nbsp;Understand what a patch is</h6></div></div></div><p>
                A "Patch" is the set of differences between two versions of the same 
                file. A patch comprises one or more "diff" files. These diffs are 
                produced by the program of the same name: diff.
            </p><p>
                Here is an example of a single diff for one of the Castor How-to 
                pages, where we are suggesting a minor text change. Do not get 
                frightened. These are just human-readable instructions to the "patch" 
                program.
            </p><pre class="programlisting">
            
Index: contrib.xml
===================================================================
RCS file: /home/projects/castor/src/doc/jdo-howto.xml,v
retrieving revision 1.7
diff -u -r1.7 contrib.xml
--- jdo-howto.xml 30 Apr 2002 07:44:52 -0000      1.7
+++ jdo-howto.xml 26 May 2002 04:08:23 -0000
@@ -208,7 +208,7 @@
    to create a patch. (The commands are for Linux.)
   &lt;/p&gt;

- &lt;s2 title="How to Establish your Local Repository"&gt;
+ &lt;s2 title="How to Establish your Local Working Copy"&gt;

   &lt;p&gt;
    This will checkout the current copy of the master cvs repository and
            </pre><p>
                That is a "unified diff" ... there a some lines of context on each 
                side of the changes. This patch is basically saying "Change the text 
                on line 208".
            </p><div class="itemizedlist"><ul type="disc"><li><p>lines to be deleted are preceded with -</p></li><li><p>lines to be added are preceded with +</p></li><li><p>contextual lines with no leader remain the same</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.modify-and-ensure-consistency"></a>3.9.3.6.4.2.&nbsp;Modify your document and ensure consistency</h6></div></div></div><p>
                Let us now go though the process of preparing that patch. Go ahead 
                and edit your local copy of the document at 
                <code class="filename">$CASTOR_HOME/src/doc/jdo-howto.xml</code>.
            </p><p>
                Ensure that it is valid XML using your favourite XML editor or an 
                external validating parser. Please do not leave it up to the poor 
                committer to fix broken XML.
            </p><p>
                Run the '<span><strong class="command">build doc</strong></span>' target to be sure that links 
                are not broken and that the new document is presented as you intend 
                it to be.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.get-ready"></a>3.9.3.6.4.3.&nbsp;Get ready</h6></div></div></div><p>
                If you are using the HEAD of SVN then ensure that your working copy 
                is up-to-date. Of course, if you are using a previous public release 
                version of Castor, then it is already up-to-date.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.generate-the-differences"></a>3.9.3.6.4.4.&nbsp;Generate the differences</h6></div></div></div><p>
                Prepare the diff file. SVN will contact the remote repository, ensure 
                that your working copy is up-to-date, then compare your local copy 
                with the master repository.
            </p><pre class="programlisting">
            
    cd src/doc
    svn diff jdo-howto.xml &gt; $TEMP/castor/patch/jdo-howto.xml.diff
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.describe-the-patch"></a>3.9.3.6.4.5.&nbsp;Describe the patch</h6></div></div></div><p>
                Prepare a brief explanation of what your patch does. Get this ready 
                in a text file before you go to Jira. See further hints about this 
                in the "Description" section of the How-to Jira.
            </p><p>
                What revision of SVN did you patch against? Was it HEAD branch? Was 
                it a nightly build? Was it a public release?
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.submit-via-jira"></a>3.9.3.6.4.6.&nbsp;Submit via Jira</h6></div></div></div><p>
                To contribute your patch to a specific project, use Jira - The Codehaus 
                Issue Database. The procedure is explained in How to Contribute a 
                Patch via Jira.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension"></a>3.9.3.6.5.&nbsp;Real World Extension</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension.multiple-diffs"></a>3.9.3.6.5.1.&nbsp;Multiple diffs in a single patch</h6></div></div></div><p>
                A patchfile can contain the differences to various individual 
                documents. For example, the following command does that ...
            </p><pre class="programlisting">
            
    cd src
    svn diff &gt; $WORK/castor/patch/src.dir.diff
            </pre><p>
                However, be careful not to go overboard with this technique. When 
                producing multiple diffs in one patchfile, try to limit it to one 
                particular topic, i.e when fixing the same broken external link in 
                various pages, then it would be fine to produce a single diff. 
                Consider the committer - they will find it hard to apply your patch 
                if it also attempts to fix other things.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension.diff-other"></a>3.9.3.6.5.2.&nbsp;Other ways of obtaining source for diff comparison</h6></div></div></div><p>
                Ideally you will prepare your patches against a SVN repository. 
                There are other ways to do this. They do create more work for the 
                committers, however it may be the only way that you can do it. 
                We would certainly rather receive your patch however it comes. 
                As a matter of fact, we would politely ask you first to send us a 
                unified patch.
            </p><p>
                You could get the source document via the web interface to SVN. 
                Here are the steps ...
            </p><div class="itemizedlist"><ul type="disc"><li><p>get the relevant XML file via FishEye</p></li><li><p>
                        save the file to your local disk: 
                        <code class="code">./jdo-howto.xml.orig</code>
                    </p></li><li><p>
                        create a copy of the file: <code class="code">./jdo-howto.xml</code>
                    </p></li><li><p>make your modifications and validate the XML</p></li><li><p>
                        use the "<span><strong class="command">diff</strong></span>" command 
                        (i.e. not 'cvs diff') as follows
                    </p></li><li><p>
                        <code class="code">diff -u jdo-howto.xml.orig jdo-howto.xml &gt; 
                        $WORK/castor/patch/jdo-howto.xml.diff</code>
                    </p></li><li><p>proceed as for Step 5.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.tips"></a>3.9.3.6.6.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    Please review your diffs before you submit your patch to JIRA
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.references"></a>3.9.3.6.7.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    The UNIX manual pages '<span><strong class="command">man diff</strong></span>' and 
                    '<span><strong class="command">man patch</strong></span>'.
                </p></li><li><p>
		            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">SVN Home</a> 
		            - many useful SVN related items
                </p></li></ul></div></div></div>

	      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e6447"></a>3.9.3.7.&nbsp;How to Contribute a Patch via Jira</h4></div></div></div></div>
	  </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.oql"></a>3.9.4.&nbsp;OQL</h3></div></div></div>
          
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-limit-clause"></a>3.9.4.1.&nbsp;How to use a LIMIT clause with OQL</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.overview"></a>3.9.4.1.1.&nbsp;Overview</h5></div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.intended-audience"></a>3.9.4.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to execute an OQL statement and limit the result size.
        </p><p>
            The example given describes the addition of LIMIT/OFFEST clauses to an 
            existing OQL statement.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.prerequisites"></a>3.9.4.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for two Java classes 
            <code class="classname">Product</code> and <code class="classname">ProductGroup</code>, 
            similar to the following one:
        </p><pre class="programlisting">
        
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product 
{
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name; 

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price; 

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}
        </pre><p>
            The following fragment shows the Java class declaration for the 
            <code class="classname">ProductGroup</code> class:
        </p><pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.steps"></a>3.9.4.1.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.obtain-all-productgroup-instances"></a>3.9.4.1.4.1.&nbsp;Compose an OQL statement to obtain all ProductGroup instances</h6></div></div></div><p>
                The following code fragment shows an OQL query to select the all 
                <code class="classname">ProductGroup</code> instances.
            </p><pre class="programlisting">
            
OQLQuery query = db.getOQLQuery(<span class="hl-string">"select product from ProductGroup product"</span>);
query.bind(10);
OQLResults results = query.execute();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.add-limit"></a>3.9.4.1.4.2.&nbsp;Add LIMIT clause to OQL statement</h6></div></div></div><p>
                The following code fragment shows the same OQL query as above, to 
                this time the LIMIT keyword is added to select the first 10 
                <code class="classname"></code> instances only.
            </p><pre class="programlisting">
            
    OQLQuery query = db.getOQLQuery(
            <span class="hl-string">"select product from ProductGroup product LIMIT $1"</span>);
    query.bind(10);
    OQLResults results = query.execute();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.add-offset"></a>3.9.4.1.4.3.&nbsp;Add OFFSET clause to OQL statement</h6></div></div></div><p>
                Below is the same OQL query again, restricting the number of 
                <code class="classname">ProductGroup</code> instances returned to 10, though 
                this time it is specified that the <code class="classname">ProductGroup</code> 
                instances 101 to 110 should be returned.
            </p><pre class="programlisting">
            
OQLQuery query = db.getOQLQuery(
        <span class="hl-string">"select product from ProductGroup as product LIMIT $1 OFFSET $2"</span>);
query.bind(10);
query.bind(100);
OQLResults results = query.execute();
            </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.limitations"></a>3.9.4.1.5.&nbsp;Limitations</h5></div></div></div><p>The following RDBMS fully/partially support LIMIT/OFFSET clauses.</p><div class="table"><a name="d4e6495"></a><p class="title"><b>Table&nbsp;3.9.&nbsp;Support for LIMIT in RDBMS</b></p><div class="table-contents"><table summary="Support for LIMIT in RDBMS" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left"><span class="application">RDBMS</span></th><th>LIMIT</th><th>OFFSET</th></tr></thead><tbody><tr><td><span class="application">postgreSQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">mySQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">Oracle 1) 2)</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">HSQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">MS SQL</span></td><td>Yes</td><td>-</td></tr><tr><td><span class="application">DB2</span></td><td>Yes</td><td>-</td></tr></tbody></table></div></div><br class="table-break"><p>
            1) Caster has full support for LIMIT/OFFSET clauses for Oracle 
            Releases 8.1.6 and later.
        </p><p>
            2) For the LIMIT/OFFSET clauses to work properly the OQL query is required 
            to include an ORDER BY clause.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.tips"></a>3.9.4.1.6.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    In the case a RDBMS does not support LIMIT/OFFSET clauses, a 
                    <code class="literal">SyntaxNotSupportedException</code> will be thrown.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.references"></a>3.9.4.1.7.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="#advanced-jdo.oql-to-sql-translator" title="4.2.&nbsp;OQL to SQL translator">Castor JDO's 
                    OQL</a>
                </p></li></ul></div></div></div>
      </div>

      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.core-features"></a>3.9.5.&nbsp;Core features</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-a-cache"></a>3.9.5.1.&nbsp;How to use a (performance) cache with Castor</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.intended-audience"></a>3.9.5.1.1.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to enable caching for classes already mapped with 
            <span class="application">Castor JDO</span>.
        </p><p>
            This document addresses the basics to get people familiar with the basic 
            concepts and discusses some implementation details.
        </p><p>
            The example given describes the addition of a 
            <code class="literal">&lt;cache-type&gt;</code> element to an existing class mapping.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.prerequisites"></a>3.9.5.1.2.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for a Java class, similar to the 
            following one:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.steps"></a>3.9.5.1.3.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-a-cache.steps.add-cache-type-element-to-mapping"></a>3.9.5.1.3.1.&nbsp;Add &lt;cache-type&gt; element to class mapping</h6></div></div></div><p>
                Add a &lt;cache-type&gt; element as shown below, specifying the cache 
                provider to use in the 'type' attribute.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span>/&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
                This, for example, defines the 'time-limited' cache provider to be 
                used for the <code class="classname">com.xyz.MyOtherObject</code>. This cache 
                provider applies internally a time-limited least-recently-used 
                algorithm for <code class="classname">com.xyz.MyObject</code> instances.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.tips"></a>3.9.5.1.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    With the current release, performance caches also serve a dual 
                    purpose as dirty checking caches for 
                    <a href="#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">long-transactions</a>. 
                    This limitation implies that the object's duration in the 
                    performance cache determines the allowed time span of a long 
                    transaction. This might become an issue when performance caches 
                    of type '<code class="literal">count-limited</code>' or 
                    '<code class="literal">time-limited</code>' are being used, as objects will 
                    eventually be disposed. If an application tries to update an 
                    object that has been disposed from the dirty checking cache, an 
                    ObjectModifedException will be thrown.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.references"></a>3.9.5.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">Long 
                    transactions</a>
                </p></li><li><p><a href="#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">Caching</a></p></li><li><p>
                    <a href="#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">Caching 
                    and clustered environments</a>
                </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.map-enums"></a>3.9.5.2.&nbsp;How to map typesafe enumerations with Castor</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.intended-audience"></a>3.9.5.2.1.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to persist object that refer to a typesafe enumeration.
        </p><p>
            This document addresses the basics and shows an example how to map an 
            object that has a typesafe enumeration property.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.prerequisites"></a>3.9.5.2.2.&nbsp;Prerequisites</h5></div></div></div><p>
            Enumerations are a common method for ensuring data integrity, both in 
            software and in relational databases. As a platform for linking the two, 
            we added support for persisting class fields whose type is a Java typesafe 
            enumeration to <span class="application">Castor JDO</span>.
        </p><p>
            To use this new feature your typesafe enumeration should follow the enum 
            pattern commonly used and provide a static
            <code class="methodname">valueOf(String)</code> method. An enum of 
            different kinds of computer equipment may look like:
        </p><pre class="programlisting">
        
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> KindEnum {
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Map KINDS = <span class="hl-keyword">new</span> HashMap();

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum MOUSE = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Mouse"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum KEYBOARD = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Keyboard"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum COMPUTER = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Computer"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum PRINTER = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Printer"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum MONITOR = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Monitor"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> String _kind;

    <span class="hl-keyword">private</span> KindEnum(<span class="hl-keyword">final</span> String kind) {
        _kind = kind;
        KINDS.put(kind, <span class="hl-keyword">this</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> KindEnum valueOf(<span class="hl-keyword">final</span> String kind) {
	    <span class="hl-keyword">return</span> (KindEnum) KINDS.get(kind);
    }

    <span class="hl-keyword">public</span> String toString() { <span class="hl-keyword">return</span> _kind; }
}
        </pre><p>
            At your <code class="classname">Product</code> class you may want to have a 
            property that tells you what kind of computer equipment a product is of.
        </p><pre class="programlisting">
        
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>         _id;
    <span class="hl-keyword">private</span> String      _name;
    <span class="hl-keyword">private</span> KindEnum    _kind;
    
    <span class="hl-keyword">public</span> Product() { }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { <span class="hl-keyword">return</span> _id; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { _id = id; }

    <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> _name; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { _name = name; }

    <span class="hl-keyword">public</span> KindEnum getKind() { <span class="hl-keyword">return</span> _kind; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setKind(KindEnum kind) { _kind = kind; }
}
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.steps"></a>3.9.5.2.3.&nbsp;Steps</h5></div></div></div><p>
            Your mapping for the <code class="classname">Product</code> class should be:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">description</span>&gt;Product with kind enum&lt;<span class="hl-tag">/description</span>&gt;
  &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"enum_prod"</span>/&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"kind"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"KindEnum"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"kind"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.tips"></a>3.9.5.2.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                   To add this new feature we added an additional check when searching 
                   for field types. Like before <span class="application">Castor</span> 
                   first searches for know types and thereafter for a mapping for 
                   the class you specified as type. If both of them do not match it 
                   now checks if the class specified as type is available at classpath 
                   and has a static <code class="methodname">valueOf(String)</code> method. 
                   Only if all of this conditions are met it will be viewed as a 
                   valid mapping.
               </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-connection-proxies"></a>3.9.5.3.&nbsp;How to use Castor JDO's connection proxies</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.introduction"></a>3.9.5.3.1.&nbsp;Introduction</h5></div></div></div><p>
            <span class="application">Castor JDO</span> uses the 
            <span class="application">Jakarta Common's Logging</span> package for output 
            information relevant to the execution of a specific JDO operations to a 
            log file. The information output historically included the SQL statements 
            used by <span class="application">Castor</span> to execute the various 
            persistence operations such as loading or updating domain entities. 
            Unfortunately, the SQL statements logged did not include any information 
            about the parameters being bound to the prepared statements immediately 
            before execution, and hence made it very hard for users of 
            <span class="application">Castor JDO</span> to analyze these in the case of an 
            issue/problem.
        </p><p>
            To improve this situation, proxy classes for the 
            <span class="interface">java.sql.Connection</span> and 
            <span class="interface">java.sql.PreparedStatement</span> interfaces have been 
            added, to allow for complete and better JDBC statements to be output to 
            the log files. As this might impose a performance penalty at run-time, 
            we have allowed for this to be turned off completely through the standard 
            Castor property file. 
        </p><p>
            A new property has been added to the Castor property file 
            (<code class="filename">castor.properties</code>) to allow configuration of this 
            feature.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.intended-audience"></a>3.9.5.3.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to use the new JDBC proxy classes with 
            <span class="application">Castor JDO</span> selectively, i.e. enabling and 
            disabling their use.
        </p><p>
            The example given describes how to turn the use of the proxy classes on/off.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.prerequisites"></a>3.9.5.3.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid <code class="filename">castor.properties</code> file as 
            part of your application.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.steps"></a>3.9.5.3.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-connection-proxies.steps.enable-jdbc-classes"></a>3.9.5.3.4.1.&nbsp;Enable the use of the JDBC proxy classes</h6></div></div></div><p>
                To enable the use of the JDBC proxy classes described above, please 
                add the following section to your 
                <code class="filename">castor.properties</code> file.
            </p><pre class="programlisting">
            
  # True if JDBC proxy classes should be used to enable more detailed logging output of SQL
  # statements; false otherwise (logging of SQL statements will be turned off completely).
  #
  org.exolab.castor.persist.useProxy=true
            </pre><p>
                This instructs <span class="application">Castor JDO</span> to use the JDBC 
                proxy classes and to output full information about the SQL statements 
                used at run-time. When disabled, no logging of SQL statements will 
                occur at all.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.references"></a>3.9.5.3.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/conf-lib.html" target="_top">Configuration 
                    of Castor</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/logging/" target="_top">Jakarta 
                    Common Logging</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.cascading"></a>3.9.6.&nbsp;Cascading</h3></div></div></div>
          
              
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-cascading-operations"></a>3.9.6.1.&nbsp;How to use cascading operations</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.overview"></a>3.9.6.1.1.&nbsp;Overview</h5></div></div></div><p>
            Up to Castor 1.3.1, users of Castor JDO have been able to automatically 
            store/update or delete objects across relations by issuing ...
        </p><pre class="programlisting">
        
  Database.setAutostore(true)
        </pre><p>
            before going starting a transaction. This feature was useful, indeed, but 
            on a second look its limitation (global definition across all entities) 
            became obvious, especially on big projects. You might want to have 
            cascading operations activated selectively (activated for one object, 
            but not for another). Or even more tricky, you might like to automatically 
            track changes across one relation from a starting object, but but not 
            across another relation from the very same object.
        </p><p>
		    As of <span class="application">Castor 1.3.2</span>, a new 
		    <code class="literal">cascading</code> attribute has been introduced 
		    to the <code class="literal">&lt;sql&gt;</code> tag of the JDO mapping file.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.intended-audience"></a>3.9.6.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            This and all other cascading documents address people familiar with the 
            basic concepts of mapping domain entities to database tables and defining 
            relations between objects (on database level as well as on object level). 
            But in particular, this document applies to the following user groups:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Everyone who wants to cascade operations across (any type of) 
                    object relation(s).
                </p></li><li><p>
                    Everyone who now uses 
                    <code class="methodname">Database.setAutoStore(boolean)</code> to have 
                    persistence operations cascaded across relations.
                </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                Especially the second user group should change their approach towards 
                using cascading operations, and switch to using the new cascading 
                attribute. As of <span class="application">Castor 1.3.2</span>, the current 
                <code class="methodname">Database.setAutoStore(boolean)</code> methods will 
                be <span class="emphasis"><em>deprecated</em></span>, and in the long run, 
                this operations will be removed from the JDO interfaces.
            </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.prerequisites"></a>3.9.6.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
        	You should have a valid mapping file, containing at least two objects, 
        	being in relation with each other. For the remainder of this document, 
        	we'll be using the following example mapping file as a starting point. 
		</p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.Author"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"OneToOne_Author"</span> /&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time_stamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.Book"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"OneToOne_Book"</span> /&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time_stamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.Author"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.attribute"></a>3.9.6.1.4.&nbsp;Use of the cascading attribute</h5></div></div></div><p>
			In order to activate cascading for create operations for the 
			<span class="database">author</span> relation defined in the mapping 
			file above, you have to add the following attribute to the field mapping 
			of the <code class="literal">author</code> property:
        </p><pre class="programlisting">
	  
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Book"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
   ...
	
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Author"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre><p>
			Remember that the code above adding a cascading attribute with a value 
			of <code class="literal">create</code> is only an example. You can define any 
			combination of cascading attributes, delimiting those values by spaces, 
			as shown in the following example:
		</p><pre class="programlisting">
        
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Author"</span>&gt;
   &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create update"</span>/&gt;
&lt;<span class="hl-tag">/field</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.attribute-values"></a>3.9.6.1.5.&nbsp;Values for the cascading attribute</h5></div></div></div><p>
        	In order to achieve an optimal granulation of activating and de-activating
        	functionality, there are 5 possible values, out of which 3 can be activated 
        	separately or in any combination.
        </p><p>
        	In general, what you have to keep in mind is that some cascading types 
        	do not only affect the the (coincidentally) identically named database 
        	operation, but also other persistence operations. For more details please 
        	read the following references carefully. 
       	</p><div class="itemizedlist"><ul type="disc"><li><p>
    		        <span class="bold"><strong>create</strong></span>: 
    		        <a href="#jdo.howto.cascade-creation" title="3.9.6.2.&nbsp;How to cascade creation">details on create 
    		        operation</a>
    		    </p></li><li><p>
    		        <span class="bold"><strong>delete</strong></span>: 
    		        <a href="#jdo.howto.cascade-deletion" title="3.9.6.3.&nbsp;How to cascade deletion">details on delete 
    		        operation</a>
    		    </p></li><li><p>
    		        <span class="bold"><strong>update</strong></span>: 
    		        <a href="#jdo.howto.cascade-update" title="3.9.6.4.&nbsp;How to cascade update">details on update 
    		        operation</a>
    		    </p></li><li><p>
                    <span class="bold"><strong>none</strong></span>: cascading operations are disabled.
                </p></li><li><p>
                    <span class="bold"><strong>all</strong></span>: Using the value 
                    <code class="literal">all</code>, you are providing a shortcut specifying 
                    that all three basic operations should be defined at the same 
                    moment. This basically equals to a value of 
                    <code class="literal">'create delete update'</code>.
                </p></li></ul></div><p>
            If no cascading attribute is defined, its default value will be 
            <code class="literal">none</code>.            
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.references"></a>3.9.6.1.6.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><a href="#jdo.mapping" title="3.6.&nbsp;Castor JDO Mapping">JDO Mapping</a></p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-creation"></a>3.9.6.2.&nbsp;How to cascade creation</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.overview"></a>3.9.6.2.1.&nbsp;Overview</h5></div></div></div><p>
		    Cascading creation allows you to transfer some of the responsibilities 
		    of creating objects to <span class="application">Castor JDO</span>. 
		    To be more precise: if you enable cascading creation on a relation between 
		    two classes, all objects on one end of that relation that have not yet 
		    been created will be created when the other end gets persisted.
		    This saves you from manually creating every single object, which is 
		    especially useful when dealing with large object graphs that have 1:M 
		    (one to many) relations or many objects in a single relationship.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.enable"></a>3.9.6.2.2.&nbsp;Enabling cascading creation</h5></div></div></div><p>
            To enable cascading creation on a relation, you simply set the cascading 
            attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
            relation to "<code class="literal">create</code>" (or "<code class="literal">all</code>"):
        </p><p>
            In other words, the field mapping for the Java property 
            <span class="emphasis"><em>book</em></span> ...
        </p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>becomes</p><pre class="programlisting">
        
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
            In case of bidirectional relations, it does matters on which end you 
            enable cascading creation. It is also possible to enable it on both ends.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.scenarios"></a>3.9.6.2.3.&nbsp;Scenarios</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.db-create"></a>3.9.6.2.3.1.&nbsp;db.create()</h6></div></div></div><p>
                The most intuitive case is when you explicitly call 
                <code class="methodname">db.create()</code> on an object that has cascading 
                creation enabled on one or more of his relations. If the objects in 
                those relationships have not yet been created, they will be as part 
                of the <code class="methodname">create()</code> execution.
            </p><p>
                Here is a simple example, where the objects Author and Book are in a 
                one-to-one relation (i.e. every Book has exactly one Author):
            </p><pre class="programlisting">
			
db.begin();

Author author = <span class="hl-keyword">new</span> Author();
author.setId(1);
author.setName(<span class="hl-string">"John Jackson"</span>);

Book book = <span class="hl-keyword">new</span> Book();
book.setId(1);
book.setTitle(<span class="hl-string">"My Life"</span>);
book.setAuthor(author);

db.create(book);

db.commit();
            </pre><p>
                Once the commit operation has successfully completed, both the 
                <code class="classname">Author</code> and the <code class="classname">Book</code> 
                instance will have been persisted to your data store. To highlight 
                this, lets's have a look at the corresponding database tables 
                <span class="emphasis"><em>before</em></span> and <span class="emphasis"><em>after</em></span> the 
                execution of above code fragment.
            </p><p><span class="bold"><strong>Before</strong></span></p><p>
				</p><div class="table"><a name="d4e6783"></a><p class="title"><b>Table&nbsp;3.10.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="2">(empty table)</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
				</p><div class="table"><a name="d4e6796"></a><p class="title"><b>Table&nbsp;3.11.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="3">(empty table)</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p><span class="bold"><strong>After</strong></span></p><p>
				</p><div class="table"><a name="d4e6813"></a><p class="title"><b>Table&nbsp;3.12.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
				</p><div class="table"><a name="d4e6825"></a><p class="title"><b>Table&nbsp;3.13.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><p><br class="table-break">
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.db-commit"></a>3.9.6.2.3.2.&nbsp;db.commit()</h6></div></div></div><p>
                Cascading creation also works implicitly: any objects that are on the 
                receiving end of a cascaded relation will be created upon transaction 
                commit, provided they do not exist yet and that the object on the 
                primary end of that relation does. In other words: if you modify a 
                relation property of a loaded object, any new objects that now need 
                to be created will be created.
            </p><p>
                To demonstrate, let's continue the example from the previous section.
				We, again, have a <span class="database">Book</span> and an 
				<span class="database">Author</span>, in a one-to-one relation, 
				both already persisted. If we now change the book's author to someone 
				new, any object that is not yet in the database will be persisted 
				automatically. Just call <code class="methodname">db.commit()</code> after 
				setting the new author, and the new author will be persisted as well.
            </p><pre class="programlisting">
			
db.begin();

Author author = <span class="hl-keyword">new</span> Author();
author.setId(2);
author.setName(<span class="hl-string">"Bruce Willis"</span>);

Book book = db.load(Book.<span class="hl-keyword">class</span>, 1);
book.setAuthor(author);

db.commit();
        </pre><p>
                In terms of unit test assertions, the current state of the author and 
                book instances can be expressed as follows:
            </p><pre class="programlisting">
            
db.begin();

Book book = db.load(Book.<span class="hl-keyword">class</span>, 1);
assertNotNull(book);
assertEquals(1, book.getId());

Author author = book.getAuthor();
assertNotNull(author);
assertEquals(2, book.getId());

db.commit();</pre><p>
                As above, let's have a look at the corresponding database tables for 
                the entities <code class="classname">Author</code> and 
                <code class="classname">Book</code>: 
            </p><p><span class="bold"><strong>Before</strong></span></p><p>
				</p><div class="table"><a name="d4e6854"></a><p class="title"><b>Table&nbsp;3.14.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><p><br class="table-break">
		    </p><p>
				</p><div class="table"><a name="d4e6866"></a><p class="title"><b>Table&nbsp;3.15.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p><span class="bold"><strong>After</strong></span></p><p>
				</p><div class="table"><a name="d4e6882"></a><p class="title"><b>Table&nbsp;3.16.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr><tr><td>2</td><td>"Bruce Willis"</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
				</p><div class="table"><a name="d4e6897"></a><p class="title"><b>Table&nbsp;3.17.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>2</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
                Please note that we now have two authors stored, and that the book 
                with an id value of '1' now has a foreign key relationship to the 
                author with the id value '2'.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.collections"></a>3.9.6.2.3.3.&nbsp;Cascading create and collections</h6></div></div></div><p>
                The real benefit of using cascading for object creation shows when 
                dealing with 1:M relations, usually expressed through Java collections 
                in your entity classes.
            </p><p>
                For the remainder of this secction, we will use the Java classes 
                <code class="classname">Department</code> and <code class="classname">Employee</code>, 
                which have a 1:M relationship (in other words, every department has 
                one or more employees). On the Java side, this is expressed as the 
                <code class="classname">Department</code> having a collection of 
                <code class="classname">Employee</code> objects in form of a Java collection. 
                In the database, this will obviously be the other way around, with the 
                <span class="database">emp</span> table referencing the 
                <span class="database">dept</span> table. Every example in this 
                section will use the same database state as a starting point, as 
                shown here:
            </p><div class="table"><a name="d4e6921"></a><p class="title"><b>Table&nbsp;3.18.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e6932"></a><p class="title"><b>Table&nbsp;3.19.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>Example 1: Adding objects</strong></span></p><pre class="programlisting">
			
db.begin();

Employee employee = <span class="hl-keyword">new</span> Employee();
employee.setId(4);
employee.setName(<span class="hl-string">"George"</span>);

Department department = db.load(Department.<span class="hl-keyword">class</span>, 23);
department.getEmployees().add(employee);

db.commit();
        </pre><p><span class="bold"><strong>After</strong></span></p><div class="table"><a name="d4e6958"></a><p class="title"><b>Table&nbsp;3.20.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e6969"></a><p class="title"><b>Table&nbsp;3.21.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>23</td></tr><tr><td>4</td><td>"George"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>Example 2: Removing objects</strong></span></p><pre class="programlisting">
			
db.begin();

Department department = db.load(Department.<span class="hl-keyword">class</span>, 23);
department.getEmployees().remove(2);

db.commit();
            </pre><p><span class="bold"><strong>After</strong></span></p><div class="table"><a name="d4e6999"></a><p class="title"><b>Table&nbsp;3.22.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7010"></a><p class="title"><b>Table&nbsp;3.23.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>NULL</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                    this of course only works if you allow the employee's foreign 
                    key <span class="database">dept_id</span> to be 
                    <code class="literal">NULL</code> or, alternatively, also delete the Employee 
                    when you remove the relationship (either by manually calling 
                    <code class="methodname">db.remove()</code> or <span class="emphasis"><em>TODO</em></span>)
                </p></td></tr></table></div><p>
			    <span class="bold"><strong>Example 3: Adding &amp; removing 
			    objects</strong></span>
			</p><pre class="programlisting">
			
db.begin();

Employee e4 = <span class="hl-keyword">new</span> Employee();
e4.setId(4);
e4.setName(<span class="hl-string">"George"</span>);

Employee e5 = <span class="hl-keyword">new</span> Employee();
e5.setId(5);
e5.setName(<span class="hl-string">"Joe"</span>);

Employee e6 = <span class="hl-keyword">new</span> Employee();
e6.setId(6);
e6.setName(<span class="hl-string">"Jack"</span>);

Department dep = db.load(Department.<span class="hl-keyword">class</span>, 23);
dep.setEmployees(Arrays.asList(e4, e5, e6));

db.commit();
            </pre><p>Database after:</p><div class="table"><a name="d4e7041"></a><p class="title"><b>Table&nbsp;3.24.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7052"></a><p class="title"><b>Table&nbsp;3.25.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>NULL</td></tr><tr><td>2</td><td>"Paul"</td><td>NULL</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>NULL</td></tr><tr><td>4</td><td>"George"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>5</td><td>"Joe"</td><td>23</td></tr><tr><td>6</td><td>"Jack"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p>The note to example 2 also applies here.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.see-also"></a>3.9.6.2.4.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How to use 
					cascading operations - overview</a>
		       </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-deletion"></a>3.9.6.3.&nbsp;How to cascade deletion</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.overview"></a>3.9.6.3.1.&nbsp;Overview</h5></div></div></div><p>
		    If you enable cascading deletion on a relationship, deleting the object 
		    on one end of the relationship (i.e. calling db.remove() on the object) 
		    will also delete the object on the other end.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.enable"></a>3.9.6.3.2.&nbsp;Enabling cascading deletion</h5></div></div></div><p>
		    To enable cascading deletion on a relationship you simply set the cascading 
		    attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
		    relation to "<code class="literal">delete</code>" (or "<code class="literal">all</code>"):
		</p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"delete"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
	        In case of bidirectional relationships, be aware that it matters on which 
	        end you enable cascading deletion. It is also possible to enable it on 
	        both ends.
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.scenarios"></a>3.9.6.3.3.&nbsp;Scenarios</h5></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-deletion.scenarios.db-remove"></a>3.9.6.3.3.1.&nbsp;db.remove()</h6></div></div></div><p>
			    Let's say we have the objects Author and Book and they are in a 
			    one-to-one relationship, with every <code class="classname">Book</code> 
			    having exactly one <code class="classname">Author</code>. The database looks 
			    like this:
			</p><div class="table"><a name="d4e7115"></a><p class="title"><b>Table&nbsp;3.26.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7126"></a><p class="title"><b>Table&nbsp;3.27.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"><p>Now, since we specified the relationship to cascade deletion, if we remove the book, 
				the author gets removed too (after all, an author without a book isn't really an author).</p><pre class="programlisting">
			
db.begin();

Book b1 = db.load(Book.<span class="hl-keyword">class</span>, 1);
db.remove(db1);

db.commit();
            </pre><p>Afterwards, the database predictably looks like this:</p><div class="table"><a name="d4e7142"></a><p class="title"><b>Table&nbsp;3.28.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="2">(empty table)</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7154"></a><p class="title"><b>Table&nbsp;3.29.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="3">(empty table)</td></tr></tbody></table></div></div><br class="table-break"><p>Cascading the deletion of objects in to-many relationships works in exactly the same way.</p><p>Note: You need to explicitly invoke db.remove() to delete an object. Simply setting a relational property to NULL
				or removing an item from a collection will not remove the corresponding entity from the database, even with cascading
				deletion enabled.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.see-also"></a>3.9.6.3.4.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How to use 
					cascading operations - overview</a>
			    </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-update"></a>3.9.6.4.&nbsp;How to cascade update</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.overview"></a>3.9.6.4.1.&nbsp;Overview</h5></div></div></div><p>
			When working with long transactions, you can cascade the 
			<code class="methodname">db.update()</code> operation, so that, for example, 
			updating the root of a large object graph causes all connected entities 
			to update as well (provided cascading update is enabled on the particular 
			relationships, of course).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.enable"></a>3.9.6.4.2.&nbsp;Enabling cascading update</h5></div></div></div><p>
		    To enable cascading update on a relationship you simply set the cascading 
		    attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
		    relation to "<code class="literal">update</code>" (or "<code class="literal">all</code>"):
		</p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"update"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
            In case of bidirectional relationships, be aware that it matters on which 
            end you enable cascading update. It is also possible to enable it on both 
            ends.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.scenarios"></a>3.9.6.4.3.&nbsp;Scenarios</h5></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-update.scenarios.db-update"></a>3.9.6.4.3.1.&nbsp;db.update()</h6></div></div></div><p>
			    Let's say we have the objects Author and Book and they are in a 
			    one-to-one relationship, with every <code class="classname">Book</code> 
			    having exactly one <code class="classname">Author</code>. The database looks 
			    like this:
			</p><div class="table"><a name="d4e7200"></a><p class="title"><b>Table&nbsp;3.30.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7211"></a><p class="title"><b>Table&nbsp;3.31.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"><p>
			    Now let's change the book's title. Note that we never directly load 
			    the book and that the change happens outside of any transaction:
			</p><pre class="programlisting">
			
db.begin();
Author a1 = db.load(Author.<span class="hl-keyword">class</span>, 1);
db.commit();

a1.getBook().setName(<span class="hl-string">"My Fantastic Life"</span>);

db.begin();
db.update(a1);
db.commit();
            </pre><p>Afterwards, the database looks like this:</p><div class="table"><a name="d4e7227"></a><p class="title"><b>Table&nbsp;3.32.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7238"></a><p class="title"><b>Table&nbsp;3.33.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Fantastic Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.limitations"></a>3.9.6.4.4.&nbsp;Limitations</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>To-many relationships are currently not supported (except many-to-one).</p></li><li><p>As it is now, enabling cascading update will cause db.update() to also create any entities 
					that have not yet been persisted. (In other words: setting cascading to "update" has the same 
					effect as setting it to "update create", but only when invoking db.update().)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.see-also"></a>3.9.6.4.5.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How 
					to use cascading operations - overview</a>
			    </p></li></ul></div></div></div>
      </div>


      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.caches"></a>3.9.7.&nbsp;Caches</h3></div></div></div>
          
              
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster"></a>3.9.7.1.&nbsp;How to use Castor in a J2EE cluster</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.introduction"></a>3.9.7.1.1.&nbsp;Introduction</h5></div></div></div><p>
            With release 0.9.9, several cache providers have been added that are 
            distributed caches per se or can be configured to operate in such a mode. 
            This effectively allows <span class="application">Castor JDO</span> to be used 
            in a clustered J2EE (multi-JVM) environment, where 
            <span class="application">Castor JDO</span> runs on each of the cluster 
            instances, and where cache state is automatically synchronized between 
            these instances.
        </p><p>
            In such an environment, <span class="application">Castor JDO</span> will make 
            use of the underlying cache provider to replicate/distribute the content 
            of a specific cache between the various JDOManager instances. Through 
            the distribution mechanism of the cache provider, a client of a 
            <span class="application">Castor JDO</span> instance on one JVM will see any 
            updates made to domain objects performed against any other JVM/JDO instance.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.intended-audience"></a>3.9.7.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to use <span class="application">Castor JDO</span> in a 
            J2EE cluster.
        </p><p>
            The example given describes the use of the <span class="emphasis"><em>Coherence</em></span> 
            cache provider to enable distributed caching.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.prerequisites"></a>3.9.7.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for a Java class, similar to the 
            following one:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps"></a>3.9.7.1.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps.add-cache-type"></a>3.9.7.1.4.1.&nbsp;Add &lt;cache-type&gt; element to class mapping</h6></div></div></div><p>
                Add a <code class="literal">&lt;cache-type&gt;</code> element as shown below, 
                specifying the cache provider to use in the '<code class="literal">type</code>' 
                attribute.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"coherence"</span>/&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
                This instructs <span class="application">Castor JDO</span> to use the 
                '<code class="literal">coherence</code>' cache provider for objects of type
                <code class="classname">com.xyz.MyOtherObject</code>. It is the cache provider 
                that is responsible to distribute any changes to the cache state to 
                all other <span class="application">Castor JDO</span> instances within the 
                same cluster.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps.add-coherence-jars"></a>3.9.7.1.4.2.&nbsp;Add Coherence JARs to CLASSPATH</h6></div></div></div><p>
                Add the Coherence JARs to the class path of your e.g. web application 
                by putting the JARs into the 
                <code class="filename">WEB-INF/lib</code> folder of your 
                web application.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.references"></a>3.9.7.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><a href="#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">Caching</a></p></li><li><p>
                    <a href="#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">Caching 
                    and clustered environments</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.tangosol.com/coherence.jsp" target="_top">Tangosol 
                    Coherence</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.connection-pooling"></a>3.9.8.&nbsp;Connection pooling</h3></div></div></div>
          
        
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-jakarta-dbcp"></a>3.9.8.1.&nbsp;How to use Jakarta's DBCP for connection pooling</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.introduction"></a>3.9.8.1.1.&nbsp;Introduction</h5></div></div></div><p>
            This HOW-TO provide users with instructions on hot to configure
            <span class="application">Castor JDO</span> so that Apache Jakarta's DBCP 
            package is used as a connection pool.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.intended-audience"></a>3.9.8.1.2.&nbsp;Intended audience</h5></div></div></div><p>
            Anyone who wants to use DBCP as connection pool mechanism with 
            <span class="application">Castor JDO</span>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.steps"></a>3.9.8.1.3.&nbsp;Steps</h5></div></div></div><p>
            Below are defined the steps to configure 
            <span class="application">Castor JDO</span> to use DBCP's 
            <code class="literal">BasicDataSource</code> for connection pooling.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-jakarta-dbcp.steps.configuration"></a>3.9.8.1.3.1.&nbsp;Configuration</h6></div></div></div><p>
                To use a DBCP <code class="literal">BasicDataSource</code> with 
                <span class="application">Castor JDO</span>, please provide the following 
                <code class="literal">&lt;data-source&gt;</code> entry in the 
                <code class="filename">jdo-conf.xml</code> file.
            </p><pre class="programlisting">
            
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"min-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"40"</span> /&gt;
  &lt;<span class="hl-tag">/data-source</span>&gt;
            </pre><p>
                Above example makes use of the <span class="emphasis"><em>mySQL</em></span> JDBC driver 
                to establish a connection pool to a <span class="application">mySQL</span> 
                instance named 'test' running on the same machine as Castor itself. 
                The pool initially holds 10 connections, but is configured to allow 
                a maximum of 40 active connections at the same time.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.references"></a>3.9.8.1.4.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Other pooling examples</a>
                </p></li></ul></div></div></div>
      </div>


      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.castor-in-j2ee-apps"></a>3.9.9.&nbsp;Use of Castor in J2EE applications</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.distributed-transactions"></a>3.9.9.1.&nbsp;How to use Castor with(in) distributed J2EE transactions</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.overview"></a>3.9.9.1.1.&nbsp;Overview</h5></div></div></div><p>
            J2EE applications depend on the J2EE container (hosting Servlet, EJB, etc) 
            to configure a database connection (as well as other resource managers) 
            and use JNDI to look it up. This model allows the application deployer 
            to configure the database properties from a central place, and gives the 
            J2EE container the ability to manage distributed transactions across 
            multiple data sources.
        </p><p>
            This HOW-TO shows how to seamlessly use 
            <span class="application">Castor JDO</span> in such a managed environment, 
            and how to make <span class="application">Castor</span> participate in a 
            distributed transaction.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.intended-audience"></a>3.9.9.1.2.&nbsp;Intended audience</h5></div></div></div><p>
            Anyone who wants to use <span class="application">Castor JDO</span> with(in) 
            distributed J2EE transactions.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.steps"></a>3.9.9.1.3.&nbsp;Steps</h5></div></div></div><p>
            The following sections highlight the steps necessary to use 
            <span class="application">Castor JDO</span> seamlessly in such a (managed) 
            environment, and how to make <span class="application">Castor</span> participate 
            in a distributed transaction.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.j2ee-participation"></a>3.9.9.1.3.1.&nbsp;Make Castor participate in a J2EE transaction</h6></div></div></div><p>
                The following code fragment shows how to use JNDI to lookup a database 
                and how to use a JTA <code class="classname">UserTransaction</code> instance 
                to manage the J2EE (aka distributed) transaction:
            </p><pre class="programlisting">
<span class="hl-comment">// Lookup databse in JNDI</span>
Context ctx = <span class="hl-keyword">new</span> InitialContext();
Database db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Begin a transaction</span>
UserTransaction ut = (UserTransaction) ctx.lookup( <span class="hl-string">"java:comp/UserTransaction"</span> );
ut.begin();
<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Commit the transaction, close database</span>
ut.commit();
db.close();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.container-managed"></a>3.9.9.1.3.2.&nbsp;Make Castor participate in container-managed J2EE transaction</h6></div></div></div><p>
                If the transaction is managed by the container, a common case with 
                EJB beans and in particular entity beans, there is no need to 
                begin/commit the transaction explicitly. Instead the application 
                server takes care of enlisting the database used by 
                <span class="application">Castor JDO</span> to insert domain entities into 
                a database in the ongoing transaction and commiting/rolling back at 
                the relevant time.
            </p><p>
                The following code snippet relies on the container to manage the 
                transaction.
            </p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup databse in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Close the database</span>
db.close();
            </pre><p>
                As transaction enregistration is dealt with at the J2EE container, 
                it is not necessary anymore to obtain a 
                <code class="classname">UserTransaction</code> and start/commit the transaction 
                manually.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.resource-enlisting"></a>3.9.9.1.3.3.&nbsp;Resource enlisting</h6></div></div></div><p>
                Instead of constructing required resources directly, a typical J2EE 
                application uses the JNDI API to look up resources from centrally 
                managed place such as a naming and directory service. In such an 
                environment, <span class="application">Castor JDO</span> takes on the role 
                of a managed resource as well. It follows that, instead of constructing 
                a <code class="classname">org.exolab.castor.jdo.JDOManager</code> directly, 
                a typical J2EE application should use <span class="application">JNDI</span> 
                to look it up.
            </p><p>
                We thus recommend enlisting the <code class="classname">JDOManager</code> 
                object under the <code class="literal">java:comp/env/jdo</code> namespace, 
                compatible with the convention for listing JDBC resources.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.tips"></a>3.9.9.1.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
			        When using <span class="application">Castor JDO</span> in a J2EE 
			        environment, <span class="application">Castor</span> allows you to 
			        enable a special Database instance pooling support. 
			        This option is configured via the 
			        <code class="methodname">org.exolab.castor.jdo.JDOManager.setDatabasePooling(boolean)</code>
				    method; by default, it is turned off. This option only affects 
				    <code class="classname">JDOManager</code> if J2EE transactions are used 
				    and if a transaction is associated with the thread that calls 
				    {@link #getDatabase}.
				</p><p>
				    If database pooling is enabled, <code class="classname">JDOManager</code> 
				    will first search in this special pool to see if there is already 
				    a <code class="classname">org.exolab.castor.jdo.Database</code> instance 
				    for the current transaction. If found, it returns this 
				    <code class="classname">org.exolab.castor.jdo.Database</code> instance; 
				    if not, it creates a new one, associates it will the transaction 
				    and returns the newly created 
				    <code class="classname">org.exolab.castor.jdo.Database</code> instance.
				 </p><p>
				     Please make sure that you call this method before calling 
				     {@link #getDatabase}.
				 </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.references"></a>3.9.9.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Other pooling examples</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.database-specifica"></a>3.9.10.&nbsp;Database specifica</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e7420"></a>3.9.10.1.&nbsp;
                  How to connect to a Apache Derby instance in network server mode
              </h4></div></div></div>
              
          </div>
      </div>
  </div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.tips-tricks"></a>3.10.&nbsp;Castor JDO - Tips &amp; Tricks</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.logging-tracing"></a>3.10.1.&nbsp;Logging and Tracing</h3></div></div></div><p>
         When developing using Castor, we recommend that you use the various
         <code class="literal">setLogWriter</code> methods to get detailed information and error
         messages.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.mapping.Mapping</code> 
         will provide detailed information about mapping decisions made by Castor and
         will show the SQL statements being used.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.jdo.JDO</code> 
         will provide trace messages that show when Castor is loading, storing, 
         creating and deleting objects. All database operations will appear in 
         the log; if an object is retrieved from the cache or is not modified, 
         there will be no trace of load/store operations.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.xml.Unmarshaller</code> 
         will provide trace messages that show conflicts between the XML document and
         loaded objects.
      </p><p>
         A simple trace logger can be obtained from
         <code class="classname">org.exolab.castor.util.Logger</code>. This logger uses the
         standard output stream, but prefixes each line with a short message
         that indicates who generated it. It can also print the time and date of
         each message. Since logging is used for warning messages and simple
         tracing, Castor does not require a sophisticated logging mechanism.
      </p><p>
         Interested in integratating Castor's logging with Log4J? Then see
         <a href="#jdo.faq.logging.log4j" title="3.7.11.1.&nbsp; How can I integrate Castor's logging with a logging infrastructure using Log4J?">this question</a> 
         in the JDO FAQ.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.access-mode"></a>3.10.2.&nbsp;Access Mode</h3></div></div></div><p>
         If you are using JDO objects with the default access mode ('shared') and too many transactions
         abort when attempting to commit due to locks, you should consider upgrading to an 'exclusive'
         mode. When two transactions attempt to modify and store the same object at the same time,
         lock issues arise. Upgrading to an 'exclusive' mode will prevent concurrent transactions
         from modifying the same object at once.
      </p><p>
         If too many transactions abort when attempting to commit due to dirty checking, you should
         consider upgrading to a 'locked' mode. When external database access modifies the same objects
         being managed by Castor, Castor will complain that objects are dirty. Upgrading to a 'locked'
         mode will prevent concurrent update.
      </p><p>
         Be advised that 'exclusive' mode introduces lock contention in the Castor persistence engine,
         and 'locked' mode adds lock contention in the database. Lock contention has the effect of
         slowing down the application and consuming more CPU.
      </p><p>
         If too many transaction abort due to deadlock detection, consider modifying the application
         logic. Deadlock occurs when two transactions attempt to access the same objects but not in
         the same order.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.inheritence"></a>3.10.3.&nbsp;Inheritence</h3></div></div></div><p>
         There are two types of inheritence: Java inheritence and relational inheritence.
      </p><p>
         With Java inheritence, two objects extend the same base class and map to two different
         tables. The mapping file requires two different mappings for each of the objects.
         For example, if <code class="literal">Employee</code> and <code class="literal">Customer</code> both 
         extend <code class="literal">Person</code>, but <code class="literal">Employee</code> maps to the table 
         <code class="literal">emp</code> and <code class="literal">Person</code> to the table 
         <code class="literal">person</code>, the mapping file should map both of these objects 
         separately.
      </p><p>
         With relation inheritence, one table provides the base information and another table
         provides additional information using the same primary keys in both. Use the <code class="literal">extends</code>
         attribute to specify such inheritence in the mapping file. For example, if <code class="literal">Computer</code>
         extends <code class="literal">Product</code> and the table <code class="literal">comp</code> provides computer-specific columns
         in addition to product columns in <code class="literal">prod</code>, the mapping for <code class="literal">Computer</code> will
         specify <code class="literal">Product</code> as the extended class.
      </p><p>
         When a class just extends a generic base class or implements an interface, this form
         of inheritence is not reflected in the mapping file.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.views-of-the-same-object"></a>3.10.4.&nbsp;Views of Same Object</h3></div></div></div><p>
         It is possible to use different objects and mappings to the same tables. For example,
         it is possible to define a subset of a table and load only several of the columns,
         or load an object without its relations.
      </p><p>
         To determine the first and last names and e-mail address of an object without loading
         the entire person object, create a subset class and map that class to a portion of
         the table. Such a class cannot be used to create a new person, but can be used to
         delete or modify the person's details.
      </p><p>
         Use partial views with care. If you attempt to load the same record using a full
         object and a subset object, changes to one of these objects are allowed, but
         changes to both will result in a conflict and roll back the transaction.
         Locking will not work properly between full and subset objects.
         Also note, that each of the two objects will have its own cache, so
         if you update the first object and load the second, you may obtain old values.
         To avoid this situation you may turn off the cache for both objects:
         </p><pre class="programlisting">
             &lt;class ... &gt;
                &lt;cache-type type="none"&gt;
                ...
             &lt;/class&gt;
         </pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.upgrading-locks"></a>3.10.5.&nbsp;Upgrading Locks</h3></div></div></div><p>
         When an object is loaded into memory in the default access mode ('shared'),
         a read lock is acquired on that object. When the transaction commits, if there
         are changes to the object a write lock will be required. There is no guarantee
         that a write lock can be acquired, e.g. if another transaction attempts to
         change the same object at the same time.
      </p><p>
         To assure concurrent access, you may upgrade the object's lock by calling the
         <code class="methodname">org.exolab.castor.jdo.Database.lock(java.lang.Object)</code> 
         method. This method will either acquire a write lock or return if a timeout 
         elapses and the lock could not be acquired. Once a lock has been acquired, 
         no other transaction can attempt to read the object until the current 
         transaction completes.
      </p><p>
         Object locking is recommended only if concurrent access results in conflicts
         and aborted transactions. Generally locks results in lock contention which has an
         effect on performance.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.noclassdeffounderror"></a>3.10.6.&nbsp;NoClassDefFoundError</h3></div></div></div><p>
          Check your CLASSPATH, check it often, there is no reason not to!
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.create-method"></a>3.10.7.&nbsp;Create method</h3></div></div></div><p>
         Castor requires that classes have a public, no-argument constructor
         in order to provide the ability to marshal &amp; unmarshal objects of that type.
      </p><p>
         create-method is an optional attribute to the <code class="literal">&lt;field&gt;</code> 
         mapping element that can be used to overcome this restriction in cases where 
         you have an existing object model that consists of, say, singleton classes
         where public, no-argument constructors must not be present by definition.
      </p><p>
         Assume for example that a class "<code class="literal">A</code>" that you want to be 
         able to unmarshal uses a singleton class as one of its properties. When
         attempting to unmarshal class "<code class="literal">A</code>", you should get an 
         exception because the singleton property has no public no-arg constructor.
         Assuming that a reference to the singleton can be obtained via a static
         getInstance() method, you can add a "create method" to class 
         <code class="literal">A</code> like this:
      </p><pre class="programlisting">
         
            public MySingleton getSingletonProperty()
            {
               return MySingleton.getInstance();
            }
      </pre><p>
         and in the mapping file for class A, you can define the singleton
         property like this:
      </p><pre class="programlisting">
         
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySingletonProperty"</span>
                  <span class="hl-attribute">type</span>=<span class="hl-value">"com.u2d.MySingleton"</span>
                  <span class="hl-attribute">create-method</span>=<span class="hl-value">"getSingletonProperty"</span>&gt;
               &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my-singleton-property"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
      </pre><p>
         This illustrates how the create-method attribute is quite a useful
         mechanism for dealing with exceptional situations where you might
         want to take advantage of marshaling even when some classes do not
         have no-argument public constructors.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	        As of this writing, the specified 
	        create-method must exist as a method in the current class (i.e. the class 
	        being described by the current <code class="literal">&lt;class&gt;</code> element). 
	        In the future it may be possible to use external static factory methods.
	      </p></td></tr></table></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.advanced-features"></a>3.11.&nbsp;Castor JDO - Advanced features</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.introduction"></a>3.11.1.&nbsp;Introduction</h3></div></div></div><p>
           As explained at 
           <a href="#jdo.introduction" title="3.1.&nbsp;Castor JDO - An introduction">the introduction to Castor JDO</a>,
           Castor has support for many advanced features such as caching, depend 
           relations, inheritance, polymorphism, etc. The below sections detail these 
           features, as their understanding is required to use Castor JDO in a 
           performant and secure way.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.caching"></a>3.11.2.&nbsp;Caching</h3></div></div></div><p>
           All information related to caching and related concepts supported 
           by Castor has been consolidated into one place, and is available 
           <a href="#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">here</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.dependent-and-related"></a>3.11.3.&nbsp;Dependent and related relationships</h3></div></div></div><p>
           Castor distinguishes the relationship of two objects as dependent or related, 
           and maintains the life cycle independently for the two types of relationships. 
           Starting from Castor 0.9, the developer can explicitly define a dependent 
           relationship in the mapping file.
        </p><p>
           When using independent relations, related objects' life cycle is independent 
           of each other, meaning that they have to be created, removed and updated 
           (for long transaction) independently.
        </p><p>
           When using dependent relations, one data object class must be declared as 
           <span class="bold"><strong>depends</strong></span> on one other data object class in 
           the mapping file, and such an object is called a dependent data object class. 
           A data object class without <code class="literal">depends</code> 
           declared in the mapping is called a master object. A master object can be 
           depended upon by zero or more dependent data object class.
        </p><p>
           As of Castor 0.9, a dependent object class can be related to other master data 
           object classes including extended classes, but cannot depend on more than one 
           master class.
        </p><p>
           If an object class declared as <code class="literal">depends</code> 
           on another class, it may not be created, removed or updated separately. 
           Attempting to create, remove or update a dependent object will result in 
           ObjectNotPersistcapableException. Note that Castor doesn't allow a 
           dependent object instance to change its master object instance during a 
           transaction. Each dependent object can have only one master object. 
           Both dependent and master objects must have identities, and may or may 
           not make use of key-generators.
        </p><p>
            Here is the DTD for declaring dependent object:
            
            </p><pre class="programlisting">
&lt;!ATTLIST class     name ID  #REQUIRED
          extends   IDREF    #IMPLIED
          depends   IDREF    #IMPLIED
          identity  CDATA   #IMPLIED
          access    ( read-only | shared | exclusive | db-locked )  "shared"
          key-generator   IDREF #IMPLIED
            </pre><p>
        </p><p>
            For example,
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyDependentObject"</span>
        <span class="hl-attribute">depends</span>=<span class="hl-value">"com.xyz.MyObject"</span>&gt;
        ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
            declares the data object class 
            <code class="classname">com.xyz.MyDependentObject</code> as a dependent 
            upon class <code class="classname">com.xyz.MyObject</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.different-cardinalities"></a>3.11.4.&nbsp;Different cardinalities of relationship</h3></div></div></div><p>
           Castor supports different cardinalities of relationship, namely one-to-one, 
           one-to-many, and many-to-many. Many-to-many relationship must be related 
           rather than dependent, because each dependent object can have only one 
           master object.
        </p><p>
           Many-to-many requires a separate table for storing the relations between 
           two types of objects. Many-to-many introduces two attributes, namely 
           many-key and many-table that reside in the <code class="literal">&lt;sql&gt;</code> 
           element which is a sub-element of the <code class="literal">&lt;field&gt;</code>
           element. For all many-to-many relations, a many-table must be specified. 
           If the column name of the primary key of the class is different from the 
           foreign keys columns of the class in the relation tables, then the relation 
           table columns can be specified using the many-key attributes. Similarly, 
           if the column name of the primary key of the related class is different 
           from the foreign key columns of the related class, then the relation table 
           columns can be specified using the name attribute.
        </p><p>
            The many-table is used to store relations in a separate table
            
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span>&gt;
        &lt;<span class="hl-tag">field</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"#OPTIONAL"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"#OPTIONAL"</span>
                 <span class="hl-attribute">many-table</span>=<span class="hl-value">"#REQURIED"</span>&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
        </p><p>
            So, for example, if the SQL table is the following,

            </p><div class="table"><a name="d4e7536"></a><p class="title"><b>Table&nbsp;3.34.&nbsp;employee_table</b></p><div class="table-contents"><table summary="employee_table" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>id</th><th>name</th><th>salary</th></tr></thead><tbody><tr><td>1482</td><td>Smith, Bob</td><td>$123,456</td></tr><tr><td>628</td><td>Lee, John</td><td>$43,210</td></tr><tr><td>1926</td><td>Arnold, Pascal</td><td>$24,680</td></tr></tbody></table></div></div><p><br class="table-break">


            </p><div class="table"><a name="d4e7557"></a><p class="title"><b>Table&nbsp;3.35.&nbsp;department_table</b></p><div class="table-contents"><table summary="department_table" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>id</th><th>name</th><th>comment</th></tr></thead><tbody><tr><td>3</td><td>Accounting</td><td>&nbsp;</td></tr><tr><td>7</td><td>Engineering</td><td>The very important department. :-)</td></tr></tbody></table></div></div><p><br class="table-break">


            </p><div class="table"><a name="d4e7574"></a><p class="title"><b>Table&nbsp;3.36.&nbsp;employee_department</b></p><div class="table-contents"><table summary="employee_department" border="1"><colgroup><col><col></colgroup><thead><tr><th>e_id</th><th>d_id</th></tr></thead><tbody><tr><td>....</td><td>....</td></tr></tbody></table></div></div><p><br class="table-break">
        </p><p>
            Then, the mapping for employee data object would look like this
                </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"employee_table"</span>/&gt;
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>/&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
            &lt;<span class="hl-tag">field</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-table</span>=<span class="hl-value">"employee_department"</span>
                     <span class="hl-attribute">many-key</span>=<span class="hl-value">"e_id"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"d_id"</span>/&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"salary"</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"salary"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.lazy-loading"></a>3.11.5.&nbsp;Lazy Loading</h3></div></div></div><p>
		   As of release 0.9.6, Castor has full support for lazy loading object 
		   instances referenced as part of all relation types currently supported:
		</p><div class="itemizedlist"><ul type="disc"><li><p>1:1 relations</p></li><li><p>1:m relations</p></li><li><p>M:N relations.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.advanced-features.1-to-1-relations"></a>3.11.5.1.&nbsp;1:1 relations</h4></div></div></div><p>
        	   As of release 0.9.6, Castor supports lazy-loading of 1:1 relations. 
        	   Imagine the following class mapping:
        	</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xzy.Department"</span>&gt;
       ...
       &lt;<span class="hl-tag">field</span> <span class="hl-attribute">"employee"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
			   Per definition, when an instance of Department is loaded through e.g. 
			   Database.load(), Castor will not (pre-)load the Employee instance 
			   referenced (as such reducing the size of the initial query as well 
			   as the size of the result set returned). Only when the Emplyoee 
			   instance is accessed through Department.getEmployee(), Castor will load 
			   the actual object into memory from the persistence store.
			</p><p>
			   This means that if the Employee instance is not accessed at all, not 
			   only will the initial query to load the Department object have had its 
			   complexity reduced, but no performance penalty will be incurred for the 
			   additional access to the persistence store either.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.advanced-features.m-to-n-relations"></a>3.11.5.2.&nbsp;1:M and M:N relations</h4></div></div></div><p>
              The elements in the collection are only loaded when the application asks 
              for the object from the collection, using, for example, iterator.next(). 
              The iterator in Castor's lazy collection is optimized to return a loaded 
              object first.
           </p><p>
              In the mapping file, lazy loading is specified in the element of the 
              collection's <code class="literal">&lt;field&gt;</code>, for example,
           </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xzy.Department"</span>&gt;
       ...
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"employee"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>
               <span class="hl-attribute">collection</span>=<span class="hl-value">"collection"</span>/&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
              declares that the collection of type Employee in a Department is lazy loaded.
           </p><p>
              If lazy loading is specified for a field of a class, Castor will set the 
              field with a special collection which contains only the identities of the 
              objects. Because of that, it requires the data object to have the method 
              setDepartment( Collection department) in the data object class which was 
              not required in previous versions.
           </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                 Please note that currently <span class="bold"><strong>only</strong></span> the 
                 <span class="bold"><strong><span class="type">java.util.Collection</span></strong></span> 
	             type is supported. 
              </p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.multiple-cols-primary-keys"></a>3.11.6.&nbsp;Multiple columns primary keys</h3></div></div></div><p>
            The support of multiple column primary keys (also called compound primary 
            keys) was another major enhancement added into Castor 0.9. 
            Specifying multiple column primary keys is simple and straightforward, 
            in the mapping file, 
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"firstName lastName"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"firstName"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fname"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lastName"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lname"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
           ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
           Multiple column primary keys work with both master and dependent objects, 
           all cardinalities of relationship, including one-to-one, one-to-many and 
           many-to-many, as well as lazy loading. 
        </p><p>
           However, multiple column primary keys should only be used to adhere to an 
           existing database design, not when designing a new database. In general, 
           it is not a good idea to use an identity or identities which can be modified 
           by the user, or which contain application-visible data. For example, if the 
           system allows the user name to be changed, using user name as identity is 
           highly discouraged, as this practice can require a major data migration to 
           a new schema to update all foreign keys to adhere to a new primary key 
           structure, should the user name no longer be adequate as a primary key. 
           It should be noted that Castor doesn't support identity change, as specified 
           in the ODMG 3.0 specification. So, primary keys changes are almost certainly 
           a large trade off between data integrity and performance. Well chosen 
           primary keys are usually single (not multiple) column numeric or character 
           fields for the reasons outlined above, as well as performance, as joining 
           operations are faster for single column primary keys.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.callback-interface"></a>3.11.7.&nbsp;Callback interface for persistent operations</h3></div></div></div><p>
            For the various persistence operations as available through the 
            <span class="interface">org.exolab.castor.jdo.Database</span> interface, 
            Castor JDO provides a callback interface that informs the implementing 
            class on events taking place related to selected persistence operations.
         </p><p>
            Once your entity class implements the 
            <span class="interface">org.exolab.castor.jdo.Persistence</span> interface, 
            you'll have to provide implementations for the following methods (with 
            their respective semantics described next to them):
         </p><div class="table"><a name="d4e7628"></a><p class="title"><b>Table&nbsp;3.37.&nbsp;Interface methods</b></p><div class="table-contents"><table summary="Interface methods" border="1"><colgroup><col><col></colgroup><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>jdoAfterCreate()</td><td>
	                    Indicates that an object has been created in persistent storage.
	                </td></tr><tr><td>jdoAfterRemove()</td><td>
	                     Indicates that an object has been removed from persistent storage.
	                </td></tr><tr><td>jdoBeforeCreate()</td><td>
	                    Indicates that an object is to be created in persistent storage.
	                </td></tr><tr><td>jdoBeforeRemove()</td><td>
	                    Indicates that an object is to be removed from persistent storage.
	                </td></tr><tr><td>jdoLoad()</td><td>
	                    Indicates that the object has been loaded from persistent storage.
	                </td></tr><tr><td>jdoPersistent(Database)</td><td>
	                    Sets the database to which this object belongs when this object 
	                    becomes persistent.
	                </td></tr><tr><td>jdoStore()</td><td>Indicates that an object is to be stored in persistent storage.
	                </td></tr><tr><td>jdoTransient()</td><td>Indicates the object is now transient.</td></tr><tr><td>jdoUpdate()</td><td>
	                    Indicates that an object has been included to the current 
	                    transaction by means of db.update() method (in other words, 
	                    at the end of a "long" transaction).
	                </td></tr></tbody></table></div></div><br class="table-break"></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.self-executable-examples"></a>3.12.&nbsp;Running the self-executable Castor JDO examples</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><p>
      As of release 1.0M3, the Castor JDO examples have been packaged in a
      new way and are available for download at the
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/download.html" target="_top">download page</a>. In the 
      following sections, we explain the steps required to unpack this new archive, 
      and how to execute the tests.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.zip-archive"></a>3.12.1.&nbsp;Download the castor-$RELEASE-examples.zip archive</h3></div></div></div><p>
        In order to be able to run the new Castor JDO examples, please download
        the new <code class="literal">castor-</code>${RELEASE}<code class="literal">-examples.zip</code> from the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/download.html" target="_top">download page</a> and put it into 
        some location on your computer.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.unpack-zip"></a>3.12.2.&nbsp;Unpack the ZIP file</h3></div></div></div><p>
        To unpack the ZIP file downloaded, issue one of the following commands:
      </p><pre class="programlisting">unzip castor-1.1M2-examples.zip</pre><p>or</p><pre class="programlisting">jar xvf castor-1.1M2-examples.zip</pre><p>
        You can now run the examples using the directions provided in the
        next section.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.run"></a>3.12.3.&nbsp;Running the Castor JDO samples</h3></div></div></div><p>
        In the directory where you have unpacked the ZIP file you'll find a
        castor-1.1M2-examples.jar. In addition, you'll find a directory named
        <code class="literal">lib</code> where you'll find several JAR files required to
        run the samples.
      </p><p>To execute the samples, issue the following command:</p><pre class="programlisting">java -jar castor-1.1M2-examples.jar</pre><p>
        ... et voila ! You'll see various lines of logging output flashing
        by whilst the Castor JDO samples are executing against a database.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.what-happens"></a>3.12.4.&nbsp;What happens</h3></div></div></div><p>
        The Castor JDO sample will test persistence between a set of Java
        classes (Product, ProductGroup, ProductDetail, etc.) and perform this
        code against an Apache Derby instance as RDBMS. For this purpose, the
        sample code will start an embedded Derby instance on the fly, create
        the required tables, and then continue to execute several code
        fragments using various Castor JDO artifacts (JDOManager, Database,
        etc.) against this embedded database.
      </p><p>
        In other words, everything is self-contained and there is no need to
        install a database, create a database schema, or create database tables.
        Everything required for the tests is initiated and set up from within
        the sample code.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.hints"></a>3.12.5.&nbsp;Hints</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
	          If it is not set yet, you might have to set the 
	          <code class="literal">JAVA_HOME</code> environment variable, and add the 
	          $JAVA_HOME/bin directory to your path.
          </p></li></ul></div></div></div>
  
</div>
  
  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="advanced-jdo"></a>Chapter&nbsp;4.&nbsp;Advanced JDO</h2></div></div></div>
    



  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.caching"></a>4.1.&nbsp;Castor JDO - Caching</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.introduction"></a>4.1.1.&nbsp;Introduction</h3></div></div></div><p>
           As explained at 
           <a href="#jdo.introduction" title="3.1.&nbsp;Castor JDO - An introduction">the introduction to Castor JDO</a>,
           Castor has support for many advanced features such as caching. 
           The below sections detail the features related to caching in Castor JDO, 
           as their understanding is required to use Castor JDO in a performant and 
           secure way.
        </p><p>
           In general, performance caches enhance the application performance 
           by reducing the number of read operations against the persistence 
           storage, by storing and reusing the last read or committed values of 
           the object. Performance caches do not affect the behavior of short 
           transactions or locking. It only affects persistence objects that have 
           been released from any transactional context.
        </p><p>
           Starting from Castor 0.8.6, a performance cache implementation has been 
           added. At a technical level, Castor maintains separate (performance) caches 
           for each object type specified in the JDO mapping provided, allowing users 
           to specify - for each object type individually - the type and 
           capacity of the cache.
        </p><p>By default, the following cache types are available:</p><div class="table"><a name="d4e7716"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Available cache types</b></p><div class="table-contents"><table summary="Available cache types" border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>name</th><th>Vendor</th><th>Version</th><th>Distributable?</th><th>Open source/commercial</th><th>high volume/performance</th><th>Added in release</th></tr></thead><tbody><tr><td>none</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>unlimited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>count-limited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>time-limited</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">&nbsp;</td></tr><tr><td>coherence</td><td>
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.tangosol.com/coherence.jsp" target="_top">Tangosol 
                  Coherence</a>
                </td><td>2.5</td><td align="center">Yes</td><td>Commercial</td><td align="center">Yes</td><td align="center">0.9.9</td></tr><tr><td>jcs</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/jcs" target="_top">JCS</a></td><td>1.2.5</td><td align="center">Yes</td><td>Open source</td><td align="center">Yes</td><td align="center">0.9.9</td></tr><tr><td>fkcache</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jcache.sourceforge.net/" target="_top">FKCache</a></td><td>1.0-beta6</td><td align="center">No</td><td>Open Source</td><td align="center">No</td><td align="center">0.9.9</td></tr><tr><td>oscache</td><td>
                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.opensymphony.com/oscache/" target="_top">OSCache</a>
                </td><td>2.5</td><td align="center">Yes</td><td>Open Source</td><td align="center">No</td><td align="center">1.0</td></tr><tr><td>fifo</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">Yes</td><td align="center">1.0</td></tr><tr><td>lru</td><td>Built-in</td><td>-</td><td align="center">No</td><td>Open Source</td><td align="center">Yes</td><td align="center">1.0</td></tr><tr><td>ehcache</td><td>Built-in</td><td>-</td><td align="center">Yes</td><td>Open Source</td><td align="center">?</td><td align="center">1.0.1</td></tr><tr><td>gigaspaces</td><td><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/jcs" target="_top">JCS</a></td><td>5.0</td><td align="center">Yes</td><td>Commercial</td><td align="center">Yes</td><td align="center">1.0.1</td></tr></tbody></table></div></div><br class="table-break"><p>
           As some of these cache providers allow for allow you to use it in a 
           <span class="bold"><strong>distributed</strong></span> mode, this allows Castor 
           JDO to be used in a clustered (multi-JVM) environment. Please see the 
           section 
           <a href="#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">below</a> 
           for short summary of this feature.
        </p><p>
           Per definition, all build-in performance caches are 
           <span class="bold"><strong>write-through</strong></span>, because all 
           changes to objects as part of a transaction should be persisted into the 
           cache at commit time without delay.
        </p><p>
           For problems related to the use of performance caches, please consult with 
           the relevant entries in the 
           <a href="#jdo.faq.performance-caches" title="3.7.4.&nbsp;Castor and performance caches">JDO F.A.Q.</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.long-transactions"></a>4.1.2.&nbsp;Caching and long transactions</h3></div></div></div><p>
           As it stands currently, performance caches also serve a dual purpose 
           as dirty checking caches for 
           <a href="#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">long-transactions</a>.
           This limitation implies that the object's availability in the performance 
           cache determines the allowed time span of a long transaction.
        </p><p>
           This might become an issue when performance caches of type 'count-limited' or 
           'time-limited' are being used, where objects will eventually be disposed. 
           If an application tries to update an object that has been disposed from 
           the dirty checking cache, an ObjectModifedException will be thrown.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration"></a>4.1.3.&nbsp;Configuration</h3></div></div></div><p>
           The DTD declaration is as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">cache-type</span>  <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
<span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">cache-type</span>
    <span class="hl-attribute">type</span>           <span class="hl-attribute">(</span> <span class="hl-attribute">none</span> <span class="hl-attribute">|</span> <span class="hl-attribute">count-limited</span> <span class="hl-attribute">|</span> <span class="hl-attribute">time-limited</span> <span class="hl-attribute">|</span> <span class="hl-attribute">unlimited</span> <span class="hl-attribute">|</span>
                     <span class="hl-attribute">coherence</span> <span class="hl-attribute">|</span> <span class="hl-attribute">fkcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jcs</span> <span class="hl-attribute">|</span> <span class="hl-attribute">oscache</span> <span class="hl-attribute">|</span>
                     <span class="hl-attribute">fifo</span> <span class="hl-attribute">|</span> <span class="hl-attribute">lru</span> <span class="hl-attribute">|</span> <span class="hl-attribute">ehcache</span> <span class="hl-attribute">|</span> <span class="hl-attribute">gigaspaces</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"count-limited"</span>
    <span class="hl-attribute">debug</span>          <span class="hl-attribute">(true|false)</span> <span class="hl-attribute">"false"</span>
    <span class="hl-attribute">capacity</span>       <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED&gt;</span>

<span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">param</span> <span class="hl-attribute">EMPTY&gt;</span>
<span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">param</span>
          <span class="hl-attribute">name</span>   <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED</span>
          <span class="hl-attribute">value</span>  <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED&gt;</span></pre><p>
        </p><p>
           With release 1.0 of Castor the DTD has changed but it is backward compatible
           to the old one and allows to enable debugging of cache access for a specific
           class as well as passing individual configuration parameters to each cache
           instance. Only <span class="bold"><strong>count-limited</strong></span> and 
           <span class="bold"><strong>time-limited</strong></span> of the current
           build-in cache types support parameters. Parameter names are case sensitive 
           and are silently ignored if they are unknown to a cache type.
        </p><p>
           It need to be noted that there are 3 parameter names that are reserved for
           internal use. If you specify a parameter with one of the names: 
           <span class="bold"><strong>type</strong></span>, <span class="bold"><strong>name</strong></span> 
           or <span class="bold"><strong>debug</strong></span> their value will silently be 
           overwritten with another one used internally.
        </p><div class="example"><a name="advanced-jdo.caching.configuration.sample-count-limited"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Configuration sample - count-limited</b></p><div class="example-contents"><p>
               A <span class="bold"><strong>count-limited</strong></span> least-recently-used 
               cache (LRU) for 500 objects can be specified by:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"500"</span>/&gt;</pre><p>or</p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span>/&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"500"</span>/&gt;
&lt;<span class="hl-tag">/cache-type</span>&gt;</pre><p>
               If both, the capacity attribute and parameter with name="capacity" is
               specified, the parameter value takes precedence over the attribute 
               value.
            </p></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.sample-time-limited"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Configuration sample - time-limited</b></p><div class="example-contents"><p>
               A <span class="bold"><strong>time-limited</strong></span> first-in-first-out 
               cache (FIFO) that expires objects after 15 minutes can be specified by:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"900"</span>/&gt;</pre><p>or</p><pre class="programlisting">
&lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span>/&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"900"</span>/&gt;
&lt;<span class="hl-tag">/cache-type</span>&gt;</pre><p>
              If both, the capacity attribute and parameter with name="ttl" is 
              specified, the parameter value takes precedence over the attribute value.
           </p></div></div><br class="example-break"><p>
           The <span class="bold"><strong>debug</strong></span> attribute can be used to enable 
           debugging for objects of a single class. In addition to setting this 
           attribut to <span class="bold"><strong>true</strong></span> you also need to set 
           logging level of <span class="bold"><strong>org.castor.cache.Cache</strong></span> 
           to debug.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              The default cache-type is <code class="literal">count-limited</code> with a 
              capacity of 30. This will be used when no cache-type is specified in 
              the mapping for a class.
           </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration.fifo-lru"></a>4.1.4.&nbsp;fifo and lru cache providers</h3></div></div></div><p>
           The cache types <span class="bold"><strong>fifo</strong></span> and 
           <span class="bold"><strong>lru</strong></span> are based on a set of articles in the
           O'Reilly Network by William Grosso, to implement a simplified and 
           1.3-compatible implementation of a Hashbelt algorithm.
        </p><p>
           Hashbelts are simple, in principle. Instead of walking all objects and 
           finding out when they're supposed to expire, use a "conveyor belt" approach. 
           At any particular point in time, objects going into the cache go into the 
           front of the conveyor belt. After a certain amount of time or when the size 
           limit of a container has been reached, move the conveyor belt - put a new, 
           empty container at the front of the conveyor belt to catch new objects, and 
           the one that drops off of the end of the conveyor belt is, by definition, 
           ready for garbage collection.
        </p><p>
           As seen in his system, you can use a set of pluggable strategies to 
           implement the actual hashbelt bits. A container strategy allows you to 
           change out the implementation of the container itself - from simple 
           hashtable-based implementations, up through more complex uses of soft 
           referenced or hashset-based implementations, depending on what you need 
           and what you want it to be used for. A pluggable "expire behavior" handler 
           allows you to determine what action is taken on something which drops off 
           of the bottom of the conveyor belt.
        </p><p>
           In difference to all other cache types the 
           <span class="bold"><strong>fifo</strong></span> and 
           <span class="bold"><strong>lru</strong></span> cache types offer various configuration 
           options. Both of them have 6 parameters to configure their behaviour.
        </p><div class="table"><a name="d4e7886"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;cache types parameters</b></p><div class="table-contents"><table summary="cache types parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">parameter</th><th align="left">description</th></tr></thead><tbody><tr><td>containers</td><td>
                   The number of containers in the conveyor belt. For example: If a 
                   box will drop off of the conveyor belt every 30 seconds, and you 
                   want a cache that lasts for 5 minutes, you want 5 / 30 = 6 
                   containers on the belt. Every 30 seconds, another, clean container 
                   goes on the front of the conveyor belt, and everything in the last 
                   belt gets discarded. If not specified 10 containers are used by default.

                   For systems with fine granularity, you are free to use a large 
                   number of containers; but the system is most efficient when the 
                   user decides on a "sweet spot" determining both the number of 
                   containers to be managed on the whole and the optimal number of 
                   buckets in those containers for managing. This is ultimately a 
                   performance/accuracy tradeoff with the actual discard-from-cache 
                   time being further from the mark as the rotation time goes up. 
                   Also the number of objects discarded at once when capacity limit 
                   is reached depends upon the number of containers.
                </td></tr><tr><td>capacity</td><td>
                   Maximum capacity of the whole cache. If there are, for example, ten
                   containers on the belt and the capacity has been set to 1000, each 
                   container will hold a maximum of 1000/10 objects. Therefore if the 
                   capacity limit is reached and the last container gets droped from 
                   the belt there are up to 100 objects discarted at once. By default 
                   the capacity is set to 0 which causes capacity limit to be ignored 
                   so the cache can hold an undefined number of objects.
                </td></tr><tr><td>ttl</td><td>
                   The maximum time an object lifes in cache. If the are, for example, 
                   ten containers and ttl is set to 300 seconds (5 minutes), a new 
                   container will be put in front of the belt every 300/10 = 30 seconds 
                   while another is dropped at the end at the same time. Due to the 
                   granularity of 30 seconds, everything just until 5 minutes 30 
                   seconds will also end up in this box. The default value for ttl 
                   is 60 seconds. If ttl is set to 0 which means that objects life 
                   in cache for unlimited time and may only discarded by a capacity 
                   limit.
                </td></tr><tr><td>monitor</td><td>
                   The monitor intervall in minutes when hashbelt cache rports the 
                   current number of containers used and objects cached. If set to 0 
                   (default) monitoring is disabled.
                </td></tr><tr><td>container-class</td><td>
                   The implementation of 
                   <span class="interface">org.castor.cache.hashbelt.container.Container</span>
                   interface to be used for all containers of the cache. 
                   Castor provides the following 3 implementations of the Container 
                   interface.
                    <div class="itemizedlist"><ul type="disc"><li><p>
                           org.castor.cache.hashbelt.container.FastIteratingContainer
                        </p></li><li><p>
                          org.castor.cache.hashbelt.container.MapContainer
                        </p></li><li><p>
                          org.castor.cache.hashbelt.container.WeakReferenceContainer
                        </p></li></ul></div>
                    If not specified the MapContainer will be used as default.
                </td></tr><tr><td>reaper-class</td><td>
                   Specific reapers yield different behaviors. The GC reaper, 
                   the default, just dumps the contents to the garbage collector. 
                   However, custom implementations may want to actually do something 
                   when a bucket drops off the end; see the javadocs on other available 
                   reapers to find a reaper strategy that meets your behavior 
                   requirements. Apart of the default 
                   <code class="classname">org.castor.cache.hashbelt.reaper.NullReaper</code> we provide 
                   3 abstract implementations of 
                   <span class="interface">org.castor.cache.hashbelt.reaper.Reaper</span> interface:
                    <div class="itemizedlist"><ul type="disc"><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.NotifyingReaper
                          </code>
                        </p></li><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.RefreshingReaper
                          </code>
                        </p></li><li><p>
                          <code class="classname">
                            org.castor.cache.hashbelt.reaper.ReinsertingReaper
                          </code>
                        </p></li></ul></div>
                    to be extended by your custom implementation.
                </td></tr></tbody></table></div></div><br class="table-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-fifo"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Configuration sample - fifo</b></p><div class="example-contents"><p>
            A <span class="bold"><strong>fifo</strong></span> cache with default values 
            explained above is specified by:
          </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"fifo"</span>/&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-lru"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Configuration sample - lru</b></p><div class="example-contents"><p>
            A <span class="bold"><strong>lru</strong></span> cache with capacity=300 and 
            ttl=300 is defined by:
          </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lru"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"300"</span>/&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>or better by:</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lru"</span>&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"300"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"300"</span>/&gt;
       &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.fifo-lru.sample-fifo-customized"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Configuration sample - fifo (custommized)</b></p><div class="example-contents"><p>An example of a customized configuration of a <span class="bold"><strong>fifo</strong></span> cache is:</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
       &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"fifo"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"container"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"capacity"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ttl"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"600"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"monitor"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"container-class"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.castor.cache.hashbelt.container.WeakReferenceContainer"</span>/&gt;
          &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"reaper-class"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.castor.cache.hashbelt.reaper.NullReaper"</span>/&gt;
       &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.configuration.clustered-environments"></a>4.1.5.&nbsp;Caching and clustered environments</h3></div></div></div><p>
           All of the cache providers added with release 0.9.9 are distributed caches 
           per se or can be configured to operate in such a mode. This effectively 
           allows Castor JDO to be used in a clustered J2EE (multi-JVM) environment, 
           where Castor JDO runs on each of the cluster instances, and where cache 
           state is automatically snychronized between these instances.
        </p><p>
           In such an environment, Castor JDO wil make use of the underlying cache 
           provider to replicate/distribute the content of a specific cache between 
           the various JDOManager instances. Through the distribution mechanism of 
           the cache provider, a client of a Castor JDO instance on one JVM will see 
           any updates made to domain objects performed against any other JVM/JDO 
           instance.
        </p><div class="example"><a name="advanced-jdo.caching.configuration.sample-coherence"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Configuration sample - Coherence</b></p><div class="example-contents"><p>The following class mapping, for example, ... </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"coherence"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
               defines that for all objects of type 
               <code class="literal">com.xyz.MyOtherObject</code> Tangosol's 
               <span class="italic">Coherence</span> cache provider should 
               be used.
            </p></div></div><br class="example-break"><div class="example"><a name="advanced-jdo.caching.configuration.sample-gigaspaces"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Configuration sample - Gigaspaces</b></p><div class="example-contents"><p>The following class mapping, for example, ... </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"gigaspaces"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
               defines that for all objects of type 
               <code class="literal">com.xyz.MyOtherObject</code> the 
               <span class="italic">Gigaspaces</span> cache provider should 
               be used. As Gigspaces supports various cache and clsuer modes, this 
               cache provider allows product-specific configuration as shown below:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    ...
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span>&gt;
       ...
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"gigaspaces"</span> &gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"spaceURL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"/./"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"spaceProperties"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"useLocalCache"</span> /&gt;
        &lt;<span class="hl-tag">/cache-type</span>&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
    ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.custom-provider"></a>4.1.6.&nbsp;Custom cache provider</h3></div></div></div><p>
          As of release 0.9.6, Castor allows for the addition of user-defined cache 
          implementations. Whilst Castor provides a set of pre-built cache providers, 
          offering a variety of different cache algorithms, special needs still might
          require the application developer to implement a custom cache 
          algorithm. Castor facilitates such need by making available standardized
          interfaces and an easy to understand recipe for integrating a custom 
          cache provider with Castor.
       </p><p>
          As explained in <span class="package">org.exolab.castor.jdo.persist</span> 
          (API docs for the persists package), 
          <code class="classname">org.exolab.castor.persist.LockEngine</code> implements 
          a persistence engine that caches objects in memory for performance reasons 
          and thus reduces the number of operations against the persistence storage.
       </p><p>
          The main component of this package is the interface 
          <span class="interface">org.castor.cache.Cache</span>, which declares the external 
          functionality of a (performance) cache. Existing (and future) cache 
          implementations (have to) implement this interface, which is closely 
          modelled after the <span class="interface">java.util.Map</span> interface.
          </p><p>
          Below is a summary of the steps required to build a custom cache provider 
          and register it with Castor JDO:
       </p><p>
         </p><div class="orderedlist"><ol type="1"><li><p>
                Create a class that implements 
                <span class="interface">org.exolab.castor.persist.cache.Cache</span>.
              </p></li><li><p>
                Create a class that implements 
                <span class="interface">org.exolab.castor.persist.cache.CacheFacto</span>
              </p></li><li><p>
                Register your custom cache implementation with Castor JDO in the
                <code class="filename">castor.properties</code> file.
              </p></li></ol></div><p>
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.cache-implementation"></a>4.1.6.1.&nbsp;Cache implementation</h4></div></div></div><p>
               Please create a class that implements the interface
               <span class="interface">org.exolab.castor.persist.cache.Cache"&gt;Cache</span>.
            </p><p>
               To assist users in this task, a 
               <code class="classname">org.castor.cache.AbstractBaseCache</code> 
               class has been supplied, which users should derive their custom 
               <code class="classname">org.castor.cache.Cache</code> instances 
               from, if they wish so. Please consult existing 
               <code class="classname">org.castor.cache.Cache</code> implementations such as 
               <code class="classname">org.castor.cache.simple.TimeLimited</code>} or 
               <code class="classname">org.castor.cache.simple.CountLimited</code> 
               for code samples.
            </p><pre class="programlisting">
<span class="hl-comment">/**
 * My own cache implementation
 */</span> 
 <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomCache <span class="hl-keyword">extends</span> AbstractBaseCache {
 
    ...
    
 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.cachefactory-implementation"></a>4.1.6.2.&nbsp;CacheFactory implementation</h4></div></div></div><p>
               Please add a class that imnplements the 
               <span class="interface">org.castor.cache.CacheFactory</span> interface 
               and make sure that you provide valid values for the two 
               properties <code class="literal">name</code> and <code class="literal">className</code>.
            </p><p>
               To assist users in this task, a 
               <code class="classname">org.castor.cache.AbstractCacheFactory</code> 
               class has been supplied, which users should derive their custom 
               <span class="interface">org.castor.cache.CacheFactory</span> instances 
               from, if they wish so. Please consult existing 
               <span class="interface">org.castor.cache.CacheFactory</span> implementations 
               such as <code class="classname">org.castor.cache.simple.TimeLimitedFactory</code>} or 
               <code class="classname">org.castor.cache.simple.CountLimitedFactory</code> 
               for code samples.
            </p><pre class="programlisting">
<span class="hl-comment">/**
 * My own cache factory implementation
 */</span> 
 <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomCacheFactory <span class="hl-keyword">extends</span> AbstractCacheFactory {
 
    <span class="hl-comment">/**
     * The name of the factory
     */</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String NAME = <span class="hl-string">"custom"</span>;

    <span class="hl-comment">/**
     * Full class name of the underlying cache implementation.
     */</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CLASS_NAME = <span class="hl-string">"my.company.project.CustomCache"</span>; 
    
    <span class="hl-comment">/**
     * Returns the short alias for this factory instance.
     * @return The short alias name. 
     */</span>
    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> NAME;
    }
    
    <span class="hl-comment">/**
     * Returns the full class name of the underlying cache implementation.
     * @return The full cache class name. 
     */</span>
    <span class="hl-keyword">public</span> String getCacheClassName() {
        <span class="hl-keyword">return</span> CLASS_NAME;   
    }
    
 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.caching.custom-provider.configuration"></a>4.1.6.3.&nbsp;Configuration</h4></div></div></div><p>
               The file <code class="filename">castor.properties</code> holds a property
               <code class="literal">org.castor.cache.Factories</code> that enlists the available
               cache types through their related CacheFactory instances.
            </p><pre class="programlisting">
# 
# Cache implementations
# 
org.castor.cache.Factories=\
  org.castor.cache.simple.NoCacheFactory,\
  org.castor.cache.simple.TimeLimitedFactory,\
  org.castor.cache.simple.CountLimitedFactory,\
  org.castor.cache.simple.UnlimitedFactory,\
  org.castor.cache.distributed.FKCacheFactory,\
  org.castor.cache.distributed.JcsCacheFactory,\
  org.castor.cache.distributed.JCacheFactory,\
  org.castor.cache.distributed.CoherenceCacheFactory,\
  org.castor.cache.distributed.OsCacheFactory,\
  org.castor.cache.hashbelt.FIFOHashbeltFactory,\
  org.castor.cache.hashbelt.LRUHashbeltFactory</pre><p>
               To add your custom cache implementation, please append the 
               fully-qualified class name to this list as shown below:
            </p><pre class="programlisting">
# 
# Cache implementations
# 
org.castor.cache.Factories=\
  org.castor.cache.simple.NoCacheFactory,\
  org.castor.cache.simple.TimeLimitedFactory,\
  org.castor.cache.simple.CountLimitedFactory,\
  org.castor.cache.simple.UnlimitedFactory,\
  org.castor.cache.distributed.FKCacheFactory,\
  org.castor.cache.distributed.JcsCacheFactory,\
  org.castor.cache.distributed.JCacheFactory,\
  org.castor.cache.distributed.CoherenceCacheFactory,\
  org.castor.cache.distributed.OsCacheFactory,\
  org.castor.cache.hashbelt.FIFOHashbeltFactory,\
  org.castor.cache.hashbelt.LRUHashbeltFactory,\
  <span class="bold"><strong>org.whatever.somewhere.nevermind.CustomCache</strong></span></pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.caching.cachemanager"></a>4.1.7.&nbsp;CacheManager - monitoring and clearing caches</h3></div></div></div><p>
	     Sometimes it is necessary to interact with Castor's (performance) caches to 
         e.g.  (selectively) clear a Castor cache of its content, or inquire about 
         whether a particular object instance (as identified by its identity) is 
         cached already.
      </p><p>
	     For this purpose a 
         <code class="classname">org.exolab.castor.jdo.CacheManager</code> can 
	     be obtained from a <code class="classname">org.exolab.castor.jdo.Database</code> 
         instance by issuing the following code:
      </p><pre class="programlisting">
	  
JDO jdo = ....;
Database db = jdo.getDatabase();
CacheManager manager = db.getCacheManager();
	  </pre><p>
	     This instance can subsequently be used to selectively clear the 
         Castor performance cache using one of the following methods:
      </p><p>
	     </p><div class="itemizedlist"><ul type="disc"><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache()</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class,Object)</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class,Object[])</code>
	          </p></li><li><p>
		        <code class="methodname">org.exolab.castor.jdo.CacheManager.expireCache(Class[])</code>
	          </p></li></ul></div><p>
	  </p><p>
	     To inquire whether an object has already been cached, please use the 
         following method:
      </p><p>
	     </p><div class="itemizedlist"><ul type="disc"><li><p>
	            <code class="methodname">org.exolab.castor.jdo.CacheManager.isCached (Class, Object);</code>
	          </p></li></ul></div><p>
	  </p><p>
	     Please note that once you have closed the Database instance from which you 
         have obtained the CacheManager, the CacheManager cannot be used anymore and 
         will throw a 
	     <code class="exceptionname">org.exolab.castor.jdo.PersistenceException</code>.
	  </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.oql-to-sql-translator"></a>4.2.&nbsp;OQL to SQL translator</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.news"></a>4.2.1.&nbsp;News</h3></div></div></div><p>
               <span class="bold"><strong>Release 0.9.6</strong></span>:
               </p><div class="itemizedlist"><ul type="disc"><li><p>
                      Added support for LIMIT clause for MS SQL Server.
                    </p></li><li><p>
                      In the case a RDBMS does not support LIMIT/OFFSET clauses, a
                      SyntaxNotSupportedException is thrown.
                    </p></li><li><p>
                      Added support for a limit clause and an offset clause. 
                      Currently, only HSQL, mySQL and postgreSQL are supported.
                    </p></li><li><p>
                      Added an 
                      <a href="#advanced-jdo.oql-to-sql-translator.examples" title="4.2.10.&nbsp;Examples">example 
                      section</a>.
                    </p></li></ul></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.status"></a>4.2.2.&nbsp;Status</h3></div></div></div><p>
                The Castor OQL implementation is currently in phase 3 of development.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                This documentation is not yet finished
              </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.introduction"></a>4.2.3.&nbsp;Introduction</h3></div></div></div><p>
               This document describes an OQL to SQL translator to be added to the
               Castor JDO Java object 
               <a href="#advanced-jdo.persist.api" title="4.4.2.&nbsp;Persistence API">Persistence API</a>. 
               The translator will accept OQL queries passed as strings, and generate 
               a parse tree of the OQL. It will then traverse the tree creating the 
               appropriate SQL. The user will then be able to bind parameters to 
               parameterized queries. Type checking will be performed on the bound 
               parameters. When the user executes the query, the system will submit 
               the query to the SQL database, and then postprocess the SQL resultset 
               to create the appropriate result as a Java Object or literal. The 
               current <span class="package">org.exolab.castor.mapping</span> and
               <span class="package">org.exolab.castor.persist</span> packages will be used 
               for metadata and RDBMS communication.
            </p><p>
               Four of the (now defunct) SourceXchange milestones for this project 
               call for java source code. These milestones will be referred to here 
               as phase 1, 2, 3, and 4. There are many possible OQL features that 
               can be supported, but weren't discussed in the proposal or RFP. 
               Many of these are probably unwanted. These additional features are 
               specified as phase 5, which is out of the scope of this SourceXChange 
               project.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.overview"></a>4.2.4.&nbsp;Overview</h3></div></div></div><p>
                The parser will construct a parse tree as output from an OQL query
                string given as input. The OQL syntax is a subset of the syntax
                described in the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.odmg.org/" target="_top">ODMG 3.0</a> 
                specification section 4.12, with some additional constructs. 
                Following is a description of the supported OQL syntax, and its SQL 
                equivalent.
            </p><p>
                Certain features of OQL may not be directly translatable to SQL, but
                may still be supported, by post processing the query. For example, the
                <span class="bold"><strong>first()</strong></span> and 
                <span class="bold"><strong>last()</strong></span> collection functions supported 
                in OQL are not directly translatable to standard SQL, but a resultset 
                can be post-processed to return the appropriate values. Features 
                requiring post-processing of SQL resultsets will be documented as such
                below.
            </p><p>
               Currently the OQLQuery checks for correct syntax at the same time as
               it does type checking and other types of error checking. The new code
               will involve a multiple pass strategy, with the following passes:
               </p><div class="orderedlist"><ol type="1"><li><p>
                       Parse the String query checking for syntax errors, and return
                       a parse tree.
                    </p></li><li><p>
                       Traverse the parse tree checking for correct types, valid 
                       member and method identifiers, and use of features which are 
                       unsupported. This pass may also generate some data necessary 
                       for creating the SQL.
                    </p></li><li><p>
                       Traverse the tree one final time, creating the equivalent SQL
                       statement to the OQL Query originally passed.
                    </p></li></ol></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.syntax"></a>4.2.5.&nbsp;Syntax</h3></div></div></div><p>
               This section describes the first pass which will be done by the
               parser. The parser will create a StringTokenizer like this:
               </p><pre class="programlisting">
StringTokenizer tokenizer
    = <span class="hl-keyword">new</span> StringTokenizer(oql,
    <span class="hl-string">"\n\r\t,.()[]+-*/&lt;&gt;=:|$"</span>, true);</pre><p>
               This will create a StringTokenizer with the delimiter
               characters listed in the second argument, and it will return delimeters
               as well as tokens. The parser will also create a Vector to be used as a
               token buffer. As tokens are returned from the StringTokenizer they will 
               be added to the Vector. Older tokens will be removed from the Vector 
               when it reaches a certain size. The Vector will also be modified when 
               the StringTokenizer returns multi character operators as seperate 
               tokens, for example the -&gt; method invocation operator.
            </p><p>
               The parser will consume tokens from the StringTokenizer, generating a
               ParseTree. Each ParseTree node will have a nodeType corresponding to 
               its symbol in the OQL syntax. After each node is created it will look 
               at the next token and act acordingly, either modifying its properties 
               (i.e. for DISTINCT property of selectExpr), creating a new child node 
               or returning an error. If the error travels up to the root node of the
               ParseTree, there is a syntax error in the OQL submitted. At the end of 
               this pass, the ParseTree will contain an apropriate representation of 
               the query, which will be analyzed, and used to create SQL. Below is 
               the modified EBNF which will be the Castor OQL syntax.
            </p><p>
               </p><pre class="programlisting">
query                   ::= selectExpr
                            | expr

selectExpr              ::= <span class="bold"><strong>select</strong></span> [<span class="bold"><strong>distinct</strong></span>] 
                            projectionAttributes
                            fromClause
                            [whereClause]
                            [groupClause]
                            [orderClause]
                            [limitClause [offsetClause]]

projectionAttributes    ::= projectionList
                          | *

projectionList          ::= projection {, projection }

projection              ::= field
                          | expr [<span class="bold"><strong>as</strong></span> identifier]

fromClause              ::= <span class="bold"><strong>from</strong></span> iteratorDef {, iteratorDef}

iteratorDef             ::= identifier [ [<span class="bold"><strong>as</strong></span> ] identifier ]
                          | identifier <span class="bold"><strong>in</strong></span> identifier

whereClause             ::= <span class="bold"><strong>where</strong></span> expr

groupClause             ::= <span class="bold"><strong>group by</strong></span> fieldList {havingClause}

havingClause            ::= <span class="bold"><strong>having</strong></span> expr

orderClause             ::= <span class="bold"><strong>order by</strong></span> sortCriteria

limitClause             ::= <span class="bold"><strong>limit </strong></span> queryParam

offsetClause            ::= <span class="bold"><strong>offset</strong></span> queryParam

sortCriteria            ::= sortCriterion {, sortCriterion }

sortCriterion           ::= expr [ (<span class="bold"><strong>asc</strong></span> | <span class="bold"><strong>desc</strong></span>) ]

expr                    ::= castExpr

castExpr                ::= orExpr
                            | <span class="bold"><strong>(</strong></span> type <span class="bold"><strong>)</strong></span> castExpr

orExpr                  ::= andExpr {<span class="bold"><strong>or</strong></span> andExpr}

andExpr                 ::= quantifierExpr {<span class="bold"><strong>and</strong></span> quantifierExpr}

quantifierExpr          ::= equalityExpr
                            | <span class="bold"><strong>for all</strong></span> inClause <span class="bold"><strong>:</strong></span> equalityExpr
                            | <span class="bold"><strong>exists</strong></span> inClause <span class="bold"><strong>:</strong></span> equalityExpr

inClause                ::= identifier <span class="bold"><strong>in</strong></span> expr

equalityExpr            ::= relationalExpr
                            {(<span class="bold"><strong>=</strong></span> | <span class="bold"><strong>!=</strong></span>) 
                                [compositePredicate] relationalexpr }
                            | relationalExpr {<span class="bold"><strong>like</strong></span> relationalExpr}

relationalExpr          ::= additiveExpr
                            {(<span class="bold"><strong>&lt;</strong></span> | <span class="bold"><strong>&lt;=</strong></span> 
                                | <span class="bold"><strong>&gt;</strong></span> | <span class="bold"><strong>&gt;=</strong></span> ) 
                                    [ compositePredicate ] additiveExpr }
                                | additiveExpr <span class="bold"><strong>between</strong></span> 
                                    additiveExpr <span class="bold"><strong>and</strong></span> additiveExpr

compositePredicate      ::= <span class="bold"><strong>some</strong></span> | <span class="bold"><strong>any</strong></span> | <span class="bold"><strong>all</strong></span>

additiveExpr            ::= multiplicativeExpr
                                {<span class="bold"><strong>+</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>-</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>union</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>except</strong></span> multiplicativeExpr}
                            | multiplicativeExpr
                                {<span class="bold"><strong>||</strong></span> multiplicativeExpr}

multiplicativeExpr      ::= inExpr {<span class="bold"><strong>*</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>/</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>mod</strong></span> inExpr}
                            | inExpr {<span class="bold"><strong>intersect</strong></span> inExpr}

inExpr                  ::= unaryExpr {<span class="bold"><strong>in</strong></span> unaryExpr}

unaryExpr               ::= <span class="bold"><strong>+</strong></span> unaryExpr
                            | <span class="bold"><strong>-</strong></span> unaryExpr
                            | <span class="bold"><strong>abs</strong></span> unaryExpr
                            | <span class="bold"><strong>not</strong></span> unaryExpr
                            | postfixExpr

postfixExpr             ::= primaryExpr{<span class="bold"><strong>[</strong></span> index <span class="bold"><strong>]</strong></span>}
                            | primaryExpr
                            {(<span class="bold"><strong>.</strong></span> | <span class="bold"><strong>-&gt;</strong></span>)identifier[arglist]}

index                   ::= expr {<span class="bold"><strong>,</strong></span> expr}
                            | expr <span class="bold"><strong>:</strong></span> expr

argList                 ::= <span class="bold"><strong>(</strong></span>[ valueList ]<span class="bold"><strong>)</strong></span>

primaryExpr             ::= conversionExpr
                            | collectionExpr
                            | aggregateExpr
                            | undefinedExpr
                            | collectionConstruction
                            | identifier[ arglist ]
                            | queryParam
                            | literal
                            | <span class="bold"><strong>(</strong></span> query <span class="bold"><strong>)</strong></span>

conversionExpr          ::= <span class="bold"><strong>listtoset(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>element(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>distinct(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>flatten(</strong></span> query <span class="bold"><strong>)</strong></span>

collectionExpr          ::= <span class="bold"><strong>first(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>last(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>unique(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>exists(</strong></span> query <span class="bold"><strong>)</strong></span>

aggregateExpr           ::= <span class="bold"><strong>sum(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>min(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>max(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>avg(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>count(</strong></span>( query | * )<span class="bold"><strong>)</strong></span>

undefinedExpr           ::= <span class="bold"><strong>is_undefined(</strong></span> query <span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>is_defined(</strong></span> query <span class="bold"><strong>)</strong></span>

fieldList               ::= field {, field}

field                   ::= identifier<span class="bold"><strong>:</strong></span> expr

collectionConstruction  ::= <span class="bold"><strong>array(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>set(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>bag(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>list(</strong></span>[valueList]<span class="bold"><strong>)</strong></span>
                            | <span class="bold"><strong>list(</strong></span>listRange<span class="bold"><strong>)</strong></span>

valueList               ::= expr {, expr}

listRange               ::= expr..expr

queryParam              ::= <span class="bold"><strong>$</strong></span>[(type)]longLiteral

type                    ::= [<span class="bold"><strong>unsigned</strong></span>] <span class="bold"><strong>short</strong></span>
                            | [<span class="bold"><strong>unsigned</strong></span>] <span class="bold"><strong>long</strong></span>
                            | <span class="bold"><strong>long long</strong></span>
                            | <span class="bold"><strong>float</strong></span>
                            | <span class="bold"><strong>double</strong></span>
                            | <span class="bold"><strong>char</strong></span>
                            | <span class="bold"><strong>string</strong></span>
                            | <span class="bold"><strong>boolean</strong></span>
                            | <span class="bold"><strong>octet</strong></span>
                            | <span class="bold"><strong>enum</strong></span> [identifier.]identifier
                            | <span class="bold"><strong>date</strong></span>
                            | <span class="bold"><strong>time</strong></span>
                            | <span class="bold"><strong>interval</strong></span>
                            | <span class="bold"><strong>timestamp</strong></span>
                            | <span class="bold"><strong>set &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>bag &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>list &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>array &lt;</strong></span>type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>dictionary &lt;</strong></span>type, type<span class="bold"><strong>&gt;</strong></span>
                            | <span class="bold"><strong>identifier</strong></span>

identifier              ::= letter{letter| digit| _}

literal                 ::= booleanLiteral
                            | longLiteral
                            | doubleLiteral
                            | charLiteral
                            | stringLiteral
                            | dateLiteral
                            | timeLiteral
                            | timestampLiteral
                            | <span class="bold"><strong>nil</strong></span>
                            | <span class="bold"><strong>undefined</strong></span>

booleanLiteral          ::= <span class="bold"><strong>true</strong></span>
                            | <span class="bold"><strong>false</strong></span>

longLiteral             ::= digit{digit}

doubleLiteral           ::= digit{digit}.digit{digit}
                            [(<span class="bold"><strong>E</strong></span> | <span class="bold"><strong>e</strong></span>)[<span class="bold"><strong>+</strong></span>|<span class="bold"><strong>-</strong></span>]digit{digit}]

charLiteral             ::= 'character'

stringLiteral           ::= "{character}"

dateLiteral             ::= <span class="bold"><strong>date</strong></span>
                                'longliteral-longliteral-longliteral'

timeLiteral             ::= <span class="bold"><strong>time</strong></span>
                                'longliteral:longLiteral:floatLiteral'

timestampLiteral        ::= <span class="bold"><strong>timestamp</strong></span>
                                'longLiteral-longLiteral-longLiteral
                                longliteral:longLiteral:floatLiteral'

floatLiteral            ::= digit{digit}.digit{digit}

character               ::= letter
                            | digit
                            | special-character

letter                  ::= <span class="bold"><strong>A</strong></span>|<span class="bold"><strong>B</strong></span>|...|<span class="bold"><strong>Z</strong></span>|
                            <span class="bold"><strong>a</strong></span>|<span class="bold"><strong>b</strong></span>|...|<span class="bold"><strong>z</strong></span>

digit                   ::= <span class="bold"><strong>0</strong></span>|<span class="bold"><strong>1</strong></span>|...|<span class="bold"><strong>9</strong></span>

special-character       ::= <span class="bold"><strong>?</strong></span>|<span class="bold"><strong>_</strong></span>|<span class="bold"><strong>*</strong></span>|<span class="bold"><strong>%</strong></span>|<span class="bold"><strong>\</strong></span>
               </pre><p>
            </p><p>
              The following symbols were removed from the standard OQL Syntax for
              the following reasons:

              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="bold"><strong>andthen</strong></span>: Cannot be implemented in
                    a single SQL query. 
                  </p></li><li><p>
                    <span class="bold"><strong>orelse</strong></span>: Same as above. 
                  </p></li><li><p>
                    <span class="bold"><strong>import</strong></span>: This is advanced
                    functionality which may be added later. This phase will use the
                    castor mapping mechanism to define the namespace. 
                  </p></li><li><p>
                    Defined Queries: This is another feature
                    which can be added later. It is unclear where the queries would be
                    stored, and what their scope would be seeing as how this project
                    is an OQL to SQL translator, and not an ODBMS. 
                  </p></li><li><p>
                    iteratorDef was changed so that all
                    instances of expr were replaced by identifier. This means that the
                    from clause can only contain extent names (class names), rather
                    than any expression. This is the most common case and others could
                    create complicated SQL sub-queries or post-processing
                    requirements.
                  </p></li><li><p>
                    objectConstruction and
                    structConstruction were removed. What is the scope of the
                    constructed object or struct, and how is a struct defined in Java?
                  </p></li></ul></div><p>
            </p><p>
              The following symbols were added or modified.
              </p><div class="itemizedlist"><ul type="disc"><li><p>
                    <span class="bold"><strong>between</strong></span> added to relationalExpr.
                  </p></li><li><p>
                    Optional type specification added to
                    queryParam. 
                  </p></li></ul></div><p>
            </p><p>
	            The rest of the standard OQL syntax remains unchanged. 
	            Certain syntactically correct queries may not be supported in Castor. 
	            For example, top level expressions which do not contain a selectExpr 
	            anywhere in the query may not be supported. This will be discussed 
	            further in the next section.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.type-and-validity-checking"></a>4.2.6.&nbsp;Type and validity checking</h3></div></div></div><p>
	            The first pass over the ParseTree will do type checking, and create some
	            structures used in the SQL generation pass. It will also check whether
	            the identifiers used are valid, and whether the query uses unsupported
	            features. The following table describes each type of node in the 
	            ParseTree, and how it will be processed in the first pass.
	        </p><p>
            </p><div class="table"><a name="d4e8302"></a><p class="title"><b>Table&nbsp;4.3.&nbsp;The first pass</b></p><div class="table-contents"><table summary="The first pass" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>expr</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            A query whose top level element is an expr, rather 
			                            than a selectExpr will not be supported within the 
			                            scope of this project. These queries can either be 
			                            stated as a selectExpr, like aggregateExpr's, or 
			                            they would require post-processing of the SQL 
			                            results, like 
			                            <span class="bold"><strong>element()</strong></span>
			                            <span class="bold"><strong>first()</strong></span> and 
			                            <span class="bold"><strong>last()</strong></span>.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projectionAttributes</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
		                                select * will return a Collection of Arrays of Objects.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projectionList</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Selecting multiple fields will return a Collection 
			                            of Arrays of Objects.
		                            </p></li><li><p>
			                            When there are multiple fields selected, 
			                            a list of field names and aliases will be kept for 
			                            checking validity of expr's in the whereClause, 
			                            groupClause, and orderClause.
		                            </p></li></ul></div>
		                </td><td>Phase 5</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>Alias identifier will be stored.</p></li><li><p>
		                                 expr in projection may only be identifier, 
		                                 without an arglist.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            expr in projection may only be identifier 
			                            (with optional argList), aggregateExpr, undefinedExpr, 
			                            and postfixExpr (for selecting fields and accessors).
		                            </p></li><li><p>
			                            The subquery in aggregateExpr and undefinedExpr can be 
			                            identifier (with optional arglist), or postfixExpr for 
			                            applying these functions to fields and accessors.
		                            </p></li><li><p>
			                            If an identifier before the 
			                            <span class="bold"><strong>.</strong></span> or 
			                            <span class="bold"><strong>-&gt;</strong></span> contains an 
			                            arglist, it will be considered a SQL function, and 
			                            passed through to the RDBMS.
		                            </p></li><li><p>
			                            If the postfixExpr contains one of the above 
			                            operators, the mapping mechanism will be used 
			                            to determine if the path expression is valid 
			                            and to generate a list of required join tables, 
			                            using the manyKey and manyTable from the 
			                            JDOFieldDescriptor.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>fromClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            The class of the extent being selected from will be 
			                            stored, and ClassDescriptor objects will be 
			                            instantiated.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            expr in whereClause may onlycontain orExpr, 
			                            andExpr, equalityExpr (without compositePredicate), 
			                            relationalExpr, additiveExpr (without set operators 
			                            <span class="bold"><strong>union</strong></span> and 
			                            <span class="bold"><strong>except</strong></span>), 
			                            multiplicativeExpr (without set operator 
			                            <span class="bold"><strong>intersect</strong></span>), 
			                            unaryExpr, postFixExpr (must be only primaryExpr, 
			                            no array or property reference or method calls).
		                            </p></li><li><p>
			                            primaryExpr may only contain identifier (without an 
			                            argList), literal and queryParam. Identifier will 
			                            be checked against object name and alias in 
			                            projectionList.
		                            </p></li><li><p>
			                            For equalityExpr, relationalExpr, aditiveExpr, 
			                            multiplicativeExpr, the left side and right side 
			                            expr's must evaluate to comparable types.
		                            </p></li><li><p>
			                            For unaryExpr, simple type checking for numerical 
			                            or character based types will be performed.
		                            </p></li><li><p>
			                            If the operands for any of the relational, 
			                            equality, additive, multiplicative, or unary 
			                            operators is a query parameter, an expected type 
			                            will be determined. If the parameter included a 
			                            specified type which is incompatible with the 
			                            system determined type, an error will be generated.
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Support for built in OQL functions will be added 
			                            to the whereClause: is_defined, is_undefined.
		                            </p></li><li><p>inExpr will be supported in whereClause.</p></li><li><p>
			                            inExpr will only allow collectionConstruction for 
			                            the right side argument to 
			                            <span class="bold"><strong>in</strong></span>. No subQueries
			                            will be allowed.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            identifiers will be able to contain an 
			                            optional arglist. If the arglist is before a 
			                            <span class="bold"><strong>.</strong></span> or 
			                            <span class="bold"><strong>-&gt;</strong></span> the 
			                            identifier will be considered a SQL function and 
			                            will be passed through to the DBMS. Otherwise, 
			                            the identifier will be for an accessor method, 
			                            or a property name.
		                            </p></li><li><p>
			                            Accessor methods and property references will cause 
			                            a check through the ClassDescriptor and 
			                            FieldDescriptors for the object type, and the 
			                            required join tables.
		                            </p></li></ul></div>
		                </td><td>Phase 3</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
		                                compositePredicate will be suported in equalityExpr.
		                            </p></li><li><p>exists(query) will be supported.</p></li><li><p>
			                            quantifierExpr will support 
			                            <span class="bold"><strong>for all</strong></span> and 
			                            <span class="bold"><strong>exists</strong></span>.
		                            </p></li><li><p>
			                            Subqueries will be supported on the right side of
			                            the <span class="bold"><strong>in</strong></span> operator.
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr><tr><td>groupClause, havingClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Will identify appropriate fields
			                            in SQL schema for each expr.
		                            </p></li><li><p>aggregateExpr will be supported.</p></li><li><p>
			                            Only expr's which translate to SQL columns which 
			                            are already being selected will be supported.
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr><tr><td>orderClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            May only contain expr's which translate into SQL 
			                            columns which are already being selected.
		                            </p></li></ul></div>
		                </td><td>Phase 3</td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.sql-generation"></a>4.2.7.&nbsp;SQL Generation</h3></div></div></div><p>
            After the first pass, the ParseTree is free of errors, and ready for
            the SQL generation step. The existing implementation of the OQLParser
            uses the persistence API for SQL generation. This API lacks the
            necessary features to generate SQL from any OQL. The SQLEngine class
            which implements Persistence is used to create a JDBCQueryExpression.
            The SQL is derived from the finder, which is a JDBCQueryExpression
            produced by the SQLEngine. The problem is that the SQLEngine only
            supports single objects. It cannot generate SQL for path expressions
            like this:
            </p><pre class="programlisting">
select p.address from Person p </pre><p>

            This query requires a SQL statement like this:
            </p><pre class="programlisting">
select address.* from person, address
    where person.address_id = address.address_id</pre><p>
            The buildFinder method should not be used to generate a
            queryExpression. The SQLEngine should be used to get a ClassDescriptor,
            and to create a new QueryExpression. The OQLParser should use the
            methods in the QueryExpression to generate the SQL. The
            JDBCQueryExpression which is an implementation of QueryExpression is
            also lacking in necessary features. This class should continue to be
            used, but the following features will need to be added:
            </p><div class="variablelist"><dl><dt><span class="term">addColumn(String)</span></dt><dd><p>
	                  For adding something to select without specifying the tablename,
	                  for use with functions (i.e. select count(*))
                  </p></dd><dt><span class="term">addTable(String)</span></dt><dd><p>For when the table has to be added manually.</p></dd><dt><span class="term">addCondition(String)</span></dt><dd><p>
	                    Add a condition created outside the class, for nested 
	                    expressions, and other expressions that are not of the form 
	                    table.column op table.column.
                    </p></dd><dt><span class="term">setDistinct(boolean)</span></dt><dd><p>Used for select distinct.</p></dd><dt><span class="term">
                    addOrderColumn(String tableName, String columnName, boolean desc)
                </span></dt><dd><p>Used for order by</p></dd><dt><span class="term">addGroupExpr(String)</span></dt><dd><p>Used for group by</p></dd><dt><span class="term">addHavingExpr(String)</span></dt><dd><p>Used for having.</p></dd></dl></div><p>
        </p><p>
            The following table lists each type of tree node, and how it will be 
            processed in the SQL generation pass.
        </p><p>
            </p><div class="table"><a name="d4e8475"></a><p class="title"><b>Table&nbsp;4.4.&nbsp;SQL generation pass</b></p><div class="table-contents"><table summary="SQL generation pass" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>selectExpr</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                        distinct in the selectExpr will result in a call to
			                        setDistinct(true) in the queryExpr.
		                          </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                        The queryExpr will be populated with the columns 
			                        and tables necessary to retrieve the object. This 
			                        will use code similar to SQLEngine.addLoadSql(...).
		                          </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>projection</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            aggregateExpr and SQL functions
			                            will be passed to addColumn.
		                            </p></li><li><p>
			                            undefinedExpr will be translated to 
			                            <span class="bold"><strong>is null</strong></span> and 
			                            <span class="bold"><strong>is not null</strong></span>
		                            </p></li><li><p>
			                            postfixExpr (for selecting fields and 
			                            accessors) will result in a different group 
			                            of select expressions and "from tables" being
			                            generated.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            Entire expr in where clause will be translated, 
			                            and then added to the QueryExpr, using a single 
			                            call to addCondition(String), and multiple 
			                            calls to addTable(String).
		                            </p></li></ul></div>
		                </td><td>Phase 1</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            <span class="bold"><strong>is_defined()</strong></span>
			                             will translate into 
			                             <span class="bold"><strong>is not null</strong></span>
			                             and 
			                             <span class="bold"><strong>is_undefined()</strong></span>
			                             will translate into 
			                             <span class="bold"><strong>is null</strong></span>.
		                            </p></li><li><p>
			                            inExpr will translate directly, with the 
			                            collectionConstruction removed.
		                            </p></li></ul></div>
		                </td><td>Phase 2</td></tr><tr><td>whereClause</td><td>
		                    <div class="itemizedlist"><ul type="disc"><li><p>
			                            compositePredicate and exists(query) 
			                            translate directly to SQL.
		                            </p></li><li><p>
			                            For quantifierExpr, 
			                            <span class="bold"><strong>exists</strong></span>
			                            will translate into an exists() SQL subquery. 
			                            <span class="bold"><strong>for all</strong></span>
			                            will translate into the contrapositive(?) 
			                            exists query, for example:
		
		                            </p><pre class="programlisting">
	for all x in teachers:
	    x.name = 'Nis'</pre><p>
	                            translates to:
	                            </p><pre class="programlisting">
	not exists (select * from teachers
	    where name != 'Nis')</pre><p>
		                            </p></li></ul></div>
		                </td><td>Phase 4</td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.oql-faq"></a>4.2.8.&nbsp;OQL FAQ</h3></div></div></div><p>
            Please see the <a href="#jdo.faq.oql" title="3.7.5.&nbsp;OQL">OQL section</a>
            of the JDO FAQ.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.summary"></a>4.2.9.&nbsp;Summary</h3></div></div></div><p>
            The Parser and ParseTree classes will be improved through the phases
            of this project. The top level of OQL to SQL translation will look very
            simple, like this:
            </p><pre class="programlisting">
OQLParser parser = <span class="hl-keyword">new</span> OQLParser(query);
ParseTree pt = parser.getParseTree();
pt.checkPass();
<span class="hl-comment">//the SQL generation pass</span>
_expr = pt.getQueryExpr();
            </pre><p>

            These methods will have some additional parameters passed
            for storing and retrieving data relevant to the query. Following is a
            table containing a list of what will be introduced in each coding phase
            of the project.
        </p><p>
            </p><div class="table"><a name="d4e8548"></a><p class="title"><b>Table&nbsp;4.5.&nbsp;Coding phases</b></p><div class="table-contents"><table summary="Coding phases" border="1"><colgroup><col><col></colgroup><tbody><tr><td>Phase 1</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>
		                                New parser structure which generates symbol tree
		                            </p></li><li><p>
	                                    Parser still supports only limited OQL
	                                </p></li><li><p>selected field aliases</p></li><li><p>
	                                    whereClause supports or, and, equality, 
	                                    additive, multiplicative, and unary Operators.
	                                </p></li><li><p>support for specifying parameter types</p></li><li><p>
	                                    check specified parameter type
	                                    against system determined type
	                                </p></li><li><p>specifying ordered parameters.</p></li><li><p>
		                                JDBCQueryExpression must support
		                                addCondition(String condition)
	                                </p></li></ul></div>
	                     </td></tr><tr><td>Phase 2</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>
	                                    Distinct keyword will be supported in selectExpr
	                                </p></li><li><p>
		                                aggregateExpr and undefinedExpr supported in 
		                                projection (Select statement)
	                                </p></li><li><p>isDefined, isUndefined in whereClause</p></li><li><p>inExpr in whereClause</p></li><li><p>type checking/conversion in bind()</p></li><li><p>
		                                fields and accessors in the
		                                projection. Mapping mechanism may need some additional
		                                features.
	                                </p></li><li><p>SQL functions in the projection</p></li><li><p>order by</p></li></ul></div>
	                    </td></tr><tr><td>Phase 3</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>fields and accessors in whereClause</p></li><li><p>SQL functions in the where clause</p></li></ul></div>
	                    </td></tr><tr><td>Phase 4</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>sub queries</p></li><li><p>exists()</p></li><li><p>compositePredicate</p></li><li><p>quantifierExpr's: for all and exists</p></li><li><p>group by</p></li><li><p>having</p></li></ul></div>
	                    </td></tr><tr><td>Phase 5:</td><td>
	                        <div class="itemizedlist"><ul type="disc"><li><p>expr as top level symbol</p></li><li><p>
		                                queries selecting multiple fields or as
		                                comma separated list or * 
	                                </p></li></ul></div>
	                    </td></tr></tbody></table></div></div><p><br class="table-break">
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.oql-to-sql-translator.examples"></a>4.2.10.&nbsp;Examples</h3></div></div></div><p>
          Please find below various examples of OQL queries using the Java class files 
          as outlined below.
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.oql-to-sql-translator.examples.java-class-files"></a>4.2.10.1.&nbsp;Java class files</h4></div></div></div><p>
              The following fragment shows the Java class declaration for the 
              <code class="classname">Product</code> class:
          </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product 
{
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name; 

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price; 

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}
	  </pre><p>
          The following fragment shows the Java class declaration for the 
          <code class="classname">ProductGroup</code> class:
      </p><pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.oql-to-sql-translator.limit-clause"></a>4.2.10.2.&nbsp;Limit Clause</h4></div></div></div><p>
            On a selected number of RDBMS, Castor JDO now supports the use of 
            LIMIT/OFFSET clauses.
         </p><p>
            As per this release, the following RDBMS have full/partial support for this
            feature.
         </p><div class="table"><a name="d4e8639"></a><p class="title"><b>Table&nbsp;4.6.&nbsp;Limit support</b></p><div class="table-contents"><table summary="Limit support" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">RDBMS</th><th>LIMIT</th><th>OFFSET</th></tr></thead><tbody><tr><td>postgreSQL</td><td>Yes</td><td>Yes</td></tr><tr><td>mySQL</td><td>Yes</td><td>Yes</td></tr><tr><td>Oracle - 1)2)</td><td>Yes</td><td>Yes</td></tr><tr><td>HSQL</td><td>Yes</td><td>Yes</td></tr><tr><td>MS SQL</td><td>Yes</td><td>-</td></tr><tr><td>DB2</td><td>Yes</td><td>-</td></tr></tbody></table></div></div><br class="table-break"><p>
            1) Oracle has full support for LIMIT/OFFSET clauses for release 8.1.6 and
            later.
         </p><p>
            2) For the LIMIT/OFFSET clauses to work properly the OQL query is required
			to include a ORDER BY clause.
	     </p><p>
            The following code fragment shows an OQL query that uses the LIMIT keyword 
            to select the first 10 ProductGroup instances.
         </p><pre class="programlisting">
query = db.getOQLQuery(<span class="hl-string">"select p from ProductGroup as p LIMIT $1"</span>);
query.bind(10);
         </pre><p>
            Below is the same OQL query again, restricting the number of ProductGroup instances
            returned to 10, though this time it is specified that the ProductGroup 
            instances 11 to 20 should be returned.
         </p><pre class="programlisting">
query = db.getOQLQuery (<span class="hl-string">"select p from ProductGroup as p LIMIT $1 OFFSET $2"</span>);
query.bind(10);
         </pre><p>
            In the case a RDBMS does not support LIMIT/OFFSET clauses, a 
            SyntaxNotSupportedException will be thrown.
         </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.locking"></a>4.3.&nbsp;Transaction And Locking Modes</h2></div><div><span xmlns:fo="http://www.w3.org/1999/XSL/Format" class="author"><span class="firstname">Assaf</span> <span class="surname">Arkin</span> 
            ()
            </span></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.model"></a>4.3.1.&nbsp;The JDO Model</h3></div></div></div><p>
           In order to understand how the JDO transaction model affects applications
           performance and transactional integrity, you must first understand the semantics
           of the Java Data Objects. Java Data Objects are objects loaded from and stored
           to the database, but are disassociated from the database itself. That is, once an
           object has been loaded into memory, changes to the object in memory are not
           reflect in the database until the transaction commits.
        </p><p>
           The following table shows a sample code and the state of the JDO object and
           the relevant database field:
        </p><div class="table"><a name="d4e8692"></a><p class="title"><b>Table&nbsp;4.7.&nbsp;JDO objects</b></p><div class="table-contents"><table summary="JDO objects" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Code</th><th>Object value</th><th>Record value</th></tr></thead><tbody><tr><td><code class="code">results = oql.execute();</code></td><td align="center">N/A</td><td align="center">X</td></tr><tr><td><code class="code">obj = results.next();</code></td><td align="center">X</td><td align="center">X</td></tr><tr><td><code class="code">obj.setValue( Y );</code></td><td align="center">Y</td><td align="center">X</td></tr><tr><td><code class="code">db.commit();</code></td><td align="center">Y</td><td align="center">Y</td></tr></tbody></table></div></div><br class="table-break"><p>
             Concurrency conflicts do not occur when an object is changed in memory,
             but rather when the transaction commits and changes are saved back to the
             database. No changes are saved if the transaction rolls back.
         </p><p>
             Conflicts could occur if two threads attempted to modify the same object,
             or the same thread receives two objects associated with the same database 
             record and performs different changes to each object. Castor solves these 
             issues through a transaction-object-identity association.
         </p><p>
             When the same transaction attempts to query the same database record twice,
             (e.g. as the result of two different queries) the same object is returned,
             assuring that different changes will be synchronized through the same 
             object.
         </p><p>
             When two transactions attempt to query the same database record, each 
             transaction receives a different object mapping to the same record, 
             assuring that changes done in one transaction are not visible to the 
             other transactions. Changes should only become visible when the 
             transaction commits and all its changes are made durable.
         </p><p>
             This approach places the responsibility of synchronization and deadlock 
             detection on the Castor persistence engine, easing the life of the 
             developer.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.modes"></a>4.3.2.&nbsp;Locking Modes</h3></div></div></div><p>
          Concurrent access requires use of locking to synchronize two transactions
          attempting to work with the same object. The locking mechanism has to take into
          account several possible use of objects, as well as help minimize database access
          through caching and is-modified checking.
      </p><p>
          Locking modes are declared in the <a href="#jdo.mapping.file.class-element" title="3.6.3.2.&nbsp;The <class&gt; element">
          class element</a> of the XML mapping on a per class basis.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.shared"></a>4.3.2.1.&nbsp;Access mode: Shared</h4></div></div></div><p>
           The shared mode is the default for all objects, unless otherwise specified in the
           mapping file. Shared mode allows two transactions to read the same record at the
           same time. Each transaction will get it's own view of the record as a separate
           object, to prevent in-memory changes from conflicting with each other. However,
           the values loaded from the database are the same for both transactions.
        </p><p>
           When transactions query different objects or query the same objects but for
           read-only purposes, shared access provides the most efficient means of access
           in terms of performance, utilizing record caching and eliminating lock
           contention. For example, when each transaction retrieves a different Customer
           record and all transactions retrieved the same set of Department records but
           hardly ever change them, both Customer and Department should be declared as
           having a shared lock.
        </p><p>
           However, when two transactions attempt to access the same object, modify it,
           and commit the changes, a concurrency conflict will occur. Some concurrency
           conflicts can lead to one of the transactions aborting. For example, if two
           transactions happen to load the same Account object with a balance of X,
           one adds 50 and the other adds 60, if both were allowed to commit the changes
           the new account balance will be either X+50 or X+60, but not X+110.
        </p><p>
           In the above case either exclusive or db-locked modes should be used to
           reduce potential conflicts. However exclusive and db-locked modes may cause
           the application to perform slower due to lock contention and should not be
           used as the general case. In rare cases conflicts may occur where shared
           locks are the preferred choice, e.g. when two transactions attempt to
           modify the same Department object, or somehow get hold of the same Customer
           records.
        </p><p>
           Castor detects such conflicts as they occur and uses two mechanisms to
           deal with them: write locks and deadlock detection. When a transaction commits
           Castor first tries to determine whether the object has been modified from
           it's known state (i.e. during query). If the object has not been modified,
           Castor will not attempt to store the object to the database. If the object 
           has been modified, Castor acquires a write lock on the object preventing 
           other transactions from accessing the object until the current transaction 
           completes storing all changes to the database. A write lock prevents other 
           transactions from acquiring either a write or read lock, preventing them 
           from accidentally loading a dirty image of the object.
        </p><p>
           If the second transaction has a read lock on the object, the current
           transaction will block until the second transaction releases the lock,
           either by rolling back or by not modifying its object. If the other
           transaction modifies the object and attempts to store it, a deadlock
           occurs. If both transactions have a read lock, both require a write lock in
           order to proceed and neither can proceed until the other terminates.
        </p><p>
           Castor detects such deadlock occurences and causes the second transaction
           to rollback, allowing the first transaction to commit properly. Such
           conflicts do not happen often, but when they happen some transactions will
           fail. The application developer should either be aware of the possibility
           of failing, or choose to use a more severe lock type.
        </p><p>
           Conflicts occur not just from other Castor transactions, but also from
           direct database access. Consider another application modifying the exact
           same record through direct JDBC access, or a remote server connecting to
           the same database. To detect such conflicts Castor uses a dirty checking
           mechanism.
        </p><p>
           When an object is about to be stored, Castor compares the current values
           in the database records with those known when the object was originally
           loaded from the database. Any changes are regarded as dirty fields and
           cause the transaction to rollback with the proper error message.
        </p><p>
           Not all fields are necessarily sensitive to dirty checking. The balance
           in a bank account is a sensitive field, but the date of the last transaction
           might not be. Since the date does not depend on the original value of the
           account, but on the last modification to it, dirty checking can be avoided.
        </p><p>
           A field marked with dirty="ignore" will not take part in dirty 
           checking. Furthermore, modifications to such a field will not require a 
           write lock on the object, further improving throughput. Marking fields as 
           non-dirty should be done with extreme care.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.exclusive"></a>4.3.2.2.&nbsp;Access mode: Exclusive</h4></div></div></div><p>
           The exclusive mode assures that no two transactions can use the same
           record at the same time. Exclusive mode works by acquiring a write lock in
           memory and synchronizing transactions through a lock mechanism with configured
           timeout.
        </p><p>
           Using in-memory locks, exclusive access provides some transaction synchronization
           that is efficient in terms of performance and increases the chance of a commit
           being successful. It does not, however, guarantee commit. Since the lock is
           acquired by Castor, it can be used to synchronize Castor access, but other forms
           of direct database access may still modify the database record.
        </p><p>
           When a transaction obtains an object that was specified as exclusive access
           in the mapping file or when performing a query, Castor will always obtain a
           write lock on that object. The write lock will prevent a second transaction
           from being able to access the object either for read or write, until the current
           transaction commits. If the object is already being accessed by another
           transaction, the current transaction will block until the other transaction
           commits and release the lock.
        </p><p>
           It is possible to upgrade from a shared to an exclusive lock by calling the
           <code class="methodname">org.exolab.castor.jdo.Database.lock(java.lang.Object)</code>
           method. This method can be used with shared objects when the application
           wants to assure that other transactions will be blocked and changes can be
           made to the current object.
        </p><p>
           Because direct database access can modify the same record as represented by
           an exclusive locked object, Castor uses dirty checking when updating the
           database. Dirty checking does not have a severe affect on performance, and can
           be disabled by marking all the fields of the object with dirty="ignore".
        </p><p>
           To reduce the possibility of dirty reads, Castor will always synchronize
           exclusive locked objects with the database at the beginning of a transaction.
           That is, when an object is loaded the first time in a transaction with an
           exclusive lock, Castor will retrieve a fresh copy of the object from the
           database. Castor will not, however, refresh the object if the lock is upgraded
           in the middle of a transaction using the <code class="methodname">lock</code> method.
        </p><p>
           Exclusive mode does cause lock contention and can have an affect on application
           performance when multiple transactions attempt to access the same record.
           However, when used smartly with on a small set of objects it can help reduce
           the possibility of concurrency conflicts. It can also be used to force an object
           to be loaded from the database and the cache refreshed.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.database-locked"></a>4.3.2.3.&nbsp;Access mode: Database Locked</h4></div></div></div><p>
           The locked mode performs optimistic locking using the underlying database
           engine to assure that only one transaction has access to the record.
           In addition to acquiring a write lock in memory, Castor performs a query
           with a special SQL construct (FOR UPDATE in Oracle, HOLDLOCK in Sybase)
           to guarantee access by one transaction.
        </p><p>
           In the event that the same database record will be accessed directly through
           JDBC, stored procedure, or a second machine using Castor, the only way to
           achieve object locking is through the database layer. However, such write
           locks should be cooperative, that is, other forms of database access should
           attempt to use the same locking mechanism.
        </p><p>
           In some isolation levels, when Castor acquires a write lock on the database
           it will prevent other applications from accessing the same record until the
           Castor transaction commits. However, certain isolation levels allow other 
           applications to obtain a dirty image of the record.
        </p><p>
           Write locks on the database have a severe impact on application performance.
           They incur overhead in the database manager, and increase lock contention.
           It is recommended to use database locks with care, pay extra attention to the
           isolation level being used, and follow good practices recommended by the
           database vendor with regards to such locks.
        </p><p>
           In the future long transaction will be supported. Long transactions rely on
           the dirty checking mechanism and only hold connections open for as long as
           they are required for queries. Long transactions cannot be used with database
           locking.
        </p><p>
           Locked mode must be specified for the object in the mapping file or when
           conducting the query. It is not possible to upgrade to a locked lock in the
           middle of a transaction.
        </p><p>
           Objects loaded in this mode are always synchronized with the database, that
           is, they will never be obtained from the cache and always re-loaded for each
           new transaction.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.locking.modes.read-only-queries"></a>4.3.2.4.&nbsp;Read-only Queries</h4></div></div></div><p>
           When a query is performed in read-only mode or no mode is specified and the
           object is marked as read-only in the database, Castor will return a transient
           object. The returned object will not be locked and will not participate in the
           transaction commit/rollback.
        </p><p>
           When the same object is queried twice in a transaction as read-only, Castor
           will return two separate objects, allowing the caller to modify one object
           without altering the other. Castor will utilize the cache and only perform
           one load from the database to the cache.
        </p><p>
           Read-only access is recommended only when the object is intentionally queried
           as read-only and changes to the object should not be reflected in the database.
           If the object will not be modified, or modifications will be stored in the
           database, it is recommended to use the shared mode. Shared mode allows the
           same object to be returned twice in the same transaction.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.locking.visibility-of-changes"></a>4.3.3.&nbsp;Visibility of Changes</h3></div></div></div><p>
            The visibility of changes occuring in one transaction to other transactions
            depends upon the transaction isolation level specified for the database connection.
            Whether or not the changes are visible in the current transaction depends upon the
            operation being done.
        </p><p>
            There are four types of changes, the following table summarizes the affect of
            each change in one transaction on other queries in that transaction as well
            as other transactions.
        </p><div class="table"><a name="d4e8773"></a><p class="title"><b>Table&nbsp;4.8.&nbsp;Changes</b></p><div class="table-contents"><table summary="Changes" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Type of change</th><th>Same transaction</th><th>Other transaction</th></tr></thead><tbody><tr><td>Create new object</td><td>New object is visible and will be returned from a query</td><td>New object might be visible, depending on isolation level, but access
                         is blocked until the first transaction completes</td></tr><tr><td>Delete existing object</td><td>Object is no longer visible and will not be returned from a query</td><td>Object might not be visible, depending on isolation level, but access
                         is blocked until the first transaction completes</td></tr><tr><td>setXXX()</td><td>Change is visible in object itself</td><td>Change is not visible, object is accessible depending on lock</td></tr><tr><td>update()</td><td>Change is visible in object itself</td><td>Change might be visible, depending on isolation level, object might
                         be accessible depending on lock</td></tr></tbody></table></div></div><br class="table-break"></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.persist"></a>4.4.&nbsp;Castor Persistence Architecture</h2></div><div><span xmlns:fo="http://www.w3.org/1999/XSL/Format" class="author"><span class="firstname">Assaf</span> <span class="surname">Arkin</span> 
            ()
            </span></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.layered-architecture"></a>4.4.1.&nbsp;Layered Achitecture</h3></div></div></div><p>
          The Castor persistence engine is based on a layer
          architecture allowing different APIs to be plugged on top of
          the system, and different persistence engines to be combined
          in a single environment.
        </p><div align="center"><img src="images/persistence-layered-architecture.png" align="middle"></div><p>
          At the top level are the application level APIs. These are industry standard APIs
          that allow an application to be ported in and to other environments. These APIs
          consist of interfaces as well as semantics that make them suitable for a particular
          type of applications.
        </p><p>
          At the medium level is the Castor persistence mechanism. The persistence 
          mechanism exposes itself to the application through the application level 
          APIs. These typically have a one to one mapping with the persistence 
          mechanism API. The persistence mechanism takes care of object caching and 
          rollback, locking and deadlock detection, transactional integrity, and two 
          phase commit.
        </p><p>
          At the bottom level are the Castor service providers. SPIs provide the 
          persistence and query support into a variety of persistence mechanism. 
          This version of Castor is bundled with an SQL 92 and LDAP persistence SPIs. 
          Additional SPIs can be added, for example, alternative engines streamlined 
          for Oracle, Sybase, DB2 and other databases.
        </p><p>
          This document will describe the persistence mechanism API and SPI to allow 
          for those interested in adding new top level APIs or service providers.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.api"></a>4.4.2.&nbsp;Persistence API</h3></div></div></div><p>
          The persistence mechanism is responsible for object caching and rollback, 
          locking and deadlock detection, transaction integrity and two phase commit. 
          All data access goes through the persistence mechanism. All operations are 
          performed in the context of a transaction, even if the underlying SPI does 
          not support transactions (e.g. LDAP).
        </p><p>
          The persistence API is defined in the package 
          <span class="package">org.exolab.castor.persist</span>.
          The persistence mechanism implements the 
          <span class="interface">org.exolab.castor.persist.PersistenceEngine</span>
          interface, which allows objects to be loaded, created, deleted and locked 
          in the context of a transaction. The actual implementation is obtained from
          <code class="classname">org.exolab.castor.persist.PersistenceEngineFactory</code>.
        </p><p>
          All operations are performed through the context of a transaction. 
          A transaction is required in order to properly manage locking and caching, 
          and to automatically commit or rollback objects at transaction termination 
          (write-at-commit). Persistence operations are performed through the 
          <span class="interface">org.exolab.castor.persist.TransactionContext</span>
          interface.
        </p><p>
          The actual implementation of a transaction context is specific to each 
          application API and set of SPIs. One is created from an 
          <code class="classname">org.exolab.castor.persist.XAResourceSource</code>
          which abstracts the data source for the purpose of connection pooling and 
          XA transaction enlistment. A default implementation of 
          <span class="interface">XAResource</span> is available from
          <code class="classname">org.exolab.castor.persist.XAResourceImpl</code>.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.transactions"></a>4.4.2.1.&nbsp;Transactions</h4></div></div></div><p>
           Every persistence operation is performed within the context of a transaction.
           This allows changes to objects to be saved when the transaction commits and 
           to be rolled back when the transaction aborts. Using a transactional API 
           relieves the application developer from worrying about the commit/rollback 
           phase. In addition it allows distributed transactions to be managed by a 
           transactional environment, such as an EJB server.
        </p><p>
           Each time an object is retrieved or created the operation is performed 
           in the context of a transaction and the object is recorded with the 
           transaction and locked. When the transaction completes, the modified 
           object is persisted automatically. If not all objects can be persisted, 
           the transaction rolls back. The transaction context implements full 
           two phase commit.
        </p><p>
           Each transaction sees it's own view of the objects it retrieves from 
           persistent storage. Until the transaction commit, these changes are 
           viewable only within that transaction. If the transaction rolled back, 
           the objects are automatically reverted to their state in persistent storage.
        </p><p>
           The transaction context 
           (<code class="classname">org.exolab.castor.persist.TransactionContext</code>)
           is the only mechanism by which the top level APIs can interact with the 
           persistence engine. A new transaction must be opened in order to perform 
           any operation.
        </p><p>
           A transaction context is not created directly, but through a derived class 
           that implements the proper mechanism for obtaining a new connection, 
           committing and rolling back the connection. Note that commit and rollback 
           operations are only required in a non-JTA environment. When running inside 
           a JTA environment (e.g. an EJB server), the container is responsible to 
           commit/rollback the underlying connection.
        </p><p>
           Application level APIs implement data sources that can be enlisted directly 
           with the transaction monitor through the JTA 
           <span class="interface">XAResource</span> 
           interface. A data source can be implemented using 
           <code class="classname">org.exolab.castor.persist.XAResourceSource</code>
           which serves as a factory for new transaction contexts and
           <code class="classname">org.exolab.castor.persist.XAResourceImpl</code> 
           which provides an <span class="interface">XAResource</span> implementation.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.oids-and-locks"></a>4.4.2.2.&nbsp;OIDs and Locks</h4></div></div></div><p>
           Each object participating in a transaction is associated with an object 
           identifier, or <span class="bold"><strong>OID</strong></span> 
           (<code class="classname">org.exolab.castor.persist.OID</code>). 
           The OID identifies the object through its type and identity value. 
           The identity object must be unique across all OIDs for the same object type 
           in the same persistence engine.
        </p><p>
           Each object is also associated with a lock 
           (<code class="classname">org.exolab.castor.persist.ObjectLock</code>).
           An <span class="bold"><strong>object lock</strong></span> supports read and write 
           locks with deadlock detection. Any number of transactions may acquire a 
           read lock on the object. Read lock allows the transaction to retrieve the 
           object, but not to delete or store it. Prior to deleting or storing the 
           object, the transaction must acquire a write lock. Only one transaction 
           may acquire a write lock, and a write lock will not be granted if there 
           is any read lock on the object.
        </p><p>
           If an object is loaded read-only, a read lock is acquired at the begin of 
           the load operation and realeased when the load is finished. Someone now 
           could ask why do you acquire a read lock at all if it only lasts during 
           the load operation. For an explanation we have to take a look on what 
           happens if an object is loaded. Loading one object from database may cause
           castor to load a whole tree of objects with relations to each other. 
           In the background castor may performs various queries to load all related 
           objects. For this object tree to be consistent and reflect the persistent 
           state of all the objects in the database at one point in time we need to 
           lock all objects involved in all load operations to prevent any involved 
           object to be write locked and changed by another transaction. If the load 
           operation is finished these read locks are not required anymore. On the 
           other hand, read locks are acquired to prevent an object already locked 
           in the write mode from getting the read lock.
        </p><p>
           Write locks are acquired at the begin of the load operation similar then 
           read locks. But in contrast to read locks, write locks are hold until the 
           transaction is commited or rolled back. Holding the write lock until the 
           end of the transaction is required as the changes to the objects, that 
           could happen anytime between begin and end of the transaction, are only 
           persisted if the transaction successfully commits.
        </p><p>
           If a transaction requires a read lock on an object which is write locked 
           by another transaction, or requires a write lock on an object which is read 
           or write locked by another transaction, the transaction will block until the 
           lock is released, or the lock timeout has elapsed. The lock timeout is a 
           property of the transaction and is specified in seconds. A
           <code class="classname">org.exolab.castor.persist.LockNotGrantedException</code> 
           is thrown if the lock could not be acquired within the specified timeout.
        </p><p>
           This locking mechanism can lead to the possibility of a deadlock. The object 
           lock mechanism provides automatic deadlock detection by tracking blocked 
           transactions, without depending on a lock wait to timeout.
        </p><p>
           Write locks and exclusive locks are always delegated down to the persistence 
           storage. In a distributed environment the database server itself provides 
           the distributed locking mechanism. This approach assures proper concurrency 
           control in a distributed environments where multiple application servers 
           access the same database server.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.cache-engine"></a>4.4.2.3.&nbsp;Cache Engine</h4></div></div></div><p>
           The concurrency engine includes a layer that acts as a cache engine. 
           This layer is particularly useful for implementing optimistic locking and 
           reducing synchronization with the database layer. It is also used to perform 
           dirty checks and object rollback. The cache engine is implemented in 
           <code class="classname">org.exolab.castor.persist.CacheEngine</code> and
           exposed to the application through the 
           <code class="classname">org.exolab.castor.persist.PersistenceEngine</code>.
        </p><p>
           When an object is retrieved from persistent storage it is placed in the 
           cache engine. Subsequent requests to retrieve the same object will return 
           the cached copy (with the exception of pessimistic locking, more below). 
           When the transaction commits, the cached copy will be updated with the 
           modified object. When the transaction rolls back, the object will be 
           reverted to its previous state from the cache engine.
        </p><p>
           In the event of any error or doubt, the cached copy will be dumped from 
           the cache engine. The least recently used objects will be cleared from 
           the cache periodically.
        </p><p>
           The cache engine is associated with a single persistence mechanism, 
           e.g. a database source, and LDAP directory. Proper configuration is 
           the only way to assure that all access to persistent storage goes 
           through the same cache engine.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.pessimistic-or-optimistic-locking"></a>4.4.2.4.&nbsp;Pessimistic/Optimistic Locking</h4></div></div></div><p>
           The concurrency engine works in two locking modes, based on the type of 
           access requested by the application (typically through the API). 
           Pessimistic locking are used in read-write access mode, optimistic locking 
           are used in exclusive access mode.
        </p><p>
           In <span class="bold"><strong>optimistic locking mode</strong></span> it is assumed 
           that concurrent access to the same object is rare, or that objects are 
           seldom modified. Therefore objects are retrieved with a read lock and 
           are cached in memory across transactions.
        </p><p>
           When an object is retrieved for read/write access, if a copy of the object 
           exists in the cache, that copy will be used. A read lock will be acquired 
           in the cache engine, preventing other Castor transactions from deleting or 
           modifying the object. However, no lock is acquired in persistent storage, 
           allowing other applications to delete or modify the object while the Castor 
           transaction is in progress.
        </p><p>
           To prevent inconsistency, Castor will perform 
           <span class="bold"><strong>dirty checking</strong></span> prior to storing the object, 
           detecting whether the object has been modified in persistent storage. 
           If the object has been modified outside the transaction, the transaction 
           will rollback. The application must be ready for that possibility, or 
           resort to using pessimistic locking.
        </p><p>
           In <span class="bold"><strong>pessimistic locking mode</strong></span> it is assumed 
           that concurrent access to the same object is the general case and that 
           objects are often modified. Therefore objects are retrieved with a write 
           lock and are always synchronized against the persistence storage. When 
           talking to a database server, a request to load an object in exclusive mode 
           will always load the object (unless already loaded in the same transaction)
           using a <code class="code">SELECT .. FOR UPDATE</code> which assures no other application 
           can change the object through direct access to the database server.
        </p><p>
           The locking mode is a property of the chosen access mode. The two access 
           modes as well as read-only access can be combined in a single transaction, 
           as a property of the query or object lookup. However, it is not possible 
           to combine access modes for the same object, in certain cases this will 
           lead to a conflict.
        </p><p>
           The pessimistic locking mode is not supported in LDAP and similar 
           non-transactional servers. LDAP does not provide a mechanism to lock 
           records and prevent concurrent access while they are being used in a 
           transaction. Although all Castor access to the LDAP server is properly 
           synchronized, it is possible that an external application will modify 
           or delete a record while that record is being used in a Castor transaction. 
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.relations"></a>4.4.2.5.&nbsp;Relations</h4></div></div></div><p>TBD</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.api.queryresults"></a>4.4.2.6.&nbsp;QueryResults</h4></div></div></div><p>TBD</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.spi"></a>4.4.3.&nbsp;Service Providers (SPI)</h3></div></div></div><p>
          Castor supports a service provider architecture that allows different 
          persistence storage providers to be plugged in. The default implementation 
          includes an SQL 92 provider and an and an LDAP provider. Additional 
          providers will be available optimized for a particular database server 
          or other storage mechanisms.
      </p><p>
          The service provider is defined through two interfaces, 
          <span class="interface">org.exolab.castor.persist.spi.Persistence</span>
          and <span class="interface">org.exolab.castor.persist.spi.PersistenceQuery</span>. 
          The first provides creation, deletion, update and lock services, 
          the second is used to process queries and result sets. Service providers 
          are obtained through the 
          <span class="interface">org.exolab.castor.persist.spi.PersistenceFactory</span>
          interface.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.spi.persistence"></a>4.4.3.1.&nbsp;Persistence</h4></div></div></div><p>
           The interface 
           <span class="interface">org.exolab.castor.persist.spi.Persistence</span> defines 
           the contract between the persistence mechanism and a persistence service 
           provider. Each persistence storage (i.e. database server, directory server) 
           is associated with a single persistence engine, which in turn contains a 
           number of service providers, one per object type. Service providers are 
           acquired through a 
           <span class="interface">org.exolab.castor.persist.spi.PersistenceFactory</span> 
           interface, which is asked by each persistence engine to return 
           implementations for all the object types supported by that persistence 
           engine.
        </p><p>
           The object's identity is an object that unique identifies the object within 
           persistent storage. Typically this would be the primary key on a table, or 
           an RDN for LDAP. The identity object may be a simple type (e.g. integer, 
           string) or a complex type.
        </p><p>
           The service provider may support the stamp mechanism for efficiently 
           tracking dirty objects. The stamp mechanism is a unique identifier of 
           the persistent object that changes when the object is modified in 
           persistent storage. For example, a RAWID in Oracle or TIMESTAMP in Sybase. 
           If a stamp is return by certain operations it will be stored with the 
           object's OID and passed along to the store method.
        </p><p>
           The <code class="methodname">create</code> method is called to create a new object 
           in persistent storage. This method is called when the created object's 
           identity is known. If the object's identity is not know when the object is 
           made persistent, this method will be called only when the transaction 
           commits. This method must check for duplicate identity with an already 
           persistent object, create the object in persistent storage, such that 
           successful completion of the transaction will result in durable storage, 
           and retain a write lock on that object for the duration of the transaction.
        </p><p>
           The <code class="methodname">load</code> method is called to load an object from 
           persistent storage. An object is passed with the requested identity. If the 
           object is found in persistent storage, it's values should be copied into the 
           object passed as argument. If the lock flag is set, this method must create 
           a write lock on the object at the same time it loads it.
        </p><p>
           The <code class="methodname">load</code> method is called in two cases, when an 
           object is first loaded or when an object is synchronized with the database 
           (reloaded) in exclusive access mode. In the second case this method will 
           be called with an object that is already set with values that are not 
           considered valued, and must reset these values.
        </p><p>
           The <code class="methodname">store</code> method is called to store an object into 
           persistent storage. The store method is called for an object that was loaded 
           and modified during a transaction when the transaction commits, as well as 
           for an object that was created during the transaction. This method must 
           update the object in persistent storage and retain a write lock on that 
           object.
        </p><p>
           This method might be given two views of an object, one that is being saved 
           and one that was originally loaded. If the original view is provided as 
           well, this method should attempt to perform dirty check prior to storing 
           the object. Dirty check entails a comparison of the original object against 
           the copy in persistent storage, to determine whether the object has changed 
           in persistent storage since it was originally loaded. The class descriptor 
           will indicate whether the object is interested in dirty checking and which 
           of its fields should be checked.
        </p><p>
           The <code class="methodname">delete</code> method is called to delete an object 
           from persistent storage. The delete method is called when the transaction 
           commits and expects the object to deleted, if it exists. This method is not 
           called when the transaction rolls back, objects created during the 
           transaction with the create method are automatically rolled back by the 
           persistent storage mechanism.
        </p><p>
           The <code class="methodname">writeLock</code> method is called to obtain a write 
           lock on an object for which only a read lock was previously obtained. 
           The <code class="methodname">changeIdentity</code> method is called to change 
           the identity of the object after it has been stored with the old identity.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.persist.spi.persistencequery"></a>4.4.3.2.&nbsp;PersistenceQuery</h4></div></div></div><p>
           The interface 
           <span class="interface">org.exolab.castor.persist.spi.PersistenceQuery</span> 
           defines the contract between the persistence engine and a query mechanism.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.persist.ejb-cmp"></a>4.4.4.&nbsp;Enterprise JavaBeans CMP</h3></div></div></div><p>TBD</p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.key-generator"></a>4.5.&nbsp;Castor JDO Key Generator Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.introduction"></a>4.5.1.&nbsp;Introduction</h3></div></div></div><p>
         The key generator gives a possibility to generate identity field
         values automatically. During <code class="literal">create</code> the value of the
         identity field is set to the value obtained from the key generator.
         Different algorithms may be used here, both generic and specific
         for database server.
      </p><p>
         The key generator for the given class is set in the mapping specification 
         file (<code class="filename">mapping.xml</code>), in the 
         <code class="literal">key-generator</code> attribute of the 
         <code class="literal">class</code> element, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"MAX"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
      </pre><p>
         The following key generator names are supported in Castor 1.0:
      </p><div class="table"><a name="d4e8927"></a><p class="title"><b>Table&nbsp;4.9.&nbsp;Supported key generator names</b></p><div class="table-contents"><table summary="Supported key generator names" border="1"><colgroup><col><col></colgroup><tbody><tr><td>MAX</td><td>"MAX( pk ) + 1" generic algorithm</td></tr><tr><td>HIGH-LOW</td><td>HIGH-LOW generic algorithm</td></tr><tr><td>UUID</td><td>UUID generic algorithm</td></tr><tr><td>IDENTITY</td><td>
                Supports autoincrement identity fields in Sybase ASE/ASA, 
                MS SQL Server, MySQL and Hypersonic SQL
              </td></tr><tr><td>SEQUENCE</td><td>
                Supports SEQUENCEs in Oracle, PostgreSQL, Interbase and SAP DB
              </td></tr></tbody></table></div></div><br class="table-break"><p>
         Some of these algorithms have parameters, which can be specified 
         in the <code class="literal">key-generator</code> element of the mapping
         specification file, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"HIGH-LOW"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"table"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key-column"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ_TableName"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"value-column"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SEQ_MaxPKValue"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"grab-size"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"1000"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"HIGH-LOW"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>
         It is possible to create several key generators with the same
         algorithms but different parameters.
         In this case you have to specify the <code class="literal">alias</code> attribute
         in the <code class="literal">key-generator</code> element, for example:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SEQUENCE"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"A"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sequence"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"a_seq"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">key-generator</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SEQUENCE"</span> <span class="hl-attribute">alias</span>=<span class="hl-value">"RETURNING"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sequence"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"b_seq"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"returning"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span>/&gt;
&lt;<span class="hl-tag">/key-generator</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">key-generator</span>=<span class="hl-value">"RETURNING"</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
      </pre><p>
         Below all supported key generators a described in details.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.max"></a>4.5.2.&nbsp;MAX key generator</h3></div></div></div><p>
         MAX key generator fetches the maximum value of the primary key 
         and lock the record having this value until the end of transaction.
         Then the generated value is set to (MAX + 1).
         Due to the lock concurrent transactions which perform insert 
         to the same table using the same key generator algorithm will wait 
         until the end of the transaction and then will fetch new MAX value.
         Thus, duplicate key exception is almost impossible (see below).
         Note, that it is still possible to perform multiple inserts during
         the same transaction.
      </p><p>
         There is one "singular" case of this algorithm: the case when the table 
         is empty. In this case there is nothing to lock, so duplicate key exception
         is possible. The generated value in this case is 1.
      </p><p>
         This algorithm has no parameters. Primary key must have type 
         <span class="type">integer</span>, <span class="type">bigint</span> or <span class="type">numeric</span>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.high-low"></a>4.5.3.&nbsp;HIGH-LOW key generator</h3></div></div></div><p>
         This key generator uses one of the variants of the generic HIGH-LOW
         algorithm. It is needed a special auxiliary table ("sequence table")
         which has the unique column which contains table names (of the type
         <span class="type">char</span> or <span class="type">varchar</span>) and the column which is used 
         to reserve values of the primary keys (of the type <span class="type">integer</span>,
         <span class="type">bigint</span> or <span class="type">numeric</span>).
         The key generator seeks for the given table name, reads the last
         reserved value and increases it by some number N, which is called 
         "grab size". Then the lock on the auxiliary table is released,
         so that concurrent transactions can perform insert to the same table.
         The key generator generates the first value from the grabbed 
         interval.
         During the next (N - 1) invocations it generates the other grabbed
         values without database access, and then grabs the next portion.
         Note, that the auxiliary table must be in the same database as
         the table for which key is generated. So, if you work with multiple 
         databases, you must have one auxiliary table in each database.
      </p><p>
         If the grab size is set to 1, the key generator each time stores
         the true maximum value of the primary key to the auxiliary table.
         In this case the HIGH-LOW key generator is basically equivalent to
         the MAX key generator.
         On you want to have LOW part of the key consisting of 3 decimal
         digits, set the grab size to 1000. If you want to have 2 LOW bytes in
         the key, set the grab size to 65536.
         When you increase the grab size, the speed of 
         key generation also increases because the average number of 
         SQL commands that are needed to generate one key is (2 / N).
         But that average number of key values that will be skipped (N / 2)
         also increases.
      </p><p>
         The HIGH-LOW key generator has the following parameters:
      </p><div class="table"><a name="d4e8972"></a><p class="title"><b>Table&nbsp;4.10.&nbsp;parameters of the HIGH-LOW key generator</b></p><div class="table-contents"><table summary="parameters of the HIGH-LOW key generator" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>table</td><td>The name of the special sequencetable.</td><td>Mandatory</td></tr><tr><td>key-column</td><td>The name of the column which contains table names</td><td>Mandatory</td></tr><tr><td>value-column</td><td>
                The name of the column which is used to reserve primary key values
              </td><td>Mandatory</td></tr><tr><td>grab-size</td><td>
                The number of new keys the key generator should grab from the sequence 
                table at a time.
              </td><td>Optional, default="10"</td></tr><tr><td>same-connection</td><td>
                To use the same Connection for writing to the sequence table, values:
                "true"/"false". This is needed when working in EJB environment, though 
                less efficient.
              </td><td>Optional, default="false"</td></tr><tr><td>global</td><td>To generate globally unique keys, values: "true"/"false".</td><td>Optional, default="false"</td></tr><tr><td>global-key</td><td>
                The name of key, which is used when globally unique keys are generated.
              </td><td>Optional, default="&lt;GLOBAL&gt;"</td></tr></tbody></table></div></div><br class="table-break"><p>
         If the parameter <code class="literal">global</code> is set to <code class="literal">true</code>, 
         the sequence table contains only one row with the value set in parameter 
         <code class="literal">global-key</code> (or "&lt;GLOBAL&gt;" if "global-key was not set") 
         instead of the table name. This row serves for all tables.
      </p><p>
         Don't forget to set same-connection="true" if you are working in 
         EJB environment!
      </p><p>
         Note, that the class <code class="classname">HighLowKeyGenerator</code> is not final, 
         so you can extend it in order to implement other variants of HIGH-LOW
         algorithm (for example, HIGH/MID/LOW or char key values).
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.uuid"></a>4.5.4.&nbsp;UUID key generator</h3></div></div></div><p>
         This key generator generates global unique primary keys.
         The generated key is a combination of the IP address, the current
         time in milliseconds since 1970 and a static counter.
         The complete key consists of a 30 character fixed length string.
      </p><p>
         This algorithm has no parameters. Primary key must have type 
         <span class="type">char</span>, <span class="type">varchar</span> or <span class="type">longvarchar</span>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.identity"></a>4.5.5.&nbsp;IDENTITY key generator</h3></div></div></div><p>
         IDENTITY key generator can be used only with autoincrement primary
         key columns (identities) with Sybase ASE/ASA, MS SQL Server, MySQL and
         Hypersonic SQL.
      </p><p>
         After the insert the key generator selects system variable
         <code class="literal">@@identity</code> which contains the last identity value for
         the current database connection.
      </p><p>
         In the case of MySQL and Hypersonic SQL the system functions
         <code class="function">LAST_INSERT_ID()</code> and <code class="function">IDENTITY()</code> 
         are called, respectively.
      </p><p>This algorithm has no parameters.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.key-generator.sequence"></a>4.5.6.&nbsp;SEQUENCE key generator</h3></div></div></div><p>
         The SEQUENCE key generator type is supported in conjunction with the following
         DBMS: Derby, Interbase, Oracle, PostgreSQL, and SAP DB.
      </p><p>It generates keys using database sequence objects.</p><p>
         The key generator has the following parameters:
      </p><div class="table"><a name="d4e9032"></a><p class="title"><b>Table&nbsp;4.11.&nbsp;parameters of the SEQUENCE key generator</b></p><div class="table-contents"><table summary="parameters of the SEQUENCE key generator" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>sequence</td><td>The name of the sequence</td><td>Optional, default="{0}_seq"</td></tr><tr><td>returning</td><td>RETURNING mode for Oracle8i, values: "true"/"false"</td><td>Optional, default="false"</td></tr><tr><td>increment</td><td>Increment for Interbase</td><td>Optional, default="1"</td></tr><tr><td>trigger</td><td>
	               Assume that there is a trigger that already generates key. 
	               Values: "true"/"false"
	             </td><td>Optional, default="false"</td></tr></tbody></table></div></div><br class="table-break"><p>
         Usually one sequence is used for one table, so in general you have to
         define one key generator per table.
      </p><p>
         But if you use some naming pattern for sequences, you can use one 
         key generator for all tables.
      </p><p>
         For example, if you always obtain sequence name by adding "_seq" to
         the name of the correspondent table, you can set "sequence" parameter
         of the key generator to "{0}_seq" (the default value).
      </p><p>
         In this case the key generator will use sequence "a_seq" for table 
         "a", "b_seq" for table "b", etc.  Castor also allows for inserting 
         the primary key into the sequence name as well.  This is accomplished 
         by including the {1} tag into the "sequence" parameter. Example: 
         "{0}_{1}_seq"
      </p><p>
         Actually the SEQUENCE key generator is "4 in 1". 
         With PostgreSQL it performs "SELECT nextval(sequenceName)" before 
         INSERT and produces identity value that is then used in INSERT.
         Similarly, with Interbase it performs
         "select gen_id(sequenceName, increment) from rdb$database" before
         INSERT.
      </p><p>
         With Oracle by default (returning=false) and with SAP DB it transforms
         the Castor-generated INSERT statement into the form
         "INSERT INTO tableName (pkName,...) VALUES 
         (sequenceName.nextval,...)" and after INSERT it performs "SELECT 
         seqName.currval FROM tableName" to obtain the identity value. With 
         Oracle8i it is possible to use more efficient RETURNING mode: to 
         the above INSERT statement is appened "RETURNING primKeyName INTO 
         ?" and the identity value is fetched by Castor during INSERT, so 
         that only one SQL query is needed.
      </p><p> 
         In case when your table has an on_Insert trigger which already generates
         values for your key, like the following Oracle example: 
      </p><pre class="programlisting">
create or replace trigger "trigger_name"
before insert on "table_name" for each row 
begin 
   select "seq_name".nextval into :new."pk_name" from dual;
end;</pre><p>    
          you may set the "trigger" parameter to "true". This will prevent the 
          "Sequence_name".nexval from being pulled twice (first time in the insert 
          statement (see above), then in the trigger). Also usefull in combination 
          with the "returning" parameter set to "true" for Oracle (in this case you 
          may not specify the sequence name).
       </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.long-transactions"></a>4.6.&nbsp;Castor JDO Long Transactions Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.introduction"></a>4.6.1.&nbsp;Introduction</h3></div></div></div><p>
         The usual Castor transactions are called here short
         transactions: an object is read, modified and written within the
         bounds of one transaction.
         Long transactions consist of two Castor transactions:
         an object is read in the first and written in the second.
         Between them the object is sent "outwards" and modified there.
         For example, the object may be send to a client application and
         dispayed to a user, or it may be sent to a servlet engine and is
         displayed on a web page. After that the modified object returns
         back and is written to the database in the second transaction.
         At this point the object is usually not the same physical instance
         as one that was read in the first transaction.
         The example code for writing the object in the second Castor
         transaction follows:
         </p><pre class="programlisting">
    <span class="hl-comment">// a customer go to a webpage to review her personal information.</span>
    <span class="hl-comment">// The servlet then call this server side function: getCustomerInfo</span>
    <span class="hl-keyword">public</span> CustomerInfo getCustomerInfo( Integer customNum ) {
         
         <span class="hl-comment">// in most case, users simply review information and</span>
         <span class="hl-comment">// make no change. Even if they make changes, it often</span>
         <span class="hl-comment">// takes time for them to decide. We don't want to</span>
         <span class="hl-comment">// lock the database row, so commit right after we load.</span>
         db.begin();
         CustomerInfo info = (CustomerInfo)
            db.load( CustomerInfo.<span class="hl-keyword">class</span>, customNum );

         
         <span class="hl-comment">// we also want to keep track of customers patterns</span>
         <span class="hl-comment">// well...it helps us provide better service.</span>
         info.setLastVisit( today );
         db.commit();
         <span class="hl-keyword">return</span> info;
    }

    <span class="hl-comment">// Three days passed, the indecisive customer finally agrees to</span>
    <span class="hl-comment">// marry Joe. She changes her last name in the webpage and</span>
    <span class="hl-comment">// clicked the "Submit" button on the webpage.</span>
    
    <span class="hl-comment">// The servlet then calls updateCustomerInfo to update the</span>
    <span class="hl-comment">// last name for the indecisive customer.</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateCustomerInfo( CustomerInfo info ) {
        db.begin();
        db.update(info);
        db.commit();
    }
         </pre><p>
         Note, that it is natural to read the object in the first
         transaction in the read-only mode.
      </p><p>
         Since the time interval between the first and the second
         transaction is relatively big, it is desirable to perform dirty
         checking, i.e. to check that the object has not been modified
         in the database during the long transaction.
         For that the object must hold a timestamp: it is set by
         Castor during the first Castor transaction and is checked during
         the second one.
         In order to enable the dirty checking for long transactions,
         the object should implement the interface
         org.exolab.castor.jdo.TimeStampable
         having two methods: <code class="code">long jdoGetTimeStamp()</code> and
         <code class="code">void jdoSetTimeStamp(long timeStamp)</code>

         
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.bounded-dirty-checking"></a>4.6.2.&nbsp;Bounded dirty checking</h3></div></div></div><p>
         The advantage of the bounded dirty checking is that it doesn't require
         any changes to the database schema. It uses the Castor cache to store
         object timestamps. The disadvantage of this algorithm is that it is
         bounded by a lifetime of the cached copy of the object. After the
         cached copy has been purged, db.update() causes ObjectModifiedException.
      </p><p>
         Thus, parameters of the cache define dirty checking capabilities.
         The cache-type attribute is part of the
         <a href="#jdo.mapping.file.class-element" title="3.6.3.2.&nbsp;The <class&gt; element">
         &lt;class&gt; element</a> in the XML mapping. Consider the existing cache types:
         
         </p><div class="itemizedlist"><ul type="disc"><li><p>none - the bounded dirty checking is impossible</p></li><li><p>
               count-limited - the count limit for the cache is a count
               limit for the objects of this class that can participate in long
               and short transactions simultaneously.
             </p></li><li><p>
               time-limited - the time limit for the cache is a time limit
               for the long transaction.
             </p></li><li><p>
               unlimited - the bounded dirty checking gives correct results
               while the cache exists, i.e. until the crash of the server.
             </p></li></ul></div><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.long-transactions.no-dependance-on-cache"></a>4.6.3.&nbsp;Long transactions that do not depend on cache</h3></div></div></div><p>
			For long transactions (detached objects) it was required 
	      	that the entity has been kept in cache from being loaded until its update. 
	      	If the entity was expired from cache before the update an 
	      	ObjectModifiedException had been thrown. While this is no 
	      	problem if all entities of an application can be kept in 
	      	cache all the time, it is one for large scale applications 
	      	with millions of entities.
	    </p><p>
			With release 1.3 we have changed the handling of timestamps. 
			While it is still possible to rely on cache only it is now 
			also possible to persist the timestamp together with the 
			other properties of the entity. Doing so will ensure that 
			the timestamp do not change even if the entity got expired 
			from cache from being loaded until it gets updated. If this 
			happens the entity gets reloaded during update which also 
			loads the previous timestamp. Having said that it still is 
			possible that an ObjectModifiedException is thrown when 
			another user has changed the same entity in the meantime.
	    </p><p>See an example entity and its mapping below: </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Entity <span class="hl-keyword">implements</span> TimeStampable {
    <span class="hl-keyword">private</span> Integer _id;
    <span class="hl-keyword">private</span> String _name;
    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> _timeStamp;
    
    <span class="hl-keyword">public</span> Integer getId() { <span class="hl-keyword">return</span> _id; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> Integer id) { _id = id; }
    
    <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> _name; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) { _name = name; }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getTimeStamp() { <span class="hl-keyword">return</span> _timeStamp; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTimeStamp(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> timeStamp) {
        _timeStamp = timeStamp;
    }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> jdoGetTimeStamp() { <span class="hl-keyword">return</span> _timeStamp; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> jdoSetTimeStamp(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> timestamp) {
        _timeStamp = timestamp;
    }
}       </pre><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Entity"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"300"</span>/&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"entity"</span>/&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"true"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timeStamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.nested-attributes"></a>4.7.&nbsp;Nested Attributes</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.introduction"></a>4.7.1.&nbsp;Introduction</h3></div></div></div><p>
	        In some cases it is desirable to map a plain sequence of fields
	        in a database record to more complicated structure of attributes
	        in a Java object, where the target attributes are contained (nested)
	        in other attributes.
	        In brief, you can specify a path to the target attribute as a name 
	        of the field in a configuration file, and Castor is able to handle
	        such nested attributes.
	        For example:
	        </p><pre class="programlisting">
&lt;field name=<span class="hl-string">"address.country.code"</span>...&gt;
  &lt;sql name=<span class="hl-string">"person_country"</span>/&gt;
&lt;/field&gt;
	        </pre><p>
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.application-types"></a>4.7.2.&nbsp;Application types</h3></div></div></div><p>
	        The first case is an attribute of an application type that is 
	        a container for some value of a Java type supported by Castor.
	        Usually the application type also has some business methods. 
	        Examples are: class Balance that contains a BigDecimal value and 
	        has some accounting-specific methods; 
	        class CountryCode that contains a String value and has 
	        methods validate(), getDisplayName(), etc.; class Signature that 
	        contains a byte[] value and has some security-specific methods. 
	        In order to use such type with Castor you should provide 
	        a pair of methods to get/set the value of the Castor-supported type, 
	        e.g. getBigDecimal/setBigDecimal, getCode/setCode, getBytes/setBytes. 
	     </p><p>
	        Assume that you have the class Address
	        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Address {
    <span class="hl-keyword">private</span> CountryCode _country;
    <span class="hl-keyword">private</span> String      _city;
    <span class="hl-keyword">private</span> String      _street;

    <span class="hl-keyword">public</span> CountryCode getCountry() {
        <span class="hl-keyword">return</span> _country;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setCountry(CountryCode country) {
        _country = country;
    }
    ...
}
	        </pre><p>
	        where the class <code class="classname">CountryCode</code> is like this
	        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CountryCode {
    <span class="hl-keyword">private</span> String _code;
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> String[] _allCodes;
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> String[] _allDisplayNames;

    <span class="hl-keyword">public</span> String getCode() {
        <span class="hl-keyword">return</span> _code;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setCode(String code) {
        _code = code;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> getDisplayName() {
    ...
}
	        </pre><p>
	        then write in the configuration file:
	        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Address"</span><span class="hl-attribute">...&gt;</span>
  <span class="hl-attribute">&lt;field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"country.code"</span><span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">&lt;sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"addr_country"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  ...
&lt;<span class="hl-tag">/class</span>&gt;
	        </pre><p>
	        When reading the object from the database Castor will use
	        </p><pre class="programlisting">
object.getCountry().setCode(value);
	        </pre><p>
	        to set the nested attribute value.
	        Moreover, if object.getCountry() is null, Castor will create the 
	        intermediate object of the application type:
	        </p><pre class="programlisting">
country = <span class="hl-keyword">new</span> CountryCode();
country.setCode(value);
object.setCountry(country);
	        </pre><p>
	        When writing the object to the database Castor will use
	        </p><pre class="programlisting">
value = object.getCountry().getCode();
	        </pre><p>
	        to get the value of the correspondent database field.
	     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.nested-attributes.compound-attributes"></a>4.7.3.&nbsp;Compound types</h3></div></div></div><p>
        The second case is an attribute that is a part of a compound 
        attribute, which contains several database fields.
        For example, database fields person_country, person_city, 
        person_street of the table <span class="database">PERSON</span> 
        correspond to one compound attribute "address" of the class 
        <code class="classname">Person</code>:
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {
    <span class="hl-keyword">private</span> String  _firstName;
    <span class="hl-keyword">private</span> String  _lastName;
    <span class="hl-keyword">private</span> Address _address;

    <span class="hl-keyword">public</span> Address getAddress() {
        <span class="hl-keyword">return</span> _address;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress(Address address) {
        _address = address;
    }
    ...
}
        </pre><p>
        where the class <code class="classname">Address</code> is the same as in the 
        previous section. Then write in the configuration file:
        </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Person"</span>...&gt;
  &lt;field name=<span class="hl-string">"address.country.code"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_country"</span>/&gt;
  &lt;/field&gt;
  &lt;field name=<span class="hl-string">"address.city"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_city"</span>/&gt;
  &lt;/field&gt;
  &lt;field name=<span class="hl-string">"address.street"</span>...&gt;
    &lt;sql name=<span class="hl-string">"person_street"</span>/&gt;
  &lt;/field&gt;
  ...
&lt;/<span class="hl-keyword">class</span>&gt;
        </pre><p>
        Similarly to the previous section, Castor will use a proper 
        sequence of get/set methods to access the nested attributes and 
        will create the intermediate objects when necessary.
        Don't forget to provide parameterless constructors for the 
        container classes.
     </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.pooling"></a>4.8.&nbsp;Using Pooled Database Connections</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.news"></a>4.8.1.&nbsp;News</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                   <span class="bold"><strong>10/22/2004</strong></span>: 
                   Added JDBC Datasource configuration for mySQL.
               </p></li><li><p>
                   <span class="bold"><strong>9/14/2004</strong></span>: 
                   Added section about using Jakarta's DBCP with Castor.
               </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.agents"></a>4.8.2.&nbsp;Pooling Agents</h3></div></div></div><p>
         There is no mechanism within Castor JDO to provide pooling of
         JDBC drivers. Rather, Castor JDO relies on the drivers or
         external driver wrappers to implement a pooling mechanism.
         Some drivers, such as Oracle, provides a pooling mechanism in
         the driver.  For those that do not, there are tools such as
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://sourceforge.net/projects/proxool/" target="_top">Proxool</a> 
         and Jakarta's 
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/dbcp/" target="_top">DBCP</a>
         project.
      </p><p>
         Here, I'll go over the various usage of the PostgreSQL driver
         with Castor.  We start with the most basic configurations
         that do not use any pooling, to those with pooling via DBCP. 
         I'll include how to configure the pooling version of the 
         PostgreSQL JDBC driver ths will be usable with PostgreSQL 7.3 and 
         later, how to setup a Tomcat JNDI context that Castor can use to get 
         a pooled JDBC connection. Finally, I'll explain how to configure a 
         <code class="classname">BasicDataSource</code> from the DBCP package using the 
         &lt;data-source&gt; element.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.standard-database-connections"></a>4.8.3.&nbsp;Standard Database Connections</h3></div></div></div><p>
           A standard jdo-conf.xml entry for using PostgreSQL without pooling
           looks like this:
        </p><pre class="programlisting">

&lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.Driver"</span>
        <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:postgresql://localhost/app"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span>/&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/driver</span>&gt;
        </pre><p>
	        On the other hand, if you wanted to use the PostgresqlDataSource, you
	        would use the data-source tag instead, and the connection entry would
	        look like this:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"app"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
      </pre><p>
         (Note that only versions before 7.3 of the PostgreSQL JDBC driver
         include this class)
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.jdbc-datasources"></a>4.8.4.&nbsp;Pooling and JDBC DataSources</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.postgresql-7-3"></a>4.8.4.1.&nbsp;PostgreSQL 7.3 and later</h4></div></div></div><p>
               In the 7.3 release of PostgreSQL, they will start providing a
               pooling mechanism with their driver.  The Castor SVN repository
               includes a beta version of the driver with this functionality.
               Here is the 'current' configuration needed for the upcoming 7.3
               release of PostgreSQL. (Unless they change it.) Note that in this
               pooling mechanism currently lacks some features of standrd pooling 
               packages such as DBCP, such as timing out idle connections and removing 
               failed connections from the pool.  In this case, we can create the 
               following  data-source entry in the jdo-conf.xml file to provide 
               for our connections with Castor.
            </p><pre class="programlisting">
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.jdbc2.optional.PoolingDataSource"</span>&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"app"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"initial-connections"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"2"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-connections"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"smith"</span> /&gt;
 &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;

            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.oracle"></a>4.8.4.2.&nbsp;Oracle</h4></div></div></div><p>
              Here is the configuration needed for using a connection pool
              with the Oracle JDBC DataSource implementations.
            </p><pre class="programlisting">
   &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"URL"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span> /&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
   &lt;<span class="hl-tag">/data-source</span>&gt;
            
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jdbc-datasources.mysql"></a>4.8.4.3.&nbsp;mySQL</h4></div></div></div><p>
              Here is the configuration needed for using a connection pool
              with the mySQL JDBC DataSource implementations.
            </p><pre class="programlisting">        

&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource"</span>&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"server-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"localhost"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"port"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"3306"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
   &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"database-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;

            </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.tomcat-jdbc-configuration"></a>4.8.5.&nbsp;Configuring JDBC DataSources in Tomcat to be used with Castor</h3></div></div></div><p>
            Finally, I want to show the configuration for using a pooling
	        data-source for Castor which is retrieved from a JNDI context
	        that Apache fills.  The first example is using the PostgreSQL
	        pooling data-source, and the second is using Castor.  The
	        information to gain here is that we did not need to change the
	        jdo-conf.xml file or the webapp's web.xml file to achieve
	        this.
         </p><p>
            First, we modify the deployment context for the webapp in Tomcat &gt;= 4.0 for our 
	        webapp in the conf/server.xml directory. (With Tomcat/Catalina releases 4.0 and higher 
	        there's more than one way of adding a 
	        <code class="literal">&lt;Resource&gt;</code> entry. Please consult with the 
	        manuals for more and more detailed information).
         </p><p>
            We add the following information (using the PostgreSQL JDBC DataSource 
	        implementations as introduced above.):
         </p><pre class="programlisting">
	        
&lt;<span class="hl-tag">Context</span> <span class="hl-attribute">path</span>=<span class="hl-value">"/webapp"</span> <span class="hl-attribute">docBase</span>=<span class="hl-value">"test"</span> <span class="hl-attribute">debug</span>=<span class="hl-value">"10"</span>&gt;
 &lt;<span class="hl-tag">Resource</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdbc/appDb"</span> <span class="hl-attribute">auth</span>=<span class="hl-value">"Container"</span>
            <span class="hl-attribute">type</span>=<span class="hl-value">"org.postgresql.jdbc2.optional.PoolingDataSource"</span>/&gt;
   &lt;<span class="hl-tag">ResourceParams</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdbc/appDb"</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;factory&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;org.postgresql.jdbc2.optional.PGObjectFactory&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
     &lt;<span class="hl-tag">name</span>&gt;dataSourceName&lt;<span class="hl-tag">/name</span>&gt;
     &lt;<span class="hl-tag">value</span>&gt;appDb&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
     &lt;<span class="hl-tag">name</span>&gt;initialConnections&lt;<span class="hl-tag">/name</span>&gt;
     &lt;<span class="hl-tag">value</span>&gt;2&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;maxConnections&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;5&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;databaseName&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;app&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;user&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;smith&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;password&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;secret&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
    &lt;<span class="hl-tag">parameter</span>&gt;
      &lt;<span class="hl-tag">name</span>&gt;serverName&lt;<span class="hl-tag">/name</span>&gt;
      &lt;<span class="hl-tag">value</span>&gt;localhost&lt;<span class="hl-tag">/value</span>&gt;
    &lt;<span class="hl-tag">/parameter</span>&gt;
  &lt;<span class="hl-tag">/ResourceParams</span>&gt;
&lt;<span class="hl-tag">/Context</span>&gt;
	     </pre><p>
            Here, we are using the PostgreSQL PGObjectFactory which
	        provides the JNDI server (Tomcat) the ability to create the
	        correct data source.  Now, the web.xml file for the webapp
	        needs to be updated too.
         </p><pre class="programlisting">        
	        
&lt;<span class="hl-tag">resource-env-ref</span>&gt;
  &lt;<span class="hl-tag">description</span>&gt;PostgreSQL pooling check&lt;<span class="hl-tag">/description</span>&gt;
  &lt;<span class="hl-tag">resource-env-ref-name</span>&gt;jdbc/appDb&lt;<span class="hl-tag">/resource-env-ref-name</span>&gt;
  &lt;<span class="hl-tag">resource-env-ref-type</span>&gt;javax.sql.DataSource&lt;<span class="hl-tag">/resource-env-ref-type</span>&gt;
&lt;<span class="hl-tag">/resource-env-ref</span>&gt;
	
	      </pre><p>
             Note that we are only calling the ref type a DataSource
	         object, not using the PostgreSQL class name.  This will
	         enable us to make changes easily.  Now, in the jdo-conf.xml
	         file that Castor uses, we no longer list the driver or
	         data-source tag, but use the JNDI one, and it is simply this:
          </p><pre class="programlisting">
	         
&lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/appDb"</span>/&gt;
	     </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.pooling.jakarta-commons-dbcp"></a>4.8.6.&nbsp;Jakarta Commons DBCP - BasicDataSource</h3></div></div></div><p>
          Commons-DBCP provides database connection pooling services, and together with 
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/pool/" target="_top">Commons-Pool</a>
          it is the default JNDI datasource provider for Tomcat.
       </p><p>
          With release 1.1 of the Jakarta Commons DBCP component, one of the major 
          new features of the JDBC 3.0 API has (finally) been added to 
          BasicDataSource, support for prepared statement pooling.
       </p><p>
          To configure Castor for the use of DBCP, please provide the following 
          &lt;data-source&gt; entry in the jdo-conf.xml file.
       </p><pre class="programlisting">
       
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
        </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="advanced-jdo.pooling.jakarta-commons-dbcp.prepared-statement"></a>4.8.6.1.&nbsp;Prepared statement pooling</h4></div></div></div><p>
               As mentioened above, please note that with DBCP 1.1 and later 
			   releases, support for prepared statement pooling has been added 
			   to DBCP. As Castor JDO does <span class="bold"><strong>not</strong></span> 
			   implement prepared statement pooling itself, you will to configure 
			   DBCP explicitely to enable this feature.
            </p><p>
               To configure Castor for the use of DBCP, and to turn prepared statement
	           pooling on, please provide the following 
	           <code class="literal">&lt;data-source&gt;</code> entry in the 
	           <code class="filename">jdo-conf.xml</code> file.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
  &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pool-prepared-statements"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"true"</span> /&gt;
&lt;<span class="hl-tag">/data-source</span>&gt;
            </pre><p>
	            There's plenty of information on 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/dbcp/configuration.html" target="_top">configuration</a>
	            of BasicDataSource.
	        </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.postgresql-blobs"></a>4.9.&nbsp;Blobs in PostgreSQL</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.postgresql-blobs.oid-support"></a>4.9.1.&nbsp;OID Support</h3></div></div></div><p>
		     PostgreSQL's blob support has evolved over the years. Today
		     PostgreSQL fields can be of unlimited length. And there are
		     specific data types for character and binary large objects. 
		     The current Castor support for blobs, however, uses an earlier
		     PostgreSQL blob support. This support places the blob data in
		     the pg_largeobject table and a object id in the referring
		     table. For most practical purposes using this earlier support
		     does not matter.
	     </p><p>
		     Database version and the JDBC driver version matter greatly. To get
		     everything to work I eventually built and installed PostgreSQL 7.2.2 and
		     used the JDBC driver from this build (i.e. not the one from
		     <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jdbc.postgresql.org/" target="_top">http://jdbc.postgresql.org</a>.
	     </p><p>
		     Since Castor is using the earlier blob support the JDBC has to be
		     placed in PostgreSQL 7.1 comparability mode. To do this use the
		     following JDBC URL
	     </p><pre class="programlisting">
	      jdbc:postgresql://host:port/database?compatible=7.1      </pre><p>
		     Once you have resolved the PostgreSQL version issues Castor
		     works as documented.
	     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.postgresql-blobs.oid-example"></a>4.9.2.&nbsp;OID Example</h3></div></div></div><p>
	      Here are the details of an example configuration.
	    </p><pre class="programlisting">
	      Client Windows 2000, Sun Java Standard Edition 1.3.1_03, Castor 0.9.3.21
	      Server RedHat 7.2, PostgreSQL 7.2.2     </pre><p>
	      The interface I am using is
	    </p><pre class="programlisting">
	    
	    <span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Document {
	        String      getTitle();
	        <span class="hl-keyword">void</span>        setTitle( String title );
	        Date        getCreatedOn();
	        <span class="hl-keyword">void</span>        setCreatedOn( Date createdOn );
	        String      getContentType();
	        <span class="hl-keyword">void</span>        setContentType( String contentType );
	        InputStream getContent();
	        <span class="hl-keyword">void</span>        setContent( InputStream content );
	    }
	    </pre><p>
	      and this is implemented by the class <code class="classname">DocumentImpl</code>.
	    </p><p>The mapping file is</p><pre class="programlisting">
	    
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
    &lt;<span class="hl-tag">mapping</span>&gt;
     &lt;<span class="hl-tag">class</span>
         <span class="hl-attribute">name</span>=<span class="hl-value">"com.ingenta.DocumentImpl"</span>
         <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>
         <span class="hl-attribute">key-generator</span>=<span class="hl-value">"SEQUENCE"</span> &gt;
         &lt;<span class="hl-tag">description</span> /&gt;
         &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;  
         &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"documents"</span> /&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> &gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span>/&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"title"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"title"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"longvarchar"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"createdOn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"createdon"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contentType"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"contenttype"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"longvarchar"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"check"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
         &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"content"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"stream"</span>&gt;
             &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"content"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
         &lt;<span class="hl-tag">/field</span>&gt;
     &lt;<span class="hl-tag">/class</span>&gt;
 &lt;<span class="hl-tag">/mapping</span>&gt;
	 </pre><p>Note that the blob is not dirty checked.</p><p>And the SQL is</p><pre class="programlisting">
	    
    create table documents (
        id          serial    not null,
        title       text      null,
        createdon   timestamp null,
        contenttype text      null,
        content     oid       null,
        primary key ( id )
    );
	    </pre><p>
		    Castor caches objects between transactions for performance. With
		    a blob however the cached object's InputStream is not
		    reusable. To workaround this I have told the cache to not cache
		    any objects of this class by adding to the class mapping, as
		    noted above.
	    </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-jdo.best-practice"></a>4.10.&nbsp;Castor JDO - Best practice</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.introduction"></a>4.10.1.&nbsp;Introduction</h3></div></div></div><p>
	       There's many users of Castor JDO out there, who (want to) use Castor JDO in 
	       in high-volume applications. To fine-tune Castor for such environment, it is 
	       necessary to understand many of the product features in detail and to be able to
	       balance their use according to the application needs. Even though many of these
	       features are detailed in various places, people have frequently been asking 
	       for a 'best practise' document, a document that brings together these technical 
	       topics (in one place) and presents them as a set of easy-to-use recipes.
	    </p><p>
	       Please be aware that this document is <span class="emphasis"><em>under construction</em></span>, 
	       but still we believe that - even when in its conception phase 
	       - it provides valuable information to users of Castor JDO.
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.general-suggestions"></a>4.10.2.&nbsp;General suggestions</h3></div></div></div><p>
           Let's start with some general suggestions that you should have a look at. Please don't 
           feel upset if some are really primitive but there may be users reading this document
		   that are not aware of them.
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Switch to version 0.9.9 of Castor as we have fixed some 100+ bugs 
                    that may causesome of your problems.
                </p><p>
                    Sidenote: Performance has, generally, improved recently. 
                    If you're not seeing performance improvements, then it's worth 
                    spending some time thinking about why.
                </p></li><li><p>
                    Initialize your JDOManager instance once and reuse it all over 
                    your application. Don't reuse the Database instances. 
                    Creating them is inexpensive, and JDBC rules state that one thread 
                    &lt;-&gt; one JDBC connection is the rule. Do not multithread inside 
                    of a Database instance; as a corrolary, do not multithread on a 
                    single JDBC connection.
                </p></li><li><p>
                    Use a Datasource instead of a Driver configuration as they enable 
                    connection pooling which gives you a great performance improvement.
                </p><p>
                    We highly suggest DBCP, here, with the beneficial use of prepared 
                    statement caching.
                </p><p>
                    Should you be running on a system where read performance is 
                    critical, feel free to take the SQL code generated by castor, 
                    and dumped to logs during the DB mapping load in debug output, 
                    and turn those into stored procedures that you then invoke via 
                    SQL CALL to perform those loads; however, I find personally that 
                    stored procedures would be a minimal improvement over the DBCP 
                    prepared statement cache; your mileage may vary. 
                    <code class="methodname">db.load()</code> has performance benefits that 
                    are worth keeping, IMO, and the pleasure of having pretty stored 
                    procedures in your database is far outweighed by the nightmare 
                    of change management.
                </p><p>
                    Have a look at 
                   <a href="#advanced-jdo.pooling.jakarta-commons-dbcp" title="4.8.6.&nbsp;Jakarta Commons DBCP - BasicDataSource">the 
                   HTML docs</a> for Jakarta DBCP, which has details about how to 
                   use and configure DBCP with Castor and Tomcat.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                        'prepared statement caches' refer to the fact that DBCP is a 
                        JDBC 3.0-compliant product, and as such has to support caching 
                        of prepared statements. This basically allows the JDBC driver 
                        to maintain a pool of prepared statements across all 
                        connections, a feature that has been added to the JDBC 
                        specification with release 3.0 only.
                    </p></td></tr></table></div><p>
                    DBCP setup is generally outside of the scope of this list, 
                    but basically, here's my two cent description:
                </p><p>
                  </p><div class="itemizedlist"><ul type="disc"><li><p>
                          Use tomcat 5.5, because mucking about in server.xml sucks. 
                          For those of you working with Tomcat 4.1.x, there's no need 
                          to muck about in server.xml, either. Afaik, a web app can be 
                          deployed using a web app descriptor copied into 
                          $TOMCAT_HOME/webapps, which is the place top define anything
                           specific to a web app context. Details can vary, of course.
                      </p></li><li><p>
                            Create a META-INF directory in your WAR deploy scripts, and put a 
                            context.xml in it.
                        </p></li><li><p>
                            In that context.xml, describe all of the things you want 
                            to be made available via JNDI to your application. 
                            These include things like UserTransaction and 
                            TransactionManager (for those of us using JOTM), all your 
                            database connection pools as datasources, etc. You can also 
                            add your JDO factory here, should you choose to do so.
                      </p></li><li><p>
                        Configure Castor to load those JNDI names to retrieve connections.
                      </p></li></ul></div><p>
                </p><p>Hit the deploy button, and bob's your uncle.</p></li><li><p>
                    Always commit or rollback your transactions and close your Database 
                    instances properly; also in fail situations.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			            Just the obvious general rule on Java objects that hold 
			            resources: Don't wait for the VM to finalize to have something 
			            happen to your objects when you could have released critical 
			            resources at the appropriate point in the codebase.
                    </p></td></tr></table></div></li><li><p>
                    Keep your transactions as short as possible. If you have an open 
                    transaction that holds a write lock on an object no other 
                    transaction can get a write lock on the same object which will 
                    lead to a LockNotGrantedException.
                </p><pre class="programlisting">
execute() {
   Database db = jdo.getDatabase();
   db.begin();
   <span class="hl-comment">// query objects from database with read only</span>
   db.commit();
   db.close();

   <span class="hl-comment">// do some time consuming processing with the data</span>

   Database db = jdo.getDatabase();
   db.begin();
   <span class="hl-comment">// use db.load() to load the objects you need to change again</span>
   <span class="hl-comment">// create, update or delete some objects</span>
   db.commit();
   db.close();
}               </pre><p>
                    It doesn't make sense to make a own transaction for every change 
                    you want to do to an object as this will slow down your application. 
                    On the other hand if you have transactions with lots of objects 
                    involved taking an valuable amonth of time you may consider to 
                    split this transactions to reduce the time an object is locked.
                </p><p>
                    Also keep in mind that folks using lockmode of DBLocked do 
                    <code class="function">FOR UPDATE</code> calls on things they read while 
                    the transaction is open; if you're using dblocked mode, be aware 
                    of how your application does things. If you're in one of the 
                    other modes, locks happen inside castor, and it's your 
                    responsibility to always use the right access mode when accessing 
                    content.
                </p><p>
                    If you can, for example, decide at the API layer whether or not an 
                    operation is going to ever need to modify an object, and know that 
                    you will only ever use an instance in read only mode, load objects 
                    with access mode read only, and not shared.
                </p><p>
                    Limit use of read-write objects to situations in which it is likely 
                    you will need to perform updates.
                </p><p>
                    Imagine, for a moment, that these transactions were in DBLocked 
                    mode - transactions which translate directly into locks on the 
                    database.
                </p><p>
                    If you're opening something up for modification on the DB 
                    - marking it as select <code class="function">FOR UPDATE</code> 
                    - then that row will be locked until you commit. 
                    The database would prevent any other transaction that wants to 
                    touch that row from doing anything to it, and it would block on 
                    your transaction - deadlock at the SQL level.
                </p><p>
                    Castor does the same things internally for its own access modes 
                    - Shared and Exclusive. Each has different locking semantics; 
                    having good performance means understanding those locking semantics.
                </p><p>
                    For example - read only transactions (should be) cheap. 
                    So there's no issue with holding those transactions open a 
                    long time; because they only translate, for an instant, into 
                    a lock. The lock is released the moment the load is completed 
                    and the object is dropped into read-only state within your 
                    transaction; read only operations therefore operate, pretty much, 
                    without locking.
                </p><p>
                    The lock is of course acquired because you might also have it in 
                    SHARED or EXCLUSIVE mode on another thread - and that read-only 
                    operation isn't safe until those transactions close.
                </p><p>
                    Once the lock is released, you're lock-free again, so the 
                    transaction basically has nothing in it that needs anything doing.
                </p><p>
                    That's not to say that holding transactions open is good practice 
                    - but transactions should always be thought of as cheap to create 
                    and destroy and expensive to hold on to - never do heavy 
                    computation inside of one, unless you're willing to live with the 
                    consequences that arise from holding transactions on object sets 
                    that others might need to access.
                </p></li><li><p>
                   Query or load your objects <span class="bold"><strong>read only</strong></span>
                   whenever possible. Even if castor creates a lock on them this does 
                   not prevent other threads from reading or writing them. Read only 
                   queries are also about 7 times faster compared with default 
                   shared mode.
               </p><p>for queries:</p><pre class="programlisting">
String oql = "select o from FooBar o";
Query query = db.getOQLQuery(oql);
QueryResults results = query.execute(Database.ReadOnly);</pre><p>to load an object by its identity:</p><pre class="programlisting">
Integer id = <span class="hl-keyword">new</span> Integer(7);
Foo foo = (Foo) db.load(Foo.<span class="hl-keyword">class</span>, id, Database.ReadOnly);</pre><p>Default accessmode is evaluated as follows:</p><p>
                    </p><div class="itemizedlist"><ul type="disc"><li><p>
                                if specified castor uses access mode from db.load()
                                or query.execute(),
                            </p></li><li><p>
                                if this is not available it takes access mode specified 
                                in class mapping,
                            </p></li><li><p>
                                if nothing is specified in mapping it defaults to shared.
                            </p></li></ul></div><p>
                </p><p>
                    One cannot stress how important this is: If 99% of your application 
                    never writes an object, and you as a programmer know it won't, 
                    then do something about it. If you're in a situation where you want 
                    the object to be read-only most of the time, and only want a 
                    writable every now and then, do so just-in-time by performing a 
                    load-modify-store operation in a single transaction for the 
                    shareable you want.</p><p>
                    In other words: Don't use read-write objects unless you know you're likely 
                    to want to write them.
                </p></li><li><p>
                   If there is a possibility you should prefer 
                   <code class="methodname">Database.load(Class, object)</code> over 
                   <code class="methodname">Query.execute(String)</code>. I suggest that as 
                   <code class="methodname">load()</code> first tries to load the requested 
                   object from cache and only retrieves it from database when it is 
                   not available there. When executing queries with 
                   <code class="methodname">Query.execute()</code> the object will always 
                   be loaded from database without looking at the cache. You may gain 
                   a improvement by a factor of 10 and more when changing from 
                   <code class="methodname">Query.execute()</code> to 
                   <code class="methodname">Database.load()</code>.
                </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="advanced-jdo.best-practice.further-optimization"></a>4.10.3.&nbsp;Further optimization</h3></div></div></div><p>
            We hope above suggestions help you to resolve the problems you have. 
            If you still need more performance there are areas of improvement 
            that are more difficult to resolve. For further ideas to improve 
            your applications performance you should take a loock at out performance 
            test suite (PTF) which you can find in Castor's source distribution under: 
            src/tests/ptf/jdo.
		</p><p>
            Now, there's lots left to do - there is still the issue, for example, 
            of dependent objects being slightly sub-optimal in performance both in 
            terms of the SQL that gets generated and the way it gets managed 
            - but there will be improvements over time to the way that this and 
            other operations are performed.
        </p><p>
            But performance should be good right now. If it isn't, you'll need to 
            think about whether you are using the optimal set of operations. 
            No environment can predict your requirements - hinting to the system when 
            objects can be safely assumed to be read-only is vital to a 
            high-performance implementation.
        </p></div></div>
  
</div>

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Spring ORM integration"></a>Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9308"></a>5.1.&nbsp;Usage</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9310"></a>5.1.1.&nbsp;Getting started using Maven 2</h3></div></div></div><p>
         In order to start using the Spring ORM module for Castor JDO, you will 
         have to have Maven 2 installed:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Download and install <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org" target="_top">Maven 2</a></p></li></ul></div><p>
        As this project uses Maven 2 for build and deployment, all required 
        compile-time and run-time dependencies will automatically be resolved 
        by Maven 2 and deployed into your local Maven 2 repository.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9318"></a>5.1.2.&nbsp;Project dependencies</h3></div></div></div><p>
         Please add the following Maven dependency to your POM to include the 
         <span class="italic">Spring ORM package for Castor JDO</span> 
         with your project:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">dependency</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.castor&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;spring-orm&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;1.3&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
      </pre><p>
         If you create a dependency against a SNAPSHOT release, you will
         have to add the following <code class="literal">&lt;repository&gt;</code> element 
         to your POM as well, so that Maven 2 knows about the 
         <span class="italic">Codehaus Snapshot repository</span> when 
         trying to resolve and download dependencies.
      </p><pre class="programlisting">
&lt;<span class="hl-tag">repository</span>&gt;
    &lt;<span class="hl-tag">id</span>&gt;codehaus-snapshots&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">name</span>&gt;Maven Codehaus Snapshots&lt;<span class="hl-tag">/name</span>&gt;
    &lt;<span class="hl-tag">url</span>&gt;http://snapshots.maven.codehaus.org/maven2/&lt;<span class="hl-tag">/url</span>&gt;
&lt;<span class="hl-tag">/repository</span>&gt;</pre>&gt;

    </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9327"></a>5.2.&nbsp;A high-level overview</h2></div></div></div><p>
        This guide assumes that you are an experienced Castor JDO users that knows how
	    to use Castor's interfaces and classes to interact with a database. If 
	    this is not the case, please familiarize yourself with 
	    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo.html" target="_top">Castor JDO</a> first. 
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9331"></a>5.2.1.&nbsp;Sample domain objects</h3></div></div></div><p>
            The sample domain objects used in here basically define a <code class="literal">Catalogue</code>, 
		    which is a collection of <code class="literal">Product</code>s. A possible castor JDO mapping could look
		    as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Catalogue"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"catalogue"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.sample.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"arraylist"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"c_id"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Product"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"product"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"desc"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
		</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9337"></a>5.2.2.&nbsp;Using Castor JDO manually</h3></div></div></div><p>
            To e.g. load a given <code class="literal">Catalogue</code> instance as defined by its identity,
		    and all its associated <code class="literal">Product</code> instances, the following code could be used, 
		    based upon the Castor-specific interfaces <code class="literal">JDOManager</code> and <code class="literal">Database</code>.
        </p><pre class="programlisting">
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdoManager = JDOmanager.createInstance(<span class="hl-string">"sample"</span>);

Database database = jdoManager.getDatabase();		
database.begin();
Catalogue catalogue = database.load(catalogue.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Long(1));
database.commit();
database.close();
		</pre><p>For brevity, exception handling has been omitted completely. But is is quite obvious
		   that - when using such code fragments to implement various methods of a DAO - 
		   there's a lot of redundant code that needed to be written again and again - and exception
		   handling is adding some additional complexity here as well.</p><p>
            Enters Spring ORM for Castor JDO, a small layer that allows usage of Castor JDO
		    through Spring ORM, with all the known benefits (exception conversion, templates, 
          tx handling).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9347"></a>5.2.3.&nbsp;Using Castor JDO with Spring ORM - Without CastorTemplate</h3></div></div></div><p>
            Let's see how one might implement the <code class="literal">loadProduct(int)</code> of a 
            <code class="literal">ProductDAO</code> class with the help of Spring ORM using Castor 
            JDO:
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> JDOManager jdoManager;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
    <span class="hl-keyword">this</span>.jdoManager = jdoManager;
  }

  <span class="hl-keyword">public</span> Product loadProduct(<span class="hl-keyword">final</span> <span class="hl-keyword">int</span> id) {
    CastorTemplate tempate = <span class="hl-keyword">new</span> CastorTemplate(<span class="hl-keyword">this</span>.jdoManager);
    <span class="hl-keyword">return</span> (Product) template.execute(
        <span class="hl-keyword">new</span> CastorCallback() {
          <span class="hl-keyword">public</span> Object doInJdo(Database database) <span class="hl-keyword">throws</span> PersistenceException {
            <span class="hl-keyword">return</span> (Product) database.load(Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer (id));
          }
        });
  }
}
		</pre><p>
            Still a lot of code to write, but compared to the above section, the DAO gets
		    passed a fully configured <code class="literal">JDOManager</code> instance through Spring's dependency
		    injection mechanism. All that's required is configuration of Castor's JDOManager
		    as a Spring bean definition in an Spring application context as 
		    follows.
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:jdo-conf.xml"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9356"></a>5.2.4.&nbsp;Using Castor JDO with Spring ORM - With CastorTemplate</h3></div></div></div><p>
            Above code is still quite verbose, as it requires you to write short 
            (though complex) callback functions. To ease life of the Castor JDO 
            user even more, a range of template methods have been added to 
            <code class="classname">CastorTemplate</code>, allowing the implementation of 
            above <code class="classname">ProductDAO</code> to be shortened considerably.
        </p><pre class="programlisting">
public class ProductDaoImplUsingTemplate extends CastorTemplate implements ProductDao {

  private JDOManager jdoManager;

  public void setJDOManager(JDOManager jdoManager) {
    this.jdoManager = jdoManager;
  }

  public Product loadProduct(final int id) {
    return (Product) load(Integer.valueOf(id));
  }
  
  ...
}
		</pre><p>
            Changing the bean definition for <code class="literal">myProductDAO</code> to ...
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImplUsingTemplate"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myJdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
            loading an instance of <code class="classname">Product</code> by its identifier 
            is reduced to ...</p><pre class="programlisting">
ProductDao dao = (ProductDAO) context.getBean (<span class="hl-string">"myProductDAO"</span>);
Product product = dao.load(1);
		</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9368"></a>5.2.5.&nbsp;Using Castor JDO with Spring ORM - With CastorDaoSupport</h3></div></div></div><p>
            Alternatively to extending <code class="literal">CastorTemplate</code>, one could extend the
		    <code class="classname">CastorDaoSupport</code> class and implement the 
            <code class="classname">ProductDAO</code> as 
		    follows.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImplUsingDaoSupport <span class="hl-keyword">extends</span> CastorDaoSupport <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> JDOManager jdoManager;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
    <span class="hl-keyword">this</span>.jdoManager = jdoManager;
  }

  <span class="hl-keyword">public</span> Product loadProduct(<span class="hl-keyword">final</span> <span class="hl-keyword">int</span> id) {
    <span class="hl-keyword">return</span> (Product) getCastorTemplate().load(Integer.valueOf(id));
  }
  
  ...
}
		</pre><p>
            Changing the bean definition for <code class="literal">myProductDAO</code> to ...
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImplUsingDaoSupport"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myJdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
            the code to load an instance of <code class="classname">Product</code> still 
            is as shown above.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9380"></a>5.3.&nbsp;Data access through Castor JDO with the Spring framework</h2></div></div></div><p>We will start with a coverage of Hibernate in a Spring environment, using 
	   it to demonstrate the approach that Spring takes towards integrating O/R 
	   mappers. This section will cover many issues in detail and show different 
	   variations of DAO implementations and transaction demarcations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9383"></a>5.3.1.&nbsp;Resource management</h3></div></div></div><p>Typical business applications are often cluttered with repetitive 
		   resource management code. Many projects try to invent their own 
		   solutions for this issue, sometimes sacrificing proper handling of 
		   failures for programming convenience. Spring advocates strikingly 
		   simple solutions for proper resource handling, namely IoC via 
		   templating; for example infrastructure classes with callback 
		   interfaces, or applying AOP interceptors. The infrastructure cares for 
		   proper resource handling, and for appropriate conversion of specific API 
		   exceptions to an unchecked infrastructure exception hierarchy. Spring introduces 
		   a DAO exception hierarchy, applicable to any data access strategy. For 
		   direct JDBC, the JdbcTemplate class mentioned in a previous section cares 
		   for connection handling, and for proper conversion of SQLException to 
		   the DataAccessException hierarchy, including translation of database-specific 
		   SQL error codes to meaningful exception classes. It supports both JTA 
		   and JDBC transactions, via respective Spring transaction managers.</p><p>This module implements Spring ORM/DAO support for Castor JDO, consisting of a 
		   CastorTemplate analogous to JdbcTemplate, a CastorInterceptor, and a Castor 
		   transaction manager. The major goal is to allow for clear application 
		   layering, with any data access and transaction technology, and for 
		   loose coupling of application objects. No more business service dependencies 
		   on the data access or transaction strategy, no more hard-coded resource 
		   lookups, no more hard-to-replace singletons, no more custom service 
		   registries. One simple and consistent approach to wiring up application 
		   objects, keeping them as reusable and free from container dependencies 
		   as possible. All the individual data access features are usable on their 
		   own but integrate nicely with Spring's application context concept, providing 
		   XML-based configuration and cross-referencing of plain JavaBean instances 
		   that don't need to be Spring-aware. In a typical Spring app, many important 
		   objects are JavaBeans: data access templates, data access objects (that 
		   use the templates), transaction managers, business services (that use 
		   the data access objects and transaction managers), web view resolvers, web 
		   controllers (that use the business services), and so on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9387"></a>5.3.2.&nbsp;JDOManager setup in a Spring container</h3></div></div></div><p>To avoid tying application objects to hard-coded resource lookups, 
		   Spring allows you to define resources like a JDBC DataSource or a 
		   Castor JDOManager as beans in an application context. Application objects 
		   that need to access resources just receive references to such 
		   pre-defined instances via bean references (the DAO definition in the 
		   next section illustrates this). The following excerpt from an XML 
		   application context definition shows how to set up a JDBC DataSource 
		   and a Castor JDOManager on top of it:</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>
		<span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myJDOManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:jdo-conf.xml"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
		</pre><p>Note that switching from a local Jakarta Commons DBCP BasicDataSource 
		   to a JNDI-located DataSource (usually managed by an application server) 
		   is just a matter of configuration:</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jndi.JndiObjectFactoryBean"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/jdbc/myds"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
		</pre><p>You can also access a JNDI-located SessionFactory, using Spring's
		   JndiObjectFactoryBean to retrieve and expose it. However, that is
		   typically not common outside of an EJB context. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9394"></a>5.3.3.&nbsp;The CastorTemplate</h3></div></div></div><p>
			The basic programming model for templating looks as follows,
			for methods that can be part of any custom data access
			object or business service. There are no restrictions on the
			implementation of the surrounding object at all, it just
			needs to provide a Castor JDOManager. It can get the
			latter from anywhere, but preferably as bean reference from
			a Spring application context - via a simple
			setJDOManager(..) bean property setter. The following
			snippets show a DAO definition in a Spring container,
			referencing the above defined JDOManager, and an example
			for a DAO method implementation.
		</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.exolab.castor.dao.ProductDaoImpl"</span>&gt;
	  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;&lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;&lt;<span class="hl-tag">/property</span>&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> Castor castorTemplate;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
     <span class="hl-keyword">this</span>.castorTemplate = <span class="hl-keyword">new</span> CastorTemplate(jdoManager);
  }

  <span class="hl-keyword">public</span> Collection loadProductsByCategory(<span class="hl-keyword">final</span> String category) 
     <span class="hl-keyword">throws</span> DataAccessException { 
    <span class="hl-keyword">return</span> (Collection) <span class="hl-keyword">this</span>.castorTemplate.execute(
       <span class="hl-keyword">new</span> CastorCallback() {
          <span class="hl-keyword">public</span> Object doInCastor(Database database) <span class="hl-keyword">throws</span> PersistenceException {
             database.begin();
             OQLQuery query = database.getOQL(<span class="hl-string">"select p from org.exolab.castor.dao.ProductDao p "</span> + 
                <span class="hl-string">" where p.category = ?"</span>);
             query.bind(category);
             QueryResults results = query.execute();
             database.commit();
             <span class="hl-keyword">return</span> Collections.list();
          }
    );
  }
}
</pre><p>A callback implementation can effectively be used for any Castor 
		   data access. CastorTemplate will ensure that Database instances are
		   properly opened and closed, and automatically participate in
		   transactions. The template instances are thread-safe and reusable, they
		   can thus be kept as instance variables of the surrounding class.</p><p>For simple single step actions like a single find, load, saveOrUpdate, or
		   delete call, CastorTemplate offers alternative convenience methods
		   that can replace such one line callback implementations. Furthermore,
		   Spring provides a convenient CastorDaoSupport base class that
		   provides a setJDOManager(..) method for receiving a JDOManager,
		   and getJDOManager() and getCastorTemplate()for use by subclasses.</p><p>In combination, this allows for very simple DAO implementations for
		   typical requirements:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">extends</span> HibernateDaoSupport 
   <span class="hl-keyword">implements</span> ProductDao {

   <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) 
      <span class="hl-keyword">throws</span> DataAccessException {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.getCastorTemplate().find(<span class="hl-string">"select p from
test.Product product where p.category=?"</span>, category);
   }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9403"></a>5.3.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div></div><p>As alternative to using Spring's CastorTemplate to implement DAOs,
		   data access code can also be written in a more traditional fashion,
		   without wrapping the Hibernate access code in a callback, while still
		   complying to Spring's generic DataAccessException hierarchy. Spring's
		   CastorDaoSupport base class offers methods to access the current
		   transactional Database and to convert exceptions in such a scenario;
		   similar methods are also available as static helpers on the
		   JDOManagerUtils class. Note that such code will usually pass "false"
		   into the getDatabased(..) method's "allowCreate" argument, to enforce
		   running within a transaction (which avoids the need to close the
		   returned Database, as it's lifecycle is managed by the transaction).</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">extends</span> HibernateDaoSupport 
   <span class="hl-keyword">implements</span> ProductDao {

   <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) 
      <span class="hl-keyword">throws</span> DataAccessException, MyException {

      Database database = getDatabase(getJDOManager(), false);
      <span class="hl-keyword">try</span> {
         List result = database.find( <span class="hl-string">"select p from test.Product p where "</span> + 
            <span class="hl-string">" product.category=?"</span>, category, Castor.STRING);
         <span class="hl-keyword">if</span> (result == null) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> MyException(<span class="hl-string">"invalid search result"</span>);
         }
         <span class="hl-keyword">return</span> result;
      } <span class="hl-keyword">catch</span> (PersistenceException ex) {
         <span class="hl-keyword">throw</span> convertCastorAccessException(ex);
      }
   }
}
        </pre><p>The major advantage of such direct Castor JDO access code is that it
		   allows any checked application exception to be thrown within the data
		   access code, while CastorTemplate is restricted to unchecked
		   exceptions within the callback. Note that one can often defer the
		   corresponding checks and the throwing of application exceptions to after
		   the callback, which still allows working with CastorTemplate. In
		   general, the CastorTemplate class' convenience methods are simpler
		   and more convenient for many scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9408"></a>5.3.5.&nbsp;Programmatic transaction demarcation</h3></div></div></div><p>Transactions can be demarcated in a higher level of the application, on
		   top of such lower-level data access services spanning any number of
		   operations. There are no restrictions on the implementation of the
		   surrounding business service here as well, it just needs a Spring
		   PlatformTransactionManager. Again, the latter can come from anywhere,
		   but preferably as bean reference via a setTransactionManager(..) method
		   - just like the productDAO should be set via a setProductDao(..) method.</p><p>The following snippets show a transaction manager and a business service
		   definition in a Spring application context, and an example for a
		   business method implementation.</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myJDOManager"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myTxManager"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

   <span class="hl-keyword">private</span> TransactionTemplate transactionTemplate; 
   
   <span class="hl-keyword">private</span> ProductDao productDao;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTransactionManager(PlatformTransactionManager transactionManager) {
      <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
      <span class="hl-keyword">this</span>.productDao = productDao;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
      <span class="hl-keyword">this</span>.transactionTemplate.execute(
         <span class="hl-keyword">new</span> TransactionCallbackWithoutResult() {
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
               List productsToChange = productDAO.loadProductsByCategory(category); 
               <span class="hl-comment">// do the price increase...</span>
            }
         }
      );
   }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9414"></a>5.3.6.&nbsp;Declarative transaction demarcation</h3></div></div></div><p>Alternatively, one can use Spring's declarative transaction support,
		   which essentially enables you to replace explicit transaction
		   demarcation API calls in your Java code with an AOP transaction
		   interceptor configured in a Spring container. This allows you to keep
		   business services free of repetitive transaction demarcation code, and
		   allows you to focus on adding business logic which is where the real
		   value of your application lies. Furthermore, transaction semantics like
		   propagation behavior and isolation level can be changed in a
		   configuration file and do not affect the business service
		   implementations.</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myJDOManager"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"proxyInterfaces"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"product.ProductService"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"target"</span>&gt;
			&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.DefaultProductService"</span>&gt;
				&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span> /&gt;
			&lt;<span class="hl-tag">/bean</span>&gt;
		&lt;<span class="hl-tag">/property</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"interceptorNames"</span>&gt;
			&lt;<span class="hl-tag">list</span>&gt;
				&lt;<span class="hl-tag">value</span>&gt;myTxInterceptor&lt;<span class="hl-tag">/value</span>&gt;&lt;<span class="hl-comment">!-- the transaction interceptor (configured elsewhere) --</span>&gt;
			&lt;<span class="hl-tag">/list</span>&gt;
		&lt;<span class="hl-tag">/property</span>&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

   <span class="hl-keyword">private</span> ProductDao productDao;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
      <span class="hl-keyword">this</span>.productDao = productDao;
   }

   <span class="hl-comment">// notice the absence of transaction demarcation code in this method </span>
   <span class="hl-comment">// Spring's declarative transaction infrastructure will be demarcating</span>
   <span class="hl-comment">//transactions on your behalf </span>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
      List productsToChange = <span class="hl-keyword">this</span>.productDAO.loadProductsByCategory(category); 
      <span class="hl-comment">// ... </span>
   }
} 
        </pre><p>Spring's TransactionInterceptor allows any checked application exception
		   to be thrown with the callback code, while TransactionTemplate is
		   restricted to unchecked exceptions within the callback.
		   TransactionTemplate will trigger a rollback in case of an unchecked
		   application exception, or if the transaction has been marked
		   rollback-only by the application (via TransactionStatus).
		   TransactionInterceptor behaves the same way by default but allows
		   configurable rollback policies per method.</p><p>The following higher level approach to declarative transactions doesn't
		   use the ProxyFactoryBean, and as such may be easier to use if you have a
		   large number of service objects that you wish to make transactional.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>You are strongly encouraged to read the section entitled Section 9.5,
		      &#8220;Declarative transaction management&#8221; if you have not done so already
		      prior to continuing.
            </p></td></tr></table></div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;

	&lt;!-- JDOManager, DataSource, etc. omitted --&gt;

	&lt;bean id="myTxManager"
		class="org.castor.spring.orm.CastorTransactionManager"&gt;
		&lt;property name="jdoManager" ref="myJDOManager" /&gt;
	&lt;/bean&gt;

	&lt;aop:config&gt;
		&lt;aop:pointcut id="productServiceMethods"
			expression="execution(* product.ProductService.*(..))" /&gt;
		&lt;aop:advisor advice-ref="txAdvice"
			pointcut-ref="productServiceMethods" /&gt;
	&lt;/aop:config&gt;

	&lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
		&lt;tx:attributes&gt;
			&lt;tx:method name="increasePrice*" propagation="REQUIRED" /&gt;
			&lt;tx:method name="someOtherBusinessMethod"
				propagation="REQUIRES_NEW" /&gt;
			&lt;tx:method name="*" propagation="SUPPORTS" read-only="true" /&gt;
		&lt;/tx:attributes&gt;
	&lt;/tx:advice&gt;

	&lt;bean id="myProductService" class="product.SimpleProductService"&gt;
		&lt;property name="productDao" ref="myProductDao" /&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9424"></a>5.3.7.&nbsp;Transaction management strategies</h3></div></div></div><p>Both TransactionTemplate and TransactionInterceptor delegate the actual
		   transaction handling to a PlatformTransactionManager instance, which can
		   be a CastorTransactionManager (for a single Castor JDOManager,
		   using a ThreadLocal Database under the hood) or a JtaTransactionManager
		   (delegating to the JTA subsystem of the container) for Castor
		   applications. You could even use a custom PlatformTransactionManager
		   implementation. So switching from native Castor transaction
		   management to JTA, such as when facing distributed transaction
		   requirements for certain deployments of your application, is just a
		   matter of configuration. Simply replace the Castor transaction
		   manager with Spring's JTA transaction implementation. Both transaction
		   demarcation and data access code will work without changes, as they just
		   use the generic transaction management APIs.</p><p>For distributed transactions across multiple Castor JDOManager instances,
		   simply combine JtaTransactionManager as a transaction
		   strategy with multiple LocalCastorFactoryBean definitions. Each of your
		   DAOs then gets one specific JDOManager reference passed into it's
		   respective bean property. If all underlying JDBC data sources are
		   transactional container ones, a business service can demarcate
		   transactions across any number of DAOs and any number of session
		   factories without special regard, as long as it is using
		   JtaTransactionManager as the strategy.</p><pre class="programlisting">
&lt;beans&gt;

	&lt;bean id="myDataSource1"
		class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
		&lt;property name="jndiName value=" java:comp/env/jdbc/myds1" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myDataSource2"
		class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
		&lt;property name="jndiName" value="java:comp/env/jdbc/myds2" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myJDOManager1"
		class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
        &lt;property name="databaseName" value="test1" /&gt;      
        &lt;property name="configLocation" value="classpath:jdo-conf-1.xml" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myJDOManager2"
		class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
        &lt;property name="databaseName" value="test2" /&gt;      
        &lt;property name="configLocation" value="classpath:jdo-conf-2.xml" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myTxManager"
		class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;

	&lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
		&lt;property name="jdoManager" ref="myJDOManager1" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
		&lt;property name="jdoManager" ref="myJDOManager2" /&gt;
	&lt;/bean&gt;

	&lt;!-- this shows the Spring 1.x style of declarative transaction configuration --&gt;
	&lt;!-- it is totally supported, 100% legal in Spring 2.x, but see also above for the sleeker, Spring 2.0 style --&gt;
	&lt;bean id="myProductService"
		class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
		&lt;property name="transactionManager" ref="myTxManager" /&gt;
		&lt;property name="target"&gt;
			&lt;bean class="product.ProductServiceImpl"&gt;
				&lt;property name="productDao" ref="myProductDao" /&gt;
				&lt;property name="inventoryDao" ref="myInventoryDao" /&gt;
			&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="transactionAttributes"&gt;
			&lt;props&gt;
				&lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
				&lt;prop key="someOtherBusinessMethod"&gt;
					PROPAGATION_REQUIRES_NEW
				&lt;/prop&gt;
				&lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
			&lt;/props&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;
        </pre><p>Both CastorTransactionManager and JtaTransactionManager allow for
		   proper JVM-level cache handling with Castor - without
		   container-specific transaction manager lookup or JCA connector (as long
		   as not using EJB to initiate transactions).</p><p>CastorTransactionManager can export the JDBC Connection used by
		   Castor to plain JDBC access code, for a specific DataSource. This
		   allows for high-level transaction demarcation with mixed Castor/JDBC
		   data access completely without JTA, as long as you are just accessing
		   one database! CastorTransactionManager will automatically expose the
		   Castor transaction as JDBC transaction if the passed-in
		   JDOManager has been set up with a DataSource (through the
		   "dataSource" property of the LocalCastorFactoryBean class).</p><p>Alternatively, the DataSource that the transactions are supposed to be
		   exposed for can also be specified explicitly, through the "dataSource"
		   property of the CastorTransactionManager class.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9432"></a>5.4.&nbsp;Build instructions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9434"></a>5.4.1.&nbsp;Prerequisites</h3></div></div></div><p>
         In order to build the Sping ORM module for Castor JDO, you will have 
         the following requirements met on your system:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Download and install <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org" target="_top">Maven 2</a></p></li><li><p>Download and install a Subversion client.</p></li></ul></div><p>
        As this project uses Maven 2 for build and deployment, all required 
        compile-time dependencies will automatically be resolved by Maven 2
        and deployed into your local Maven 2 repository.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9444"></a>5.4.2.&nbsp;Building the Spring ORM module</h3></div></div></div><p>
            This section describes how to build the Spring module from a command 
            line using Maven 2. Whilst there is support for Maven 2 in various
            IDEs (including e.g. Eclipse, IDEA, etc.), using the Maven command 
            line seems to be the most adequate least common denominator.
        </p><p>
            This section assumes that you have ckecked out the latest sources
            from the SVN repsitory for the Spring ORM module for Castor JDO.
            Instructions for doing so are provided 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="source-repository.html" target="_top">here</a>.
        </p><p>
            Open a command line (shell) on your system, and issue the following 
            commands:
        </p><pre class="programlisting">
 &gt; mvn jar            
        </pre><p>
            Above command will compile the sources and create the distribution JAR
            in the <code class="literal">target</code> directory of the project root.
        </p><p>
           To install the newly created distribution JAR into your local Maven 2
           repository, please issue the following command:
        </p><pre class="programlisting">
 &gt; mvn install            
        </pre><p>
           To create the complete project documentation - in addition to
           the distribution assembly, please issue ...
        </p><pre class="programlisting">
 &gt; mvn site            
        </pre></div></div></div>

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jpa"></a>Chapter&nbsp;6.&nbsp;Castor JDO - Support for the JPA specification</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.why"></a>6.1.&nbsp;JPA annotations - Motivation</h2></div></div></div><p>
            It has always been a goal of the Castor JDO project to 
            eventually fully support the JPA specification and become a 
            first class JPA provider that can e.g. be easily integrated
            with Spring ORM. Whilst full compliance is still work 
            in progress, there are several small areas where sufficient 
            progress has been made, and where partial support 
            will be made available to the user community.
        </p><p>
            One such area is (partial) support for JPA annotations. This chapter 
            highlights how JPA-annotated Java classes can be used with 
            Castor JDO to persist such classes through the existing persistence 
            framework part of Castor, without little additional requirements.
        </p><p>
            The following sections describe ...
        </p><div class="orderedlist"><ol type="1"><li><p>The prerequisites.</p></li><li><p>The current limitations.</p></li><li><p>The supported JPA annotations.</p></li><li><p>How to use Castor JDO to persist JPA-annotated classes.</p></li><li><p>How to use Castor JDO as Spring ORM provider to persist JPA-annotated classes.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9475"></a>6.2.&nbsp;Prerequisites and outline</h2></div></div></div><p>
            The following sections assume that you have a (set of) JPA-annotated
            domain classes which you would like to persist using
            Castor JDO.
        </p><p>
            As such, we explain how to enlist those classes with
            Castor JDO (through the <code class="classname">JDOClassDescriptorResolver</code>
            interface, so that Castor JDO will be able to find and work with your
            JPA-annotated classes. In addition, we explain how to achieve the same
            with Spring ORM and the Spring ORM provider for Castor JDO.
        </p><p>
            By the end of this chapter is should become obvious that 
            Castor JDO is well-prepared to integrate with the annotation part of the
            JPA specification, although support for JPA annotations is 
            currently limited.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.annotations.limitations"></a>6.3.&nbsp;Limitations and Basic Information</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9483"></a>6.3.1.&nbsp;persistence.xml</h3></div></div></div><p>
                 In Castor JPA there is no use or support for a JPA
                 <code class="filename">persistence.xml</code> configuration file for 
                 now. All required configuration needs to be supplied by one 
                 of the following means:
            </p><div class="itemizedlist"><ul type="disc"><li><p>Castor JDO configuration file.</p></li><li><p><code class="classname">JDOClassDescriptorResolver</code> configuration.</p></li><li><p>Spring configuration file for the Spring ORM provider for Castor JDO.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9495"></a>6.3.2.&nbsp;JPA access type and the placing of JPA annotations</h3></div></div></div><p>
                Because Castor does not support direct field access, this 
                feature is not supported by Castor JPA. Thus all annotations have 
                to be defined on the getter methods of the fields. If JPA related 
                annotations are found on fields, Castor will throw an 
                exception.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9498"></a>6.3.3.&nbsp;Primary Keys</h3></div></div></div><p>		
                Primary keys made of single fields are supported by Castor as defined 
                in the JPA specification (through the use of the <code class="literal">@Id</code> annotation). If 
                you need to define composite primary keys, please note that that 
                Castor does <span class="bold"><strong>not</strong></span> support relations 
                with composite primary keys.
            </p><p>
                If you still want to persist single classes with the use of 
                composite primary keys, none of the available JPA annotations 
                (<code class="literal">@EmbeddedId</code> or <code class="literal">@IdClass</code>) is supported as such. Instead Castor 
                uses a kind of ad-hoc <code class="literal">IdClass</code> mechanism. Simply 
                define multiple <code class="literal">@Id</code> annotations on the fields that make up your 
                composite primary key, and Castor JDO will internally create the 
                relevant constructs.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9508"></a>6.3.4.&nbsp;Inheritance, mapped superclasses, etc.</h3></div></div></div><p>
                These JPA annotations are currently <span class="bold"><strong>not</strong></span>
                supported by Castor JDO. For now, you can only define entities.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9512"></a>6.3.5.&nbsp;Relations</h3></div></div></div><p>
                Besides the fact, that Castor does not support composite primary keys 
                in relations, there are some limitations on the different kinds of 
                relations between entities. For detailed information, please read the 
                documentation about the different relations types further below.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.annotations"></a>6.4.&nbsp;An outline of JPA-Annotations</h2></div></div></div><p>
		</p><table class="simplelist" border="0" summary="Simple list"><tr><td>S ... Supported</td></tr><tr><td>PS ... Partially Supported</td></tr><tr><td>NS ... Not Supported</td></tr></table><p>
	</p><div class="table"><a name="jpa.annotations.table"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;JPA-Annotations</b></p><div class="table-contents"><table summary="JPA-Annotations" border="1"><colgroup><col align="left"><col><col align="left"></colgroup><thead><tr><th align="left">Annotation</th><th align="center">Supported</th><th align="left">Comment</th></tr></thead><tbody><tr><td align="left">AssociationOverride</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AssociationOverrides</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AttributeOverride</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">AttributeOverrides</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Basic</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">See information on Castor fetch types!</td></tr><tr><td align="left">Column</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: column name, nullable</td></tr><tr><td align="left">ColumnResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">DiscriminatorColumn</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support Joined Table Class Hierachy.
					</td></tr><tr><td align="left">DiscriminatorValue</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support Joined Table Class Hierachy.
					</td></tr><tr><td align="left">Embeddable</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Embedded</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">EmbeddedId</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor does not support composed primary keys embedded
						in classes of their own.</td></tr><tr><td align="left">Entity</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is needed to tell Castor that this Class
						is an entity.</td></tr><tr><td align="left">EntityListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">EntityResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Enumerated</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ExcludeDefaultListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ExcludeSuperclassListeners</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">FieldResult</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">GeneratedValue</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Id</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">Use this annotation to make a field a primary key (or
						part of it).</td></tr><tr><td align="left">IdClass</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">Castor creates IdClass-like behaviour implicity when
						you define multiple Id fields. Castor does not support composed
						primary keys in relations!</td></tr><tr><td align="left">Inheritance</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">JoinColumn</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name</td></tr><tr><td align="left">JoinColumns</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">This is not supported because Castor does not support
						composed keys in relations.</td></tr><tr><td align="left">JoinTable</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name, joincolumns, inverseJoincolumns
					</td></tr><tr><td align="left">Lob</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">ManyToMany</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">this is not tested properly yet.</td></tr><tr><td align="left">ManyToOne</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, optional, cascade -
						Relations MUST BE optional! Required relations are not supported.
					</td></tr><tr><td align="left">MapKey</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">MappedSuperclass</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">NamedQuery</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is used to specify a named query in OQL.</td></tr><tr><td align="left">NamedQueries</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation specifies an array of named queries</td></tr><tr><td align="left">NamedNativeQuery</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation is used to specify a native SQL named query.</td></tr><tr><td align="left">NamedNativeQueries</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">This annotation specifies an array of named native queries.</td></tr><tr><td align="left">OneToMany</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, mappedBy, cascade</td></tr><tr><td align="left">OneToOne</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: targetEntity, fetch, optional, cascade -
						Relations MUST BE optional! Required relations are not supported.
					</td></tr><tr><td align="left">OrderBy</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceContext</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceContexts</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceProperty</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceUnit</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PersistenceUnits</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostLoad</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostPersist</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostRemove</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PostUpdate</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrePersist</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PreRemove</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PreUpdate</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrimaryKeyJoinColumn</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">PrimaryKeyJoinColumns</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">QueryHint</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SecondaryTable</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SecondaryTables</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SequenceGenerator</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SqlResultSetMapping</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">SqlResultSetMappings</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Table</td><td bgcolor="#F7FE2E" align="center">
						PS
					</td><td align="left">Supported: name</td></tr><tr><td align="left">TableGenerator</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Temporal</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Transient</td><td bgcolor="#2EFE2E" align="center">
						S
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">UniqueConstraint</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr><tr><td align="left">Version</td><td bgcolor="#FE2E2E" align="center">
						NS
					</td><td align="left">&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9790"></a>6.5.&nbsp;Usage of JPA annotations - Configuration</h2></div></div></div><p>
        This selection of HOW-TOs will show you how to persist 
        JPA-annotated classes with Castor JDO, and will outline
        the required steps for each of the following cases:
    </p><div class="itemizedlist"><ul type="disc"><li><p>Singular (stand-alone) entities</p></li><li><p>1:1 relations</p></li><li><p>1:M relations</p></li><li><p>M:N relations</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9802"></a>6.5.1.&nbsp;HOW-TO persist a single class (@Entity, @Table, @Id)</h3></div></div></div><p>
            The goal is to take an existing JPA-annotated class 
            <code class="classname">Single</code> and persist it with 
            Castor JDO. Let's first have a look at the domain class 
            itself, first without JPA annotattions.            
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Single {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id ) { ... }
   
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
}
        </pre><p>
            Here's the same class again, this time with JPA
            annotations.
        </p><pre class="programlisting">
@Entity
@Table(name=<span class="hl-string">"mySingleTable"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Single {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   
   @Id
   @Column(name=<span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
}
        </pre><p>
            As shown, the class <code class="classname">Single</code> is 
            mapped against the table <code class="literal">mySingleTable</code>,
            and its fields <code class="literal">id</code> and <code class="literal">name</code> 
            are mapped to the columns <code class="literal">id</code> and 
            <code class="literal">name</code>, where the column name for the 
            <code class="literal">id</code> property is supplied explicitly and 
            where the column name for the <code class="literal">name</code>
            property is derived from the property itself.
        </p><p>
            Next point is to create an DAO interface and 
            its implementation where we will be using 
            <code class="classname">CastorDaoSupport</code> from Castor's 
            support for Spring ORM to implement the required methods.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> SingleDao {
	
    <span class="hl-keyword">void</span> save(Single single);
	
    Single get(<span class="hl-keyword">int</span> id);
	
    <span class="hl-keyword">void</span> delete(Single single);

}
   
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SingleCastorDao <span class="hl-keyword">extends</span> CastorDaoSupport <span class="hl-keyword">implements</span> SingleDao {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> delete(Single single) {
        <span class="hl-keyword">this</span>.getCastorTemplate().remove(single);
    }

    <span class="hl-keyword">public</span> Single get(<span class="hl-keyword">int</span> id) {
        <span class="hl-keyword">return</span> (Single) <span class="hl-keyword">this</span>.getCastorTemplate().load(Single.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(id));
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> save(Single single) {
        <span class="hl-keyword">this</span>.getCastorTemplate().create(single);
    }
}
   </pre><p>
            There's one small final code change needed: For Castor to be able to work 
            with JPA-annotated classes, you have to configure an instance of 
            <code class="classname">JDOClassDescriptorResolver</code> and pass 
            it to your <code class="classname">JDOManager</code>, else Castor 
            won't be able to see those class files. Simply add 
            the individual classes one by one or the package(s)
            as shown below:
        </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = <span class="hl-keyword">new</span> JDOClassDescriptorResolverImpl();
resolver.addClass(org.castor.jpa.Single.<span class="hl-keyword">class</span>);
<span class="hl-comment">// or alternatively you can add the package:</span>
resolver.addPackage(<span class="hl-string">"org.castor.jpa"</span>);
		
InputSource jdoConfiguration = ...;
JDOManager.loadConfiguration(jdoConfiguration, null, null, resolver);
		
JDOManager jdoManager = JDOManager.createInstance(<span class="hl-string">"jpa-extensions"</span>);
...
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9825"></a>6.5.2.&nbsp;HOW-TO persist a 1:1 relation (@OneToOne)</h3></div></div></div><p>
            The goal is to take the existing JPA-annotated classes 
            <code class="classname">OneToOne_A</code> and <code class="classname">OneToOne_B</code>
            and persist them with Castor JDO. Let's first have a look 
            at the domain classes themselves, this time with JPA 
            annotations already in place.            
        </p><pre class="programlisting">
@Entity
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OneToOne_A {

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String title;
   
   @Id
   @Column(name = <span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   @Column(name = <span class="hl-string">"name"</span>)
   <span class="hl-keyword">public</span> String getTitle() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTitle(String title) { ... }
}
   
@Entity
@Table(name=<span class="hl-string">"OneToOne_B"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> B {

   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id;
   <span class="hl-keyword">private</span> String name;
   <span class="hl-keyword">private</span> OneToOne_A objA;
   
   @Id
   @Column(name = <span class="hl-string">"id"</span>)
   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... }
   
   @Column(name = <span class="hl-string">"name"</span>)
   <span class="hl-keyword">public</span> String getName() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... }
   
   @OneToOne(optional=false)
   <span class="hl-keyword">public</span> OneToOne_A getOneToOne_A() { ... }
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOneToOne_a(OneToOne_A objA) { ... }
}
        </pre><p>
            As shown, the class <code class="classname">OneToOne_A</code> is 
            mapped against the table <code class="literal">OneToOne_A</code>
            (implicit mapping), and the <code class="classname">B</code> 
            against the table <code class="literal">OneToOne-B</code> (explicit 
            mapping). Please note the <code class="literal">@OneToOne</code> annotation 
            that specifies the 1:1 relation from class 
            <code class="classname">B</code> to class 
            <code class="classname">OneToOne_A</code>.
        </p><p>
            As with the example shown further above, do not forget to 
            register all classes involved with the 
            <code class="classname">JDOClassDescriptorResolver</code>
            as shown below:
        </p><p>JDOClassDescriptorResolver fragment:</p><pre class="programlisting">
resolver.addClass(org.castor.jpa.OneToOne_A.<span class="hl-keyword">class</span>);
resolver.addClass(org.castor.jpa.B.<span class="hl-keyword">class</span>);
        </pre><p>or with the <code class="methodname">addPackage</code> method:</p><pre class="programlisting">
resolver.addPackage(<span class="hl-string">"org.castor.jpa"</span>);
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9846"></a>6.5.3.&nbsp;Persist one to many relation (@OnetoMany)</h3></div></div></div><p>First we have to annotate our java classes.</p><pre class="programlisting">
    @Entity
    @Table(name=<span class="hl-string">"OneToMany_actor"</span>)
    <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {
    
        <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> svnr;
        <span class="hl-keyword">private</span> String lastname;
        <span class="hl-keyword">private</span> String firstname;
    
        @Id
        <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getSvnr() { ... }
        
	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSvnr(<span class="hl-keyword">int</span> svnr) { ... }
    
        @Column(name=<span class="hl-string">"surname"</span>)
        <span class="hl-keyword">public</span> String getLastname() { ... }
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setLastname(String lastname) { ... }
    
        @Column(name=<span class="hl-string">"firstname"</span>)
        <span class="hl-keyword">public</span> String getFirstname() { ... }
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFirstname(String firstname) { ... }
    }
    
    @Entity 
    @Table(name=<span class="hl-string">"OneToMany_broadcast"</span>) 
    <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Broadcast { 
     
        <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> id; 
        <span class="hl-keyword">private</span> String name; 
        <span class="hl-keyword">private</span> Collection&lt;Actor&gt; actors; 
     
        @Id 
        <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... } 
	
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { ... } 
     
        <span class="hl-keyword">public</span> String getName() { ... } 
     
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { ... } 
     
        @OneToMany(targetEntity=Actor.<span class="hl-keyword">class</span>, mappedBy=<span class="hl-string">"actor_id"</span>) 
        <span class="hl-keyword">public</span> Collection&lt;Actor&gt;  getActors() { ... } 
     
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setActors(Collection&lt;Actor&gt; actors) { ... }
    } 
   </pre><p>What you see is that with the small modification you can persist one to many relations easily.</p><p>Last don't forget to change your JDOClassDescriptorResolver accordingly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9852"></a>6.5.4.&nbsp;HOW-TO create and use a named query (@NamedQuery)</h3></div></div></div><p>
            The <code class="literal">@NamedQuery</code> annotation is used to specify a
            named query in castor's own query language (OQL) and it is expressed
            in metadata. The annotation takes the <code class="literal">name</code> and
            an OQL <code class="literal">query</code> as parameters.
        </p><p>
            To define a named query, we first need a persistence entity where we
            can attach the <code class="literal">@NamedQuery</code> annotation.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@NamedQuery(name = <span class="hl-string">"findPersonByName"</span>, 
            query = <span class="hl-string">"SELECT p FROM your.package.Person p WHERE p.name = $1"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

	@Id
	<span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

	<span class="hl-keyword">public</span> String getName() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>
            As you can see, we defined a query using the name <code class="literal">
            findPersonByName</code>. The query itself uses
            <code class="literal">$1</code> as a placeholder in its <code class="literal">WHERE</code>-clause,
            which must be bound when executing the query.
        </p><p>
            The following code sample illustrates how to execute the named query defined
            above:
        </p><div class="programlistingco"><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findPersonByName"</span>);                           <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
query.bind(<span class="hl-string">"Max Mustermann"</span>);                                                          <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();                                     <span class="co"><img src="images/callouts/3.png" alt="(3)"></span>
<span class="hl-keyword">final</span> Person queriedPerson = (Person) queryResults.next();
queryResults.close();
db.commit();
            </pre></div><p>Let's have a closer look on some of the lines from this example.</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>... creates an OQL query using the above defined named query.</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>.. binds the placeholder <code class="literal">$1</code> to a value.</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/3.png" alt="3" border="0"></td><td valign="top" align="left"><p>... executes the query and handle the results.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9881"></a>6.5.5.&nbsp;HOW-TO create and use multiple named queries (@NamedQueries)</h3></div></div></div><p>The <code class="literal">@NamedQueries</code> annotation is used to specifiy 
        multiple named queries.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@NamedQueries({
    @NamedQuery(name = <span class="hl-string">"findPersonByName"</span>,
                query = <span class="hl-string">"SELECT p FROM your.package.Person p WHERE p.name = $1"</span>),
    @NamedQuery(name = <span class="hl-string">"findPersonById"</span>,
                query = <span class="hl-string">"SELECT p FROM you.package.Person p WHERE p.id = $1"</span>)
})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

    @Id
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

    <span class="hl-keyword">public</span> String getName() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>In the obove example we defined two named queries, namly
        <code class="literal">findPersonByName</code> and <code class="literal">findPersonById</code>.
        The usage of each query is identical to the usasage of a single named query.
        </p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findPersonById"</span>);
query.bind(1000L);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
<span class="hl-keyword">final</span> Person queriedPerson = (Person) queryResults.next();
queryResults.close();
db.commit();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9890"></a>6.5.6.&nbsp;HOW-TO create and use a named native query (@NamedNativeQuery)</h3></div></div></div><p>A named native query is a named query using native SQL syntax
        instead of castor's own query language. The handling of the annotation
        is similar to named queries.</p><p>First we need a entity to attach a query.</p><pre class="programlisting">
@Entity
@Table(name = personTable)
@NamedNativeQuery(name = <span class="hl-string">"selectAllPersons"</span>,
                  query = <span class="hl-string">"SELECT * FROM personTable"</span>)
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

	@Id
	<span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

	<span class="hl-keyword">public</span> String getName() {...}

	<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>Although the <code class="literal">query</code> itself is written
        in native SQL syntax, we - again - use a <code class="classname">OQLQuery</code> object
        to execute the query.</p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"selectAllPersons"</span>);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
... <span class="hl-comment">//process the results</span>
queryResults.close();
db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9899"></a>6.5.7.&nbsp;HOW-TO create and use multiple named native queries (@NamedNativeQueries)</h3></div></div></div><p>The <code class="literal">@NamedNativeQueries</code> annotation is used to specifiy
        multiple named native SQL queries.
        </p><pre class="programlisting">
<span class="hl-keyword">package</span> your.<span class="hl-keyword">package</span>;

@Entity
@Table(name = personTable)
@NamedNativeQueries({
    @NamedNativeQuery(name = <span class="hl-string">"selectAllPersons"</span>,
                      query = <span class="hl-string">"SELECT * FROM personTable"</span>),
    @NamedNativeQuery(name = <span class="hl-string">"findMustermann"</span>,
                      query = <span class="hl-string">"SELECT * FROM personTable WHERE name='Max Mustermann' and id=1000"</span>)
})
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {

    <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
    <span class="hl-keyword">private</span> String name;

    @Id
    <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {...}

    <span class="hl-keyword">public</span> String getName() {...}

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {...}
}
        </pre><p>As we have already seen, the usage of the two above defined queries
        is equivalent to the usage of a single named native query.
        </p><pre class="programlisting">
Database db = jdoManager.getDatabase();

db.begin();
<span class="hl-keyword">final</span> OQLQuery query = db.getNamedQuery(<span class="hl-string">"findMustermann"</span>);
<span class="hl-keyword">final</span> QueryResults queryResults = query.execute();
<span class="hl-keyword">final</span> Person maxMustermann = (Person) queryResults.next();
queryResults.close();
db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9906"></a>6.5.8.&nbsp;HOW-TO use persistence callbacks</h3></div></div></div><p>
        The following annotations can be used for handling persistence callbacks via JPA:
        </p><div class="itemizedlist"><ul type="disc"><li>PostLoad</li><li>PrePersist</li><li>PostPersist</li><li>PreUpdate</li><li>PostUpdate</li><li>PreRemove</li><li>PostRemove</li></ul></div><p>
    </p><p>
        Additionally, there are the following listener-related annotations:
        </p><div class="itemizedlist"><ul type="disc"><li>EntityListeners</li><li>ExcludeDefaultListeners</li><li>ExcludeSuperclassListeners</li></ul></div><p>
    </p><p>
        So, here's a basic usage example:
    </p><pre class="programlisting">
@Entity
public class Person {

    private final Log log = LogFactory.getLog(this.getClass());

    private long id;
    private String name;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    @PostLoad
    protected void testPostLoadCallbackHooking() {
        log.debug(String.format("Hello from `PostLoad`. My name is %s.",
                this.name));
    }

    @PrePersist
    protected void validateCreation() {
        if (this.name.equals("Max Mustermann")) {
            throw new PersistenceException(String.format(
                    "Person mustn't be called %s.", this.name));
        }
    }

    @PostPersist
    protected void validatePersistence() {
        if (this.name.equals("Manfred Mustermann")) {
            throw new PersistenceException(String.format(
                    "Person shouldn't be called %s either.", this.name));
        }
    }

    @PreRemove
    protected void validateRemoval() {
        if (this.name.equals("Max Musterfrau")) {
            throw new PersistenceException(this.name + " mustn't be removed.");
        }
    }

    @PostRemove
    protected void validateDeletion() {
        if (this.name.equals("Manfred Musterfrau")) {
            throw new PersistenceException(this.name
                    + " shouldn't be removed either.");
        }
    }

    @PreUpdate
    protected void validateModification() {
        if (this.name.equals("Max Musterfrau")) {
            throw new PersistenceException(String.format(
                    "Person mustn't be renamed to %s.", this.name));
        }
    }

    @PostUpdate
    protected void validateUpdating() {
        if (this.name.equals("Hans Wurst")) {
            throw new PersistenceException(String.format(
                    "Person shouldn't be renamed to %s either.", this.name));
        }
    }

}
    </pre><p>
        As one can see from this example, such callbacks can e.g. be used for
        handling validation based on CRUD (create, retrieve, update, delete)
        operation events.
    </p><p>
        Furthermore, there are possibilites to define listeners which allow for
        decoupling callback handling from entities.
    </p><p>
        Here's an example for that:
    </p><pre class="programlisting">
@Entity
@EntityListeners(DogListener.class)
public class Dog extends Animal {

    private long id;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

}

// Corresponding listener.
public class DogListener {

    @PostPersist
    protected void postPersistDogListener() {
        // Do something.
    }

}
    </pre><p>
        Apart from that, <code class="literal">ExcludeDefaultListeners</code> and
        <code class="literal">ExcludeSuperclassListeners</code> enable specifying
        exclusion of listeners within an inheritance chain of entities.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9931"></a>6.5.9.&nbsp;HOW-TO use @Enumerated</h3></div></div></div><p>
        <code class="literal">Enumerated</code> can be used to persist
        <code class="literal">Enum</code> types.
    </p><p>
        Here's an example:
    </p><pre class="programlisting">
@Entity
public class EnumEntity {

    private long id;
    private StringEnum stringEnum;
    private OrdinalEnum ordinalEnum;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Enumerated(STRING)
    public StringEnum getStringEnum() {
        return stringEnum;
    }

    public void setStringEnum(final StringEnum stringEnum) {
        this.stringEnum = stringEnum;
    }

    public OrdinalEnum getOrdinalEnum() {
        return ordinalEnum;
    }

    public void setOrdinalEnum(final OrdinalEnum ordinalEnum) {
        this.ordinalEnum = ordinalEnum;
    }

}
    </pre><p>
        So, by default enums are serialized to their corresponding ordinal
        value representations for persistence. In this case, it's also
        sufficient to skip explicitly defining so via
        <code class="literal">Enumerated</code>. If serialization to respective string
        name representations is preferred annotating accordingly is required.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9940"></a>6.5.10.&nbsp;HOW-TO use @Temporal</h3></div></div></div><p>
        This annotation can be used to specify properties mapped to temporal
        data structures.
    </p><p>Example:</p><pre class="programlisting">
@Entity
public class Person {

    private long id;
    private Date birthDate;
    private Date anotherDate;
    private Date yetAnotherDate;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Temporal(TIMESTAMP)
    public Date getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(final Date birthDate) {
        this.birthDate = birthDate;
    }

    @Temporal(TIME)
    public Date getAnotherDate() {
        return anotherDate;
    }

    public void setAnotherDate(final Date anotherDate) {
        this.anotherDate = anotherDate;
    }

    @Temporal(DATE)
    public Date getYetAnotherDate() {
        return yetAnotherDate;
    }

    public void setYetAnotherDate(final Date yetAnotherDate) {
        this.yetAnotherDate = yetAnotherDate;
    }

}
    </pre><p>
        So, it's possible to say which underlying DB-based field data structure
        to use (datetime, date or time).
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9946"></a>6.5.11.&nbsp;HOW-TO use @Lob</h3></div></div></div><p>
        Here's an example for that:
    </p><pre class="programlisting">
@Entity
public class LobEntity {

    private long id;
    private String clob;
    private byte[] blob;

    @Id
    public long getId() {
        return id;
    }

    public void setId(final long id) {
        this.id = id;
    }

    @Lob
    public String getClob() {
        return clob;
    }

    public void setClob(final String clob) {
        this.clob = clob;
    }

    @Lob
    public byte[] getBlob() {
        return blob;
    }

    public void setBlob(final byte[] blob) {
        this.blob = blob;
    }

}
    </pre><p>
        Consequently, default behavior here is to serialize to
        <code class="literal">CLOB</code> for character-based data and to
        <code class="literal">BLOB</code> for data based on byte arrays (i.e., files).
    </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9953"></a>6.6.&nbsp;Integration with Spring ORM for Castor JDO</h2></div></div></div><p>
        This guide will show you how to enable the use of JPA annotations 
        with Castor JDO in the context of Spring, Spring ORM and the
        existing Spring ORM support for Castor JDO.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9956"></a>6.6.1.&nbsp;A typical sample</h3></div></div></div><p>
            Let's look at a typical Spring configuration file
            that shows how to use Castor JDO with Spring as a 
            Spring ORM provider.
        </p><p>spring-config.xml</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> 
       <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span> 
       <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
       <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
          http://www.springframework.org/schema/tx 
          http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;
    
    &lt;<span class="hl-comment">!-- Enable transaction support using Annotations --</span>&gt;
    &lt;<span class="hl-tag">tx:annotation-driven</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">"transactionManager"</span> /&gt;
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"transactionManager"</span> 
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
          &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"jdoManager"</span> /&gt; 
    &lt;<span class="hl-tag">/bean</span>&gt;

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"dbName"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdo-conf.xml"</span> /&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"singleDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"SingleCastorDao"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
            &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
&lt;<span class="hl-tag">/beans</span>&gt; 
        </pre><p>
            Above Spring application context configures the following
            Spring beans:
        </p><div class="itemizedlist"><ul type="disc"><li><p>A factory bean for JDOManager instantiation</p></li><li><p>A Castor-specific transaction manager.</p></li><li><p>The DAO implementation as shown above.</p></li></ul></div><p>
            As shown above, the bean definition for the 
            <code class="classname">JDOManager</code> factory bean points to
            a Castor JDO configuration file (<code class="filename">jdo-conf.xml</code>),
            whose content is shown below:
        </p><p>jdo-conf.xml</p><pre class="programlisting">
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN""http://castor.org/jdo-conf.dtd"&gt;</span>
<span class="hl-attribute">&lt;jdo-conf&gt;</span>
  <span class="hl-attribute">&lt;database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dbName"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"mysql"</span>&gt;
     &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:mysql://localhost:3306/single"</span> 
             <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span>&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"password"</span> /&gt;
     &lt;<span class="hl-tag">/driver</span>&gt;
     &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"mapping-empty.xml"</span> /&gt;
  &lt;<span class="hl-tag">/database</span>&gt;
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span> /&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
        </pre><p>
            More on how to configure the Spring ORM provider for 
            Castor JDO can be found at TBD.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9975"></a>6.6.2.&nbsp;Adding a <code class="classname">JDOClassDescriptorResolver</code> configuration</h3></div></div></div><p>
            In order to use JPA-annotated classes with the Spring ORM provider 
            for Castor JDO, you will have to use and configure a 
            <code class="classname">JDOClassDescriptorResolver</code> through an
            additional bean definition and link it to your 
            <code class="classname">JDOManager</code> bean factory definition.
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://www.springframework.org/schema/beans"</span> 
          <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema-instance"</span> 
          <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">"http://www.springframework.org/schema/tx"</span>
          <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;
    
    ...

    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"classDescriptorResolver"</span>                                                 <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.ClassDescriptorResolverFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classes"</span>&gt;
            &lt;<span class="hl-tag">list</span>&gt;
                &lt;<span class="hl-tag">value</span>&gt;org.castor.jpa.test.Single&lt;<span class="hl-tag">/value</span>&gt;
            &lt;<span class="hl-tag">/list</span>&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;

    ...
    
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"dbName"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdo-conf.xml"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"classDescriptorResolver"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"classDescriptorResolver"</span> /&gt;      <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
    &lt;<span class="hl-tag">/bean</span>&gt;
    
    ...
&lt;<span class="hl-tag">/beans</span>&gt; 
            </pre></div><p>
            where ....
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                    Defines a <code class="classname">JDOClassDescriptorResolver</code>
                    bean enlisting all the Java (domain) classes that
                    carry JPA annotations.                   
                </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                    links the <code class="classname">JDOClassDescriptorResolver</code>
                    bean to the <code class="literal">classDescriptorResolver</code> property 
                    of the <code class="classname">JDOManager</code> bean definition.                   
                </p></td></tr></table></div><p>
            If your domain classes share a set of packages, it is also 
            possible to enlist those packages with the 
            <code class="classname">JDOClassDescriptorResolver</code> bean, replacing
            the bean definition shown above as follows:
        </p><pre class="programlisting">
    &lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"classDescriptorResolver"</span>
          <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.ClassDescriptorResolverFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"packages"</span>&gt;
            &lt;<span class="hl-tag">list</span>&gt;
                &lt;<span class="hl-tag">value</span>&gt;org.castor.jpa.test&lt;<span class="hl-tag">/value</span>&gt;
            &lt;<span class="hl-tag">/list</span>&gt;
        &lt;<span class="hl-tag">/property</span>&gt;
    &lt;<span class="hl-tag">/bean</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10000"></a>6.6.3.&nbsp;JPA Callbacks</h3></div></div></div><p>
            In order to enable JPA callbacks handling via Spring ORM following
            exemplary config snippet is required:
        </p><pre class="programlisting">
&lt;bean id="jdoManager" class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
    &lt;property name="databaseName" value="testSimple" /&gt;
    &lt;property name="configLocation"
        value="classpath:org/castor/jpa/scenario/callbacks/derby-jdo-conf.xml" /&gt;
    &lt;property name="classDescriptorResolver" ref="classDescriptorResolver" /&gt;
    &lt;property name="callbackInterceptor" ref="jpaCallbackHandler" /&gt;
&lt;/bean&gt;

&lt;bean id="jpaCallbackHandler" class="org.castor.jdo.jpa.info.JPACallbackHandler" /&gt;
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jpa.extensions"></a>6.7.&nbsp;Castor JPA Extensions</h2></div></div></div><p>
        This section describes all JPA-extensions provided by Castor.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jpa.extensions.cache"></a>6.7.1.&nbsp;@Cache and @CacheProperty</h3></div></div></div><p>
            In order to get the maximum out of the chosen built-in or
            external cache engine Castor provides a generic way to
            specify properties in a vendor-independent way.
            Castor allows for cache-tuning on a per-entity basis by
            simply providing key-value pairs with the <code class="interfacename">@CacheProperty</code>
            annotation in the <span class="interface">@Cache</span> container annnotation.
        </p><pre class="programlisting">
            @Entity
            @Cache({
                @CacheProperty(key=<span class="hl-string">"type"</span>, value=<span class="hl-string">"ehcache"</span>),
                @CacheProperty(key=<span class="hl-string">"capacity"</span>, value=<span class="hl-string">"50"</span>)
            })
            @Table(name=<span class="hl-string">"Cache_limited"</span>)
            <span class="hl-keyword">public</span> <span class="hl-keyword">class</span> LimitedCachingEntity <span class="hl-keyword">implements</span> CacheTestEntity {
            
                <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
                <span class="hl-keyword">private</span> String name;
            
                @Id
                <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() {
                    <span class="hl-keyword">return</span> id;
                }
            
                <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">final</span> <span class="hl-keyword">long</span> id) {
                    <span class="hl-keyword">this</span>.id = id;
                }
            
                <span class="hl-keyword">public</span> String getName() {
                    <span class="hl-keyword">return</span> name;
                }
            
                <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">final</span> String name) {
                    <span class="hl-keyword">this</span>.name = name;
                }
            
            }
        </pre><p>
            <span class="interface">@Cache</span> is based on Castor JDO and uses its default
            settings: 'count-limited' as cache type with a capacity of 30 entries.
        </p></div></div></div>

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ddlgen"></a>Chapter&nbsp;7.&nbsp;DDL generator for Castor JDO</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ddlgen.introduction"></a>7.1.&nbsp;Castor DDL Generator - An Introduction</h2></div></div></div><p>
		Describes how to use the DDL Generator, and what features and options are
		currently supported.
	</p><p>
	  Castor DDL Generator creates SQL scripts to drop/create tables, unique keys,
	  sequences and so on based on the input of a Castor JDO mapping file.
	</p><pre class="programlisting">
java org.castor.ddlgen.Main -m mapping.xml
	</pre><p>
		This will generate the SQL script <code class="methodname">mapping.sql</code> in the same directory
		<span class="emphasis"><em>mapping.xml</em></span> is located.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10025"></a>7.1.1.&nbsp;DDL Generator Options</h3></div></div></div><p>
		  The DDL Generator has a number of different options which may be set. Some of
		  them are specified at the command line while others need to be configured through
		  a property file. Most of the options are located in global properties file
		  <code class="filename">org/castor/ddlgen/ddlgen.properties</code>, but there are also some 
		  options that are specific for one database engine. These DB-specific properties can 
		  be found at <code class="filename">org/castor/ddlgen/engine/&lt;database&gt;/&lt;database&gt;.properties</code>.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10030"></a>7.1.1.1.&nbsp;Command Line Options</h4></div></div></div><div class="table"><a name="d4e10032"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Command line options</b></p><div class="table-contents"><table summary="Command line options" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Option</th><th>Args</th><th>Description</th><th>Optional?</th></tr></thead><tbody><tr><td>m</td><td>filename</td><td>Castor JDO mapping file to generate DDL for.</td><td>Required</td></tr><tr><td>o</td><td>filename</td><td>Name of file the generated DDL will be written to. If not specified the
						      generated DDL will be written to a file named similar as the Castor JDO
						      mapping source file with <span class="emphasis"><em>xml</em></span> extension being replaced by
						      <span class="emphasis"><em>sql</em></span>.</td><td>Optional</td></tr><tr><td>e</td><td>database engine</td><td>Name of database engine to generate DDL for. The engine used as default
						      can be specified with <code class="filename">org.castor.ddlgen.DefaultEngine</code> option of
						      global properties file.</td><td>Optional</td></tr><tr><td>c</td><td>filename</td><td>Alternative global properties file to be used when generating DDL.</td><td>Optional</td></tr><tr><td>d</td><td>filename</td><td>Alternative database specific properties file to be used when generating DDL.</td><td>Optional</td></tr><tr><td>h</td><td>&nbsp;</td><td>Shows help/usage information.</td><td>Optional</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10075"></a>7.1.2.&nbsp;Database Engines</h3></div></div></div><p>
			The DDL Generator supports generation of SQL scripts for the following
			database engines:
		</p><div class="table"><a name="d4e10078"></a><p class="title"><b>Table&nbsp;7.2.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Name</th><th>Database engine</th><th>Property file</th></tr></thead><tbody><tr><td><span class="bold"><strong>db2</strong></span></td><td>DB/2</td><td>org/castor/ddlgen/engine/db2/db2.properties</td></tr><tr><td><span class="bold"><strong>derby</strong></span></td><td>Apache Derby</td><td>org/castor/ddlgen/engine/derby/derby.properties</td></tr><tr><td><span class="bold"><strong>hsql</strong></span></td><td>Hypersonic SQL</td><td>org/castor/ddlgen/engine/hsql/hsql.properties</td></tr><tr><td><span class="bold"><strong>mssql</strong></span></td><td>Microsoft SQL Server</td><td>org/castor/ddlgen/engine/mssql/mssql.properties</td></tr><tr><td><span class="bold"><strong>mysql</strong></span></td><td>MySQL</td><td>org/castor/ddlgen/engine/mysql/mysql.properties</td></tr><tr><td><span class="bold"><strong>oracle</strong></span></td><td>Oracle</td><td>org/castor/ddlgen/engine/oracle/oracle.properties</td></tr><tr><td><span class="bold"><strong>pointbase</strong></span></td><td>Borland Pointbase</td><td>org/castor/ddlgen/engine/pointbase/pointbase.properties</td></tr><tr><td><span class="bold"><strong>postgresql</strong></span></td><td>PostgreSQL</td><td>org/castor/ddlgen/engine/postgresql/postgresql.properties</td></tr><tr><td><span class="bold"><strong>sapdb</strong></span></td><td>SAP DB / MaxDB</td><td>org/castor/ddlgen/engine/sapdb/sapdb.properties</td></tr><tr><td><span class="bold"><strong>sybase</strong></span></td><td>Sybase</td><td>org/castor/ddlgen/engine/sybase/sybase.properties</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ddlgen.ant.task"></a>7.2.&nbsp;Using the Ant task for the Castor DDL Generator</h2></div></div></div><p>
		Describes how to use the Ant task for the Castor DDL Generator and its features.
	</p><p>
	  An alternative to using the command line as shown in the previous section,
	  the Castor DDL Generator Ant Task can be used to call the DDL
	  generator for class generation. The only requirement is that the
	  castor-&lt;version&gt;-anttasks.jar must be made available to your Ant 
	  installation.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10141"></a>7.2.1.&nbsp;Configuration</h3></div></div></div><p>
          Please find below the complete list of parameters that can be set on the Castor
          source generator.
        </p><div class="table"><a name="d4e10144"></a><p class="title"><b>Table&nbsp;7.3.&nbsp;</b></p><div class="table-contents"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th><th>Required?</th></tr></thead><tbody><tr><td><span class="emphasis"><em>file</em></span></td><td>The name of the Castor JDO mapping file to use as input for DDL generation.</td><td>Yes</td></tr><tr><td>ddlFileName</td><td>The name of the DDL file to be generated.</td><td>Yes</td></tr><tr><td>databaseEngine</td><td>The name of database engine to generate DDL for.</td><td>Yes</td></tr><tr><td>globalProperties</td><td>Name of a custom (global) properties file to be used during DDL generation.</td><td>No</td></tr><tr><td>databaseEngineProperties</td><td>Name of a custom database specific properties file to be used during DDL generation.</td><td>No</td></tr></tbody></table></div></div><br class="table-break"><p>
          Alternatively to specifying the <span class="emphasis"><em>file</em></span> property, it is possible to work 
          with a nested &lt;FileSet&gt; element or with the <span class="emphasis"><em>dir</em></span> property.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10176"></a>7.2.2.&nbsp;Example</h3></div></div></div><p>
        	Below is an example of how to use this task from within an Ant target
          	definition named 'castor:ddl:src':
        </p><pre class="programlisting">
&lt;<span class="hl-tag">target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor:ddl:src"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"init"</span>
           <span class="hl-attribute">description</span>=<span class="hl-value">"Generate a DDL script from a JDO mapping file."</span>&gt;

  &lt;<span class="hl-tag">taskdef</span> <span class="hl-attribute">name</span>=<span class="hl-value">"castor-ddlgen"</span>
           <span class="hl-attribute">classname</span>=<span class="hl-value">"org.castor.anttask.CastorDDLGenTask"</span>
           <span class="hl-attribute">classpathref</span>=<span class="hl-value">"castor.class.path"</span> /&gt;
  &lt;<span class="hl-tag">mkdir</span> <span class="hl-attribute">dir</span>=<span class="hl-value">"generated"</span> /&gt;
  &lt;<span class="hl-tag">castor-ddlgen</span> <span class="hl-attribute">file</span>=<span class="hl-value">"src/main/resources/mapping.xml"</span>
                 <span class="hl-attribute">ddlFileName</span>=<span class="hl-value">"target/generated/ddl/mapping.sql"</span>
                 <span class="hl-attribute">databaseEngine</span>=<span class="hl-value">"mysql"</span>/&gt;
&lt;<span class="hl-tag">/target</span>&gt;
		</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ddlgen.mapping"></a>7.3.&nbsp;Castor DDL Generator - Type Mapping</h2></div></div></div><p>
		This section describes the mapping between Castor sql type java.sql.Types
		constant, java data type, sql type of supported database.
	</p><div class="table"><a name="d4e10183"></a><p class="title"><b>Table&nbsp;7.4.&nbsp;</b></p><div class="table-contents"><table border="1"><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th>Castor Type</th><th>JDBC Type</th><th>Java Object Type</th><th>MySQL</th><th>PostgreSQL</th><th>Oracle</th><th>Derby</th><th>MSSQL</th><th>SapDB</th><th>DB2</th><th>Sybase</th><th>HSQL</th><th>PointBase</th></tr></thead><tbody><tr><td>BIT</td><td>BIT</td><td>java.lang.Boolean</td><td>TINYINT(1)</td><td>BOOLEAN</td><td>BOOLEAN</td><td>CHAR FOR BIT DATA</td><td>BIT</td><td>BOOLEAN</td><td>&nbsp;</td><td>BIT</td><td>BIT</td><td>BOOLEAN</td></tr><tr><td>TINYINT</td><td>TINYINT</td><td>java.lang.Byte</td><td>TINYINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>TINYINT</td><td>SMALLINT</td><td>SMALLINT</td><td>TINYINT</td><td>TINYINT</td><td>SMALLINT</td></tr><tr><td>SMALLINT</td><td>SMALLINT</td><td>java.lang.Short</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td><td>SMALLINT</td></tr><tr><td>INTEGER</td><td>INTEGER</td><td>java.lang.Integer</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td><td>INTEGER</td></tr><tr><td>BIGINT</td><td>BIGINT</td><td>java.lang.Long</td><td>BIGINT</td><td>BIGINT</td><td>NUMERIC</td><td>BIGINT</td><td>BIGINT</td><td>INTEGER</td><td>BIGINT</td><td>INTEGER</td><td>BIGINT</td><td>NUMERIC</td></tr><tr><td>FLOAT</td><td>FLOAT</td><td>java.lang.Double</td><td>FLOAT</td><td>DOUBLE PRECISION</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td><td>FLOAT</td></tr><tr><td>DOUBLE</td><td>DOUBLE</td><td>java.lang.Double</td><td>DOUBLE</td><td>DOUBLE PRECISION</td><td>DOUBLE PRECISION</td><td>DOUBLE</td><td>DOUBLE PRECISION</td><td>DOUBLE PRECISION</td><td>DOUBLE</td><td>DOUBLE PRECISION</td><td>DOUBLE PRECISION</td><td>DOUBLE PRECISION</td></tr><tr><td>REAL</td><td>REAL</td><td>java.lang.Float</td><td>REAL</td><td>REAL</td><td>REAL</td><td>REAL</td><td>REAL</td><td>DOUBLE PRECISION</td><td>REAL</td><td>REAL</td><td>REAL</td><td>REAL</td></tr><tr><td>NUMERIC</td><td>NUMERIC</td><td>java.math.BigDecimal</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td><td>NUMERIC</td></tr><tr><td>DECIMAL</td><td>DECIMAL</td><td>java.math.BigDecimal</td><td>DECIMAL</td><td>NUMERIC</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td><td>DECIMAL</td></tr><tr><td>CHAR</td><td>CHAR</td><td>java.lang.String</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td><td>CHAR</td></tr><tr><td>VARCHAR</td><td>VARCHAR</td><td>java.lang.String</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR2</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR</td><td>VARCHAR</td></tr><tr><td>DATE</td><td>DATE</td><td>java.sql.Date</td><td>DATE</td><td>DATE</td><td>DATE</td><td>DATE</td><td>DATETIME</td><td>DATE</td><td>DATE</td><td>DATETIME</td><td>DATE</td><td>DATE</td></tr><tr><td>TIME</td><td>TIME</td><td>java.sql.Time</td><td>TIME</td><td>TIME</td><td>DATE</td><td>TIME</td><td>DATETIME</td><td>TIME</td><td>TIME</td><td>DATETIME</td><td>TIME</td><td>TIME</td></tr><tr><td>TIMESTAMP</td><td>TIMESTAMP</td><td>java.sql.Timestamp</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td><td>TIMESTAMP</td></tr><tr><td>BINARY</td><td>BINARY</td><td>byte[]</td><td>BINARY</td><td>BYTEA</td><td>RAW</td><td>CHAR [n] FOR BIT DATA</td><td>BINARY</td><td>BLOB</td><td>CHAR [n] FOR BIT DATA</td><td>BINARY</td><td>BINARY</td><td>BLOB</td></tr><tr><td>VARBINARY</td><td>VARBINARY</td><td>byte[]</td><td>VARBINARY</td><td>BYTEA</td><td>LONG RAW</td><td>VARCHAR [] FOR BIT DATA</td><td>VARBINARY</td><td>BLOB</td><td>VARCHAR [] FOR BIT DATA</td><td>VARBINARY</td><td>VARBINARY</td><td>BLOB</td></tr><tr><td>LONGVARBINARY</td><td>LONGVARBINARY</td><td>byte[]</td><td>VARBINARY</td><td>BYTEA</td><td>LONG RAW</td><td>LONG VARCHAR FOR BIT DATA</td><td>IMAGE</td><td>BLOB</td><td>LONG VARCHAR FOR BIT DATA</td><td>VARBINARY</td><td>LONGVARBINARY</td><td>BLOB</td></tr><tr><td>OTHER</td><td>OTHER</td><td>java.lang.Object</td><td>BLOB</td><td>BYTEA</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>OTHER</td><td>BLOB</td></tr><tr><td>JAVA_OBJECT</td><td>JAVA_OBJECT</td><td>java.lang.Object</td><td>BLOB</td><td>BYTEA</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>OBJECT</td><td>BLOB</td></tr><tr><td>BLOB</td><td>BLOB</td><td>java.io.InputStream</td><td>BLOB</td><td>BYTEA</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>BLOB</td><td>BLOB</td><td>IMAGE</td><td>OBJECT</td><td>BLOB</td></tr><tr><td>CLOB</td><td>CLOB</td><td>java.sql.Clob</td><td>TEXT</td><td>TEXT</td><td>CLOB</td><td>CLOB</td><td>TEXT</td><td>CLOB</td><td>CLOB</td><td>TEXT</td><td>OBJECT</td><td>CLOB</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10509"></a>7.3.1.&nbsp;JDBC Types not supported by Castor</h3></div></div></div><p>
			The following JDBC types are not supported by Castor yet. 
		</p><div class="itemizedlist"><ul type="disc"><li>ARRAY</li><li>DISTINCT</li><li>REF</li><li>STRUCT</li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ddlgen.introduction"></a>7.4.&nbsp;Castor DDL Generator - Properties</h2></div></div></div><p>
		Describes the properties available on the Castor DDL Generator.
	</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10520"></a>7.4.1.&nbsp;Overview</h3></div></div></div><p>
		  At startup, the DDL Generator first evaluates the command line options.
		  Next it loads the global properties on the command line if specified,
		  otherwise the default properties included with the DDL Generator.
		  There are two important properties loaded at startup:
		</p><div class="variablelist"><dl><dt><span class="term">org.castor.ddlgen.Generators</span></dt><dd><p>tells the DDL Generator about the supported database engines.</p></dd><dt><span class="term">org.castor.ddlgen.DefaultEngine</span></dt><dd><p>The database engine for which to generate a SQL script. Can be overridden on the command line</p></dd></dl></div><p>
		  The last step at startup is to read the specific configuration of the
		  database engine being used.  A custom configuration can be provided on
		  the command line to override the default.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10533"></a>7.4.2.&nbsp;Global properties</h3></div></div></div><p>
		  Please find below a list of global properties to control various advanced
		  options of the DDL Generator.
		</p><div class="table"><a name="d4e10536"></a><p class="title"><b>Table&nbsp;7.5.&nbsp;Command line options</b></p><div class="table-contents"><table summary="Command line options" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Option</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class="auto-generated">&nbsp;</td></tr><tr><td>org.castor.ddlgen.Generators</td><td>Generator classes of supported database engines.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.DefaultEngine</td><td>Name of default database engine. Will be overwritten by engine specified on commandline.</td><td>db2, derby, hsql, mssql, mysql, oracle, pointbase, postgresql, sapdb or sybase</td><td>mysql</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.SchemaName</td><td>Name of the database schema.</td><td>&nbsp;</td><td>test</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GroupStatements</td><td>How to group generated DDL statements?</td><td>TABLE or DDLTYPE</td><td>TABLE</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.CharFormat</td><td>How to format characters of generated DDL statements?</td><td>SENSITIVE, UPPER or LOWER</td><td>SENSITIVE</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.Newline</td><td>Character sequence to write for newline.</td><td>&nbsp;</td><td>\n</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.Indention</td><td>Character sequence to write for indented lines.</td><td>&nbsp;</td><td>\t</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateSchema</td><td>Generate SCHEMA statements.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateDrop</td><td>Generate DROP statements.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateCreate</td><td>Generate CREATE statements.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GeneratePrimaryKey</td><td>Generate PRIMARYKEY statement.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateForeignKey</td><td>Generate FOREIGNKEY statement.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateIndex</td><td>Generate INDEX statements (Not supported yet).</td><td>true or false</td><td>false</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.GenerateKeyGenerator</td><td>Generate KEYGENERATOR statements.</td><td>true or false</td><td>true</td><td>1.1</td></tr><tr><td>default_tinyint_precision</td><td>Default precision of tinyint values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_smallint_precision</td><td>Default precision of smallint values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_integer_precision</td><td>Default precision of integer values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_bigint_precision</td><td>Default precision of bigint values.</td><td>&nbsp;</td><td>19</td><td>1.1</td></tr><tr><td>default_bigint_decimals</td><td>Default decimals of bigint values.</td><td>&nbsp;</td><td>0</td><td>1.1</td></tr><tr><td>default_float_precision</td><td>Default precision of float values.</td><td>&nbsp;</td><td>38</td><td>1.1</td></tr><tr><td>&nbsp;</td><td>Default precision of tinyint values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_float_decimals</td><td>Default decimals of float values.</td><td>&nbsp;</td><td>7</td><td>1.1</td></tr><tr><td>default_double_precision</td><td>Default precision of double values.</td><td>&nbsp;</td><td>53</td><td>1.1</td></tr><tr><td>default_double_decimals</td><td>Default decimals of double values.</td><td>&nbsp;</td><td>15</td><td>1.1</td></tr><tr><td>default_real_precision</td><td>Default precision of real values.</td><td>&nbsp;</td><td>38</td><td>1.1</td></tr><tr><td>default_real_decimals</td><td>Default decimals of real values.</td><td>&nbsp;</td><td>7</td><td>1.1</td></tr><tr><td>default_numeric_precision</td><td>Default precision of numeric values.</td><td>&nbsp;</td><td>65</td><td>1.1</td></tr><tr><td>default_numeric_decimals</td><td>Default decimals of numeric values.</td><td>&nbsp;</td><td>30</td><td>1.1</td></tr><tr><td>default_decimal_precision</td><td>Default precision of decimal values.</td><td>&nbsp;</td><td>65</td><td>1.1</td></tr><tr><td>default_decimal_decimals</td><td>Default decimals of decimal values.</td><td>&nbsp;</td><td>30</td><td>1.1</td></tr><tr><td>default_char_length</td><td>Default length of char values.</td><td>&nbsp;</td><td>256</td><td>1.1</td></tr><tr><td>default_varchar_length</td><td>Default length of varchar values.</td><td>&nbsp;</td><td>256</td><td>1.1</td></tr><tr><td>default_longvarchar_length</td><td>Default length of longvarchar values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr><tr><td>default_date_precision</td><td>Default precision of date values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_time_precision</td><td>Default precision of time values.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>default_timestamp_precision</td><td>Default precision of timestamp values.</td><td>&nbsp;</td><td>19</td><td>1.1</td></tr><tr><td>default_binary_length</td><td>Default length of binary values.</td><td>&nbsp;</td><td>256</td><td>1.1</td></tr><tr><td>default_varbinary_length</td><td>Default length of varbinary values.</td><td>&nbsp;</td><td>256</td><td>1.1</td></tr><tr><td>default_longvarbinary_length</td><td>Default length of longvarbinary values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr><tr><td>default_other_length</td><td>Default length of other values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr><tr><td>default_javaobject_length</td><td>Default length of javaobject values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr><tr><td>default_blob_length</td><td>Default length of blob values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr><tr><td>default_clob_length</td><td>Default length of clob values.</td><td>&nbsp;</td><td>1024</td><td>1.1</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10810"></a>7.4.2.1.&nbsp;Supported database engines</h4></div></div></div><p>
	          The supported database engines are defined as follows:
	        </p><pre class="programlisting">
#
# generator classes of supported database engines
#
org.castor.ddlgen.Generators=\
  org.castor.ddlgen.engine.db2.Db2Generator,\
  org.castor.ddlgen.engine.derby.DerbyGenerator,\
  org.castor.ddlgen.engine.hsql.HsqlGenerator,\
  org.castor.ddlgen.engine.mssql.MssqlGenerator,\
  org.castor.ddlgen.engine.mysql.MysqlGenerator,\
  org.castor.ddlgen.engine.oracle.OracleGenerator,\
  org.castor.ddlgen.engine.pointbase.PointBaseGenerator,\
  org.castor.ddlgen.engine.postgresql.PostgresqlGenerator,\
  org.castor.ddlgen.engine.sapdb.SapdbGenerator,\
  org.castor.ddlgen.engine.sybase.SybaseGenerator
			</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10814"></a>7.4.2.2.&nbsp;Grouping of DDL statements</h4></div></div></div><p>
          There are 2 supported modes to group DDL statements. For a simple example, the
          output of both modes is:
        </p><div class="figure"><a name="d4e10817"></a><div class="figure-contents"><pre class="programlisting">
drop A if exist
create A(IDA int);
alter table A add primary key (IDA)

drop B if exist
create B(IDB int);
alter table B add primary key (IDB)
			</pre></div><p class="title"><b>Figure&nbsp;7.1.&nbsp;org.castor.ddlgen.GroupStatements=TABLE</b></p></div><br class="figure-break"><div class="figure"><a name="d4e10820"></a><div class="figure-contents"><pre class="programlisting">
drop A if exist
drop B if exist

create A(IDA int);
create B(IDB int);

alter table A add primary key (IDA)
alter table B add primary key (IDB)
			</pre></div><p class="title"><b>Figure&nbsp;7.2.&nbsp;org.castor.ddlgen.GroupStatements=DDLTYPE</b></p></div><br class="figure-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e10823"></a>7.4.3.&nbsp;Specific properties</h3></div></div></div><p>
		  Below you can find a list of specific properties to control various advanced
		  options of the DDL Generator.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10826"></a>7.4.3.1.&nbsp;Properties common for all database engines</h4></div></div></div><div class="table"><a name="d4e10828"></a><p class="title"><b>Table&nbsp;7.6.&nbsp;Common properties for all databases</b></p><div class="table-contents"><table summary="Common properties for all databases" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Option</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>org.castor.ddlgen.KeyGeneratorFactories</td><td>Key generator factory classes supported by DB/2.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.HeaderComment</td><td>Comment to add to head of generated script.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e10851"></a>7.4.3.1.1.&nbsp;Key generators</h5></div></div></div><p>
				  The key generators supported by a database engine are defined as follows
				  (example taken from Oracle):
				</p><pre class="programlisting">
#
# key generator factory classes of supported database engines
#
org.castor.ddlgen.KeyGeneratorFactories=\
  org.castor.ddlgen.keygenerator.HighLowKeyGeneratorFactory,\
  org.castor.ddlgen.keygenerator.MaxKeyGeneratorFactory,\
  org.castor.ddlgen.keygenerator.UUIDKeyGeneratorFactory,\
  org.castor.ddlgen.engine.oracle.OracleSequenceKeyGeneratorFactory
				</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10855"></a>7.4.3.2.&nbsp;Properties for db2, hsql, Oracle, Postgresql and sapdb</h4></div></div></div><div class="table"><a name="d4e10857"></a><p class="title"><b>Table&nbsp;7.7.&nbsp;Common properties for all databases</b></p><div class="table-contents"><table summary="Common properties for all databases" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Option</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>org.castor.ddlgen.TriggerTemplate</td><td>Template to create TRIGGER statements.</td><td>&nbsp;</td><td>&nbsp;</td><td>1.1</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e10874"></a>7.4.3.2.1.&nbsp;Trigger template</h5></div></div></div><p>
				  Below you can take a look at the default trigger template defined for Oracle.
				  The DDL Generator will replace the parameters in brackets with appropriate
				  values (e.g. &lt;table_name&gt;).
				</p><div class="figure"><a name="d4e10877"></a><div class="figure-contents"><pre class="programlisting">
#
# trigger template
#
org.castor.ddlgen.TriggerTemplate=\
CREATE TRIGGER &lt;trigger_name&gt;
  BEFORE INSERT OR UPDATE ON &lt;table_name&gt;
  FOR EACH ROW
  DECLARE
    iCounter &lt;table_name&gt;.&lt;pk_name&gt;%TYPE;
    cannot_change_counter EXCEPTION;
  BEGIN
    IF INSERTING THEN
      Select &lt;sequence_name&gt;.NEXTVAL INTO iCounter FROM Dual;
      :new.&lt;pk_name&gt; := iCounter;
    END IF;

    IF UPDATING THEN
      IF NOT (:new.&lt;pk_name&gt; = :old.&lt;pk_name&gt;) THEN
        RAISE cannot_change_counter;
      END IF;
    END IF;

EXCEPTION
  WHEN cannot_change_counter THEN
    raise_application_error(-20000, 'Cannot Change Counter Value');
END;
					</pre></div><p class="title"><b>Figure&nbsp;7.3.&nbsp;Default trigegr template for Oracle</b></p></div><br class="figure-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e10880"></a>7.4.3.3.&nbsp;Properties for MySQL only</h4></div></div></div><div class="table"><a name="d4e10882"></a><p class="title"><b>Table&nbsp;7.8.&nbsp;Common properties for all databases</b></p><div class="table-contents"><table summary="Common properties for all databases" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Option</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>org.castor.ddlgen.engine.mysql.StorageEngine</td><td>Storage engine to be used. If left empty the default configured at the database server will be used.</td><td>MYISAM, InnoDB, MERGE, MEMORY, BDB or ISAM</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.engine.mysql.ForeignKeyOnDeleteStrategy</td><td>Delete strategy for foreign keys. If not specified NO ACTION will be used by default.</td><td>CASCADE, RESTRICT, SET NULL, NO ACTION</td><td>&nbsp;</td><td>1.1</td></tr><tr><td>org.castor.ddlgen.engine.mysql.ForeignKeyOnUpdateStrategy</td><td>Update strategy for foreign keys. If not specified NO ACTION will be used by default.</td><td>CASCADE, RESTRICT, SET NULL, NO ACTION</td><td>&nbsp;</td><td>1.1</td></tr></tbody></table></div></div><br class="table-break"></div></div></div></div>

  

  <div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml.code.generator.extensions"></a>Chapter&nbsp;8.&nbsp;XML code generation - Extensions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.code.generator.extensions.why"></a>8.1.&nbsp;XML code generation extensions - Motivation</h2></div></div></div><p>
        With Castor 1.2 and earlier releases it has already been possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        Starting with Castor 1.3, a mechanism has been added to the XML code generator that allows
        extension of these core offerings so that either additional content is added to the generated
        domain classes additonal descriptor classes are gernated.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.extensions"></a>8.1.1.&nbsp;JDO extensions for the Castor XML code generator</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.why"></a>8.1.1.1.&nbsp;JDO extensions - Motivation</h4></div></div></div><p>
        With Castor 1.2 and previous releases it was already possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        In addition, it was already possible to use the generated set of domain classes
        in Castor JDO for object-/relational mapping purpose by supplying a 
        (manually written) JDO-specific mapping file. Whilst technically not very difficult,
        this was still an error-prone task, especially in a context where tens or 
        hundreds of classes were generated from a set of XML schemas.
    </p><p>
        The <span class="italic">JDO extensions for the Castor XML code generator</span>
        extend the code generator in such a way that a second set of descriptor classes is
        generated: the JDO descriptor classes. These new descriptor classes define
        the mapping between Java (domain) objects and database tables/columns, and as
        such remove the requirement of having to write a JDO-specific mapping file.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
           Please note that Castor JDO - upon startup - internally converts the information
           provided in the JDO mapping file to (JDO) descriptor classes. As such, the
           approach outlined above simply re-uses an existing code base and just automates the
           production of those descriptor classes.
        </p></td></tr></table></div><p>
        The following sections introduce the general principles, define the XML schema 
        artifacts available to annotate an existing XML schema and highlight the 
        usage of these artifacts by providing examples. At the same time,
        a limited set of current product limitations are spelled out.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.limitations"></a>8.1.1.2.&nbsp;Limitations</h4></div></div></div><p>
        With release 1.3 of Castor, the following limitations exist for the JDO
        extensions of the XML code generator:
    </p><div class="orderedlist"><ol type="1"><li><p>
                The extensions currently can only be used in <span class="bold"><strong>type</strong></span>
                mode of the XML code generator.
            </p></li><li><p>
                There's currently no support for <span class="bold"><strong>key generators</strong></span>. 
                There's work in progress to add this functionality, though.
            </p></li><li><p>
                There's currently no support for bidirectional relations, modelled through
                the use of &lt;xs:id&gt; and &lt;xs:idref&gt; constructs.
            </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.prerequisites"></a>8.1.1.3.&nbsp;Prerequisites</h4></div></div></div><p>
                To facilitate the detailed explanations in the following 
                sections, we now define a few &lt;complexType&gt; definitions
                that we want to map against an existing database schema, and the 
                corresponding SQL statements to create the required tables.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.prerequisites.xml.schemas"></a>8.1.1.3.1.&nbsp;Sample XML schemas</h5></div></div></div><pre class="programlisting">
               
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;

&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lectorType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;

&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.prerequisites.ddl.statements"></a>8.1.1.3.2.&nbsp;Sample DDL statements</h5></div></div></div><pre class="programlisting">
CREATE TABLE author_table (
   sin INTEGER NOT NULL,
   name VARCHAR(20) NOT NULL
);

CREATE TABLE lector_table (
   sin INTEGER NOT NULL,
   name VARCHAR(20) NOT NULL
);

CREATE TABLE book_table (
   isbn VARCHAR(13) NOT NULL,
   pages INTEGER,
   lector_id INTEGER NOT NULL,
   author_id INTEGER NOT NULL
);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.generation"></a>8.1.1.4.&nbsp;Configuring the XML code generator</h4></div></div></div><p>
            To have the Castor XML code generator generate JDO class descriptors
            when processing a set of XML schemas, please use one of the following 
            methods:
        </p><div class="table"><a name="jdo.extensions.generation.methods"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Accessing options</b></p><div class="table-contents"><table summary="Accessing options" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Usage</th><th align="center">Method</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"><code class="classname">SourceGenerator</code></td><td align="center"><code class="methodname">setJdoDescriptorCreation(boolean)</code></td><td align="center">Supply a value of <code class="literal">true</code> to enable this feature.</td></tr><tr><td align="center"><code class="classname">SourceGeneratorMain</code></td><td align="center">Flag <code class="literal">-gen-jdo-desc</code></td><td align="center">Set this optional flag to enable this feature.</td></tr><tr><td align="center">Ant task for XML code generator</td><td align="center"><code class="literal">generateJdoDescriptors</code> option</td><td align="center">Set this to a value of <code class="literal">true</code>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.schema.elements"></a>8.1.1.5.&nbsp;The JDO annotations for XML schemas</h4></div></div></div><p>
            This section enlists the XML artifacts available to annotate an existing XML schema
            with JDO extension-specific information. These constructs are defined themselves
            in an XML schema <code class="literal">jdo-extensions.xsd</code> that has a target 
            namespace of <code class="uri">http://www.castor.org/binding/persistence</code>. 
        </p><p>
            To enable proper validation of your XML schemas when editing JDO
            annotations, and to enable XML completion in your preferred XML 
            editor, please add <code class="literal">schemaLocation</code> information to 
            your XML schema definition as follows:
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xmlns:jdo</span>=<span class="hl-value">"http://www.castor.org/binding/persistence"</span>
    <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://your/target/namespace"</span>                                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/binding/persistence http://www.castor.org/jdo-extensions.xsd"</span>&gt;
    
...

&lt;<span class="hl-tag">/xs:schema</span>&gt;        
            </pre></div><p>
          where ...
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                  The values supplied in the <code class="literal">schemaLocation</code> attribute
                  define the location of the XML schema for any XML artefacts bound to
                  the <code class="literal">http://www.castor.org/binding/persistence</code> namespace.
               </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.table"></a>8.1.1.5.1.&nbsp;&lt;table&gt; element</h5></div></div></div><p>
                The &lt;table&gt; element allows you to map an &lt;complexType&gt;
                definition to a database table within a database, and to specify the
                identity (frequently referred to as <code class="literal">primary key</code>), 
                as follows:
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_table"</span>&gt;                                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;                                                  <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
               &lt;<span class="hl-tag">jdo:key</span>&gt;siNumber&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
              </pre></div><p>
             where ...
           </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                     The <code class="literal">&lt;jdo:table ...&gt;</code> defines the name 
                     of the database table to which the complex type definition
                     <code class="literal">authorType</code> should be mapped. 
                  </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                     The <code class="literal">&lt;jdo:primary-key&gt;</code> indicates which 
                     artifacts of the content model of the complex type definition
                     should be used as the corresponding object identity; in database
                     terms, this is often referred to as <code class="literal">primary key</code>.
                  </p></td></tr></table></div><p>
                Above example maps the complex  type <code class="literal">authorType</code> to
                the table <code class="literal">author_table</code>, and specifies that the 
                member <code class="literal">siNumber</code> be used as object identity.
            </p><p>
                The XML schema definition for the <code class="literal">&lt;table&gt;</code> 
                element is defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"table"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:sequence</span>&gt;
         &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"primaryKey"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"jdo:pkType"</span>/&gt;
      &lt;<span class="hl-tag">/xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span>/&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"accessMode"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"shared"</span>&gt;
         &lt;<span class="hl-tag">xs:simpleType</span>&gt;
            &lt;<span class="hl-tag">xs:restriction</span> <span class="hl-attribute">base</span>=<span class="hl-value">"xs:string"</span>&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"read-only"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"shared"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"exclusive"</span>/&gt;
               &lt;<span class="hl-tag">xs:enumeration</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db-locked"</span>/&gt;
            &lt;<span class="hl-tag">/xs:restriction</span>&gt;
         &lt;<span class="hl-tag">/xs:simpleType</span>&gt;
      &lt;<span class="hl-tag">/xs:attribute</span>&gt;
      &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detachable"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:boolean"</span> <span class="hl-attribute">default</span>=<span class="hl-value">"false"</span>/&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;

&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pkType"</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"key"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.column"></a>8.1.1.5.2.&nbsp;&lt;column&gt; element</h5></div></div></div><p>
                The &lt;column&gt; element allows you to map a member of content model 
                of a &lt;complexType&gt; definition to a column within a database
                table.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authorType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;siNumber&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"siNumber"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"sin"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;                       <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
              </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">siNumber</code>
                        be mapped against the database column <code class="literal">sin</code>, and
                        that the (database) type of this column is 
                        <code class="literal">integer</code>.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">isNumber</code> to
                the database column <code class="literal">sin</code>, and specifies the database type
                to be used for persistence (<code class="literal">integer</code>, in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;column&gt;</code> is 
                defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"column"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"type"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"required"</span> /&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"acceptNull"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:boolean"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span>
               <span class="hl-attribute">default</span>=<span class="hl-value">"true"</span> /&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="jdo.extensions.schema.elements.column.grammar"></a><p class="title"><b>Table&nbsp;8.2.&nbsp;&lt;column&gt; - Definitions</b></p><div class="table-contents"><table summary="<column&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column</td></tr><tr><td align="center">type</td><td align="center">JDO-type of the column</td></tr><tr><td align="center">acceptNull</td><td align="center">Whether this field accepts NULL values or not</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.one-to-one"></a>8.1.1.5.3.&nbsp;&lt;one-to-one&gt; element</h5></div></div></div><p>
                The &lt;one-to-one&gt; element allows you to map a member of content model 
                of a &lt;complexType&gt; definition to a 1:1 relation to another
                &lt;complexType&gt;.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_type_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;isbn&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;                                                      <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
               &lt;<span class="hl-tag">jdo:one-to-one</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector_id"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> &gt;
         ...
      &lt;<span class="hl-tag">/xs:element</span>&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
                </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines a 1:1 relation to another &lt;complexType&gt;, 
                        additionally providing the necessary foreign key column 
                        at the database level.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">lector</code> to a
                1:1 relation to the complex type <code class="literal">lectorType</code>, and 
                specifies the (column name of the) foreign key to be used 
                (<code class="literal">lector_id</code> in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;one-to-one&gt;</code> 
                is defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"one-to-one"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>/&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="jdo.extensions.schema.elements.one-to-one.grammar"></a><p class="title"><b>Table&nbsp;8.3.&nbsp;&lt;one-to-one&gt; - Definitions</b></p><div class="table-contents"><table summary="<one-to-one&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column that represents the foreign key of this relation</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.schema.elements.one-to-many"></a>8.1.1.5.4.&nbsp;&lt;one-to-many&gt; element</h5></div></div></div><p>
                The &lt;one-to-many&gt; element allows you to map a member of the 
                content model of a &lt;complexType&gt; definition as part of a 1:M relation 
                to another &lt;complexType&gt;.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">xs:annotation</span>&gt;
      &lt;<span class="hl-tag">xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">jdo:table</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_type_table"</span>&gt;
            &lt;<span class="hl-tag">jdo:primary-key</span>&gt;
               &lt;<span class="hl-tag">jdo:key</span>&gt;isbn&lt;<span class="hl-tag">/jdo:key</span>&gt;
            &lt;<span class="hl-tag">/jdo:primary-key</span>&gt;
         &lt;<span class="hl-tag">/jdo:table</span>&gt;
      &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
   &lt;<span class="hl-tag">/xs:annotation</span>&gt;
   &lt;<span class="hl-tag">xs:sequence</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:column</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"lectorType"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
               &lt;<span class="hl-tag">jdo:one-to-one</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lector_id"</span> /&gt;
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/xs:element</span>&gt;
      &lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"authors"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"authorType"</span> <span class="hl-attribute">maxOccurs</span>=<span class="hl-value">"unbounded"</span> &gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">jdo:one-to-many</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> /&gt;                             <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;    
      &lt;<span class="hl-tag">/xs:element</span>&gt;
   &lt;<span class="hl-tag">/xs:sequence</span>&gt;
&lt;<span class="hl-tag">/xs:complexType</span>&gt;
                </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines a 1:M relation to another &lt;complexType&gt;, 
                        additionally providing the necessary foreign key column 
                        for the many member at the database level.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">authors</code> as part of a
                1:M relation to the complex type <code class="literal">authorType</code>, and 
                specifies the (column name of the) foreign key of the many member 
                to be used (<code class="literal">book_id</code> in this case).
            </p><p>
                The XML schema definition for <code class="literal">&lt;one-to-many&gt;</code> 
                is given as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"one-to-many"</span>&gt;
   &lt;<span class="hl-tag">xs:complexType</span>&gt;
      &lt;<span class="hl-tag">xs:complexContent</span>&gt;
         &lt;<span class="hl-tag">xs:extension</span> <span class="hl-attribute">base</span>=<span class="hl-value">"jdo:readonlyDirtyType"</span>&gt;
            &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
         &lt;<span class="hl-tag">/xs:extension</span>&gt;
      &lt;<span class="hl-tag">/xs:complexContent</span>&gt;
   &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                with the following details applying:
            </p><div class="table"><a name="jdo.extensions.schema.elements.one-to-many.grammar"></a><p class="title"><b>Table&nbsp;8.4.&nbsp;&lt;one-to-many&gt; - Definitions</b></p><div class="table-contents"><table summary="<one-to-many&gt; - Definitions" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the column that represents the (many) foreign key of this relation</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.extensions.usage"></a>8.1.1.6.&nbsp;Using the generated (domain) classes with Castor JDO</h4></div></div></div><p>
            Once you have generated domain classes and descriptor classes 
            (both XML and JDO) from your set of XML schemas, you'll be 
            able to use them as are. There's a few minor changes, which we 
            are going to highlight below, but the main benefit is that you 
            <span class="bold"><strong>not</strong></span> have to write a JDO mapping 
            file.  
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.usage.mapping.file"></a>8.1.1.6.1.&nbsp;Empty mapping file</h5></div></div></div><p>
                As you have already generated JDO descriptor classes for each 
                of your domain objects, you won't have to supply mappings for 
                those classes anymore. As such, your mapping file will stay 
                empty, as shown:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                           <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>
<span class="hl-attribute">&lt;mapping&gt;</span>

   <span class="hl-attribute">&lt;!--</span> <span class="hl-attribute">no</span> <span class="hl-attribute">mappings</span> <span class="hl-attribute">required</span> <span class="hl-attribute">--&gt;</span>
<span class="hl-attribute">&lt;/mapping&gt;</span>
            </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                    Please note that you can of course supply mappings for 
                    those classes that stand outside of the generation
                    process from your XML schemas. It is possible, too, to
                    match both modes. In other words, a domain class mapped manually
                    will be able to refer to a domain class as generated.
                </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.extensions.usage.cdr"></a>8.1.1.6.2.&nbsp;Use of a <code class="classname">JDOClassDescriptorResolver</code></h5></div></div></div><p>
                In order for Castor to be able to access the generated (JDO) class
                descriptors and to load those classes from the file system,
                you will have to configure an instance of 
                <code class="classname">JDOClassDescriptorResolver</code> and pass it to your
                <code class="classname">JDOManager</code> instance when loading the JDO 
                configuration.
            </p><p>
                The following example shows how to configure Castor JDO so that 
                the classes generated from the sample XML schema above can be used 
                with CASTOR JDO seamlessly. 
            </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = <span class="hl-keyword">new</span> JDOClassDescriptorResolverImpl();
resolver.addClass(org.castor.jdo.extension.sample.BookType.<span class="hl-keyword">class</span>);
resolver.addClass(org.castor.jdo.extension.sample.LectorType.<span class="hl-keyword">class</span>);            
resolver.addClass(org.castor.jdo.extension.sample.AuthorType.<span class="hl-keyword">class</span>);

InputSource jdoConfiguration = ....;
JDOManager.loadConfiguration(jdoConfiguration, null, null, resolver);
   
JDOManager jdoManager = JDOManager.createInstance(<span class="hl-string">"jdo-extensions"</span>);
...             
            </pre><p>
                Alternatively, if the classes generated from the sample 
                XML schema shown above reside in the same package, you can 
                configure the <code class="classname">JDOClassDescriptorResolver</code>
                as follows:  
            </p><pre class="programlisting">
JDOClassDescriptorResolver resolver = new JDOClassDescriptorResolverImpl();
resolver.addPackage("org.castor.jdo.extension.sample");
...
            </pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
                   For the latter approach to work, you will have to make sure that the 
                   <code class="filename">.castor.jdo.cdr</code> files generated alongside
                   your domain (and descriptor classes) are included in your
                   application deployment units. If not, Castor JDO will not be 
                   able to load the descriptor classes from the file system, and
                   throw an exception. 
               </p></td></tr></table></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.extensions"></a>8.1.2.&nbsp;SOLRJ extensions for the Castor XML code generator</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.why"></a>8.1.2.1.&nbsp;SOLRJ extensions - Motivation</h4></div></div></div><p>
        With Castor 1.2 and previous releases it was already possible to 
        generate Java classes from an XML schema and use these classes 
        for XML data binding <span class="bold"><strong>without</strong></span> having 
        to write a mapping file. 
    </p><p>
        This is possible because the Castor XML code generator generated - in 
        addition to the domain classes - a set of XML descriptor classes as well,
        with one descriptor class generated per generated domain class. It's this 
        XML descriptor class that holds all the information required to map Java 
        classes and/or field members to XML artifacts, as set out in the original
        XML schema definitions. This includes ....    
    </p><div class="itemizedlist"><ul type="disc"><li><p>artefact names</p></li><li><p>XML namespace URIs</p></li><li><p>XML namespace prefix</p></li><li><p>validation code</p></li></ul></div><p>
        The <span class="italic">SOLRJ extensions for the Castor XML code generator</span>
        extend the code generator in such a way that the set of domain classes is
        augmented with SOLRJ-specific <code class="literal">@Field</code> annotations.
    </p><p>
        The following sections introduce the general principles, define the XML schema 
        artifacts available to annotate an existing XML schema and highlight the 
        usage of these artifacts by providing examples.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.prerequisites"></a>8.1.2.2.&nbsp;Prerequisites</h4></div></div></div><p>
        To facilitate the detailed explanations in the following 
        sections, we now define a few &lt;complexType&gt; definitions
        that we want to be able to store in a SOLR index in addition to vanilla XML
        data binding funtionality.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="solrj.extensions.prerequisites.xml.schemas"></a>8.1.2.2.1.&nbsp;Sample XML schemas</h5></div></div></div><pre class="programlisting">
       
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> /&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span> /&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.schema.elements"></a>8.1.2.3.&nbsp;The SOLRJ annotations for XML schemas</h4></div></div></div><p>
            This section enlists the XML artifacts available to annotate an existing XML schema
            with SOLRJ extension-specific information. These constructs are defined themselves
            in an XML schema <code class="literal">solrj-extensions.xsd</code> that has a target 
            namespace of <code class="uri">http://www.castor.org/binding/solrj</code>. 
        </p><p>
            To enable proper validation of your XML schemas when editing SOLRJ
            annotations, and to enable XML completion in your preferred XML 
            editor, please add <code class="literal">schemaLocation</code> information to 
            your XML schema definition as follows:
        </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">xs:schema</span> <span class="hl-attribute">xmlns:xs</span>=<span class="hl-value">"http://www.w3.org/2001/XMLSchema"</span>
    <span class="hl-attribute">targetNamespace</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xmlns:solr</span>=<span class="hl-value">"http://www.castor.org/binding/solrj"</span>
    <span class="hl-attribute">xmlns</span>=<span class="hl-value">"http://your/target/namespace"</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">"http://www.castor.org/binding/solrj http://www.castor.org/solrj-extens</span><span class="co"><img src="images/callouts/1.png" alt="(1)"></span><span class="hl-value">ions.xsd"</span>&gt;
    
...

&lt;<span class="hl-tag">/xs:schema</span>&gt;        
            </pre></div><p>
          where ...
        </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                  The values supplied in the <code class="literal">schemaLocation</code> attribute
                  define the location of the XML schema for any XML artefacts bound to
                  the <code class="literal">http://www.castor.org/binding/solrj</code> namespace.
               </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="solrj.extensions.schema.elements.field"></a>8.1.2.3.1.&nbsp;&lt;field&gt; element</h5></div></div></div><p>
                The &lt;field&gt; element allows you to map a member of the content model 
                of a <code class="literal">&lt;complexType&gt;</code> definition to SOLRJ field.
            </p><div class="programlistingco"><pre class="programlisting">
&lt;<span class="hl-tag">complexType</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bookType"</span>&gt;
   &lt;<span class="hl-tag">sequence</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"isbn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span>&gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">solrj:field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> /&gt;                                      <span class="co"><img src="images/callouts/1.png" alt="(1)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/element</span>&gt;
      &lt;<span class="hl-tag">element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pages"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:integer"</span>&gt;
         &lt;<span class="hl-tag">xs:annotation</span>&gt;
            &lt;<span class="hl-tag">xs:appinfo</span>&gt;
                &lt;<span class="hl-tag">solrj:field</span> /&gt;                                                <span class="co"><img src="images/callouts/2.png" alt="(2)"></span>
            &lt;<span class="hl-tag">/xs:appinfo</span>&gt;
         &lt;<span class="hl-tag">/xs:annotation</span>&gt;
      &lt;<span class="hl-tag">/element</span>&gt;
   &lt;<span class="hl-tag">/sequence</span>&gt;
&lt;<span class="hl-tag">/complexType</span>&gt;
              </pre></div><p>
                where ....
            </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">isbn</code>
                        be mapped against the SOLRJ field <code class="literal">id</code>.
                     </p></td></tr><tr><td width="5%" valign="top" align="left"><img src="images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>
                        Defines that the element definition <code class="literal">name</code>
                        be mapped to the SOLRJ field <code class="literal">name</code>.
                     </p></td></tr></table></div><p>
                Above example maps the element <code class="literal">isbn</code> to
                the SOLR index field <code class="literal">id</code>, and the element 
                <code class="literal">name</code> to the identically-named SOLR index
                field. Please note that a SOLR index field name does not have 
                to be specified if the field name and the Java property name
                are identical.
            </p><p>
                Above complex type definition will be transformed to the 
                corresponding Java property definitions (within a class):
            </p><pre class="programlisting">
public class BookType {

    @Field("id")
    private String isbn;
    
    @Field
    private long pages;
    
}
            </pre><p>
                The XML schema definition for <code class="literal">&lt;field&gt;</code> is 
                defined as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">xs:element</span> <span class="hl-attribute">name</span>=<span class="hl-value">"field"</span>&gt;
  &lt;<span class="hl-tag">xs:annotation</span>&gt;
     &lt;<span class="hl-tag">xs:documentation</span>&gt;
            Element 'field' is used to specify the use of the SOLRJ
            @Field annotation.
        &lt;<span class="hl-tag">/xs:documentation</span>&gt;
  &lt;<span class="hl-tag">/xs:annotation</span>&gt;
  &lt;<span class="hl-tag">xs:complexType</span>&gt;
     &lt;<span class="hl-tag">xs:attribute</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"xs:string"</span> <span class="hl-attribute">use</span>=<span class="hl-value">"optional"</span>&gt;
        &lt;<span class="hl-tag">xs:annotation</span>&gt;
           &lt;<span class="hl-tag">xs:documentation</span>&gt;
                    Attribute 'name' is used to specify the name of
                    the index field to be mapped against; if not used,
                    the name of the Java property will be used as filed 
                    name.
                &lt;<span class="hl-tag">/xs:documentation</span>&gt;
        &lt;<span class="hl-tag">/xs:annotation</span>&gt;
     &lt;<span class="hl-tag">/xs:attribute</span>&gt;
  &lt;<span class="hl-tag">/xs:complexType</span>&gt;
&lt;<span class="hl-tag">/xs:element</span>&gt;
            </pre><p>
                where the content is described as follows:
            </p><div class="table"><a name="solrj.extensions.schema.elements.field.grammar"></a><p class="title"><b>Table&nbsp;8.5.&nbsp;&lt;field&gt; - Definitions</b></p><div class="table-contents"><table summary="<field&gt; - Definitions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Description</th><th align="center">Optional?</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">Name of the SOLR index field.</td><td align="center">Yes</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="solrj.extensions.usage"></a>8.1.2.4.&nbsp;Using the generated domain classes with SOLR</h4></div></div></div><p>
            Once you have generated domain classes (and descriptor classes 
            for the XML binding) from your set of XML schemas, you'll be 
            able to use them as are.  
        </p></div></div></div></div>

  
  
</div></body></html>