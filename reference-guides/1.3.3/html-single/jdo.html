<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Castor JDO</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="up" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="prev" href="xml.code.generator.html" title="Chapter&nbsp;2.&nbsp;XML code generation"><link rel="next" href="advanced-jdo.html" title="Chapter&nbsp;4.&nbsp;Advanced JDO"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top"><div id="header"><div class="projectlogo"><a href="./"><img class="logoImage" src="images/castor.gif" alt="Castor" border="0"></a></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="mhSpacer"></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jdo"></a>Chapter&nbsp;3.&nbsp;Castor JDO</h2></div></div></div>
  
  
  
 
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.introduction"></a>3.1.&nbsp;Castor JDO - An introduction</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.introduction.what"></a>3.1.1.&nbsp;What is Castor JDO</h3></div></div></div><p>
       Castor JDO is an Object-Relational Mapping and Data-Binding Framework, which is 
       written in 100% pure Java[tm]. Castor can map relational database data into 
       Java Data Object based on user-defined mapping schema. In the other point-of-view, 
       it provides java data objects a persistence layer.
     </p><p>
       It frees programmer from dealing with database directly and replacing the entire 
       burden of composing updating the database. Proper SQL statements are automatically 
       generated for loading, updating, creating and deleting. Changes to objects in transaction 
       are automatically done to data source at commit time. Thus programmer can stay in pure-Java
       without remember all the details in the backing database, after the creation of 
       database tables and the mapping schema. The separation of persistence and programming 
       logic also enable much clearer object-oriented design, which is important in larger 
       projects.
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.introduction.features"></a>3.1.2.&nbsp;Features</h3></div></div></div><p>
       JDO is <span class="bold"><strong>transactional</strong></span>. Data objects loaded in Castor 
       are properly locked and isolated from other transactions. Castor supports full 
       2-phase commit via xa.Synchronzation. Castor supports several locking modes, 
       including "shared", "exclusive", "database locked", and "read-only".
     </p><p>
       </p><div class="itemizedlist"><ul type="disc"><li><p>
             <span class="bold"><strong>Shared access</strong></span>, the default, is useful for 
             situations in which it is common for two or more transactions to read the 
             same objects, and/or update different objects.
           </p></li><li><p>
             <span class="bold"><strong>Exclusive access</strong></span> uses in-memory locks 
             implemented by Castor to force competing transactions to serialize access 
             to an object. This is useful for applications in which it is common for more 
             than one transaction to attempt to update the same object, and for which most, 
             if not all access to the database is performed through Castor.
           </p></li><li><p>
             <span class="bold"><strong>Database-Locked access</strong></span> is often used for 
             applications in which exclusive locking is required, but in which the database 
             is frequently accessed from applications outside of Castor, bypassing Castor's 
             memory-based locking mechanism used by "exclusive access" locking.
           </p></li><li><p>
             <span class="bold"><strong>Read-Only access</strong></span> performs no locking at all. 
             Objects read using this access mode are not locked, and those objects do not 
             participate in transaction commit/rollback.
           </p></li></ul></div><p>
     </p><p>
       In addition, Castor supports <span class="bold"><strong>"long transactions"</strong></span>, 
       whichs allow objects to be read in one transaction, modified, and then committed 
       in a second transaction, with built-in dirty-checking to prevent data that has been 
       changed since the initial transaction from being overwritten.
     </p><p>
       Through <span class="bold"><strong>automatic dirty-checking</strong></span> 
       and <span class="bold"><strong>deadlock detection</strong></span>, Castor can be 
       used to ensure data integrity and reduce unnecessary database updates.
     </p><p>
       A subset of OQL, defined in the Object Management Group (OMG) 3.0 
       <span class="bold"><strong>Object Query Language</strong></span> Specification, 
       is supported for interacting with the database. OQL is 
       similar to SQL, though operations are performed directly on Java objects instead 
       of database tables, making the language more appropriate for use within a 
       Java-based application.
     </p><p>
       Castor implements a <span class="bold"><strong>data cache</strong></span> to reduce database 
       accesses, providing several alternative LRU-based caching strategies.
     </p><p>
       Castor supports different cardinalities of <span class="bold"><strong>relationship</strong></span>, 
       including <span class="bold"><strong>one-to-one</strong></span>, 
       <span class="bold"><strong>one-to-many</strong></span> 
       and <span class="bold"><strong>many-to-many</strong></span>. It also supports both object 
        and database record <span class="bold"><strong>inheritance</strong></span>. It distinguishes 
       between <span class="bold"><strong>related</strong></span> (i.e. association) 
       and <span class="bold"><strong>dependent</strong></span> 
       (i.e. aggregation) relationships during an object's life cycle, automatically creating 
       and deleting dependent objects at appropriate times in the independent object's 
       life cycle.
     </p><p>
       Multiple-column primary keys, and a variety of key generators are supported.
     </p><p>
       Castor automatically manages persistence for objects that contain Java collection 
       types, including Vector, Hashtable, Collection, Set, and Map. 
       <span class="bold"><strong>Lazy loading</strong></span> 
       (of collections as well as simple 1:1 relations) is implemented to reduce unnecessary 
       database loading. Lazy loading can be turned on or off for each individual field (of 
       any supported collection type for 1-to-many and many-to-many relations).
     </p><p>
       Other features include a type converter for all Java primitive types (see the 
       info on supported <a href="jdo.html#jdo.types" title="3.5.&nbsp;Type Support">types</a>).
     </p><p>
       No pre-processor (aka pre-compiler), class enhancer (bytecodes modification) is needed 
       or used for data-binding and object persistence.
     </p><p>
       Castor JDO works in an application that uses multiple ClassLoaders, making it possible to 
       use in an EJB container or servlet, for example. A Castor-defined callback interface, 
       "Persistent", can be implemented if the objects wants to be notified on Castor 
       events: jdoLoad(), jdoCreate(), jdoRemove() and jdoTransient(). This makes it possible 
       to create user-defined actions to take at various times in an object's life cycle.
     </p><p>
        The Java-XML Data-Binding Framework (Castor XML) has been merged with Castor JDO for 
        users who need both O/R Mapping and Java-XML Data-Binding together.
      </p><p>
        The following relational databases are supported: 
            
        </p><div class="itemizedlist"><ul type="disc"><li><p>DB2</p></li><li><p>Derby</p></li><li><p>Generic DBMS</p></li><li><p>Hypersonic SQL</p></li><li><p>Informix</p></li><li><p>InstantDB</p></li><li><p>Interbase</p></li><li><p>MySQL</p></li><li><p>Oracle</p></li><li><p>PostgreSQL</p></li><li><p>Progress</p></li><li><p>SAP DB / MaxDB</p></li><li><p>SQLServer</p></li><li><p>Sybase</p></li></ul></div><p>
      </p><p>
        Database support includes Oracle 8.1.x and different versions of Sybase Enterprise and 
        Anywhere. Users can implement the Driver interface to adapt Castor to the differences in 
        SQL syntax supported by different relational DBMS's, as long as the DBMS supports JDBC 
        2.0, multiple ResultSet, and transactions. Thanks to many individual open source 
        contributors, drivers for different database are available.
      </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.first-steps"></a>3.2.&nbsp;Castor JDO - First steps</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.introduction"></a>3.2.1.&nbsp;Introduction</h3></div></div></div><p>
          This guide assumes that you do not have any experience with CASTOR JDO, but would 
          like to make your first steps into the world of persistence and object/relation 
          mapping tools. The following sections show how to setup and configure Castor JDO so that
          it is possible to perform persistence operations on the domain objects presented.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.sample-domain-ojects"></a>3.2.2.&nbsp;Sample domain objects</h3></div></div></div><p>
          The sample domain objects used in here basically define a 
          <code class="literal">Catalogue</code>, 
          which is a collection of <code class="literal">Product</code>s.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Catalogue {

   <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
   <span class="hl-keyword">private</span> List products = <span class="hl-keyword">new</span> ArrayList();
   
   <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">long</span> id) { ... }

   <span class="hl-keyword">public</span> String getProducts() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProducts(List products) { ... }
   
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {

   <span class="hl-keyword">private</span> <span class="hl-keyword">long</span> id;
   
   <span class="hl-keyword">private</span> String description;

   <span class="hl-keyword">public</span> <span class="hl-keyword">long</span> getId() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">long</span> id) { ... }
   
   <span class="hl-keyword">public</span> String getDescription() { ... }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDescription(String description) { ... }
   
}</pre><p>
          In order to be able to perform any persistence operation (such as loading products, deleting 
          products from a catalogue, ...) on these domain objects through Castor JDO, a Castor 
          JDO mapping has to be provided, defining class and field level mappings for the Java classes given
          and their members:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Catalogue"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"catalogue"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.sample.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"arraylist"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"c_id"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Product"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"product"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"desc"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.first-time-use"></a>3.2.3.&nbsp;Using Castor JDO for the first time</h3></div></div></div><p>
          To e.g. load a given <code class="literal">Catalogue</code> instance as defined 
          by its identity, and all its associated <code class="literal">Product</code> instances, 
          the following code could be used, based upon the Castor-specific interfaces 
          <code class="literal">JDOManager</code> and <code class="literal">Database</code>.
        </p><pre class="programlisting">
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdoManager = JDOmanager.createInstance(<span class="hl-string">"sample"</span>);

Database database = jdoManager.getDatabase();       
database.begin();
Catalogue catalogue = database.load(catalogue.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Long(1));
database.commit();
database.close();</pre><p>
          For brevity, exception handling has been ommitted completely. But is is quite obvious
          that - when using such code fragments again and again, to e.g. implement various 
          methods of a DAO - there's a lot of redundant code that needed to be written again 
          and again - and exception handling is adding some additional complexity here as well.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.first-steps.configuration"></a>3.2.4.&nbsp;JDO configuration</h3></div></div></div><p>
          As shown in above code example, before you can perform any persistence operations on 
          your domain objects, Castor JDO has to be configured by the means of a JDO 
          configuration file. as part of this JDO configuration, the user defines one or more 
          databases and everything required to connect to this database (user credentials, JDBC
          connection string, ....).
        </p><p>
          A valid JDO configuration file for HSQL looks as follows:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0" ?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span> <span class="hl-attribute">"http://castor.org/jdo-conf.dtd"&gt;</span>
<span class="hl-attribute">&lt;jdo-conf&gt;</span>
  <span class="hl-attribute">&lt;database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hsqldb"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"hsql"</span>&gt;
    &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span> <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9002/dbname"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span>/&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span>/&gt;
    &lt;<span class="hl-tag">/driver</span>&gt;
    &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"mapping.xml"</span>/&gt;
  &lt;<span class="hl-tag">/database</span>&gt;
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span>/&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
        </pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.usage"></a>3.3.&nbsp;Using Castor JDO</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.database-connection"></a>3.3.1.&nbsp;Opening A JDO Database</h3></div></div></div><p>
        Castor JDO supports two type of environments, client applications and J2EE servers.
        <a href="jdo.html#jdo.usage.database-connection.stand-alone" title="3.3.1.1.&nbsp;Stand-alone application">Client applications</a> 
        are responsible for configuring the database connection and managing transactions 
        explicitly. 
        <a href="jdo.html#jdo.usage.database-connection.j2ee" title="3.3.1.2.&nbsp;J2EE Application">J2EE applications</a>
         use JNDI to obtain a pre-configured database connection, and use
        <code class="literal">UserTransaction</code> or container managed transactions (CMT) to 
        manage transactions. If you have been using JDBC in these two environments, 
        you will be readily familiar with the two models and the differences between 
        them. 
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-connection.stand-alone"></a>3.3.1.1.&nbsp;Stand-alone application</h4></div></div></div><p>
          Client applications are responsible for defining the JDO configuration, and managing 
          the transaction explicitly. The database is by default configured through a separate
          XML file which links to the mapping file. Alternatively, it can be configured using the
          utility class <code class="classname">org.exolab.castor.jdo.util.JDOConfFactory</code>.
        </p><p>
		  In the example code I refer to the JDO configuration file as 
		  <code class="literal">jdo-conf.xml</code>, but any name can be used. See 
		  <a href="jdo.html#jdo.configuration" title="3.4.&nbsp;Castor JDO - Configuration">Castor JDO Configuration</a> 
		  for more information.
		</p><p>
          As of release 0.9.6, a new JDOManager class is provided, that replaces the former JDO
		   class. Any new features will be implemented against the new JDOManager class only.
		</p><p>As with its predecessor, <code class="classname">org.exolab.castor.jdo.JDOManager</code> defines the database 
		   name and properties and is used to open a database connection. An instance of this class 
		   is constructed with a two-step approach:
		</p><div class="orderedlist"><ol type="1"><li><p>
              Statically load the JDO configuration file through one of the 
              loadConfiguration() methods, e.g. 
			  <code class="methodname">org.exolab.castor.jdo.JDOManager.loadConfiguration(java.lang.String)</code>.
			</p></li><li><p>
              Create an instance of the JDO engine using the factory method 
              <code class="methodname">org.exolab.castor.jdo.JDOManager.createInstance(java.lang.String)</code>
			  where you supply one of the database names defined in the configuration 
			  file loaded in step 1).
			</p></li></ol></div><p>
          The <code class="classname">org.exolab.castor.jdo.Database</code> object represents 
          an open connection to the database. By definition the database object is not 
          thread safe and should not be used from concurrent threads. There is little 
          overhead involved in opening multiple <code class="literal">Database</code>
          objects, and a JDBC connection is acquired only per open transaction.
        </p><p>
          The following code fragment creates an instance of JDOManager for a database 'mybd',
	      opens a database, performs a transaction, and closes the database - as it will typically 
		  appear in client applications (for brevity, we have ommitted any required exception 
		  handling):
	    </p><pre class="programlisting"> 
JDOManager jdoManager;
Database db;
 
<span class="hl-comment">// load the JDO configuration file and construct a new JDOManager for the database 'mydb'</span>
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
jdoManager = JDOManager.createInstance(<span class="hl-string">"mydb"</span>);

<span class="hl-comment">// Obtain a new database</span>
Database db = jdoManager.getDatabase();
    
<span class="hl-comment">// Begin a transaction</span>
db.begin();

<span class="hl-comment">// Do something</span>
. . .

<span class="hl-comment">// Commit the transaction and close the database</span>
db.commit();
db.close();
        </pre><p>
		  For an example showing how to set up a database configuration on the fly without
		  the need of a preconfigured XML configuration file) see
		  <a href="jdo.html#jdo.configuration.jdoconffactory" title="3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO">JdoConfFactory</a>.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-connection.j2ee"></a>3.3.1.2.&nbsp;J2EE Application</h4></div></div></div><p>
          J2EE applications depend on the J2EE container (Servlet, EJB, etc) to configure
          the database connection and use JNDI to look it up. This model allows the application
          deployer to configure the database properties from a central place, and gives the J2EE
          container the ability to manage distributed transactions across multiple data sources.
        </p><p>
          Instead of constructing a 
          <code class="classname">org.exolab.castor.jdo.JDOManager</code>
          the application uses the JNDI namespace to look it up. 
          We recommend enlisting the <code class="literal">JDOManager</code> 
          object under the <code class="literal">java:comp/env/jdo</code> namespace, 
          compatible with the convention for listing JDBC resources.
        </p><p>
          The following code fragment uses JNDI to lookup a database, and uses the JTA 
		  <code class="literal">UserTransaction</code> interface to manage the transaction:
		</p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup databse in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Begin a transaction</span>
ut = (UserTransaction) ctx.lookup( <span class="hl-string">"java:comp/UserTransaction"</span> );
ut.begin();
<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Commit the transaction, close database</span>
ut.commit();
db.close();
        </pre><p>
          If the transaction is managed by the container, a common case with EJB beans and
          in particular entity beans, there is no need to begin/commit the transaction explicitly.
          Instead the application server takes care of enlisting the database in the ongoing
          transaction and executes commit/rollback at the proper time.
        </p><p>
          The following code snippet relies on the container to manage the transaction
        </p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup database in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Close the database</span>
db.close();
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.database-persistence"></a>3.3.2.&nbsp;Using A JDO Database to perform persistence operations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.objects"></a>3.3.2.1.&nbsp;Transient And Persistent Objects</h4></div></div></div><p>
          All JDO operations occur within the context of a transaction. JDO works by loading
          data from the database into an object in memory, allowing the application to modify
          the object, and then storing the object's new state when the transaction commits.
          All objects can be in one of two states: transient or persistent.
        </p><p>
          <span class="bold"><strong>Transient:</strong></span> Any object whose state will not be saved 
          to the database when the transaction commits. Changes to transient objects will not 
          be reflected in the database.
        </p><p>
          <span class="bold"><strong>Persistent:</strong></span> Any object whose state will be saved 
          to the database when the transaction commits. Changes to persistent objects will 
          be reflected in the database.
        </p><p>
          An object becomes persistent in one of two ways: it is the result of a query,
          (and the query is not performed in read-only mode) or it is added to the database 
          using 
          <code class="methodname">org.exolab.castor.jdo.Database.create(java.lang.Object)</code>
          or 
          <code class="methodname">org.exolab.castor.jdo.Database.update(java.lang.Object)</code>.
          All objects that are not persistent are transient. When the transaction commits 
          or rolls back, all persistent objects become transient.
        </p><p>
         In a client application, use 
         <code class="methodname">org.exolab.castor.jdo.Database.begin()</code>,
         <code class="methodname">org.exolab.castor.jdo.Database.commit()</code> and
         <code class="methodname">org.exolab.castor.jdo.Database.rollback()</code> 
         to manage transactions. In a J2EE application, JDO relies on the container 
         to manage transactions either implicitly (based on the transaction attribute 
         of a bean) or explicitly using the
         <code class="literal">javax.transaction.UserTransaction</code> interface.
       </p><p>
         If a persistent object was modified during the transaction, at commit time the 
         modifications are stored back to the database. If the transaction rolls back, 
         no modifications will be made to the database. Once the transaction completes, 
         the object is once again transient. To use the same object in two different 
         transactions, you must query it again.
       </p><p>
         An object is transient or persistent from the view point of the database to which
         the transaction belongs. An object is generally persistent in a single database,
         and calling 
         <code class="methodname">org.exolab.castor.jdo.Database"&gt;isPersistent(java.lang.Object)</code>
         from another database will return false. It is possible to make an object persistent
         in two database, e.g. by querying it in one, and creating it in the other.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.query"></a>3.3.2.2.&nbsp;Running an OQL Query</h4></div></div></div><p>
          OQL queries are used to lookup and query objects from the database. OQL queries are
          similar to SQL queries, but use object names instead of SQL names and do not require
          join clauses. For example, if the object being loaded is of type <code class="literal">TestObject</code>,
          the OQL query will load <code class="literal">FROM TestObject</code>, whether the actual table name in
          the database is <code class="literal">test</code>, <code class="literal">test_object</code>, or any other name. 
          If a join is required to load related objects, Castor will automatically perform the join.
        </p><p>
          The following code snippet uses an OQL query to load all the objects in a given group.
          Note that product and group are related objects, the JDBC query involves a join:
        </p><pre class="programlisting">
OQLQuery     oql;
QueryResults results;

<span class="hl-comment">// Explicitly begin transaction</span>
db.begin();

<span class="hl-comment">// Construct a new query and bind its parameters</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT p FROM Product p WHERE Group=$1"</span>);
oql.bind(groupId);

<span class="hl-comment">// Retrieve results and print each one</span>
results = oql.execute();
<span class="hl-keyword">while</span> (results.hasMore()) {
  System.out.println(results.next());
}

<span class="hl-comment">// Explicitly close the QueryResults</span>
results.close();

<span class="hl-comment">// Explicitly close the OQLQuery</span>
oql.close();

<span class="hl-comment">// Explicitly commit transaction</span>
db.commit();
db.close();
        </pre><p>
          The following code snippet uses the previous query to obtain products, mark down
          their price by 25%, and store them back to the database (in this case using
          a client application transaction):
        </p><pre class="programlisting">
OQLQuery     oql;
QueryResults results;

<span class="hl-comment">// Explicitly begin transaction</span>
db.begin();

<span class="hl-comment">// Construct a new query and bind its parameters</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT p FROM Product p WHERE Group=$1"</span>);
oql.bind(groupId);

<span class="hl-comment">// Retrieve results and mark up each one by 25%</span>
Product prod;
<span class="hl-keyword">while</span> (results.hasMore()) {
  prod = (Product) results.next();
  prod.markDown(0.25);
  prod.setOnSale(true);
}

<span class="hl-comment">// Explicitly close the QueryResults</span>
results.close();

<span class="hl-comment">// Explicitly close the OQLQuery</span>
oql.close();

<span class="hl-comment">// Explicitly commit transaction</span>
db.commit();
db.close();
        </pre><p>
          As illustrated above, a query is executed in three steps. First a query object is
          created from the database using an OQL statement. If there are any parameters, the
          second step involves binding these parameters. Numbered parameters are bound using
		  the order specified in their names. (e.g. first $1, after that $2, and so on...)
		  The third step involves executing the query and obtaining a result set of type
          <code class="classname">org.exolab.castor.jdo.QueryResults</code>.
        </p><p>
          A query can be created once and executed multiple times. Each time it is executed
          the bound parameters are lost, and must be supplied a second time. The result of
          a query can be used while the query is being executed a second time.
        </p><p>
          There is also a special form of query that gives a possibility to call stored
          procedures:
        </p><p>   
            <code class="code">
oql = db.getOQLQuery("CALL sp_something($) AS myapp.Product");
            </code>
        </p><p>
          Here sp_something is a stored procedure returning one or more
          ResultSets with the same sequence of fields as Castor-generated
          SELECT for the OQL query "SELECT p FROM myapp.Product p"
          (for objects without relations the sequence is: identity, then all
          other fields in the same order as in mapping.xml).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.create"></a>3.3.2.3.&nbsp;Creating a persistent object</h4></div></div></div><p>
          The method 
          <code class="methodname">org.exolab.castor.jdo.Database.create(java.lang.Object)</code>
          creates a new object in the database, or in JDO terminology makes a transient
          object persistent. An object created with the <code class="literal">create</code> method 
          will remain in the database if the transaction commits; 
          if the transaction rolls back the object will be removed from the database. 
          An exception is thrown if an object with the same identity already exists in 
          the database.
        </p><p>
          The following code snippet creates a new product with a group that was previously
          queried:
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">//load product group</span>
ProductGroup furnitures = db.load(...);

<span class="hl-comment">// Create the Product object</span>
Product prod;
prod = <span class="hl-keyword">new</span> Product();
prod.setSku(5678);
prod.setName(<span class="hl-string">"Plastic Chair"</span>);
prod.setPrice(55.0 );
prod.setGroup(furnitures);

<span class="hl-comment">// Make it persistent</span>
db.create(prod);

db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.remove"></a>3.3.2.4.&nbsp;Removing a persistent object</h4></div></div></div><p>
          The method 
          <code class="methodname">org.exolab.castor.jdo.Database.remove(java.lang.Object)</code>
          has the reverse effect, deleting a persistent object. Once removed the object is no
          longer visible to any transaction. If the transaction commits, the object will be removed
          from the database, however, if the transaction rolls back the object will remain in
          the database. An exception is thrown when attempting to remove an object that is not
          persistent.
        </p><p>
          The following code snippet deletes the previously created Product instance:
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">// load the Product instance with sku = 5678</span>
Product prod = db.load (Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(5678);

<span class="hl-comment">// delete the Product instance</span>
db.remove(prod);

db.commit();
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.usage.database-persistence.update"></a>3.3.2.5.&nbsp;Updating a persistent object</h4></div></div></div><p>
          There's no special method offering on the 
          <code class="classname">org.exolab.castor.jdo.Database</code> 
          to update an existing persistent object. Simply load the object to be updated, change
          one or more of its properties, and commit the transaction. Castor JDO will automatically
          figure that that the object in question has changed and will persist these changes
          to the underlying database.
        </p><p>
          The following code snippet loads a previously created Product instance, changes its
          description property and commits the transaction.
        </p><pre class="programlisting">
Database db = ...;
db.begin();        

<span class="hl-comment">// load the Product instance with sku = 5678</span>
Product prod = db.load (Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer(5678);

<span class="hl-comment">// change the object properties</span>
prod.setDescription(<span class="hl-string">"New plastic chair"</span>);

<span class="hl-comment">//commit the transaction</span>
db.commit();
        </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.usage.jdo-and-xml"></a>3.3.3.&nbsp;Using JDO And XML</h3></div></div></div><p>
        Castor JDO and Castor XML can be combined to perform transactional database operations
        that use XML as the form of input and output. The following code snippet uses a combination
        of persistent and transient objects to describe a financial operation.
      </p><p>
        This example retrieves two account objects and moves an amount from one account to the
        other. The transfer is described using a transient object (i.e. no record in the database),
        which is then used to generate an XML document describing the transfer. An extra step
        (not shown here), uses XSLT to transform the XML document into an HTML page.
      </p><pre class="programlisting">
Transfer tran;
Account  from;
Account  to;
OQLQuery oql;

tran = <span class="hl-keyword">new</span> Transfer();

<span class="hl-comment">// Construct a query and load the two accounts</span>
oql = db.getOQLQuery(<span class="hl-string">"SELECT a FROM Account a WHERE Id=$"</span>);
oql.bind(fromId);
from = oql.execute().nextElement();
oql.bind(toId);
to = oql.execute().nextElement();

<span class="hl-comment">// Move money from one account to the other</span>
<span class="hl-keyword">if</span> (from.getBalance() &gt;= amount) {
  from.decBalance(amount);
  to.incBalance(amount);
  trans.setStatus(Transfer.COMPLETE);
  trans.setAccount(from);
  trans.setAmount(amount);
} <span class="hl-keyword">else</span> {
  <span class="hl-comment">// Report an overdraft</span>
  trans.setStatus( Transfer.OVERDRAFT );
}

<span class="hl-comment">// Produce an XML describing the transfer</span>
Marshaller.marshal(trans, outputStream);
      </pre><p>The XML produced by the above code might look like:</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">report</span>&gt;
  &lt;<span class="hl-tag">status</span>&gt;Completed&lt;<span class="hl-tag">/status</span>&gt;
  &lt;<span class="hl-tag">account</span> <span class="hl-attribute">id</span>=<span class="hl-value">"1234-5678-90"</span> <span class="hl-attribute">balance</span>=<span class="hl-value">"50"</span>/&gt;
  &lt;<span class="hl-tag">transfer</span> <span class="hl-attribute">amount</span>=<span class="hl-value">"49.99"</span>/&gt;
&lt;<span class="hl-tag">/report</span>&gt;
</pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.configuration"></a>3.4.&nbsp;Castor JDO - Configuration</h2></div></div></div><p>
       Castor JDO allows for two simple ways of specifying its required configuration, e.g. 
       by the means of supplying Castor JDO with an XML-based configuration file, and by 
       specifying its configuration programmatically via the 
       <code class="classname">org.exoalb.castor.util.jdo.JDOConfFactory</code> class.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.configuration-file"></a>3.4.1.&nbsp;The Castor configuration file</h3></div></div></div><p>
         The default way to configure how Castor interacts with a specific database system 
         is by using a configuration file. It specifies the means to obtain a connection
         to the database server, the mapping between Java classes and tables in that 
         database server, and the service provider to use for talking to that server 
         (For a more flexible, programmatic way without configuration files see section 
         <a href="jdo.html#jdo.configuration.jdoconffactory" title="3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO">JDOConfFactory</a>).
      </p><p>
         The application will access the database(s) by its given name
         (<code class="literal">database/name</code>) and will be able to persist all objects 
         specified in the included mapping file(s).
      </p><p>
         The <code class="literal">engine</code> attribute specifies the persistence engine for this
         database server. Different database servers vary in the SQL syntax and
         capabilites they support, and this attribute names the service provider to use.
      </p><p>The following names are supported in Castor:</p><div class="table"><a name="d4e4205"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Supported engine names</b></p><div class="table-contents"><table summary="Supported engine names" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">engine name</th><th align="left">RDBMS</th></tr></thead><tbody><tr><td>db2</td><td>DB/2</td></tr><tr><td>derby</td><td>Derby</td></tr><tr><td>generic</td><td>Generic JDBC support</td></tr><tr><td>hsql</td><td>Hypersonic SQL</td></tr><tr><td>informix</td><td>Informix</td></tr><tr><td>instantdb</td><td>InstantDB</td></tr><tr><td>interbase</td><td>Interbase</td></tr><tr><td>mysql</td><td>MySQL</td></tr><tr><td>oracle</td><td>Oracle 7 - Oracle 9i</td></tr><tr><td>postgresql</td><td>PostgreSQL 7.1</td></tr><tr><td>sapdb</td><td>SAP DB / MaxDB</td></tr><tr><td>sql-server</td><td>Microsoft SQL Server</td></tr><tr><td>sybase</td><td>Sybase 11</td></tr><tr><td>pointbase</td><td>Borland Pointbase</td></tr><tr><td>progress</td><td>Progress RDBMS</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
            Castor doesn't work with JDBC-ODBC bridge from Sun.
            In particular, MS Access is not supported.
         </p></td></tr></table></div><p>
         The means to acquire a database connection is specified in one of three
         ways: as a JDBC driver URL, as a JDBC DataSource, or as a DataSource
         to lookup through JNDI. When Castor is used inside a J2EE application server
         it is recommended to use JNDI lookup (see the <code class="literal">jndi</code> element),
         allowing the application server to manage connection pooling and distributed
         transactions.
      </p><p>
         The class mapping is included from an external mapping file, allowing
         multiple mappings to be included in the same database configuration, or two
         databases to share the same mappings. For concurrency and integrity reasons,
         two database configurations should never attempt to use overlapping mappings.
         It is recommended to use one database configuration per database server.
      </p><p>
         The mapping file is specified using a URL, typically a <code class="literal">file:</code> URL.
         If the database configuration file and mapping file reside in the same
         directory, use a relative URL. Relative URLs also work if the database
         configuration and mapping files are obtained from the application JAR and
         reside in the same classpath.
      </p><p>
         The <code class="literal">driver</code> element specifies the JDBC driver for obtaining
         new connections to the database server. The driver is obtained from the JDBC
         <code class="literal">DriverManager</code> and must be located in the class path. The JDBC URL
         locates the driver and provides the access properties. Additional properties
         may be specified using <code class="literal">param</code> elements (e.g. buffer size, network
         protocol, etc).
      </p><p>
         Use the <code class="literal">class-name</code> attribute to specify the driver class for
         automatic registration with the JDBC <code class="literal">DriverManager</code>. If missing,
         the driver must be registered in any other means, including properties file,
         <code class="literal">Class.forName()</code>, etc.
      </p><p>
         For example, to configure an Oracle 8 thin driver, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;         
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@host:port:SID"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
        &lt;<span class="hl-tag">/driver</span>&gt;
        ...
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><p>
         The <code class="literal">data-source</code> element specifies the JDBC DataSource for
         obtaining new connections to the database server. DataSources are defined
         in the JDBC 2.0 standard extension API which is included with Castor, and
         implement the interface <code class="literal">javax.sql.DataSource</code>.
      </p><p>
         The DataSource implementation class name is specified by the 
         <code class="literal">class-name</code> attribute and configured through Bean-like accessor 
         methods specified for the <code class="literal">param</code> element. 
         The DTD for the <code class="literal">param</code> element is undefined
         and depends on the DataSource being used.
      </p><p>
         For example, to configure a PostgreSQL 7.1 DataSource, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5432"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password="</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
        &lt;<span class="hl-tag">/data-source</span>&gt;
        ...
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><p>
         The <code class="literal">jndi</code> element specifies the JDBC DataSource for obtaining
         new connections to the database server through a JNDI lookup. The JNDI environment
         naming context (ENC) is used to obtain a suitable DataSource..
      </p><p>
         When running inside a J2EE application server, this is the preferred method
         for obtaining database connections. It enables the J2EE application server to
         configure the connection, maintain a connection pool, and manage distributed
         transactions.
      </p><p>
         For example, to specify a J2EE DataSource, use:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/mydb"</span> /&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     ...
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.transaction"></a>3.4.1.1.&nbsp;Transaction demarcation</h4></div></div></div><p>
           As opposed to release pre 0.9.6, transaction demarcation is now configured 
           in the JDO configuration file. As such, the user has to specify which transaction
           demarcation to use. Transactions when used with Castor JDO can either be 
           <span class="bold"><strong>local</strong></span> or <span class="bold"><strong>global</strong></span>, 
           and you instruct Castor to use a specific mode by supplying 
           a <code class="literal">&lt;transaction-demarcation&gt;</code> element.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.transaction.local-mode"></a>3.4.1.1.1.&nbsp;Local Mode</h5></div></div></div><p>
              When using Castor JDO stand-alone and you want Castor to control
              transaction demarcation, please use the 
              <code class="literal">&lt;transaction-demarcation&gt;</code> element as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span> /&gt;
           </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.transaction.global-mode"></a>3.4.1.1.2.&nbsp;Global Mode</h5></div></div></div><p>
              When running inside a J2EE application server, and you want to use
              global (XA) transactions, please make use the 
              <code class="literal">&lt;transaction-demarcation&gt;</code> element as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
   &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span> /&gt;
&lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
           </pre><p>
              In this mode, the <code class="literal">&lt;transaction-manager&gt;</code> 
              element specifies the transaction manager that is used by your 
              J2EE container to control these transactions.
           </p><p>The following transaction managers are supported in Castor:</p><div class="table"><a name="d4e4308"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Supported transaction managers</b></p><div class="table-contents"><table summary="Supported transaction managers" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Name</th><th align="left">Description</th></tr></thead><tbody><tr><td>jndi</td><td>TM looked up in the JNDI ENC</td></tr><tr><td>websphere</td><td>IBM WebSphere 4 and previous releases</td></tr><tr><td>websphere5</td><td>IBM WebSphere 5</td></tr><tr><td>websphere51</td><td>IBM WebSphere 5.1</td></tr><tr><td>jotm</td><td>JOTM</td></tr><tr><td>atomikos</td><td>Atomikos</td></tr></tbody></table></div></div><br class="table-break"><p>
               In addition to specifying the transaction manager name, it is possible
               to pass arbitrary name/value pairs to the transaction manager instance.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	               At the moment, only the JNDI transaction manager factory supports 
	               such an attribute. In this context, the jndiEnc attribute can be 
	               used to specify what JNDI ENC to use to lookup the transaction 
	               manager as shown below:
               </p></td></tr></table></div><pre class="programlisting">
  &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
     &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span>&gt;
        &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiEnc"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/TransactionManager"</span>/&gt;
     &lt;<span class="hl-tag">/transaction-manager</span>&gt;
  &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.sample"></a>3.4.1.2.&nbsp;Sample Configuration File</h4></div></div></div><p>
         The following configuration file instructs Castor JDO to execute against 
         an Oracle RDBMS using the thin (type 4) JDBC driver, and refers to 
         three mapping files that define mappings for product, order and customer related 
         data.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">jdo-conf</span> <span class="hl-attribute">name</span>=<span class="hl-value">"order-system"</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@machine:post:SID"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span>/&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span>/&gt;
        &lt;<span class="hl-tag">/driver</span>&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"products.xml"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"orders.xml"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"customers.xml"</span>/&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"local"</span>/&gt;
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
         The following configuration file uses a connection obtained from the
         J2EE application server and a single mapping file:
         </p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">jdo-conf</span>&gt;
     &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"ebiz"</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span>&gt;
        &lt;<span class="hl-tag">jndi</span> <span class="hl-attribute">name</span>=<span class="hl-value">"java:comp/env/jdbc/mydb"</span>/&gt;
        &lt;<span class="hl-tag">mapping</span> <span class="hl-attribute">href</span>=<span class="hl-value">"ebiz.xml"</span>/&gt;
     &lt;<span class="hl-tag">/database</span>&gt;
     &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span>&gt;
        &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span>&gt;
           &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiEnc"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/TransactionManager"</span>/&gt;
        &lt;<span class="hl-tag">/transaction-manager</span>&gt;
     &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
  &lt;<span class="hl-tag">/jdo-conf</span>&gt;</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.pooling"></a>3.4.1.3.&nbsp;Prepared statement pooling</h4></div></div></div><p>
           Castor JDO uses <span class="italic">JDBC prepared statements</span> 
           to execute SQL statements against the specified RDBMS of your choice. 
           Per definition, Castor JDO does <span class="bold"><strong>not</strong></span>
           provide any prepared statement pooling. As such, Castor relies on prepared
           statement pooling being provided by different means.
        </p><p>
           One such way is to use 
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/dbcp/" target="_top">Jakarta's Commons DBCP</a> 
           as database connection pool, and to turn prepared statement pooling on by 
           configuring DBCP accordingly.
        </p><p>
           Please check with 
           <a href="advanced-jdo.html#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Using Pooled Database Connections</a>
           for general information about hot to use DBCP with Castor.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.configuration-file.sample-files"></a>3.4.1.4.&nbsp;Sample configurations for various databases</h4></div></div></div><p>
           Besides the examples listed above, more configuraton examples can be found in the
           configuration files for the Castor JDO tests, which can be found in 
           <span class="package">src/tests/jdo</span> once you have downloaded and expanded the Castor 
           source package. For each database (vendor) supported, you are going to find a 
           database-specific JDO configuration file in this directory, e.g. 
           <code class="filename">src/tests/jdo/mysql.xml</code> for 
           <span class="productname">mySQL</span>&#8482; or 
           <code class="filename">src/tests/jdo/oracle.xml</code>
           for <span class="productname">Oracle</span>&#8482;.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.sybase-jconnect"></a>3.4.1.4.1.&nbsp;Sybase JConnect (JDBC data source)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for Sybase using jConnect --</span>&gt;
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.sybase.jdbc2.jdbc.SybDataSource"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password value="</span><span class="hl-attribute">secret"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"4100"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
  &lt;<span class="hl-tag">/data-source</span>&gt;
  ...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.postgresql"></a>3.4.1.4.2.&nbsp;PostgreSQL (JDBC data source)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for PostgreSQL --</span>&gt;
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.postgresql.PostgresqlDataSource"</span>&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"serverName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"host"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"portNumber"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"5432"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"db"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"user"</span> /&gt;
     &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"secret"</span> /&gt;
   &lt;<span class="hl-tag">/data-source</span>&gt;
   ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.oracle"></a>3.4.1.4.3.&nbsp;Oracle (JDBC Driver)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC driver definition for Oracle --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:oracle:thin:@host:post:SID"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.mysql"></a>3.4.1.4.4.&nbsp;mySQL (JDBC Driver)</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for mySQL --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:mysql:/localhost:2206/test"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"scott"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"tiger"</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.configuration.configuration-file.instantdb"></a>3.4.1.4.5.&nbsp;InstantDB</h5></div></div></div><pre class="programlisting">
  ...
  &lt;<span class="hl-comment">!-- JDBC data source for InstantDB --</span>&gt;
  &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.enhydra.instantdb.jdbc.idbDriver"</span>
          <span class="hl-attribute">url</span>=<span class="hl-value">"jdbc:idb:C:\\castor-1.0\\db\\test\\test.prp"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
  &lt;<span class="hl-tag">/driver</span>&gt;
  ...
          </pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.jdoconffactory"></a>3.4.2.&nbsp;JDOConfFactory - A programmatic way of configuring Castor JDO</h3></div></div></div><p>
          Many applications need to connect to a database using varying
          user accounts or database instances. To accomplish this, the utility class 
          <code class="classname">org.exolab.castor.jdo.util.JDOConfFactory"&gt;JDOConfFactory</code>
          and a 
          <code class="methodname">JDOManager.loadConfiguration(org.exolab.castor.jdo.conf.JdoConf)</code>
          method has been added to Castor.
       </p><p>
          The following code snippet shows an example how to create a JDO configuration without 
          the use of a default XML-based database configuration file:
       </p><pre class="programlisting">
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DRIVER = <span class="hl-string">"oracle.jdbc.driver.OracleDriver"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CONNECT = <span class="hl-string">"jdbc:oracle:thin:localhost:1521:SID"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String USERNAME = <span class="hl-string">"scott"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String PASSWORD = <span class="hl-string">"tiger"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String MAPPING = <span class="hl-string">"mapping.xml"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DATABASE = <span class="hl-string">"mydb"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String ENGINE = <span class="hl-string">"oracle"</span>;
  
  <span class="hl-comment">// create driver configuration</span>
  org.castor.jdo.conf.Driver driverConf =
      JDOConfFactory.createDriver(DRIVER, CONNECT, USERNAME, PASSWORD);
      
  <span class="hl-comment">// create mapping configuration</span>
  org.castor.jdo.conf.Mapping mappingConf =
      JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString());

  <span class="hl-comment">// create database configuration</span>
  org.castor.jdo.conf.Database dbConf =
      JDOConfFactory.createDatabase(DATABASE, ENGINE, driverConf, mappingConf);
     
  <span class="hl-comment">// create and load jdo configuration</span>
  JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf));
  
  <span class="hl-comment">// Construct a new JDOManager for the database</span>
  jdoManager = JDOManager.createInstance(DATABASE);
  
  <span class="hl-comment">// Obtain a new database</span>
  Database db = jdoManager.getDatabase();
       </pre><p>
          As an alternative to using a org.exolab.castor.jdo.conf.Driver,
          you can also configure Castor to use a JDBC 2.0 DataSource:
       </p><pre class="programlisting">
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DS = <span class="hl-string">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CONNECT = <span class="hl-string">"jdbc:oracle:thin:localhost:1521:SID"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String USERNAME = <span class="hl-string">"scott"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String PASSWORD = <span class="hl-string">"tiger"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String MAPPING = <span class="hl-string">"mapping.xml"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String DATABASE = <span class="hl-string">"mydb"</span>;
  <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String ENGINE = <span class="hl-string">"oracle"</span>;
  
  <span class="hl-comment">// setup properties for datasource configuration</span>
  Properties props = <span class="hl-keyword">new</span> Properties();
  props.put(<span class="hl-string">"URL"</span>, CONNECT);
  props.put(<span class="hl-string">"user"</span>, USERNAME);
  props.put(<span class="hl-string">"password"</span>, PASSWORD);
            
  <span class="hl-comment">// create datasource configuration</span>
  org.castor.jdo.conf.DataSource dsConf =
      JDOConfFactory.createDataSource(DS, props);
              
  <span class="hl-comment">// create mapping configuration</span>
  org.castor.jdo.conf.Mapping mappingConf =
      JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString());
        
  <span class="hl-comment">// create database configuration</span>
  org.castor.jdo.conf.Database dbConf =
      JDOConfFactory.createDatabase(DATABASE, ENGINE, dsConf, mappingConf);
  
  <span class="hl-comment">// create and load jdo configuration</span>
  JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf));
  
  <span class="hl-comment">// Construct a new JDOManager for the database</span>
  jdoManager = JDOManager.createInstance(DATABASE);
  
  <span class="hl-comment">// Obtain a new database</span>
  Database db = jdoManager.getDatabase();
       </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.configuration.references"></a>3.4.3.&nbsp;References</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.configuration.references.dtd"></a>3.4.3.1.&nbsp;The JDO Configuration DTD</h4></div></div></div><p>
             For validation, the configuration file should include the following
             document type definition. For DTD validation use:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                            <span class="hl-attribute">"http://castor.org/jdo-conf.dtd"&gt;</span>

             </pre><p>
             For XML Schema validation use:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">JDO</span> <span class="hl-attribute">Configuration</span> <span class="hl-attribute">Schema</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                             <span class="hl-attribute">"http://castor.org/jdo-conf.xsd"&gt;</span>

             </pre><p>
             The Castor namespace URI is <code class="uri">http://castor.org/</code>.
          </p><p>
             The Castor JDO database configuration DTD is:
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">jdo-conf</span> <span class="hl-attribute">(</span> <span class="hl-attribute">database+,</span> <span class="hl-attribute">transaction-demarcation</span> <span class="hl-attribute">)&gt;</span>

  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">jdo-conf</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">"jdo-conf"&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">database</span> <span class="hl-attribute">(</span> <span class="hl-attribute">(</span> <span class="hl-attribute">driver</span> <span class="hl-attribute">|</span> <span class="hl-attribute">data-source</span> <span class="hl-attribute">|</span> <span class="hl-attribute">jndi</span> <span class="hl-attribute">)?,</span> <span class="hl-attribute">mapping+</span> <span class="hl-attribute">)&gt;</span>
                       
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">database</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">ID</span>      <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">engine</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">"generic"&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">mapping</span>
            <span class="hl-attribute">href</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">driver</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">driver</span>
            <span class="hl-attribute">url</span>        <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">class-name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">data-source</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">data-source</span>
            <span class="hl-attribute">class-name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">jndi</span> <span class="hl-attribute">ANY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">jndi</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">transaction-demarcation</span> <span class="hl-attribute">(</span> <span class="hl-attribute">transaction-manager?</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">transaction-demarcation</span>
            <span class="hl-attribute">mode</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>

  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">transaction-manager</span> <span class="hl-attribute">(</span> <span class="hl-attribute">param*</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">transaction-manager</span>
            <span class="hl-attribute">name</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>
            
  <span class="hl-attribute">&lt;!ELEMENT</span> <span class="hl-attribute">param</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">param</span>
            <span class="hl-attribute">name</span>  <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">value</span> <span class="hl-attribute">CDATA</span> <span class="hl-attribute">#REQUIRED&gt;</span>


             </pre><p>
          </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.types"></a>3.5.&nbsp;Type Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.types"></a>3.5.1.&nbsp;Types</h3></div></div></div><p>
        The Castor type mechanism assures proper conversion between Java types
        and external types.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-xml"></a>3.5.1.1.&nbsp;Castor XML</h4></div></div></div><p>
          Castor XML converts all Java fields into XML element and attribute
          values.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-jdo"></a>3.5.1.2.&nbsp;Castor JDO</h4></div></div></div><p>
          Castor JDO converts Java fields into SQL columns which are persisted
          through the JDBC driver. Due to implementation details, the field
          type expected by the JDBC driver is not always the field type defined
          for the mapped object.
        </p><p>
          The most common occurrences of mistyping is when using fields of type
          <span class="type">FLOAT</span>, <span class="type">DOUBLE</span>, <span class="type">NUMERIC</span>, 
          and <span class="type">DECIMAL</span>. SQL type <span class="type">FLOAT</span> actually 
          maps to Java type <span class="type">java.lang.Double</span>. SQL types 
          <span class="type">NUMERIC</span> and <span class="type">DECIMAL</span> map to Java 
          type <span class="type">java.math.BigDecimal</span>.
        </p><p>
          When such an inconsistency occurs, Castor JDO will throw an
          <code class="literal">IllegalArgumentException</code> during object persistence with a
          message indicating the two conflicting types.
        </p><p>
          In order to avoid runtime exceptions, we recommend explicitly
          specifying types in the mapping file using the SQL typing convention.
          See <a href="jdo.html#jdo.types.type-conversion" title="3.5.4.&nbsp;SQL Type Conversion">SQL Type Conversion</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.types.types.castor-dax"></a>3.5.1.3.&nbsp;Castor DAX</h4></div></div></div><p>
          Castor DAX converts all Java fields into LDAP attribute values. LDAP
          attribute values are always textual and are represented as the string
          value of the field, e.g. "5" or "true".
        </p><p>
          LDAP attributes may also contain binary values. When storing byte
          arrays or serialized Java objects, DAX will store them as byte arrays.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.field-mapping"></a>3.5.2.&nbsp;The Field Mapping</h3></div></div></div><p>
        The field element includes an optional attribute called 
        <code class="literal">type</code> which can be used to specify 
        the Java type of the field. This attribute is optional since Castor 
        can always derive the exact Java type from the class definition.
      </p><p>
        We highly recommend that developers use the type field in their mapping
        file as a means to provide static type checking. When loading a mapping
        file, Castor will compare the actual Java type with the type specified
        in the mapping and will complain about inconsistencies.
      </p><p>
        The field type can be specified either given the full class name 
        (e.g. <span class="type">java.lang.Integer</span>) or using a short name. 
        The following table lists all the acceptable short names and the Java 
        types they represent:
      </p><div class="table"><a name="d4e4431"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Acceptable short names</b></p><div class="table-contents"><table summary="Acceptable short names" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">short name</th><th align="left">Primitive type?</th><th align="left">Java Class</th></tr></thead><tbody><tr><td>big-decimal</td><td>N</td><td>java.math.BigDecimal</td></tr><tr><td>boolean</td><td>Y</td><td>java.lang.Boolean.TYPE</td></tr><tr><td>byte</td><td>Y</td><td>java.lang.Byte.TYPE</td></tr><tr><td>bytes</td><td>N</td><td>byte[]</td></tr><tr><td>char</td><td>Y</td><td>java.lang.Character.TYPE</td></tr><tr><td>chars</td><td>N</td><td>char[]</td></tr><tr><td>clob</td><td>N</td><td>java.sql.Clob</td></tr><tr><td>date</td><td>N</td><td>java.util.Date</td></tr><tr><td>double</td><td>Y</td><td>java.lang.Double.TYPE</td></tr><tr><td>float</td><td>Y</td><td>java.lang.Float.TYPE</td></tr><tr><td>integer</td><td>Y</td><td>java.lang.Integer.TYPE</td></tr><tr><td>locale</td><td>N</td><td>java.util.Locale</td></tr><tr><td>long</td><td>Y</td><td>java.lang.Long.TYPE</td></tr><tr><td>other</td><td>N</td><td>java.lang.Object</td></tr><tr><td>short</td><td>Y</td><td>java.lang.Short.TYPE</td></tr><tr><td>string</td><td>N</td><td>java.lang.String</td></tr><tr><td>strings</td><td>N</td><td>String[]</td></tr><tr><td>stream</td><td>N</td><td>java.io.InputStream</td></tr></tbody></table></div></div><br class="table-break"><p>
        In addition, support for the following Castor-internal field types
        has been added:
      </p><div class="table"><a name="d4e4513"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Castor-internal field types</b></p><div class="table-contents"><table summary="Castor-internal field types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">short name</th><th align="left">Primitive type?</th><th align="left">Java Class</th></tr></thead><tbody><tr><td>duration</td><td>N</td><td>org.exolab.castor.types.Duration</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.dates-timezones"></a>3.5.3.&nbsp;SQL Dates and Default Timezones</h3></div></div></div><p>
        Castor will use the JDBC 
        <code class="methodname">ResultSet.getDate(int, Calendar)</code> 
        and related methods which take a Calendar object to specify the timezone of
        the data retrieved from the database when the timezone information is not
        already specified in the data; this ensures that the "current"
        timezone is applied.
      </p><p>
        The default time zone can be configured in the castor.properties file;
        see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/conf-lib.html" target="_top">configuration section</a> for details
        on how to configure Castor with information about your default time zone.
      </p><p>
        To change the timezone to a different timezone than the default, please
        set a (different) value on the 
        <code class="literal">org.exolab.castor.jdo.defaultTimeZone</code> property:
      </p><pre class="programlisting">
# Default time zone to apply to dates/times fetched from database fields,
# if not already part of the data.  Specify same format as in
# java.util.TimeZone.getTimeZone, or an empty string to use the computer's
# local time zone.
org.exolab.castor.jdo.defaultTimeZone=
#org.exolab.castor.jdo.defaultTimeZone=GMT+8:00
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.type-conversion"></a>3.5.4.&nbsp;SQL Type Conversion</h3></div></div></div><p>
        Castor JDO uses the JDBC <code class="literal">getObject/setObject</code> methods 
        in order to retrieve and set fields. These methods do not perform 
        automatic type conversion, often resulting in unexpected behavior. 
        For example, when using a NUMERIC field with direct JDBC access, 
        application developers tend to call <code class="literal">getInteger()</code> 
        or <code class="literal">getFloat()</code>, but the Java object returned from 
        a call to <code class="literal">getObject</code> is often a 
        <code class="literal">java.math.BigDecimal</code>.
      </p><p>
        Castor JDO implements automatic type conversion between Java and SQL.
        For this mechanism to work, the mapping file must specify the SQL type
        being used for Castor to employ the proper convertor. If no SQL type
        is specified, no conversion will occur, possibly resulting in an
        <code class="literal">IllegalArgumentException</code> being thrown.
      </p><p>
        SQL types are specified with the 
        <span class="italic">sql-type</span> attribute using either
        the default Java type returned by the JDBC driver 
        (e.g. <code class="literal">java.lang.Integer</code> or the proper SQL type name 
        (without precision). The following table lists the supported SQL type 
        names and the corresponding Java types:
      </p><div class="table"><a name="d4e4548"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Supported SQL type names</b></p><div class="table-contents"><table summary="Supported SQL type names" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">SQL Type</th><th align="left">Java Type</th></tr></thead><tbody><tr><td>bigint</td><td>java.lang.Long</td></tr><tr><td>binary</td><td>byte[]</td></tr><tr><td>bit</td><td>java.lang.Boolean</td></tr><tr><td>blob</td><td>java.io.InputStream</td></tr><tr><td>char</td><td>java.lang.String</td></tr><tr><td>clob</td><td>java.sql.Clob</td></tr><tr><td>decimal</td><td>java.math.BigDecimal</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>float</td><td>java.lang.Double</td></tr><tr><td>integer</td><td>java.lang.Integer</td></tr><tr><td>longvarbinary</td><td>byte[]</td></tr><tr><td>longvarchar</td><td>java.lang.String</td></tr><tr><td>numeric</td><td>java.math.BigDecimal</td></tr><tr><td>real</td><td>java.lang.Float</td></tr><tr><td>smallint</td><td>java.lang.Short</td></tr><tr><td>time</td><td>java.sql.Time</td></tr><tr><td>timestamp</td><td>java.sql.Timestamp</td></tr><tr><td>tinyint</td><td>java.lang.Byte</td></tr><tr><td>varbinary</td><td>byte[]</td></tr><tr><td>varchar</td><td>java.lang.String</td></tr><tr><td>other</td><td>java.lang.Object</td></tr><tr><td>javaobject</td><td>java.lang.Object</td></tr></tbody></table></div></div><br class="table-break"><p>
        The following example illustrates how to specify SQL type in field mapping:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prodId"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        Please note that java.util.Date is not automatically converted into a
        java.sql.Date object; while it is in theory possible to do so, there
        are three different possible storage formats for date information:
        as a java.sql.Date, java.sql.Time, and java.sql.Timestamp.  Rather than
        impose a possibly inappropriate data mapping on an entry, no automatic
        transformation will take place.
      </p><p>
        JDBC drivers which do not, themselves, perform a mapping between
        java.util.Date and the sql format specified on the database will throw
        an error when java.util.Date is passed to them on the prepared
        statement.  Moreover, auto-conversion of java.util.Date is outside of
        the JDBC specification; it is not a supported auto-convert format.
      </p><p>
        Users wishing to store date information into the database should ensure
        that they set date, time, or timestamp as the sql type on the
        <code class="literal">sql-type</code> attribute.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.type-convertors"></a>3.5.5.&nbsp;Parameterized Type Convertors</h3></div></div></div><p>
        Some of the type convertors may have a string parameter, which changes
        the conversion algorithm. The parameter is specified in square
        brackets after the SQL type, for example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"active"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"boolean"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"acc_active"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char[01]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
         where "0" is the character value for 
         <span class="bold"><strong>false</strong></span> and "1" is
         the character value for <span class="bold"><strong>true</strong></span>.
      </p><p>
        In the above example the first of a bunch of parameterized type convertors
        is used, "boolean --&gt; char" convertor.  The parameter must have length 2,
        the first character is the value for <span class="bold"><strong>false</strong></span>, 
        the second character is the value for <span class="bold"><strong>true</strong></span>. 
        The default value is "FT". The actual SQL type should be char(1).
      </p><p>
        The second and third convertors are "boolean --&gt; integer" and
        "boolean --&gt; numeric". Its parameter must be 
        <span class="bold"><strong>+</strong></span> for +1 or 
        <span class="bold"><strong>-</strong></span> for -1 representing true. 
        False is always converted to 0. For example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"flagWithMinusOneForTrue"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"boolean"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"flag"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer[-]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>If the parameter is not specified, true is converted to +1.</p><p>
        The fourth convertor is "date --&gt; char". Its parameter must be a correct
        pattern for SimpleDateFormat. For example:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"dateOfBirth"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pers_dob"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char[MMM d, yyyy]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        If the parameter is not specified, the conversion is performed
        using toString() method of the Date class.
      </p><p>
        The fifth and the sixth convertors are "date --&gt; integer" and
        "date --&gt; numeric".  Their parameters are also patterns having syntax
        based on the SimpleDateFormat syntax, but repeated characters are
        eliminated. The following table shows the substitution rules that are
        used to obtain the SimpleDateFormat pattern from the parameter.
      </p><div class="table"><a name="d4e4647"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Substitution rules</b></p><div class="table-contents"><table summary="Substitution rules" border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Y,y</td><td>yyyy</td><td>year</td></tr><tr><td>M</td><td>MM</td><td>month in year</td></tr><tr><td>D,d</td><td>dd</td><td>day in month</td></tr><tr><td>h,H</td><td>HH</td><td>hour in day (0~23)</td></tr><tr><td>m</td><td>mm</td><td>minute in hour</td></tr><tr><td>s</td><td>ss</td><td>second in minute</td></tr><tr><td>S</td><td>SSS</td><td>millisecond</td></tr></tbody></table></div></div><br class="table-break"><p>
        For example, "YMD" parameter is expanded to "yyyyMMdd" SimpleDateFormat
        pattern, "YMDhmsS" parameter is expanded to "yyyyMMddHHmmssSSS"
        SimpleDateFormat pattern.  The length of the expanded parameter gives
        the minimal number of decimal digits that the actual SQL type must
        support. The default value of the parameter is "YMD".
      </p><p>
        The date and time types of 
        <span class="package">org.exolab.castor.types</span> package 
        support 2 timelines as defined by XML schema specification. One for timezoned 
        values and one for non-timezoned values which are treated to be local. 
        When converting such types to long the timezone information is lost. 
        In most cases it is no problem to loose for which timezone the value was 
        specified if the value get converted to UTC time before. But we also loose 
        if the value had a timezone or not. This causes that we do not know to which 
        timeline the value belongs. If we just treat it as non-timezoned value while 
        it has been a timezoned one we have changed the value.
      </p><p>
        Therefore we have added support for another parameterized type converter. This one
        allows you to specify if the date and time values created out of a persisted long
        value are meant to be timezoned or not. By default, without a parameter, local
        date or time instances are created without a timezone. If you specify the parameter
        <code class="code">utc</code> in mapping the date or time values are created based on UTC timezone.
        It need to be noted that such a mapping can only handle date and time values of one
        of the 2 timelines defined by XML schema specification. Having said that this only
        applies to the conversion of such values to long and does not cause issues when
        converting to string and back.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timeOfBirth"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.exolab.castor.types.Time"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"pers_tob"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"bigint[utc]"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.types.blob-clob"></a>3.5.6.&nbsp;BLOB and CLOB Types</h3></div></div></div><p>
        BLOB and CLOB stand for binary and character large objects (or in
        Sybase, IMAGE and TEXT types, respectively).  This means that most
        likely you don't want to load the whole objects into memory, but
        instead want to read and write them as streams. Usually these types are
        not comparable via the <code class="literal">WHERE</code> clause of a SQL statement. 
        That is why you should disable dirty checking for such fields, e.g.
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"text"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        In this example CLOB field will be read as a String. This may cause
        OutOfMemoryError if the text is really large, but in many cases mapping
        CLOB to String is acceptable.  The advantage of mapping to String is
        that we obtain a Serializable value that can be passed via RMI.
        Similarly you can map BLOB and CLOB to <code class="literal">byte[]</code> and
        <code class="literal">char[]</code> types, respectively:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"photo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"bytes"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"photo"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resume"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"chars"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"resume"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        Now, assume that mapping to String is not acceptable. The natural Java
        type mapping for the BLOB type is <code class="literal">java.io.InputStream</code>, 
        and this mapping is supported by Castor:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"cdImage"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"stream"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"cd_image"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"blob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        The natural Java type mapping for the CLOB type is
        <code class="literal">java.io.Reader</code>, but this mapping is 
        <span class="bold"><strong>not</strong></span> supported by Castor because 
        <code class="literal">java.io.Reader</code> doesn't provide information
        about the length of the stream and this information is necessary
        for JDBC driver (at least for the Oracle driver) to write the value to
        the database. This is why the CLOB type is mapped to
        <code class="literal">java.sql.Clob</code>:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
  &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
        When you read data from the database, you can use the
        <code class="literal">getCharacterStream()</code> method to obtain a
        <code class="literal">java.io.Reader</code> from <code class="literal">java.sql.Clob</code>. 
        When you write data to the database, you can either use the helper class
        <code class="literal">org.exolab.castor.jdo.engine.ClobImpl</code> to construct
        <code class="literal">java.sql.Clob</code> from <code class="literal">java.io.Reader</code> 
        and the length:
      </p><pre class="programlisting">
  object.setClob(<span class="hl-keyword">new</span> ClobImpl(<span class="hl-keyword">new</span> FileReader(file), file.length());</pre><p>
        or implement the <code class="literal">java.sql.Clob</code> interface yourself.
      </p><p>
        But be aware of the followng restriction: if you map BLOB to
        <code class="literal">java.io.InputStream</code> or CLOB to 
        <code class="literal">java.sql.Clob</code>, then you should turn caching 
        off for the Java class containing those values, e.g.:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">...&gt;</span>
    <span class="hl-attribute">&lt;cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span>/&gt;
      ...
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span>&gt;
        &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"novel"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"clob"</span> <span class="hl-attribute">dirty</span>=<span class="hl-value">"ignore"</span> /&gt;
      &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
        Blob and Clob values cannot be cached, because they are alive only while
        the ResultSet that produced them is open. In particular, this means
        that you cannot use dirty checking for long transactions with such
        classes.
      </p></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.mapping"></a>3.6.&nbsp;Castor JDO Mapping</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Bruce</span> <span class="surname">Snyder</span> 
            ()
            </span>, <span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.news"></a>3.6.1.&nbsp;News</h3></div></div></div><p>
          <span class="bold"><strong>Release 1.0 M3</strong></span>:
          </p><div class="itemizedlist"><ul type="disc"><li><p>Added collection type 'iterator'.</p></li><li><p>Added collection type 'enumerate'.</p></li><li><p>Added additional syntax for specifying the identity of a class.</p></li></ul></div><p>
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.introduction"></a>3.6.2.&nbsp;Introduction</h3></div></div></div><p>
         The Castor mapping file also provides a mechanism for binding a Java
         object model to a relational database model. This is usually referred to
         as object-to-relational mapping (O/R mapping). O/R mapping bridges the gap
         between an object model and a relational model.
      </p><p>
         The mapping file provides a description of the Java object model to
         Castor JDO. Via Castor XML, Castor JDO uses the information in the mapping
         file to map Java objects to relational database tables. The
         following is a high-level example of a mapping file:
      </p><pre class="programlisting">
  &lt;<span class="hl-tag">mapping</span>&gt;
      &lt;<span class="hl-tag">class</span> <span class="hl-attribute">...</span> &gt;
          &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">...</span> /&gt;
          &lt;<span class="hl-tag">field</span> <span class="hl-attribute">...</span> &gt;
              &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">...</span> /&gt;
          &lt;<span class="hl-tag">/field</span>&gt;
          ...
      &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
         Each Java object is represented by a &lt;class&gt; element composed of attributes,
         a &lt;map-to&gt; element and &lt;field&gt; elements. The &lt;map-to&gt; element
         contains a reference to the relational table to which the Java object maps.
         Each &lt;field&gt; element represents either a public class variable or the
         variable's accessor/mutator methods (depending upon the mapping info). Each
         &lt;field&gt; element is composed of attributes and one &lt;sql&gt; element.
         The &lt;sql&gt; element represents the field in the relational table to which
         the &lt;field&gt; element maps.
      </p><p>
         It is possible to use the mapping file and Castor's default behavior in
         conjunction. When Castor handles an object but is unable to locate
         information about it in the mapping file, it will rely upon its default
         behavior. Castor makes use of the Java programming language
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/reflect/package-summary.html" target="_top">
         Reflection API</a> to introspect the Java objects to determine the methods
         to use. This is the reason some attributes are not required in the mapping
         file.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.mapping.file"></a>3.6.3.&nbsp;The Mapping File</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.mapping-element"></a>3.6.3.1.&nbsp;The &lt;mapping&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">include*,</span> <span class="hl-attribute">class*,</span> <span class="hl-attribute">key-generator*</span> <span class="hl-attribute">)&gt;</span></pre><p>
           The &lt;mapping&gt; element is the root element of a mapping file. It contains:
        </p><div class="itemizedlist"><ul type="disc"><li><p>an optional description</p></li><li><p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li><li><p>
                zero or more &lt;class&gt; descriptions: one for each class we intend to give
                mapping information
             </p></li><li><p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li></ul></div><p>A mapping file look like this:</p><pre class="programlisting">
  &lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
  &lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Object</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                           <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>

  <span class="hl-attribute">&lt;mapping&gt;</span>
     <span class="hl-attribute">&lt;description&gt;Description</span> <span class="hl-attribute">of</span> <span class="hl-attribute">the</span> <span class="hl-attribute">mapping&lt;/description&gt;</span>
     <span class="hl-attribute">&lt;include</span> <span class="hl-attribute">href</span>=<span class="hl-value">"other_mapping_file.xml"</span>/&gt;

     &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"A"</span>&gt;
         ...
     &lt;<span class="hl-tag">/class</span>&gt;

     &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"B"</span>&gt;
        ...
     &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">/mapping</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.class-element"></a>3.6.3.2.&nbsp;The &lt;class&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">class</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">cache-type?,</span> <span class="hl-attribute">map-to?,</span> <span class="hl-attribute">field+</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">class</span>
            <span class="hl-attribute">name</span>            <span class="hl-attribute">ID</span>       <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">extends</span>         <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">depends</span>         <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">auto-complete</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|false</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">identity</span>        <span class="hl-attribute">CDATA</span>    <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">access</span>          <span class="hl-attribute">(</span> <span class="hl-attribute">read-only</span> <span class="hl-attribute">|</span> <span class="hl-attribute">shared</span> <span class="hl-attribute">|</span> <span class="hl-attribute">exclusive</span> <span class="hl-attribute">|</span> <span class="hl-attribute">db-locked</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"shared"</span>
            <span class="hl-attribute">key-generator</span>   <span class="hl-attribute">IDREF</span>    <span class="hl-attribute">#IMPLIED</span> &gt;</pre><p>
           The  &lt;class&gt; element contains all the information used to map a Java object
           to a relational database. The content of &lt;class&gt; is mainly used to describe
           the fields that will be mapped.
        </p><p>Description of the attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>
	             <span class="bold"><strong>name:</strong></span> The fully qualified package name of the 
	             Java object to map to.
             </p></li><li><p>
	             <span class="bold"><strong>extends:</strong></span> Should be used 
	             <span class="bold"><strong>only</strong></span> if this Java object extends another Java
	             object for which mapping information is provided. It should 
	             <span class="bold"><strong>not</strong></span> be used if the extended 
	             Java object is not referenced in the mapping file.
             </p></li><li><p>
	             <span class="bold"><strong>depends:</strong></span> For more information on this field, 
	             please see
	             <a href="jdo.html#jdo.advanced-features.dependent-and-related" title="3.11.3.&nbsp;Dependent and related relationships">
	             Dependent and related relationships</a>.
             </p></li><li><p>
	             <span class="bold"><strong>identity:</strong></span> For more information on this field, 
	             please see 
	             <a href="advanced-jdo.html#advanced-jdo.persist.spi.persistence" title="4.4.3.1.&nbsp;Persistence">Design -&gt; Persistence</a>.
             </p></li><li><p>
	             <span class="bold"><strong>access:</strong></span> For more information on this field, 
	             please see <a href="advanced-jdo.html#advanced-jdo.locking.modes" title="4.3.2.&nbsp;Locking Modes">Locking Modes</a>.
             </p></li><li><p>
	             <span class="bold"><strong>key-generator</strong></span>: For more information on 
	             this field, please see <a href="advanced-jdo.html#advanced-jdo.key-generator" title="4.5.&nbsp;Castor JDO Key Generator Support">KeyGen</a>.
             </p></li></ul></div><p>Description of the elements:</p><div class="itemizedlist"><ul type="disc"><li><p>
		             <span class="bold"><strong>&lt;description&gt;</strong></span>: 
		             An optional description.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;cache-type&gt;</strong></span>: 
		             For more information on this field please see
		             <a href="advanced-jdo.html#advanced-jdo.long-transactions.bounded-dirty-checking" title="4.6.2.&nbsp;Bounded dirty checking">Bounded 
		             Dirty Checking</a> and 
		             <a href="jdo.html#jdo.advanced-features.caching" title="3.11.2.&nbsp;Caching">Caching</a>.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;map-to&gt;</strong></span>: 
		             Used to tell Castor the name of the relational
		             table to which to map.
	             </p></li><li><p>
		             <span class="bold"><strong>&lt;field&gt;</strong></span>: Zero or more 
		             &lt;field&gt; elements are used to describe properties
		             of each Java object.
	             </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.map-to-element"></a>3.6.3.3.&nbsp;The &lt;map-to&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;!ELEMENT map-to EMPTY&gt;
  &lt;!ATTLIST map-to
            table      NMTOKEN  #IMPLIED
            xml        NMTOKEN  #IMPLIED
            ns-uri     NMTOKEN  #IMPLIED
            ns-prefix  NMTOKEN  #IMPLIED
            ldap-dn    NMTOKEN  #IMPLIED
            ldap-oc    NMTOKEN  #IMPLIED&gt;</pre><p>&lt;map-to&gt; is used to specify the name of the item that should be associated
          with the given Java object. The &lt;map-to&gt; element is only used for the root
          Java object.</p><p>Description of the attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>
	            <span class="bold"><strong>table:</strong></span> 
	            The name of the relational database table to which the
	            Java object is associated.
	         </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.field-element"></a>3.6.3.4.&nbsp;The &lt;field&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">field</span> <span class="hl-attribute">(</span> <span class="hl-attribute">description?,</span> <span class="hl-attribute">sql?,</span> <span class="hl-attribute">xml?,</span> <span class="hl-attribute">ldap?</span> <span class="hl-attribute">)&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">field</span>
            <span class="hl-attribute">name</span>           <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#REQUIRED</span>
            <span class="hl-attribute">type</span>           <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">required</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">direct</span>         <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">lazy</span>           <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">transient</span>      <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">identity</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">get-method</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">set-method</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">create-method</span>  <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">collection</span>     <span class="hl-attribute">(</span> <span class="hl-attribute">array</span> <span class="hl-attribute">|</span> <span class="hl-attribute">enumerate</span> <span class="hl-attribute">|</span> <span class="hl-attribute">collection</span> <span class="hl-attribute">|</span> <span class="hl-attribute">set</span> <span class="hl-attribute">|</span> 
                             <span class="hl-attribute">arraylist</span> <span class="hl-attribute">|</span> <span class="hl-attribute">vector</span> <span class="hl-attribute">|</span> <span class="hl-attribute">map</span> <span class="hl-attribute">|</span> <span class="hl-attribute">hashtable</span> <span class="hl-attribute">|</span> <span class="hl-attribute">sortedset</span> <span class="hl-attribute">|</span> <span class="hl-attribute">iterator</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">comparator</span>     <span class="hl-attribute">NMTOKEN</span>  <span class="hl-attribute">#IMPLIED&gt;</span></pre><p>
           The &lt;field&gt; element is used to describe a property of a Java object. It provides:
        </p><div class="itemizedlist"><ul type="disc"><li><p>the identity ('name') of the property</p></li><li><p>the type of the property (inferred from 'type' and 'collection')</p></li><li><p>
                the access method of the property 
                (inferred from 'direct', 'get-method', 'set-method')
             </p></li></ul></div><p>
          From this information, Castor is able to access a given property in the Java
          object.
        </p><p>
          In order to determine the signature that Castor expects, there are two easy
          rules to apply.
        </p><p><span class="bold"><strong>1. Determine &lt;type&gt;.</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>
	              <span class="bold"><strong>If there is no 'collection' attribute</strong></span>, 
	              the object type is the value of the 'type' attribute. 
	              The value of the type attribute can be a fully qualified Java object 
	              like 'java.lang.String' or one of the allowed aliases:
	           </p><table border="0" cellspacing="1" cellpadding="2"><tr xmlns:xi="http://www.w3.org/2001/XInclude">
	               <td rowspan="1" colspan="1">
	                  <table border="0" cellspacing="0" cellpadding="6"><tr>
	                        <th align="left" rowspan="1" colspan="1">short name</th>
	                        <th align="left" rowspan="1" colspan="1">Primitive type?</th>
	                        <th align="left" rowspan="1" colspan="1">Java Class</th>
	                     </tr><tr><td rowspan="1" colspan="1">big-decimal</td> <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.math.BigDecimal</td>    </tr><tr><td rowspan="1" colspan="1">big-integer</td> <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.math.BigInteger</td>    </tr><tr><td rowspan="1" colspan="1">boolean</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Boolean.TYPE</td>  </tr><tr><td rowspan="1" colspan="1">byte</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Byte.TYPE</td>     </tr><tr><td rowspan="1" colspan="1">bytes</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">byte[]</td>                  </tr><tr><td rowspan="1" colspan="1">char</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Character.TYPE</td></tr><tr><td rowspan="1" colspan="1">chars</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">char[]</td>                  </tr><tr><td rowspan="1" colspan="1">clob</td>        <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.sql.Clob</td>           </tr><tr><td rowspan="1" colspan="1">date</td>        <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.util.Date</td>          </tr><tr><td rowspan="1" colspan="1">double</td>      <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Double.TYPE</td>   </tr><tr><td rowspan="1" colspan="1">float</td>       <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Float.TYPE</td>    </tr><tr><td rowspan="1" colspan="1">int</td>         <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Integer.TYPE</td>  </tr><tr><td rowspan="1" colspan="1">integer</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Integer</td>       </tr><tr><td rowspan="1" colspan="1">locale</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.util.Locale</td>        </tr><tr><td rowspan="1" colspan="1">long</td>        <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Long.TYPE</td>     </tr><tr><td rowspan="1" colspan="1">other</td>       <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.lang.Object</td>        </tr><tr><td rowspan="1" colspan="1">serializable</td><td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.io.Serializable</td>    </tr><tr><td rowspan="1" colspan="1">short</td>       <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.lang.Short.TYPE</td>    </tr><tr><td rowspan="1" colspan="1">sqldate</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.sql.Date</td>           </tr><tr><td rowspan="1" colspan="1">sqltime</td>     <td rowspan="1" colspan="1">Y</td><td rowspan="1" colspan="1">java.sql.Date</td>           </tr><tr><td rowspan="1" colspan="1">string</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.lang.String</td>        </tr><tr><td rowspan="1" colspan="1">strings</td>     <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">String[]</td>                </tr><tr><td rowspan="1" colspan="1">stream</td>      <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.io.InputStream</td>     </tr><tr><td rowspan="1" colspan="1">timestamp</td>   <td rowspan="1" colspan="1">N</td><td rowspan="1" colspan="1">java.sql.Timestamp</td>      </tr></table>
	               </td>
	            </tr></table><p>
	            Castor will try to cast the data in the mapping file to the proper Java 
	            type.
	         </p></li><li><p>
	            <span class="bold"><strong>If there is a collection attribute</strong></span>, 
	            the items in the following table can be
	            used:
	         </p><table border="0" cellspacing="1" cellpadding="2"><tr xmlns:xi="http://www.w3.org/2001/XInclude">
	               <td rowspan="1" colspan="1">
	                  <table border="0" cellspacing="0" cellpadding="6"><tr>
	                        <th align="left" rowspan="1" colspan="1">name</th>
	                        <th align="left" rowspan="1" colspan="1">type</th>
	                        <th align="left" rowspan="1" colspan="1">default implementation</th>
	                        <th align="left" rowspan="1" colspan="1">added in release</th>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">array</td>
	                       <td rowspan="1" colspan="1">&lt;type_attribute&gt;[]</td>
	                       <td rowspan="1" colspan="1">&lt;type_attribute&gt;[]</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">enumerate</td>
	                       <td rowspan="1" colspan="1">java.util.Enumeration</td>
	                       <td rowspan="1" colspan="1">-</td>
	                       <td style="color:red;" rowspan="1" colspan="1">1.0 M3</td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">collection</td>
	                       <td rowspan="1" colspan="1">java.util.Collection</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList </td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">set</td>
	                       <td rowspan="1" colspan="1">java.util.Set</td>
	                       <td rowspan="1" colspan="1">java.util.HashSet</td>
	                       <td rowspan="1" colspan="1"></td>
	                       </tr><tr>
	                       <td rowspan="1" colspan="1">arraylist</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList</td>
	                       <td rowspan="1" colspan="1">java.util.ArrayList </td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">vector</td>
	                       <td rowspan="1" colspan="1">java.util.Vector</td>
	                       <td rowspan="1" colspan="1">java.util.Vector</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">map</td>
	                       <td rowspan="1" colspan="1">java.util.Map</td>
	                       <td rowspan="1" colspan="1">java.util.HashMap</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">hashtable</td>
	                       <td rowspan="1" colspan="1">java.util.Hashtable</td>
	                       <td rowspan="1" colspan="1">java.util.Hashtable</td>
	                       <td rowspan="1" colspan="1"></td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">sortedset</td>
	                       <td rowspan="1" colspan="1">java.util.SortedSet</td>
	                       <td rowspan="1" colspan="1">java.util.TreeSet</td>
	                       <td rowspan="1" colspan="1">1.0 M2</td>
	                     </tr><tr>
	                       <td rowspan="1" colspan="1">iterator</td>
	                       <td rowspan="1" colspan="1">java.util.Iterator</td>
	                       <td rowspan="1" colspan="1"> n/a </td>
	                       <td style="color:red" rowspan="1" colspan="1">1.0 M3</td>
	                     </tr></table>
	               </td>
	            </tr></table><p>
	            The type of the object inside the collection is the 'type' attribute. The 'default
	            implementation' is the type used if the object holding the collection is found
	            to be null and needs to be instantiated.
	         </p><p>
	            For hashtable and map, Castor will add an object using the put(object, object) 
	            method - the object is both the key and the value. This will be improved in the future.
	         </p></li></ul></div><p>
           It is necessary to use a collection when the content model of the element expects more 
           than one element of the specified type. This is how the 'to-many' portion of a relationship 
           is described.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              It is not possible to use a collection of type 'iterator' or 'enumerate' 
              with lazy loading enabled.
           </p></td></tr></table></div><p>
           <span class="bold"><strong>2. Determine the signature of the method</strong></span>
        </p><div class="itemizedlist"><ul type="disc"><li><p>
	              <span class="bold"><strong>If 'direct' is set to true</strong></span>, 
	              Castor expects to find a public Java object variable with the 
	              given signature:
	           </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; &lt;name&gt;;</pre></li><li><p>
	               <span class="bold"><strong>If 'direct' is set to false or omitted</strong></span>, 
	               Castor will access the property though accessor methods. 
	               Castor determines the signature of the accessors and mutators as follows: 
	               If the 'get-method' or 'set-method' attributes are supplied, it will
		           try to find a function with the following signature:
	           </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; &lt;get-method&gt;();</pre><p>or</p><pre class="programlisting">  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> &lt;set-method&gt;(&lt;type&gt; value);</pre><p>
	           If 'get-method' or 'set-method' attributes are not provided, Castor will try to
	           find the following functions:
	        </p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; is&lt;capitalized-name&gt;();</pre><p>or</p><pre class="programlisting">  <span class="hl-keyword">public</span> &lt;type&gt; get&lt;capitalized-name&gt;();</pre><p>
			   the former for boolean types, the latter for all other types (or if the 
	           'is&lt;capitalized-name&gt;()' method is not defined for a boolean type), and 
	           a standard set method of
	        </p><pre class="programlisting">  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> set&lt;capitalized-name&gt;(&lt;type&gt; value);</pre><p>
		       If there are more than one set&lt;capitalized-name&gt; method it first tries to find the one
	           that exactly matches &lt;type&gt;. If no such method is available and &lt;type&gt; is a java
	           primitive type it tries to find a method with the corresponing java object type.
	        </p><p>
	           &lt;capitalized-name&gt; means that Castor uses the &lt;name&gt; attribute by changing its first
	           letter to uppercase without modifying the other letters.
	        </p><p>
	           The content of the &lt;field&gt; element will contain the information about how to map 
	           this field to the relational table.
	        </p></li></ul></div><p>Description of the attributes: </p><div class="itemizedlist"><ul type="disc"><li><p>
	             <span class="bold"><strong>name:</strong></span> If 'direct' access is used, 
	             'name' should be the name of a public variable in the object we are 
	             mapping (the field must be public, not static and not transient). 
	             If no direct access and no 'get-/set-method' is specified, 
	             this name will be used to infer the name of the accessor and 
	             mutator methods.
             </p></li><li><p>
                 <span class="bold"><strong>type:</strong></span> The Java type of the field. 
                 This is used to access the field. Castor will use this information 
                 to cast the data type(e.g. string into integer). It is also used 
                 to define the signature of the accessor and mutator methods. 
                 If a collection is specified, this is used to specify the type of 
                 the object inside the collection. See description above for more 
	             details.
             </p></li><li><p>
                <span class="bold"><strong>required:</strong></span> If true, the field is not optional.
             </p></li><li><p>
                 <span class="bold"><strong>transient:</strong></span> If true, the field will 
                 be ignored during persistence (and XML un-/marshalling). 
                 If you want this field to be ignored during any persistence-related 
                 operations only, please use the 'transient' attribute at the &lt;sql&gt; 
                 level.
             </p></li><li><p>
              <span class="bold"><strong>identity:</strong></span> If true, the field is part of 
              the class identity. Please use this as an alternative way of specifying 
              the identity of an object.
            </p></li><li><p>
                <span class="bold"><strong>direct:</strong></span> If true, Castor expects a public 
                variable in the object and will modify it directly.
             </p></li><li><p>
                <span class="bold"><strong>collection:</strong></span> If a parent object expects
                more than one occurrence of one of its fields, it is necessary to specify 
                which collection type Castor will use to handle them. The type specified 
                is used to define the type of the content inside the collection.
             </p></li><li><p>
                <span class="bold"><strong>comparator:</strong></span> If the collection type equals 
                'sortedset', it is possible to specify a 
                <code class="classname">java.util.Comparator</code> instance that will be used with 
                the <code class="classname">java.util.SortedSet</code> (implementation) to specify 
                a custom sort order. Please use this attribute to specify the class name 
                of the Comparator instance to be used. Alternatively, it is possible to not 
                specify a Comparator instance and have the Java objects stored in the 
                SortedSet implement <code class="classname">java.util.Comparable</code> 
                to specify the sort order.
            </p></li><li><p>
                 <span class="bold"><strong>get-method:</strong></span> An optional name of the 
                 accessor method Castor should use. If this attribute is not set, 
                 Castor will try to guess the name with the algorithm described above.
             </p></li><li><p>
	             <span class="bold"><strong>set-method:</strong></span> An optional name of the 
	             mutator method Castor should use. If this attribute is not set, 
	             Castor will try to guess the name with the algorithm described above.
             </p></li><li><p>
                <span class="bold"><strong>create-method:</strong></span> Factory method 
                for instantiation of the object.
             </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.mapping.file.sql-element"></a>3.6.3.5.&nbsp;The &lt;sql&gt; element</h4></div></div></div><pre class="programlisting">
  &lt;<span class="hl-tag">!ELEMENT</span> <span class="hl-attribute">sql</span> <span class="hl-attribute">EMPTY&gt;</span>
  <span class="hl-attribute">&lt;!ATTLIST</span> <span class="hl-attribute">sql</span>
            <span class="hl-attribute">name</span>        <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">type</span>        <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">many-key</span>    <span class="hl-attribute">NMTOKENS</span>  <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">many-table</span>  <span class="hl-attribute">NMTOKEN</span>   <span class="hl-attribute">#IMPLIED</span>
            <span class="hl-attribute">transient</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>    <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">read-only</span>   <span class="hl-attribute">(</span> <span class="hl-attribute">true</span> <span class="hl-attribute">|</span> <span class="hl-attribute">false</span> <span class="hl-attribute">)</span>    <span class="hl-attribute">"false"</span>
            <span class="hl-attribute">dirty</span>       <span class="hl-attribute">(</span> <span class="hl-attribute">check</span> <span class="hl-attribute">|</span> <span class="hl-attribute">ignore</span> <span class="hl-attribute">)</span>  <span class="hl-attribute">"check"&gt;</span>
            <span class="hl-attribute">cascading</span>	<span class="hl-attribute">(</span> <span class="hl-attribute">create</span> <span class="hl-attribute">|</span> <span class="hl-attribute">delete</span> <span class="hl-attribute">|</span> <span class="hl-attribute">update</span> <span class="hl-attribute">|</span> <span class="hl-attribute">all</span> <span class="hl-attribute">|</span> <span class="hl-attribute">none</span> <span class="hl-attribute">)</span> <span class="hl-attribute">"none"</span></pre><p>
           The &lt;sql&gt; element is used to denote information about the database 
           column to which a Java object is mapped. It should be declared for all 
           &lt;field&gt; elements. Each &lt;field&gt; element contains one &lt;sql&gt; 
           element. The &lt;sql&gt; element correlates directly to the &lt;map-to&gt; 
           element for the containing &lt;class&gt; element. The &lt;sql&gt; elements 
           contains the following attributes:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                 <span class="bold"><strong>name:</strong></span> The name of the column in the 
                 database table.
              </p></li><li><p>
	              <span class="bold"><strong>type:</strong></span> The JDBC type of the column. 
	              It is inferred from the object when the type of this field is a 
	              persistent Java class that is defined elsewhere in the mapping. 
	              The complete list of automatic type conversions, and which values 
	              require manual mapping (e.g, java.util.Date) is listed in the
	              <a href="jdo.html#jdo.types.type-conversion" title="3.5.4.&nbsp;SQL Type Conversion">SQL Type Conversion 
	              section of the Type Support</a> document.
	          </p></li><li><p>
	              <span class="bold"><strong>read-only:</strong></span> If true, the column in 
	              the relational database table will only be read, not updated or deleted.
	          </p></li><li><p>
	              <span class="bold"><strong>transient (as of 0.9.9):</strong></span> If true, the 
	              field will be ignored during persistence only. If you want this field 
	              to be ignored during XML un-/marshalling as well, please use the 
	              'transient' attribute at the &lt;field&gt; level.
	          </p></li><li><p>
	              <span class="bold"><strong>dirty:</strong></span> If the value is 'ignore', the 
	              field will not be checked against the database for modification.
	          </p></li><li><p>
	               <span class="bold"><strong>cascading:</strong></span> If the field is a relation, 
	               this attribute specifies which operations to cascade. Possible values 
	               are: 'all', none', 'create', 'update' or 'delete'; when not specifying
	               'none' or 'all', it is possibel to specify more than one value, using 
	               whitespace as a delimiter (e.g. 'create update'). For further 
	               information see 
                   <a href="jdo.html#jdo.howto.use-cascading-operations" title="3.9.6.1.&nbsp;How to use cascading operations">HOW-TO</a> 
	               on using cascading operation.
              </p></li></ul></div><p>
           There are two more attributes used <span class="bold"><strong>only</strong></span> 
           with 'to-many' relations.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
		            <span class="bold"><strong>many-key:</strong></span> Specifies the name 
		            of the column that holds the foreign key to this object. 
		            That column is in the database table that stores objects 
		            of the Java type of this field.
	            </p></li><li><p>
		            <span class="bold"><strong>many-table:</strong></span> Specifies the 
		            name of the bridge table that contains the primary keys of 
		            the object on each side of the relationship. This is 
		            <span class="emphasis"><em>only</em></span> used for many-to-many relationships.
	            </p></li></ul></div></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.faq"></a>3.7.&nbsp;Castor JDO FAQ</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.other-specifications"></a>3.7.1.&nbsp;Castor's relation to other specifications</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.other-specifications.sun-jsr-000012"></a>3.7.1.1.&nbsp;Does Castor JDO comply with the SUN JSR-000012 specification?</h4></div></div></div><p>
	            No, Castor JDO doesn't comply with the SUN's JDO specification.
            </p><p>
	            Although Castor JDO carries very similar goals as SUN's JDO, it has 
	            been developed independently from the JSR.
            </p><p>
	            Although it is not impossible to shape (perhaps "hammer" is a more 
	            descriptive verb) Castor JDO into the SUN's JDO specification, there 
	            are several major technical differences which make it unfavorable to 
	            do so. Castor is RDBMS centric. Each persistence object loaded by 
	            Castor is locked. Locks in Castor are observable, meaning that locks 
	            may not be granted because of timeout or deadlock. On the other 
	            hand, the SUN's JDO hides details about locks.
            </p><p>
	            Internally, Castor JDO maintains a single copy of lock (and cache) 
	            for each active persistence object for all transaction. SUN's JDO 
	            specification implicitly requires a copy of cache per object per 
	            transaction. SUN's JDO also implicitly requires a bytecode modifier 
	            which Castor doesn't require.
            </p><p>
	            Castor also provides other features, such as key generators, long 
	            transaction support and OQL query which cannot be found in SUN's JSR.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.other-specifications.ejb-cmp"></a>3.7.1.2.&nbsp;Is Castor JDO better than EJB CMP?</h4></div></div></div><p>
	            The relation between JDO and EJB Container-Managed
	            Persistence is more complicated than simply saying, "one
	            is better than the other".
            </p><p>
	            An Entity Bean may manage persistence itself - the EJB
	            specification calls this Bean Managed Persistence
	            (BMP). Alternatively, the Entity Bean may rely on an EJB
	            container to manage all peersistence automatically - the
	            EJB specification calls this Container Managed Persistence
	            (CMP). When implementing BMP, an Entity Bean may use
	            Castor JDO as its persistence mechanism, or it may use
	            others methods, such as dealing with JDBC directly.
	            During CMP, an EJB Container vendor may implement their
	            CMP on top of Castor JDO.  In such an implementation,
	            Castor JDO will be used to persist the Entity Bean.
            </p><p>
	            If a developer would like to take advantage of an EJB's
	            life-cycle management, security, the "write once deploy
	            anywhere" promise and other distributed business
	            application facilities, then EJB will be the right
	            choice. Otherwise, the fact that Castor is simple, is Open
	            Source (you can always include Castor in your application
	            or product), has much less overhead, provides more design
	            freedom, and is integrated with Castor XML may be enough
	            of a reason to choose Castor JDO.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.xml"></a>3.7.2.&nbsp;XML related questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.xml.marsgalling-transactional"></a>3.7.2.1.&nbsp;Is it possible to make XML marshalling transactionally using Castor?</h4></div></div></div><p>
	            No. The decision of putting XML and JDO together is NOT intended to 
	            make XML marshalling transactional. Instead, the integration is done 
	            to help developers of a typical client-server situation whereby an 
	            application server receives incoming XML messages, process the 
	            messages and replies to the client.
            </p><p>
	            With Castor, incoming XML messages can be unmarshaled into data 
	            objects. Required information can be obtained from a database using 
	            JDO in form of data objects. With this approach, all data 
	            manipulation can be done in an object-oriented way. Changes to JDO 
	            data objects can be committed transactionally, and result data 
	            objects can be marshaled into XML and returned to the client. 
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.xml.xml-file-queries"></a>3.7.2.2.&nbsp;Is it possible to do queries on a XML file using Castor?</h4></div></div></div><p>
	            No, Castor does not provide an OQL query facility on a XML file. If 
	            querying is important for you, you should consider using a DBMS to store 
	            your data instead of using XML files, especially if querying performance 
	            is a concern.
            </p><p>
	            Another alternative is parse an XML Document directly and use XPath to
	            retrieve Nodes and/or NodeSets from an XML Document.  Other open source
	            tools which provide this functionality are:
	            </p><div class="itemizedlist"><ul type="disc"><li><p>
	                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://sourceforge.net/projects/saxpath/" target="_top">SAXPath</a>
	                </p></li><li><p>
	                  <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/jxpath/index.html" target="_top">Jakarta Commons JXPath</a>
	                </p></li></ul></div><p>
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.technical"></a>3.7.3.&nbsp;Technical questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.examples"></a>3.7.3.1.&nbsp;Where can I find some examples to start with?</h4></div></div></div><p>
	            Download the full SVN snapshot and look into the src/tests/jdo 
	            directory.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.sub-jdbc-odbc"></a>3.7.3.2.&nbsp;I have encountered problems using Sun JDBC-ODBC bridge with Castor...</h4></div></div></div><p>
	            It cannot be used with Castor, because it doesn't allow more than one
	            open <code class="literal">ResultSet</code> at the same time. 
	            Either use JDBC driver of type &gt; 1, or use some other JDBC-ODBC 
	            bridge without such a restriction
	            (for example, from <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.easysoft.com" target="_top">Easysoft</a>).
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.collection-get-method"></a>3.7.3.3.&nbsp;
              My get-method for the Collection of dependent objects returns null. 
              Why?
            </h4></div></div></div><p>You should initialize the Collection yourself:
            </p><pre class="programlisting">
<span class="hl-keyword">private</span> Collection _children = <span class="hl-keyword">new</span> ArrayList();

<span class="hl-keyword">public</span> Collection getChildren() {
    <span class="hl-keyword">return</span> _children;
}
            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.implement-interfaces"></a>3.7.3.4.&nbsp;Should my JDO classes implement some special interface?</h4></div></div></div><p>
	            In general, no. If you need some behavior that is not directly 
	            supported by Castor, you can implement interface 
	            <span class="interface">org.exolab.castor.jdo.Persistent</span>. 
	            In order to use dirty checking for long transaction you should 
	            implement interface 
	            <span class="interface">org.exolab.castor.jdo.TimeStampable</span>. 
	            If you need an example of use of these interfaces, see Persistent.java 
	            and TestPersistent.java among Castor JDO tests.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.create-or-remove"></a>3.7.3.5.&nbsp;Can Castor automatically create/remove related objects?</h4></div></div></div><p>
	            First of all, let's agree upon terminology. We distinguish dependent 
	            and independent objects:
	
	            </p><div class="itemizedlist"><ul type="disc"><li><p>
	                     <span class="bold"><strong>dependent</strong></span> objects are bounded 
	                     to the parent object's lifecycle
	                   </p></li><li><p>
	                     <span class="bold"><strong>independent</strong></span> objects have 
	                     independent lifecycle
	                   </p></li></ul></div><p>
	
	            Thus, dependent objects are created/removed automatically, when 
	            their parent object is created/removed, while all operations on 
	            independent objects should be performed explicitly.
            </p><p>
	            However, with Castor 0.8.x you cannot describe explicitly the kind 
	            of object. Instead, the following rule applies: if you have 
	            one-to-many relation, and each side of the relation refers to 
	            another (Collection attribute on "one" side, simple attribute on 
	            "many" side), then "many" side is a dependent object. All other 
	            objects are independent. In particular, related objects via 
	            one-to-one relation are not created/removed automatically.
            </p><p>
	            With Castor 0.9 dependent objects should be described via "depends" 
	            attribute of "class" element in mapping configuration file.
            </p><p>
	            If you wish some independent object was created and/or removed 
	            automatically on operations on other independent object, you may 
	            use interface <span class="interface">Persistent</span> to code the desired 
	            behavior.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.connection-pooling"></a>3.7.3.6.&nbsp;
	            Is Castor JDO using any connection pooling mechanism to improve 
	            the overall performance?
            </h4></div></div></div><p>
	            No, Castor JDO doesn't have any built-in JDBC resource pooling. 
	            However the framework can transparently use any resource pooling 
	            facilities provided through DataSource implementation or 
	            -even better- through JDNI. In fact we even recommend people to use 
	            some Connection and PreparedStatement pool with Castor as this can
	            increase Castor's performance 3-5 fold.
            </p><p>
	            For example the following set of statements:
	            </p><pre class="programlisting">
db.begin();
db.execute(...)
db.commit()
	            </pre><p>
	            will be executed in much less time with the resource pooling because it 
	            will avoid creating a new physical JDBC connection at every execution.
            </p><p>
	            With Oracle, instead of specifying the usual JDBC driver you can use a
	            DataSource that specifically provides some Connection caching/pooling.
            </p><p>
		        Thus if your jdo config file looks like :
		        </p><pre class="programlisting">
        &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span> &gt;
            &lt;<span class="hl-tag">driver</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.driver.OracleDriver"</span>
                    <span class="hl-attribute">URL</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span> &gt;
                &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"user"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"SYSTEM"</span>/&gt;
                &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"manager"</span>/&gt;
            &lt;<span class="hl-tag">/driver</span>&gt;
            ...
        &lt;<span class="hl-tag">/database</span>&gt;
		        </pre><p>
		        then it can be changed into (for example):
		        </p><pre class="programlisting">
        &lt;<span class="hl-tag">database</span> <span class="hl-attribute">name</span>=<span class="hl-value">"..."</span> <span class="hl-attribute">engine</span>=<span class="hl-value">"oracle"</span> &gt;
            &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"oracle.jdbc.pool.OracleConnectionCacheImpl"</span>&gt;
                &lt;<span class="hl-tag">params</span> <span class="hl-attribute">URL</span>=<span class="hl-value">"jdbc:oracle:thin:@localhost:1521:TEST"</span>
                        <span class="hl-attribute">user</span>=<span class="hl-value">"scott"</span> 
                        <span class="hl-attribute">password</span>=<span class="hl-value">"tiger"</span>
                /&gt;
            &lt;<span class="hl-tag">/data-source</span>&gt;
            ...
        &lt;<span class="hl-tag">/database</span>&gt;
		        </pre><p>
	        </p><p>
	            When Castor is used inside a Container such as an EJB container 
	            (within BMP or Session Bean), then the Container usually provides 
	            the JDBC resource through the JNDI ENC, which implicitely includes 
	            pooling facilities.
	        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.classnotfoundexception"></a>3.7.3.7.&nbsp;
               I am getting ClassNotFoundException for my JDO class, 
               but it is in the class path. Why?
            </h4></div></div></div><p>
	            Probably castor.jar file is in jre/lib/ext directory. In this case 
	            you should call:
	            </p><pre class="programlisting">
      jdo.setClassLoader(getClass().getClassLoader());
	            </pre><p>
	           before jdo.getDatabase().
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.notpersistencecapable"></a>3.7.3.8.&nbsp;
              I am getting exception 
              'the class ... is not persistence capable...'. Why?
            </h4></div></div></div><p>
	            In this case as well as in many others you can get more information 
	            with the help of logging. Call:
            </p><pre class="programlisting">
  jdo.setLogWriter(Logger.getSystemLogger());
	        </pre><p>and seek in the output for warnings and errors.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.db-remove"></a>3.7.3.9.&nbsp;
	            I call db.remove() on the dependent object and commit, 
	            but this doesn't work...
            </h4></div></div></div><p>
	            You should not add/remove dependent objects directly. In order to 
	            add/remove the dependent object you should just add/remove it from the 
	            collection in the master object and call db.commit()
            </p><p>
	            Dependent objects cannot be created/removed explicitly. It's created 
	            automatically when it is added to a master object, and removed 
	            automatically when it de-linked/dereferenced from a master object.
            </p><p>
	            Otherwise, we will be encounter into problem where a dependent object 
	            created explicitly but removed implicitly (delinked from a master object), 
	            or vice versa. It can also lead to other problems that are harder to 
	            detect.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.string-date-boolean-literals"></a>3.7.3.10.&nbsp;
	            How should I represent string/date/boolean literals in OQL query?
            </h4></div></div></div><p>
	            It is recommended to replace literals with parameters and to set them 
	            via <code class="methodname">OQLQuery.bind()</code>, for example:
            </p><pre class="programlisting">
OQLQuery query = db.getOQLQuery(
        <span class="hl-string">"SELECT p FROM Person p "</span>
      + <span class="hl-string">"WHERE name LIKE $1 AND dob&gt;$2 AND married=$3"</span>);
query.bind(<span class="hl-string">"John %"</span>);
query.bind((<span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-string">"yyyy-MM-dd"</span>))
       .parse(<span class="hl-string">"1960-01-01"</span>));
query.bind(false);
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.abstractmethoderror"></a>3.7.3.11.&nbsp;
	            I get 'java.lang.AbstractMethodError: getBigDecimal' 
	            for numeric fields. Why?
             </h4></div></div></div><p>
	            Your JDBC driver is not JDBC 2.0 compliant, upgrade it or find another one.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.bi-directional"></a>3.7.3.12.&nbsp;Does Castor support both one-way and two-way relationships?</h4></div></div></div><a name="bi-directional"></a><p>
	            Typcially a relationship between two objects is either one-way 
	            (aka uni-directional) or two-way (aka bi-directional). 
	            Officially, Castor currently only supports bi-directional relationships. 
	            For example, if an <code class="classname">Order</code> object contains a 
	            reference to a <code class="classname">LineItem</code> object, the 
	            <code class="classname">LineItem</code> object must contain a reference to the 
	            Order object. However, this requirement is not enforced in all 
	            situations. 
            </p><p>
	            This is a very complex problem to solve. So until Castor is expanded 
	            the support uni-directional relationships, the best policy is to 
	            implement the bi-directionalality for all relationships. This will 
	            ensure proper functionality.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.self-relation"></a>3.7.3.13.&nbsp;
	            I have an object that holds a relation to itself. 
	            Does Castor support this?
            </h4></div></div></div><p>
	            This is a very common occurrence in an object model and is known as 
	            a self-referenential relationship. Unfortunately, Castor does not 
	            currently support self-referential relationships. An example of such 
	            a relationship occurs when a <code class="literal">Folder</code> object contains
	            a reference to another <code class="literal">Folder</code> object. 
	            Castor does not currently support this. However, there are ways 
	            around this limitation. 
            </p><p>
	            One way is to manage this type of relationship manually. For example, 
	            let's say that a parent object <code class="literal">FolderA</code> needs to hold 
	            references to child objects <code class="literal">FolderB</code>, 
	            <code class="literal">FolderC</code> and <code class="literal">FolderD</code>. 
	            The <code class="literal">Folder</code> object contains not only a property 
	            to hold its own id, but also a property to hold its parent id 
	            (we'll call this <code class="literal">parentId</code>). 
	            The <code class="literal">parentId</code> property is used to determine 
	            if there is a relationship to another <code class="literal">Folder</code> object. 
	            If <code class="literal">parentId</code> is null, there is no relationship. 
	            If <code class="literal">parentId</code> is populated, there is a relationship 
	            and the object tree can be walked by comparing the object id to the 
	            <code class="literal">parentId</code>. When the two properties are equal, 
	            you're at the top of the tree. 
            </p><p>
	            Another say to solve this problem is to make use of an intermediary 
	            object. For example, a <code class="literal">Folder</code> object contains a 
	            <code class="literal">Reference</code> object in lieu of the actual 
	            <code class="literal">Folder</code> object. The <code class="literal">Reference</code> 
	            object is somewhat of a proxy object whereby it only contains enough 
	            information to identify the object to which the 
	            <code class="literal">Reference</code> object refers. Then the 
	            <code class="literal">Folder</code> object can be easily instantiated via the 
	            information contained in the <code class="literal">Reference</code> object. 
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.objectmodifiedexception"></a>3.7.3.14.&nbsp;
	            Why do I get an ObjectModifiedException when trying to commit 
	            a transaction?
            </h4></div></div></div><p>
	            The dirty checking engine will throw an 
	            <code class="literal">ObjectModifiedException</code> when the values in the
	            cache and in the database are different. This can happen when 
	            someone else changed the database content, but also when type 
	            mapping is not reversible.
            </p><p>
	            For example, if a java timestamp (<code class="literal">java.util.Date</code>) 
	            is stored as a DATE, the time part is lost and the dirty checking 
	            will fail. Oracle cannot tell the difference between an empty String
	            and a null value: if an attribute value is an empty String, dirty 
	            checking will also fail. Some precision loss sometimes occur with 
	            floating point numbers.
            </p><p>
	            To avoid this, always use reversible mapping conversions. If this 
	            is not possible, mark the fields with <code class="literal">dirty="ignore"</code> 
	            in the mapping file.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.technical.ora-01461"></a>3.7.3.15.&nbsp;I'm receiving a java.sql.SQLException: ORA-01461</h4></div></div></div><p>
	            When using Weblogic Portal 4.0 with Oracle I am receiving the following 
	            error:
	            </p><pre class="programlisting">
java.sql.SQLException: ORA-01461: can bind a LONG value only for insert into a LONG column
	            </pre><p>
	            According to Weblogic Release Notes, this error can remedied by setting 
	            a Weblogic environment variable. 
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.performance-caches"></a>3.7.4.&nbsp;Castor and performance caches</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.objectmodifiedexception"></a>3.7.4.1.&nbsp;
	            Sometimes long transaction fails: on update() it is thrown 
	            ObjectModifiedException. Why?
            </h4></div></div></div><p>
	            Most probably the object that is being updated has more than 100 related 
	            objects of one class and the cache size for this class is not enough. 
	            You should either increase the size of the cache or change the cache type 
	            to time-limited (the default cache type is count-limited, the default 
	            size is 100), for example:
		        </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">...&gt;</span>
  <span class="hl-attribute">&lt;cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"count-limited"</span> <span class="hl-attribute">capacity</span>=<span class="hl-value">"1000"</span>/&gt;
  ...
&lt;<span class="hl-tag">/class</span>&gt;
		        </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.cache-type-none"></a>3.7.4.2.&nbsp;Can I use the cache-type='none' with long transactions?</h4></div></div></div><p>
	            As of release 0.9.5.3, you cannot. When using a cache of type 'none' 
	            with your 'Timestampable' objects, a MappingException is thrown when 
	            performing long transactions. Currently, Castor requires a (performance) 
	            cache of type other than 'none' to be used with classes  that implement 
	            the <span class="interface">TimeStampable</span> interface. In other words, 
	            if you want to use long transactions, please make sure that you use one 
	            of these cache types: 'unlimited', 'count-limited' or 'time-limited'. 
            </p><p>
	            The next entry has some more information about a potential cause of 
	            confusion in the context of long transactions and a cache type other 
	            than 'unlimited'.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.performance-caches.persistenceexception"></a>3.7.4.3.&nbsp;
	            What is causing a PersistenceException with long transactions and 
	            how do I fix it?
            </h4></div></div></div><p>
	            With long transactions, sometimes update() throws a PersistenceException. 
	            As of release 0.9.5.3, Castor requires a (performance) cache (of type 
	            other than 'none') to be used with classes that implement the 
	            <span class="interface">TimeStampable</span> interface. 
            </p><p>
	            Please note that if you are using a cache type other than 'unlimited', 
	            it is possible that objects expire from the cache. This case will be 
	            highlighted to you by a PersistenceException being thrown.
            </p><p>
	            In this cases, please consider switching to cache type 'unlimited' 
	            (if possible) or increase the size of the cache according to your 
	            needs when using 'count-limited' (which has a default capacity of 100). 
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.oql"></a>3.7.5.&nbsp;OQL</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.document"></a>3.7.5.1.&nbsp;Is there any document available for Castor OQL?</h4></div></div></div><p>
	            Yes. It is available from the Castor website: 
                <a href="advanced-jdo.html#advanced-jdo.oql-to-sql-translator" title="4.2.&nbsp;OQL to SQL translator">Advanced JDO &#8212;&gt; OQL</a>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.phase"></a>3.7.5.2.&nbsp;
	            The OQL document describes several phases of development. 
	            Which is the current phase?
            </h4></div></div></div><p>We are currently working on Phase 3.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.sub-queries"></a>3.7.5.3.&nbsp;Does Castor OQL support sub-queries?</h4></div></div></div><p>Not yet</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.join"></a>3.7.5.4.&nbsp;
	            I cannot get Castor OQL to join two objects for me. Is it supported?
            </h4></div></div></div><p>
	            Yes or no. Castor OQL supports implicit joins. And, in most case, 
	            you simply don't need explicit join.
            </p><p>
	            Consider the following example, 
	            </p><pre class="programlisting">
SELECT o FROM Order o, LineItem i WHERE o.id = i.id AND i.price &gt; 100
	            </pre><p>
            </p><p>
	            It is simply equivalent to the following OQL
	            </p><pre class="programlisting">
SELECT o FROM Order o WHERE o.lineItem.price &gt; 100
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.pass-thru"></a>3.7.5.5.&nbsp;Can I write a pass-thru OQL?</h4></div></div></div><p>
	            Yes. Just put "CALL SQL" keywords in front of your SQL statement. For example,
	            </p><pre class="programlisting">
OQLQuery oql = castorDb.getOQLQuery(
    <span class="hl-string">"CALL SQL SELECT id, name, date "</span>
   +<span class="hl-string">"FROM user WHERE upper(name) like $1 AS myapp.Product"</span>);
	            </pre><p>
            </p><p>
	            <span class="bold"><strong>
	            But remember that the order of the fields listed must match what is 
	            defined in the mapping file.
	            </strong></span>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.struct"></a>3.7.5.6.&nbsp;Does Castor OQL support struct?</h4></div></div></div><p>
	            No, Castor OQL doesn't support struct. For example, the following 
	            query CANNOT be done:
	            </p><pre class="programlisting">
select c.name, c.age from Client c
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.like"></a>3.7.5.7.&nbsp;How do I structure a query using the 'LIKE' expression?</h4></div></div></div><p>
	            A query using the 'LIKE' expression includes the use of the SQL 
	            wildcard '%'. The wildcard must be included in the 
	            <code class="code">bind()</code> statement:
	            </p><pre class="programlisting">
        OQLQuery oql = castorDb.getOQLQuery(
                <span class="hl-string">"SELECT p FROM Product p WHERE p.name LIKE $1"</span> );
        oql.bind( <span class="hl-string">"%widget%"</span> );
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.oql.in"></a>3.7.5.8.&nbsp;Does Castor support the SQL 'IN' expression?</h4></div></div></div><p>
	            Yes. However, the full expression is a bit different using the LIST 
	            keyword. The following example provides a demonstration:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.id IN LIST ( 123, 456, 789 )
	            </pre><p>
            </p><p>
	            If identifiers other than numbers are used, those identifiers must be 
	            quoted:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.name IN LIST ( "abc", "jkl", "xyz" )
	            </pre><p>
            </p><p>
	            To include NULL values in the 'IN' list, use the 'nil' keyword:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.name IN LIST( "ABC", nil )
	            </pre><p>
            </p><p>
	            It is even possible to include bind values in the 'IN' lists 
	            using the following syntax:
	            </p><pre class="programlisting">
SELECT p FROM Product p WHERE p.id IN LIST( $(int)1, $2, $3 )
	            </pre><p>
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.feature-requests"></a>3.7.6.&nbsp;Features requests</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.feature-requests.foreign-key-multiple"></a>3.7.6.1.&nbsp;Can a foreign key be part of multiple primary keys?</h4></div></div></div><p>
	            Unfortunately, the answer is no. We're aware that many users need 
	            this feature so it is a very high priority in our todo list.
            </p><p>
	            If foreign key is the primary key, as a workaround you may consider 
	            using the 'extends' relationship.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.feature-requests.polymorphic-collection"></a>3.7.6.2.&nbsp;Is polymorphic collection supported?</h4></div></div></div><p>Unfortunately, the answer is no.</p><p>
	            In version 0.8.11, we tried to enable polymorphic collection by 
	            introducing the notation of Object Reloading. Object Reloading 
	            delegates the determination of the class to a data object. However, 
	            it is proved that reloading can only be done before any instance of 
	            the target object is returned to user, and we have no way to determine 
	            that. As a result, we removed the support in version 0.9.x.
            </p><p>
	            In the near future, we are going to use a new mechanism to provide 
	            extends. The new mechanism loads a table with an SQL statement that 
	            outer-joins all of the extending tables with the base. The existence 
	            of an extended table row can be used to determine the class of a data 
	            object. Notice that all extended table rows of the same entity should 
	            always be stored in the same data-store.
            </p><p>
	            In the further future, we also want to let users to define a 
	            discriminator column (or determinance field). Basing on the value of 
	            discriminator columns in the base table, the bridge layer fetches the 
	            additional information and returns the combined entity with the 
	            appropriate list of entity classes.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.data-model"></a>3.7.7.&nbsp;Data model issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.map-to-multiple-tables"></a>3.7.7.1.&nbsp;Is it possible to map an object to more than one tables?</h4></div></div></div><p>
	            Yes, if the two tables share the same identity, you can specify one 
	            data object to "extends" the other. When the extended data object is 
	            loaded, its table (specified in &lt;map-to/&gt; will be joined 
	            with all the tables of its super classes'.
            </p><p>
	            Another solution (in my opinion more flexible) is having two set 
	            of methods in the main object. One for Castor JDO and another for 
	            application.
            </p><p>
	            Consider the following example:
	            </p><pre class="programlisting">
<span class="hl-keyword">class</span> Employee {
   <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _employeeNumber;
   <span class="hl-keyword">private</span> Address _address;
   <span class="hl-keyword">private</span> Collection _workGroup;

   <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getEmployeeNumber() {
        <span class="hl-keyword">return</span> _employeeNumber;
   }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setEmployeeNumber( <span class="hl-keyword">int</span> id ) {
        _employeeNumber = id;
   }

   <span class="hl-comment">// methods for Castor JDO</span>
   <span class="hl-keyword">public</span> Address getAddress() {
       <span class="hl-keyword">return</span> _address;
   }
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress( Address address ) {
        _address = address;
   }
   <span class="hl-keyword">public</span> Collection getWorkGroup() {
        <span class="hl-keyword">return</span> _workGroup;
   }
   <span class="hl-keyword">public</span> Collection setWorkGroup( Collection workGroup ) {
        _workGroup = workGroup;
   }

   <span class="hl-comment">// methods for application</span>
   <span class="hl-keyword">public</span> String getAddressCity() {
       <span class="hl-keyword">return</span> _address.getCity();
   }
   <span class="hl-keyword">public</span> String getAddressZip() {
       <span class="hl-keyword">return</span> _address.getZip();
   }
   <span class="hl-comment">// ...</span>
}
	            </pre><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.remove-recreate"></a>3.7.7.2.&nbsp;
	            Can an object with the same identity be re-created after being removed 
	            in the same transaction?
            </h4></div></div></div><p>
	            Yes, as long as the deleted object is the same instance as the one 
	            being recreated.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.dependent-object"></a>3.7.7.3.&nbsp;What is a dependent object?</h4></div></div></div><p>
	            Dependent object is actually a concept from the object-oriented 
	            database world.  A dependent object's lifetime depends on its master 
	            object. So, create/delete/update of the master object will trigger 
	            the proper actions, newly linked dependent object will be 
	            automatically created and de-referenced dependent object will be 
	            removed.
            </p><p>
	            The concept was also used in the earlier CMP 2.0 draft, although 
	            it is later removed.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.data-model.dependent-many-to-many"></a>3.7.7.4.&nbsp;
	            Can a data object involved in many-to-many relationship be dependent?
	        </h4></div></div></div><p>No</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.design"></a>3.7.8.&nbsp;Castor JDO design</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.functionality"></a>3.7.8.1.&nbsp;How does Castor JDO work anyway?</h4></div></div></div><p>Let's use object loading as an example.</p><p>
	            When an application invoke db.load, the underneath 
	            <code class="literal">TransactionContext</code> is invoked. 
	            If the object with the requested identity exists in the 
	            <code class="literal">TransactionContext</code>, previously loaded object in the 
	            <code class="literal">TransactionContext</code> is returned. Otherwise, 
	            <code class="literal">TransactionContext</code> creates a new instance 
	            of the interested type and invokes LockEngine to "fill" the object.
            </p><p>
	            <code class="literal">LockEngine</code> acquires a lock of the object, 
	            and it makes sure <code class="literal">ClassMolder</code> has a thread-safe 
	            environment when it invokes <code class="literal">ClassMolder</code>. 
	            In <code class="literal">ClassMolder</code>, if the interested set of fields 
	            representing the object is not existed in the cache yet, 
	            <code class="literal">SQLEngine</code> will be invoked and the set of fields 
	            from the underneath data store will be returned. 
	            <code class="literal">ClassMolder</code> binds the loaded or cached fields into 
	            the new instance. <code class="literal">ClassMolder</code> requests the 
	            <code class="literal">TransactionContext</code> to load the related and the 
	            dependent objects. Eventually, the object is returned after all of 
	            the relationships are resolved.
            </p><p>
	            The process of commit has several states. The first state is 
	            preStore. In preStore state, objects existing in the 
	            <code class="literal">TransactionContext</code> are checked for modification 
	            one by one, including dependent and related objects. 
	            De-referenced dependent objects are marked as delete-able, 
	            and reachable dependent objects are added into 
	            <code class="literal">TransactionContext</code>. An object is marked 
	            "dirty" if it is modified. Also, if any modification should cause 
	            any related or dependent to be dirty, the related or dependent object 
	            is marked as dirty as well.
            </p><p>
	            After the preStore state, all dirty object is properly stored. And, 
	            all marked delete object will be removed. Then, the connection is 
	            committed. If succeed, all cache with be updated. Finally, all lock 
	            is released.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.two-phase-commits"></a>3.7.8.2.&nbsp;
	            Does Castor support two-phase commits? How is this implemented?
	        </h4></div></div></div><p>
	            Yes, via <span class="interface">javax.transaction.Synchronization</span> interface.
            </p><p>
	            For Castor to work with global transactions, Castor must be configured
	            to use global transaction demarcation in its main configuration file:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">jdo-conf</span>&gt;
   ...
   &lt;<span class="hl-tag">transaction-demarcation</span> <span class="hl-attribute">mode</span>=<span class="hl-value">"global"</span> &gt;
      &lt;<span class="hl-tag">transaction-manager</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndi"</span> /&gt;
   &lt;<span class="hl-tag">/transaction-demarcation</span>&gt;
&lt;<span class="hl-tag">/jdo-conf</span>&gt;
            </pre><p>When retrieving a Database instance via</p><pre class="programlisting">
...
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdo = JDOManager.createInstance(<span class="hl-string">"mydb"</span>);
...
Database db = jdo.getDatabase();
            </pre><p>
	            the <code class="literal">Database</code> implementation will authomatically 
	            be registered with the transaction manager, as it implements 
	            <span class="interface">javax.jta.Synchronization</span> interface. 
	            Subsequently, the transaction manager communicates with Castor 
	            via the beforeCompletion() and afterCompletion() calls.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.design.nested-transaction"></a>3.7.8.3.&nbsp;Does Castor support nested transaction?</h4></div></div></div><p>No</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.open-source-databases"></a>3.7.9.&nbsp;Working with open source databases</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.postgresql"></a>3.7.9.1.&nbsp;Does Castor support PosgreSQL?</h4></div></div></div><p>
	            Yes, starting from PostgreSQL 7.1, where outer joins support has 
	            been added.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.mysql"></a>3.7.9.2.&nbsp;Does Castor support MySQL?</h4></div></div></div><p>
	            Yes, starting from MySQL version 3.23, where transaction support has 
	            been added. Note: if you use Mark Matthews MySQL JDBC driver, then 
	            you need version 2.0.3 or higher.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.open-source-databases.which"></a>3.7.9.3.&nbsp;Which Open Source database is supported better?</h4></div></div></div><p>
	            For now only with 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.postgresql.org" target="_top">PostgreSQL 7.1</a> 
	            and <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.sapdb.org" target="_top">SAP DB</a> you get a full 
	            set of Castor features. Other Open Source databases don't support 
	            select with write lock, so db-locked locking mode doesn't work 
	            properly (it works in the same way as exclusive locking mode).
            </p><p>
	            All other Castor features are supported with 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mysql.com" target="_top">MySQL</a>, 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.interbase2000.org" target="_top">Interbase</a>, 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://instantdb.enhydra.org" target="_top">InstantDB</a> and 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hypersonicsql.com" target="_top">Hypersonic SQL</a>.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.rdbms-specific"></a>3.7.10.&nbsp;RDBMS-specific issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.rdbms-specific.mysql"></a>3.7.10.1.&nbsp;MySQL</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.datetime"></a>3.7.10.1.1.&nbsp;Use of DATETIME fields in general</h5></div></div></div><p>
    			   MySQL in it's current releases (4.0.x and 4.1.x) does not store fractions of a 
    			   second in fields of type DATETIME that are mapped to java.sql.TimeStamp fields.
    			   As a result, Castor will throw ObjectModifiedExceptions during commits as Castor 
    			   internally maintains fractions of a seconds. 
    			</p><p>
    			   Instead, Please use a column type that can be mapped to a long value, as Castor 
                   internally handles conversion between java.util.Date and long values with 
                   the required precision.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.timestamp-null"></a>3.7.10.1.2.&nbsp;Use of TIMESTAMP fields &amp; NULLs in long transactions</h5></div></div></div><p>
    			   In MySQL, fields of type 'Timestamp' exhibit special behaviour wih 
    			   regards to NULLs. When inserting a "NULL" into such a field, it 
    			   actually inserts the current date and time. This causes problems 
    			   for Castor's caching mechanism since Castor internally believes the 
    			   field is still NULL. If you subsequently perform an update on the 
    			   entry whilst it is still in the cache, an ObjectModifiedException 
    			   will be thrown, because Castor believes that the database record 
    			   has changed in the meantime.
    			</p><p>The workaround is to use a DATETIME field instead of TIMESTAMP.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.mysql.upgrade-issues"></a>3.7.10.1.3.&nbsp;MySQL 4.1.x and upgrade issues</h5></div></div></div><p>
 				   As with many other open source products, MySQL seems to be changing 
 				   slightly from version to version. There seems to be a problem with 
 				   concurrency in MySQL 4.1.5 that can be resolved by upgrading to 
 				   4.1.7 or higher.
				</p><p>
				   At Castor we frequently use Connector/J 3.0.16, 3.1.13 and nowadays 5.1.6 to
				   execute our test farmework. If you use one of this versions of Connector/J 
				   you should be on the safe side. If you are hit by any problems using one of 
				   these versions, please let us know.
				</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.rdbms-specific.oracle"></a>3.7.10.2.&nbsp;Oracle</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.faq.rdbms-specific.oracle.clob-blob-lob-fields"></a>3.7.10.2.1.&nbsp;Oracle &amp; (C|B)LOB fields</h5></div></div></div><p>
    			   As of Oracle release 10g, the problem of Castor to handle BLOBs 
    			   with a size greater than 2kB and CLOBs with a size greater than 
    			   4 kB correctly has been resolved. With the 10 release of Oracle's 
    			   JDBC driver, both driver types (type 2 and type 4) can be used. 
    			   With earlier releases, only the OCI driver (type 2) seems to work.
    			</p><p>
    			   The 10g release of the Oracle JDBC Driver can be downloaded
    			   <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/index.html" target="_top">here</a>.
    			</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.logging"></a>3.7.11.&nbsp;Castor &amp; Logging</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.log4j"></a>3.7.11.1.&nbsp;
	            How can I integrate Castor's logging with a logging infrastructure 
	            using Log4J?
	        </h4></div></div></div><p>
	            Please see 
	            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mail-archive.com/castor-dev@exolab.org/msg02710.html" target="_top">
	            this message</a> from the mailing list. It includes an adapter class 
	            that will provide this functionality. (Thanks John!)
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.sql-statement"></a>3.7.11.2.&nbsp;
			    Can I see what SQL statement Castor issues to the database as a result 
			    of an operation?
			</h4></div></div></div><p>
			   Yes, you can. By default, Castor uses JDBC proxy classes (wrapping
			   <code class="literal">java.sql.Connection</code> and 
			   <code class="literal">java.sql.PreparedStatement</code>) that capture the 
			   core SQL statements as generated by Castor and the user-supplied 
			   parameters at execution timeof the various persistence operations, 
			   and outputs them to the standard logger used by Castor. 
			   By default, these output statements are not visible, 
			   as the log level is set to level 'info'. To see these SQL statements, 
			   please increase the log level to level 'debug' in 
			   <code class="literal">log4j.xml</code>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.logging.disable-jdbc-proxy-classes"></a>3.7.11.3.&nbsp;How can I disable the use of JDBC proxy classes?</h4></div></div></div><p>
			   As of <span class="bold"><strong>release 0.9.7</strong></span>, a new property
			   </p><pre class="programlisting">org.exolab.castor.persist.useProxies</pre><p>
			   has been added to <code class="literal">castor.properties</code> to allow 
			   configuration of the JDBC proxy classes mentioned above. 
			   If enabled, JDBC proxy classes will be used for logging SQL statements. 
			   When turned off, no logging statements will be generated at all.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.lazy-loading"></a>3.7.12.&nbsp;Lazy Loading related questions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-1"></a>3.7.12.1.&nbsp;
	           How do I configure the JDO mapping to use the lazy loading feature 
	           for 1:1 relations?
           </h4></div></div></div><p>
              Let us convert one of the classes from the 
              
              <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top">JDO examples</a> to use 
              lazy-loading.
           </p><p>
              In the example model, every Product belongs to one ProductGroup. 
              This is reflected in the conventional mapping as below. 
              Here's the mapping for Product:
           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product  --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">description</span>&gt;Product definition&lt;<span class="hl-tag">/description</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"product"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
 
   &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;

    &lt;<span class="hl-comment">!--  Product has reference to ProductGroup,
          many products may reference same group  --</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
      &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    
&lt;<span class="hl-tag">/class</span>&gt;
</pre><p>
              Let us now make the relationship between Product and ProductGroup use 
              lazy loading. The relevant field in Product can be re-written like so:
           </p><pre class="programlisting">
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
      &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
           </pre><p>
              There have been one change only. We have placed the attribute lazy="true" in 
              the field element. Note that no change is required in the ProductDetail 
              mapping.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-1-serialization"></a>3.7.12.2.&nbsp;Lazy loading for 1:1 relations and serialization</h4></div></div></div><p>
       	      Please note that Castor does not support full serialization of lazy-loaded 
       	      objects at this time. Rather than serializing just the information 
       	      required to re-build the underlying proxy implementation during 
       	      deserialization, Castor will materialize (read: load from the persistence 
       	      store) all objects before serialization. As this can lead to a lot of 
       	      database accesses, please use this feature carefully. A full working 
       	      solution will be provided with the next release.
       	   </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.1-to-m-m-to-n"></a>3.7.12.3.&nbsp;
	           How do I configure the JDO mapping to use the lazy loading feature for 
	           1:m and M:N relations?
	       </h4></div></div></div><p>
	           Let us convert one of the classes from the 
	           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top"> JDO examples</a> 
	           to use lazy-loading.
           </p><p>
	           In the example model, one Product can contain many ProductDetails. 
	           This is reflected in the conventional mapping as below. 
	           First, the mapping for Product:
	           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product  --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span>
       <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">description</span>&gt;Product definition&lt;<span class="hl-tag">/description</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"product"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
 
   &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;

   &lt;<span class="hl-comment">!-- Product has reference to ProductDetail
            many details per product  --</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span>
           <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detail"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
	            </pre><p>
           </p><p>
	           Now let us examine ProductDetail. Note, the relationship is mapped 
	           <a href="jdo.html#jdo.faq.technical.bi-directional" title="3.7.3.12.&nbsp;Does Castor support both one-way and two-way relationships?">bi-directionally</a> as must be 
	           all relationships when using Castor JDO.
	           </p><pre class="programlisting">
&lt;<span class="hl-comment">!--  Mapping for Product Detail --</span>&gt;
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"myapp.Product"</span> &gt;
   &lt;<span class="hl-tag">description</span>&gt;Product detail&lt;<span class="hl-tag">/description</span>&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_detail"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"detail"</span> /&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span>&gt;
       &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> /&gt;
       &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
   
       &lt;<span class="hl-comment">!-- more fields ... --</span>&gt;
   
&lt;<span class="hl-tag">/class</span>&gt;
	           
	           </pre><p>
           </p><p>
	           Let us now make the relationship between Product and ProductDetail use 
	           lazy loading. We need only change the way that the relationship to 
	           ProductDetail is specified in the mapping of Product. The relevant 
	           field in Product can be re-written like so: 
	           </p><pre class="programlisting">
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">required</span>=<span class="hl-value">"true"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>
            <span class="hl-attribute">collection</span>=<span class="hl-value">"collection"</span>&gt;
   &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
   &lt;<span class="hl-tag">xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"detail"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
           
           </pre><p>
           </p><p>
	           There have been two changes.
	           </p><div class="itemizedlist"><ul type="disc"><li><p>
		               We have placed the attribute lazy="true" in the field element
		             </p></li><li><p>
		               We have changed the type of the underlying collection type to be 
		               a <code class="literal">java.util.Collection</code> by changing the field 
		               element attribute to collection="collection".
		             </p></li></ul></div><p>   
           </p><p> 
           Note that no change is required in the ProductDetail mapping.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.lazy-loading.no-method-error"></a>3.7.12.4.&nbsp;
               I have modified my mapping to use lazy loading. Now I get the error 
               'no method to set value for field: com.xyz.ClassB in class: 
               ClassMolder com.xyz.ClassA' or 
               'org.exolab.castor.jdo.DataObjectAccessException: no method to set 
               value for field: com.xyz.ClassB in class: ClassMolder com.xyz.ClassA'. 
               What am I doing wrong?
           </h4></div></div></div><p>
	           To use lazy loading you must also change the persistent class that 
	           will hold the related objects. At the very highest level, you need 
	           to provide a set method that accepts a java.util.Collection for the 
	           field in question. This is demonstrated by changing the 
	           
	           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/examples.html" target="_top">JDO examples</a> below.
           </p><p>
	           In the original Product class we have the following code:
	           </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Vector;
...
<span class="hl-keyword">private</span> Vector _details = <span class="hl-keyword">new</span> Vector();
...
<span class="hl-keyword">public</span> Vector getDetails()
{
   <span class="hl-keyword">return</span> _details;
}


<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> addDetail( ProductDetail detail )
{
   _details.add( detail );
   detail.setProduct( <span class="hl-keyword">this</span> );
}
	           </pre><p>
           </p><p>
	           Let us now make the necessary changes to set up lazy loading. 
	           As stated above we now require a special set method for the related 
	           ProductDetails (stored originally as a 
	           <code class="literal">java.util.Vector</code>) that accepts a 
	           <code class="literal">java.util.Collection</code> as an argument. This mandates 
	           that we must also use a <code class="literal">java.util.Collection</code> to 
	           hold our ProductDetails. If this is not added, you will receive the 
	           errors above.
	           </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Collection;
...
<span class="hl-keyword">private</span> Collection _details;
...
<span class="hl-keyword">public</span> Collection getDetails()
{
   <span class="hl-keyword">return</span> _details;
}


<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDetails( Collection details )
{
   _details = details;
}

	           </pre><p>
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.lob-tuning"></a>3.7.13.&nbsp;Tuning for LOBs</h3></div></div></div><p>
	        Castor JDO provides a property in <code class="literal">castor.properties</code> 
	        for adjusting the size of the JDBC driver's buffer for reading LOBs 
	        (BLOBs and CLOBs) from the database. The propery is named 
	        <code class="literal">org.exolab.castor.jdo.lobBufferSize</code> and its default 
	        is 5120 bytes (5k). The size of this buffer can be tuned for larger LOBs, 
	        but is dependent upon the JDBC driver implementation being used and what 
	        it supports. 
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.database-specific"></a>3.7.14.&nbsp;Database-specific issues</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.faq.database-specific.hsql-identity-key-generators"></a>3.7.14.1.&nbsp;HSQL and identity key generators</h4></div></div></div><p>
               Due to a product limitation, AUTO_INCREMENT sequences in HSQL begin 
               with 0 rather 1, as is the case with most other RDBMS. As a result 
               of this, long transactions will not work for the object with the 
               identity 0, and a ObjectModifiedException will be thrown.
            </p><p>
               To avoid this issue, we recommend inserting a temp object into the 
               database in question, and removing thereafter so that no object with 
               identity 0 is stored.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.faq.change-configurations"></a>3.7.15.&nbsp;Changing database configurations</h3></div></div></div><p>
           Some applications need to change the database connection or switch 
           between different mapping files on the fly. Because Castor caches 
           database configurations per name, you would have to register a new 
           JDO configuration using a distinct name for any of the different 
           configurations.
        </p><p>
		   Instead you can call 
		   <code class="methodname">org.exolab.castor.jdo.engine.DatabaseRegistry.clear()</code>
		   to reset the database registry before registering the new configuration as 
		   follows:
		</p><pre class="programlisting">
<span class="hl-comment">// Reset database registry</span>
org.exolab.castor.jdo.engine.DatabaseRegistry.clear();
		</pre></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.code-samples"></a>3.8.&nbsp;Castor JDO code samples</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.code-samples.introduction"></a>3.8.1.&nbsp;Introduction</h3></div></div></div><p>
         This document provides object mapping examples and the corresponding
         Java objects and DDL for the database table.
       </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.java-class-files"></a>3.8.1.1.&nbsp;Java class files</h4></div></div></div><p>
            The following fragment shows the Java class declaration for the
            <code class="classname">Product</code> class:
          </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price;

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}</pre><p>
        The following fragment shows the Java class declaration for the
        <code class="classname">ProductGroup</code> class:
      </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.ddl"></a>3.8.1.2.&nbsp;DDL</h4></div></div></div><p>
            The following sections show the DDL for the relational database
            tables <span class="database">PROD</span>, 
            <span class="database">PROD_GROUP</span>, 
            and <span class="database">PROD_DETAIL</span>:
          </p><p>
            <span class="bold"><strong><code class="literal">PROD</code></strong></span>:
          </p><pre class="programlisting">
create table prod (
  id        int           not null,
  name      varchar(200)  not null,
  price     numeric(18,2) not null,
  group_id  int           not null
);</pre><p>
            <span class="bold"><strong><code class="literal">PROD_GROUP</code></strong></span>:
          </p><pre class="programlisting">
create table prod_group (
  id        int           not null,
  name      varchar(200)  not null
);</pre><p>
            <span class="bold"><strong><code class="literal">PROD_DETAIL</code></strong></span>:
          </p><pre class="programlisting">
create table prod_detail (
  id        int           not null,
  prod_id   int           not null,
  name      varchar(200)  not null
);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.introduction.object-mappings"></a>3.8.1.3.&nbsp;Object Mappings</h4></div></div></div><p>
          The following code fragment shows the object mapping for the
          <code class="classname">ProductGroup</code> class:
        </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">!DOCTYPE</span> <span class="hl-attribute">mapping</span> <span class="hl-attribute">PUBLIC</span> <span class="hl-attribute">"-//EXOLAB/Castor</span> <span class="hl-attribute">Object</span> <span class="hl-attribute">Mapping</span> <span class="hl-attribute">DTD</span> <span class="hl-attribute">Version</span> <span class="hl-attribute">1.0//EN"</span>
                         <span class="hl-attribute">"http://castor.org/mapping.dtd"&gt;</span>
<span class="hl-attribute">&lt;mapping&gt;</span>

  <span class="hl-attribute">&lt;class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    &lt;<span class="hl-tag">description</span>&gt;Product group&lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_group"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"group"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> &gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
         As a result of that declaration, Castor JDO will create the following
         SQL statements for creating, deleting, loading and updating instances
         of <code class="classname">ProductGroup</code>:
       </p><pre class="programlisting">
create: INSERT INTO prod_group (id, name) VALUES (?,?)
delete: DELETE FROM prod_group WHERE id=?
load:   SELECT prod_group.id, prod_group.name FROM prod_group WHERE prod_group.id=?;
update: UPDATE prod_group SET name=? WHERE id=?
       </pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.introduction.read-only-fields"></a>3.8.1.3.1.&nbsp;Read-only fields</h5></div></div></div><p>
            To declare the <span class="database">name</span> field 
            <span class="bold"><strong>read-only</strong></span>, the field definition 
            above for the field <span class="database">name</span> needs 
            to be changed to:
          </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    ...
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">"true"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
            As a result of that declaration, Castor JDO creates the following
            SQL statements for creating, deleting, loading and updating
            instances of <code class="classname">ProductGroup</code>:
          </p><pre class="programlisting">
create: INSERT INTO prod_group (id) VALUES (?)
delete: DELETE FROM prod_group WHERE id=?
load:   SELECT prod_group.id, prod_group.name FROM prod_group WHERE prod_group.id=?;
update: /* no statement will be generated */
          </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.transient-fields"></a>3.8.1.3.2.&nbsp;Transient fields</h5></div></div></div><p>
            To declare the <span class="database">name</span> field 
            <span class="bold"><strong>transient</strong></span> with regards to
            persistence, above field definition for the field 
            <span class="database">name</span> needs to be changed to:
          </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductGroup"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    ...
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> &gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> <span class="hl-attribute">transient</span>=<span class="hl-value">"true"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.relations"></a>3.8.1.4.&nbsp;Relations</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.1-to-1"></a>3.8.1.4.1.&nbsp;1:1 relation</h5></div></div></div><p>
            The following code fragment shows the mapping file for the Product
            class.  Apart from the simple field declarations, this includes a
            simple 1:1 relation between <code class="literal">Product</code> and
            <code class="literal">ProductGroup</code>, where every product instance 
            is associated with a <code class="literal">ProductGroup</code>:
          </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span>
               <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.1-to-m"></a>3.8.1.4.2.&nbsp;1:M relation</h5></div></div></div><p>
               The following code fragment shows (again) the mapping file for
               the <code class="classname">Product</code> class. The field definition highlighted
               shows how to declare a 1:M relation between <code class="literal">Product</code> 
               and <code class="literal">ProductDetail</code>, where every product instance is 
               made up of many <code class="literal">ProductDetails</code>:
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
               The following code fragment shows the corresponding mapping
               entry for the <code class="classname">ProductDetail</code> class that defines the
               second leg of the 1:M relation between <code class="literal">Product</code> and
               <code class="literal">ProductDetail</code>.
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"myapp.Product"</span> &gt;

    &lt;<span class="hl-tag">description</span>&gt;Product detail&lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod_detail"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"detail"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"product"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.code-samples.relations.m-to-n"></a>3.8.1.4.3.&nbsp;M:N relation</h5></div></div></div><p>
               The following code fragment shows (again) the mapping file for
               the <code class="classname">Product</code> class.  The field definition highlighted
               shows how to declare a M:N relation between <code class="literal">Product</code> 
               and <code class="literal">ProductCategory</code>, where many products can be 
               mapped to many product categories:
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"prod"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"float"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"price"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductGroup"</span> &gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"group_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"details"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.ProductDetail"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span>&gt;/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"categories"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"category_id"</span>
                <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"prod_id"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
               The following code fragment shows the corresponding mapping
               entry for the <code class="classname">ProductCategory</code> class that defines the
               second leg of the M:N relation between <code class="literal">Product</code> and
               <code class="literal">Category</code>.
             </p><pre class="programlisting">
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Category"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

    &lt;<span class="hl-tag">description</span>&gt;
        A product category, any number of products can belong to
        the same category, a product can belong to any number of
        categories.
    &lt;<span class="hl-tag">/description</span>&gt;

    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"category"</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"category"</span> /&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"vector"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"prod_id"</span>
           <span class="hl-attribute">many-table</span>=<span class="hl-value">"category_prod"</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"category_id"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;

  &lt;<span class="hl-tag">/class</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.extend-relation-polymorphism"></a>3.8.1.5.&nbsp;Extend relation &amp; polymorphism</h4></div></div></div><p>
           As of release 0.9.9, Castor supports polymorphic queries on extend
           hierarchies.  (That is, hierarchies where some entities "extend"
           other entities.)  To highlight this new feature, let's add two new
           classes to what we have currently.
         </p><pre class="programlisting">
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Computer <span class="hl-keyword">extends</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _make;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getmake() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMake( String aMake ) { ... }

}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Car <span class="hl-keyword">extends</span> Product {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> Date    _registeredIn;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> Date getRegisteredIn() { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setRegisteredIn( Date aRegisteredIn ) { ... }
}</pre><p>
            The corresponding DDL statements for the relational database tables
            <span class="database">COMP</span> and 
            <span class="database">CAR</span> would look as follows:
          </p><p><span class="bold"><strong><code class="literal">COMP</code></strong></span>:</p><pre class="programlisting">
create table comp (
  id        int           not null,
  make      varchar(200)  not null
);</pre><p><span class="bold"><strong><code class="literal">CAR</code></strong></span>:</p><pre class="programlisting">
create table car (
  id        int           not null,
  regIn     int           not null
);</pre><p>
               Based upon the mapping defined for the <code class="classname">Product</code> 
               class as shown above, the following code fragment shows the mapping 
               for the <code class="literal">Computer</code> and <code class="literal">Car</code> classes.
             </p><pre class="programlisting">
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Computer"</span> <span class="hl-attribute">extends</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"COMP"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"make"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"make"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;

    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myapp.Car"</span> <span class="hl-attribute">extends</span>=<span class="hl-value">"myapp.Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;

        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"CAR"</span> /&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"registeredIn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"date"</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"regIn"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span> /&gt;
        &lt;<span class="hl-tag">/field</span>&gt;

    &lt;<span class="hl-tag">/class</span>&gt;</pre><p>
          Based upon this mapping, it is possible to execute the following OQL
          queries against this class model:
        </p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT c FROM myapp.Computer c"</span>);
        </pre><p>To return all computers:</p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT c FROM myapp.Computer c WHERE c.make = $"</span>);
        </pre><p>To return all computers of a particular make:</p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT p FROM myapp.Product p"</span>);
        </pre><p>
          To return all products (where Castor will return the actual object
          instances, i.e. a <code class="literal">Computer</code> instance if the object 
          returned by the query is of type <code class="literal">Computer</code> or a 
          <code class="literal">Car</code> instance if the object returned by the query is 
          of type <code class="literal">Car</code>):
        </p><pre class="programlisting">
OQLQuery query = d.getOQLQuery(<span class="hl-string">"SELECT p FROM myapp.Product p WHERE p.group.name = $"</span>);
        </pre><p>
          To return all products that belong to the specified product group
          (where Castor will return the actual object instances, i.e. a
          <code class="literal">Computer</code> instance if the object returned by the query 
          is of type <code class="literal">Computer</code> or a <code class="literal">Car</code> instance 
          if the object returned by the query is of type <code class="literal">Car</code>):
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.code-samples.oql-samples"></a>3.8.1.6.&nbsp;OQL samples</h4></div></div></div><p>
          Based upon above definitions, here are a few OQL sample queries that
          highlight various artifacts of the OQL support of Castor JDO.
        </p><p>
          <span class="bold"><strong><span class="italic">To Be Written</span></strong></span>
        </p></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.howto"></a>3.9.&nbsp;Castor JDO - How To's</h2></div></div></div>

      

      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.introduction"></a>3.9.1.&nbsp;Introduction</h3></div></div></div>
	      
	
	      <p>
	          This is a collection of HOW-TOs. The Castor project is actively seeking 
	          additional HOW-TO contributors to expand this collection. For information 
	          on how to do that, please see 'How to author a HOW-TO'.
	      </p>
      </div>
	
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.documentation"></a>3.9.2.&nbsp;Documentation</h3></div></div></div>
	      
		
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5642"></a>3.9.2.1.&nbsp;How to author a HOW-TO document</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5644"></a>3.9.2.2.&nbsp;How to author an FAQ entry</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5646"></a>3.9.2.3.&nbsp;How to author a code snippet</h4></div></div></div></div>
		        
		  <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e5648"></a>3.9.2.4.&nbsp;How to author core documentation</h4></div></div></div></div>
	  </div>
		
		
	  <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.contribution"></a>3.9.3.&nbsp;Contribution</h3></div></div></div>
	      
	      
	      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.setup-eclipse-castor-project"></a>3.9.3.1.&nbsp;How to setup Castor project in eclipse</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.introduction"></a>3.9.3.1.1.&nbsp;Introduction</h5></div></div></div><p>
        Are you just interested in how Castor source looks like, want to report a bug 
        or enhancement request or like to contribute to the project? The first step we 
        suggest you to do is to setup a Castor project with eclipse IDE. As we use 
        eclipse to work at Castor, there is everything in place to work with eclipse. 
        While you are free to use other IDE's, you will need to configure things 
        yourself with them.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.prerequisites"></a>3.9.3.1.2.&nbsp;Prerequisites</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            Download and install 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/javase/downloads/index.jsp" target="_top">JDK 1.5
            or newer</a>
          </p></li><li><p>
            Download and install 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.eclipse.org/downloads/index.php" target="_top">Eclipse 
            3.x</a>
          </p></li><li><p>
            Install the latest 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subclipse.tigris.org/download.html" target="_top">Subclipse 
            eclipse plugin</a>
          </p></li><li><p>
            Optionally install the latest 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://eclipse-cs.sourceforge.net/" target="_top">CheckStyle eclipse 
            plugin</a>
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.create-project"></a>3.9.3.1.3.&nbsp;Create Project</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            Create a New Project in eclipse from 
            <code class="literal">File -&gt; New -&gt; Projects</code>
          </p></li><li><p>
            Select <code class="literal">"Checkout Projects from SVN"</code>
            in <code class="literal">"SVN"</code> from 
            <code class="literal">"Select a wizard"</code> window 
            and click <code class="literal">Next</code> 
            (this option will only come if you have installed the subclipse plugin)
          </p></li><li><p>
            Select <code class="literal">"Create a new repository location"</code>
            and click <code class="literal">Next</code>
          </p></li><li><p>
            Enter the URL 
            <code class="literal">"https://svn.codehaus.org/castor/castor"</code>
            and click <code class="literal">Next</code>
          </p></li><li><p>
            Select the folder <code class="literal">"trunk"</code> 
            from the list and click <code class="literal">Next</code>
          </p></li><li><p>
            In <code class="literal">"Check Out As"</code> 
            window the name of the project will be 
            <code class="literal">"castor"</code> then click 
            <code class="literal">Next</code>
          </p></li><li><p>
            At last, you can choose the workspace and click 
            <code class="literal">Finish</code>
          </p></li><li><p>
            You can see castor project in your 
            <code class="literal">"Project Navigator" of eclipse</code>
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.setup-eclipse-castor-project.troubleshooting"></a>3.9.3.1.4.&nbsp;Troubleshooting</h5></div></div></div><p>
        <span class="bold"><strong>If you have trouble with Subclipse behind a proxy 
        server:</strong></span> In Windows development environment, open the file: 
        <code class="filename">C:\Documents and 
        Settings\MyUserId\Application Data\Subversion\servers</code> 
        in text editor. Near the bottom of that file is a [global] section with 
        http-proxy-host and http-proxy-port (user and password also) settings. 
        Uncommented those lines, modified them for your proxy server and go back 
        to the SVN Repository view in Eclipse. This should solve the problem.
      </p></div></div>
	      
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.jdo-unit-tests"></a>3.9.3.2.&nbsp;How to run Castor JDO's database independend unit tests</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.overview"></a>3.9.3.2.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite that is used to test various functional areas 
            against different database engines to give developers/committers some 
            reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite to evaluate impact of changes on performance.
          </p></li></ul></div><p>
        This document provides general information about running Castor JDO's database 
        independend unit tests.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.prerequisites"></a>3.9.3.2.2.&nbsp;Prerequisites</h5></div></div></div><p>
        See: <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
        project in eclipse</a>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.execute-in-eclipse"></a>3.9.3.2.3.&nbsp;Execute tests in eclipse</h5></div></div></div><p>
        To execute tests in eclipse, go and right click on 
        <code class="filename">cpa/src/test/java</code> source folder and select 
        <code class="literal">"Run As -&gt; JUnit Test"</code>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-unit-tests.references"></a>3.9.3.2.4.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.jdo-test-suite"></a>3.9.3.3.&nbsp;How to run Castor JDO's test suite</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.overview"></a>3.9.3.3.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite (CTF) that is used to test various functional 
            areas against different database engines to give developers/committers 
            some reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite (PTF) to evaluate impact of changes on performance.
          </p></li></ul></div><p>
        This document provides general information about running Castor JDO's test 
        suite (CTF).
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.intended-audience"></a>3.9.3.3.2.&nbsp;Intended Audience</h5></div></div></div><p>
        Anyone who wants to run the CTF test suite. This document outlines 
        the basic steps to get people unfamiliar with this area started.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.prerequisites"></a>3.9.3.3.3.&nbsp;Prerequisites</h5></div></div></div><p>
        Anybody wishing to run the CTF test suite should have access to the 
        source code of Castor. This can be obtained in one of the following ways:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Download the sources distribution from the 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/download.html" target="_top">download page</a>
          </p></li><li><p>
            Download the latest snapshot from SVN from
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://svn.castor.codehaus.org/viewrep/castor/castor/trunk" target="_top">Fisheye</a>
            (see links on the bottom left corner)
          </p></li><li><p>
            Check out the latest code from SVN into your prefered developement environment. 
            For instructions on this task, take a look at 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/scm.html#Subversion-access" target="_top">Subversion 
            access</a>. For eclipse
            <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How 
            to setup Castor project in eclipse</a> provides a detailed description 
            of this task.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.2-versions-of-ctf"></a>3.9.3.3.4.&nbsp;2 versions of CTF</h5></div></div></div><p>
        At the moment we are in the middle of replacing the old CTF with a new one. 
        While the old CTF still is our reference for refactorings of Castor does the 
        new CTF contain some tests which could not be added to the old one due to its 
        limitations. On the other hand are not all tests ported to the new CTF yet.
      </p><p>
        In the next sections we describe how to setup the environment to execute both 
        CTF versions. While both versions of CTF are designed to be executed against 
        every supported database engine, we will describe things with regard to mysql. 
        Having said that there are only scripts for mysql at the new CTF at the moment. 
        At a later step of the CTF refactoring we will add scripts for other databases 
        as well. In addition we intend to allow its execution with an embedded derby 
        database out of the box, but this have not been implemented yet.
      </p><p>
        For those who might be wondering about the numbering of tests, 
        the numbers of the old tests are just random. 
        The numbers of the new tests are the jira issue numbers.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.setup-environment-for-old-ctf"></a>3.9.3.3.5.&nbsp;Steps to setup environment for old CTF</h5></div></div></div><p>
        To execute tests against mysql database you probably need access to a 
        mysql server. To create a database for CTF, you have to execute the following 
        commands on mysql consol.
      </p><pre class="programlisting">
# create database test;
# grant all on test.* at "localhost" to "test" identified by "test";
# use test;
# source [path-to-script];</pre><p>
          If the server is not installed on your local machine (the one you execute
          the tests on) you have to replace "<code class="literal">localhost</code>" with the 
          IP of the machine the tests get executed on. The script to execute can be 
          found in "<code class="filename">cpactf/src/old/ddl/</code>" 
          directory. For mysql it's "<code class="filename">mysql.sql</code>". 
          If you like to use a different name for the database or use 
          other user credential you can adjust them at 
          "<code class="filename">cpactf/src/old/resources/jdo/mysql.xml</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically. Another option is to modify 
        "<code class="filename">bin/test.sh</code>" or "<code class="filename">bin/test.bat</code>" 
        script depended on your operating system.
      </p><p>
        For <span class="productname">mysql</span>&#8482; we still use 
        "<code class="filename">mysql-connector-java-3.1.13-bin</code>", also for 
        <span class="productname">mysql server</span>&#8482; of version 5. 
        This version has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p><p>
        As already explained you will find JDO configurations for every supported 
        database in 
        "<code class="filename">cpactf/src/old/resources/jdo</code>".
        The JDO configurations are named <code class="filename">mysql.xml</code>, 
        <code class="filename">oracle.xml</code> etc. In the same directory you will also 
        find main mapping file "<code class="filename">mapping.xml</code>" that includes all 
        other mappings which are located in the 
        "<code class="filename">cpactf/src/old/resources/ctf/jdo/...</code>" 
        directories. There is one more important file for the old tests 
        "<code class="filename">cpactf/src/old/resources/tests.xml</code>", 
        it is the main config file which defines which test should be executed 
        against which database engine. As mentioned previously not every test 
        works with every database engine as some missing some features or castor 
        does not support everything of every engine.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-old-ctf-from-commandline"></a>3.9.3.3.6.&nbsp;Steps to run old CTF from commandline</h5></div></div></div><p>
        From a command line (e.g a shell), please execute the following commands 
        to run the whole test suite against mysql (where 
        <code class="literal">&lt;castor-root&gt;</code> points to the directory 
        where you installed the Castor sources:
      </p><pre class="programlisting">
cd <span class="emphasis"><em>&lt;castor-root&gt;</em></span>/bin
build clean
build tests
test castor.mysql</pre><p>
        To execute just one of the many tests of the complete test suite, 
        please change this to:
      </p><pre class="programlisting">
cd <span class="emphasis"><em>&lt;castor-root&gt;</em></span>/bin
build clean
build tests
test castor.mysql.TC30</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	      You have to execute "<span><strong class="command">build clean</strong></span>" and 
	      "<span><strong class="command">build tests</strong></span>" again if you have changed anything within 
	      eclipse (e.g. a configuration file or a class).
	    </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-old-ctf-out-of-eclipse"></a>3.9.3.3.7.&nbsp;Steps to run old CTF out of eclipse</h5></div></div></div><p>Now, let's see how we can run these old CPACTF tests through eclipse.</p><div class="itemizedlist"><ul type="disc"><li><p>
            Go to "<span class="package">/cpacft/src/old/java</span>" and right click
          </p></li><li><p>Select <code class="literal">Run As -&gt; Run...</code></p></li><li><p>
            Select <code class="literal">"Java Application"</code> from the left side menu 
            and double click on it to create <code class="literal">"New_configuration"</code>.
          </p></li><li><p>Select <code class="literal">Project -&gt; castor</code></p></li><li><p>Enter <code class="literal">Main class -&gt; MainApp</code></p></li><li><p>Select Arguments Tab</p></li><li><p>
            Enter <code class="literal">Program Arguments</code> for example: 
            "<code class="literal">castor.mysql.TC31</code>" or "<code class="literal">castor.mysql</code>"
          </p></li><li><p>Now "Run"</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.description-of-old-ctf"></a>3.9.3.3.8.&nbsp;Short description of the old CTF tests</h5></div></div></div><p>As some features are not supported by all database engines (e.g. sequence keygenerator) or a test have not been
        verified against a database, only a subset of the following tests will be executed if you run CTF.</p><div class="itemizedlist"><ul type="disc"><li><p>TC01 Duplicate key detection tests.</p></li><li><p>TC02 Concurrent access tests.</p></li><li><p>TC03 Read only tests.</p></li><li><p>TC04 Deadlock detection tests.</p></li><li><p>TC05 Update rollback tests.</p></li><li><p>TC06 Race tests.</p></li><li><p>TC07 Cache leakage tests.</p></li><li><p>TC08 Cache expiry measure.</p></li><li><p>TC09 TxSynchronizable interceptor tests.</p></li><li><p>TC10 Type handling tests.</p></li><li><p>TC11 Type handling of LOB tests.</p></li><li><p>TC12 Type Conversion tests.</p></li><li><p>TC13 Serializable object tests.</p></li><li><p>TC14 Rollback primitive tests.</p></li><li><p>TC15 Multiple columns primary keys tests.</p></li><li><p>TC15a Multiple columns primary keys only tests.</p></li><li><p>TC16 Nested fields tests.</p></li><li><p>TC17 Timestamp tests.</p></li><li><p>TC18 Persistence interface tests.</p></li><li><p>TC19 InstanceFactory interface tests.</p></li><li><p>TC20 Key generators: MAX, HIGH-LOW.</p></li><li><p>TC23 Key generator: IDENTITY.</p></li><li><p>TC24 Key generator: UUID.</p></li><li><p>TC25 Dependent objects tests.</p></li><li><p>TC26 Dependent objects tests.</p></li><li><p>TC27 Dependent update objects tests.</p></li><li><p>TC28 Dependent update objects tests.</p></li><li><p>TC30 OQL-supported syntax.</p></li><li><p>TC31 OQL queries for extends.</p></li><li><p>TC32 Test limit clause.</p></li><li><p>TC33 Test limit clause with offset.</p></li><li><p>TC34 Test limit clause with offset at extended object.</p></li><li><p>TC36 SizeOracle.</p></li><li><p>TC37 Absolute.</p></li><li><p>TC38 CALL SQL with parameters.</p></li><li><p>TC38a Named query support.</p></li><li><p>TC70 Collections.</p></li><li><p>TC71 Test special collections.</p></li><li><p>TC72 Test sorted collections.</p></li><li><p>TC73 ManyToMany.</p></li><li><p>TC74 ManyToManyKeyGen.</p></li><li><p>TC75 Expire Many-To-Many.</p></li><li><p>TC76 Cached OID with db-locked.</p></li><li><p>TC77 Query garbage collected.</p></li><li><p>TC78 JDBC connection.</p></li><li><p>TC79 Test the use of Database.isLocked().</p></li><li><p>TC79a Test auto-store attribute.</p></li><li><p>TC79aa Test auto-store attribute for 1:M relations.</p></li><li><p>TC79b Test the use of Database.isPersistent().</p></li><li><p>TC80 self-referential relation test with extend hierarchies.</p></li><li><p>TC81 Dependent relation test.</p></li><li><p>TC82 Dependent relation test (using no key generators).</p></li><li><p>TC83 Identity definition through identity attribute in field mapping.
        </p></li><li><p>TC84 Transient attribute.</p></li><li><p>TC85 TestEnum.</p></li><li><p>TC87 TestLazy1to1.</p></li><li><p>TC88 Lazy Loading.</p></li><li><p>TC89 Expire Lazy Employee.</p></li><li><p>TC93 Polymorphism Degenerated tests.</p></li><li><p>TC94 Polymorphism tests.</p></li><li><p>TC95 Polymorphism tests with key generator.</p></li><li><p>TC96 Polymorphism tests for depend relations.</p></li><li><p>TC97 Polymorphism tests.</p></li><li><p>TC98 Polymorphism tests in a threaded environment.</p></li><li><p>TC99 Polymorphism tests (many 2 many).</p></li><li><p>TC200 Self-referential relation tests.</p></li><li><p>TC201 Self-referential relation tests with extend hierarchy.
        </p></li><li><p>TC202 ForeignKeyFirst tests.</p></li><li><p>TC203 Timezone tests.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.setup-environment-for-new-ctf"></a>3.9.3.3.9.&nbsp;Steps to setup environment for new CTF</h5></div></div></div><p>
        To execute tests against mysql database you probably need access to a 
        mysql server. To create a database for CTF, you have to execute the 
        following commands on mysql console.
      </p><pre class="programlisting">
# create database cpactf;
# grant all on cpactf.* at "localhost" to "test" identified by "test";
# use cpactf;
# source <span class="emphasis"><em>&lt;path-to-script&gt;</em></span>;</pre><p>
        If the server is not installed on your local maschine (the one you execute the 
        tests on) you have to replace "<code class="literal">localhost</code>" with the IP 
        of the maschine the tests get executed on. For mysql execute every 
        "<code class="filename">mysql.sql</code>" script found in subdirectories of 
        "<code class="filename">cpactf/src/test/ddl/</code>" directory. 
        If you like to use a different name for the database or use other user 
        credential you can adjust them at 
        "<code class="filename">cpactf/src/test/resources/cpactf-conf.xml</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically. Another option is to modify 
        "<code class="filename">bin/test.sh</code>" or "<code class="filename">bin/test.bat</code>" 
        script depended on your operating system.
      </p><p>
        For mysql we still use "<code class="literal">mysql-connector-java-3.1.13-bin</code>", 
        also for <span class="productname">mysql server</span>&#8482; of version 5. This version 
        has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.run-new-ctf-out-of-eclipse"></a>3.9.3.3.10.&nbsp;Steps to run new CTF out of eclipse</h5></div></div></div><p>
        Execution of the new test suite from within eclipse against 
        <span class="productname">mysql</span>&#8482; is very simple.
      </p><div class="itemizedlist"><ul type="disc"><li><p>Select "<span class="package">cpactf/src/test/java</span>" and right click</p></li><li><p>
            Select "<code class="literal">Run as</code>" -&gt; "<code class="literal">JUnit tests</code>"
          </p></li></ul></div><p>
        In in the configuration file "cpactf-conf.xml" mysql is configuerd as default 
        database. To execute tests against another database engine or to force 
        execution of tests that have been excluded you can pass VM parameter to the 
        test framework. VM Arguments can also be specified in eclipse.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Select "<code class="literal">Run as</code>" -&gt; "<code class="literal">Run..</code>"
            from main menu
          </p></li><li><p>Select Arguments Tab</p></li><li><p>
            Enter <code class="literal">VM Arguments</code> for example: 
            "<code class="literal">-Dname=value</code>"
          </p></li><li><p>Now "<code class="literal">Run</code>"</p></li></ul></div><p>The following VM parameters are supported by CTF.</p><div class="variablelist"><dl><dt><span class="term">config</span></dt><dd><p>Path to an alternate configuration file.</p></dd><dt><span class="term">database</span></dt><dd><p>Name of the database configuration.</p></dd><dt><span class="term">transaction</span></dt><dd><p>Name of the transaction manager configuration.</p></dd><dt><span class="term">force</span></dt><dd><p>Force execution of excluded tests (true/false).</p></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.troubleshooting"></a>3.9.3.3.11.&nbsp;Troubleshooting</h5></div></div></div><p>
        <span class="bold"><strong>For those who face the following problem in eclipse 
        while executing the tests</strong></span>
      </p><pre class="programlisting">
#An unexpected error has been detected by HotSpot Virtual Machine:
#
#EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x7c918fea, pid=2460, tid=3712
#
#Java VM: Java HotSpot(TM) Client VM (1.5.0-b64 mixed mode)
#Problematic frame:
#C [ntdll.dll+0x18fea]
#
#An error report file with more information is saved as hs_err_pid2460.log
#
#            If you would like to submit a bug report, please visit:
#              http://java.sun.com/webapps/bugreport/crash.jsp
#</pre><p>
        It is a problem with memory configured for eclipse. It can be changed in 
        <code class="filename">eclipse.ini</code> file which can be found in installation 
        directory of Eclipse. By default it is <code class="literal">-Xmx256m</code>, 
        just increase it and problem go away.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.jdo-test-suite.references"></a>3.9.3.3.12.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li><li><p>
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/scm.html#Subversion-access" target="_top">Subversion 
            access</a>
          </p></li><li><p>
            
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/test-framework.html" target="_top">The testing 
            framework</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.performance-tests"></a>3.9.3.4.&nbsp;How to run Castor JDO's performance tests</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.overview"></a>3.9.3.4.1.&nbsp;Overview</h5></div></div></div><p>At the time of this writing Castor JDO has 3 kinds of test suites:</p><div class="itemizedlist"><ul type="disc"><li><p>Database independend plan unit tests.</p></li><li><p>
            A JUnit based test suite that is used to test various functional areas 
            against different database engines to give developers/committers some 
            reassurance when changing the codebase.
          </p></li><li><p>
            A Junit based test suite to evaluate impact of changes on performance.
          </p></li></ul></div><p>This document provides general information about running Castor JDO's performance tests.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.prerequisites"></a>3.9.3.4.2.&nbsp;Prerequisites</h5></div></div></div><p>
        See: <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How 
        to setup Castor project in eclipse</a>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.setup-environment-for-old-ctf"></a>3.9.3.4.3.&nbsp;Steps to setup environment for old CTF</h5></div></div></div><p>
        To execute performance tests against mysql database you probably need access 
        to a mysql server. To create a database for PTF, you have to execute the 
        following commands on mysql console.
      </p><pre class="programlisting">
# create database cpaptf;
# grant all on cpaptf.* at "localhost" to "test" identified by "test";
# use cpaptf;
# source <span class="emphasis"><em>[path-to-script]</em></span>;</pre><p>
        If the server is not installed on your local machine (the one you execute 
        the tests on) you have to replace "<code class="literal">localhost</code>" with the IP 
        of the machine the tests get executed on. The script to execute is
        "<code class="filename">cpaptf/src/test/ddl/mysql.sql</code>".
      </p><p>
        As we do not include JDBC drivers for every database with Castor you also have 
        to add the driver you like to use to your classpath to execute the tests. 
        The easiest way is to copy the driver to 
        "<code class="filename">lib/</code>" directory as all jar's
        contained therein are added automatically.
      </p><p>
        For mysql we still use "<code class="literal">mysql-connector-java-3.1.13-bin</code>", 
        also for <span class="productname">mysql server</span>&#8482; of version 5. 
        This version has proven to be stable. While other versions of 
        <span class="productname">mysql connector</span>&#8482; may also work, 
        some of them have bugs from our experience.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.execute-in-eclipse"></a>3.9.3.4.4.&nbsp;Steps to execute performance tests in eclipse</h5></div></div></div><p>
        Execution of the performance test suite from within eclipse is very simple.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Select "<code class="literal">cpaptf/src/test/java</code>" 
            -&gt; "<code class="literal">org.castor.cpaptf</code>" 
            -&gt; "<code class="filename">TestAll.java</code>" and right click
          </p></li><li><p>
            Select "<code class="literal">Run As</code>" -&gt; "<code class="literal">JUnit Test</code>"
          </p></li></ul></div><p>
        By default the test uses 2000 service objects that get created, loaded with 
        various configurations and deleted afterwards. Obviously this will take quite 
        some time. Please be patient for normal termination of the tests as you will 
        need to clean test tables by hand otherwise. To execute tests with a different 
        number of objects you can adjust "<code class="constant">FACTOR</code>" constant in 
        "<code class="filename">TestCreate.java</code>". For example, if you set 
        "<code class="constant">Factor</code>" to 1.0 the tests will be executed with 10000 
        service objects. When using more test objects be aware that you may need to 
        increase heap size of the virtual machine for the test to finish.
      </p><p>
        By default you won't see any output of results on the console as logging level 
        of log4j is set to "warn" by default. But if you change log level of 
        "<span class="package">org.castor.cpaptf</span>" package to "<code class="literal">info</code>" 
        you will see detailed execution times for every test on the console. 
        Be aware that there are quite some <code class="filename">log4j.xml</code> 
        configurations in the whole Castor project at the moment of which the one 
        first one on classpath will be used.
      </p><p>
        If you like to review some older test results you will find them under 
        "<code class="filename">cpaptf/src/site/resources/results/</code>" 
        but they depend heavy on the machine you are running the tests on.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.performance-tests.references"></a>3.9.3.4.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="jdo.html#jdo.howto.setup-eclipse-castor-project" title="3.9.3.1.&nbsp;How to setup Castor project in eclipse">How to setup Castor 
            project in eclipse</a>
          </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.submit-a-bug"></a>3.9.3.5.&nbsp;Submitting a bug report</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.submit-a-bug.problem-report"></a>3.9.3.5.1.&nbsp;Submitting a problem report</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.driver"></a>3.9.3.5.1.1.&nbsp;Driver</h6></div></div></div><p>
			   Most of the traffic on the Castor Users mailing list is about people 
			   asking for help on various features of Castor (whether JDO or XML). 
			   Whilst there is nothing wrong about asking questions and looking for 
			   help if you are stuck, it seems that there is room to improve the 
			   structure of this 'conversation'.
			</p><p>
			   If you have a look at some of these threads (e.g. at the 
			   <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.mail-archive.com/castor-dev%40exolab.org" target="_top">searchable 
			   mailing list archive</a>), it's quite easy to see that most 
			   of the time ...
			</p><div class="orderedlist"><ol type="1"><li><p>An initial question is posted.</p></li><li><p>
				    An initial reply is posted with some follow-up questions, 
				    e.g. request for code fragments, mapping files, etc.
				  </p></li><li><p>
				    One or more code fragments, mapping files, etc. are being posted.
				  </p></li><li><p>etc.</p></li></ol></div><p>
			  This document will establish guidelines with regards to step 3) above.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.introduction"></a>3.9.3.5.1.2.&nbsp;Introduction</h6></div></div></div><p>
			    This document provides step-by-step instructions on how to submit a 
			    problem report (when being asked to do so). It does so by walking you 
			    through a fictive problem and its resulting bug report, and providing 
			    instructions based upon this scenario.
			</p><p>
			    Per definition, any problem report submitted (in other words, most 
			    likely attached to a bug report at 
			    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jira.codehaus.org/browse/CASTOR" target="_top">http://jira.codehaus.org/browse/CASTOR</a>)
			    by the means of a patch has to include the following artefacts:
			</p><div class="itemizedlist"><ul type="disc"><li><p>A JUnit test case that 'showcases' your problem.</p></li><li><p>Castor JDO configuration file.</p></li><li><p>Castor JDO mapping file.</p></li><li><p>
				    One or more 'entity' classes required to run your test case.
				  </p></li><li><p>
				    A SQL schema file (to help in the creation of required tables).
				  </p></li><li><p>
				    A <code class="literal">README</code> file (with any additional 
				    information/instructions required to understand /run your test case.
				  </p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			    Whilst we can and will not impose these guidelines in their strictest 
			    sense, I think that the use of technologies such as JUnit will simplify problem 
			    resolution and as a result lead to shorter turn-around times. Which is ultimately where 
			    you, the user, gains..
			  </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.templates"></a>3.9.3.5.1.3.&nbsp;Templates</h6></div></div></div><p>
		        To facilitate creation of a fully featured patch as discussed above, 
		        we have provided you with an already existing bug template at 
		        '<code class="filename">src/bugs/jdo/template</code>'.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
			        Please note that this directory is distributed only as part of the 
				    source archive(s).
				</p></td></tr></table></div><p>
			    This directory holds all artefacts mentioned above, as is structured 
			    as follows:
			</p><div class="table"><a name="d4e6184"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;bug template artefacts</b></p><div class="table-contents"><table summary="bug template artefacts" border="1"><colgroup><col><col></colgroup><tbody><tr><td><code class="filename">src</code></td><td>Source code</td></tr><tr><td><code class="filename">src/bugs</code></td><td>Common root for bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo</code>
                        </td><td>Common root for JDO bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template</code>
                        </td><td>Patch template</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/TestTemplate.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/EntityOne.java</code>
                        </td><td>Entity required by the test case</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/create.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td><code class="filename">src/bugs/jdo/template/README</code></td><td>Test instructions</td></tr></tbody></table></div></div><br class="table-break"><p>
			    To create you own bug report, please copy 
			    '<code class="filename">template</code>'
			    to e.g. <code class="filename">bug1820</code>, 
			    assuming that 1820 is the number assigned to your BugZilla 
			    problem report). Subsequently, please amend the files provided to 
			    match your own requirements. After you have consolidated your changes, 
			    the original directory structure in 
			    <code class="filename">src/bugs</code> could look as follows:
			</p><div class="table"><a name="d4e6232"></a><p class="title"><b>Table&nbsp;3.8.&nbsp;
			        directory structure of 
			        <code class="filename">src/bugs</code>
			    </b></p><div class="table-contents"><table summary="&#xA;        directory structure of &#xA;        src/bugs&#xA;    " border="1"><colgroup><col><col></colgroup><tbody><tr><td>
                            <code class="filename">src</code>
                        </td><td>Source code</td></tr><tr><td>
                            <code class="filename">src/bugs</code>
                        </td><td>Common root for bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo</code>
                        </td><td>Common root for JDO bug reports</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template</code>
                        </td><td>Patch template</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/TestTemplate.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/EntityOne.java</code>
                        </td><td>Entity required by the test case</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/create.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/template/README</code>
                        </td><td>Test instructions</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820</code>
                        </td><td>Your specific bug (as per BugZilla bug number)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/TestCase.java</code>
                        </td><td>JUnit test case.</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/Entity1.java</code>
                        </td><td>Entity required</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/Entity2.java</code>
                        </td><td>Entity required</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/jdo-conf.xml</code>
                        </td><td>Castor JDO configuration</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/mapping.xml</code>
                        </td><td>Castor mapping file</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/schema.sql</code>
                        </td><td>SQL schema to create database table(s)</td></tr><tr><td>
                            <code class="filename">src/bugs/jdo/bug1820/README</code>
                        </td><td>Test instructions</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.add-test-case"></a>3.9.3.5.1.4.&nbsp;Add your test case to the master test suite</h6></div></div></div><p>
		        Once you have successfully executed your JUnit test case, please add 
		        this test to the master test suite available in 
		        <code class="filename">src/bugs/AllTests.java</code> as follows. To add 
			    a test to this suite, please duplicate the line
			</p><pre class="programlisting">
			
    suite.addTestSuite(template.TestTemplate.<span class="hl-keyword">class</span>);
			</pre><p>
			    and replace the term 
			    '<code class="literal">jdo.template.TestTemplate.class</code>' with 
			    '<code class="literal">jdo.bug1820.TestCase</code>'.
			</p><p>
		        This will allow us to run all tests related to all open bugs in one go by executing
			    just this test suite.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.creating-the-patch"></a>3.9.3.5.1.5.&nbsp;Creating the patch</h6></div></div></div><p>
		        As explained in 
		        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/contributing.html#Guidelines-For-Code-Contribution" target="_top"> 
		        Guidelines For Code Contribution</a>, we ask you to submit your code
                changes in the form of a unified patch by attaching it to the relevant
                bug report.
            </p><p>
		        To create a <span class="bold"><strong>unified</strong></span> patch for 
		        submission, you can either use the command line SVN client 
		        (which you find instructions to download for at 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">http://subversion.tigris.org/</a> 
                or any IDE that offers support or SVN 
                (such as Eclipse with Subclipse plugin)
            </p><p>
		        In any case, please note that we are trying to standardize on the use
                of <span class="bold"><strong>unified</strong></span> patches only, and that 
                you should <span class="bold"><strong>always</strong></span> update your code 
                (against the SVN repository) before creating the patch. 
                If you have never used SVN before, there will be ways to
                convince us to accept e.g. a Zip file includig your changes.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.submit-a-bug.problem-report.references"></a>3.9.3.5.1.6.&nbsp;References</h6></div></div></div><p>
		        Whilst we cannot assume that every Castor (JDO) user is an expert in
                the use of JUnit, we do believe that they are quite easy to get
                acquainted with. As a starting point, please find below some
                references:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
				        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.junit.org/" target="_top">JUnit</a> - A well-known
                        framework for writing integration-level and functional tests.
                    </p></li><li><p>
				        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">SVN Home</a>
				         - many usefulSVN related items
                    </p></li></ul></div></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.prepare-a-patch"></a>3.9.3.6.&nbsp;How to prepare a patch</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.overview"></a>3.9.3.6.1.&nbsp;Overview</h5></div></div></div><p>
           A "<code class="literal">patch</code>" is the set of differences between two versions of the same file. 
           Patches are used to send someone the exact changes that you have made to 
           your version of a program or a document. They can then apply that patch 
           to their version to merge the changes and bring their version up-to-date 
           with your version.
        </p><p>
           As our example we use the contribution of a simple documentation patch for 
           the Castor project. The principles apply to any project and to any type of 
           file, e.g. <code class="filename">*.xml</code>, 
           <code class="filename">*.java</code>, 
           <code class="filename">*.xsd</code>, etc.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.intended-audience"></a>3.9.3.6.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to contribute to a project. This document addresses the 
            basics, so as to get new people started.
        </p><p>
            Our example describes the use of command-line tools for a UNIX system. 
            Other tools can be used, as long as they produce a 
            "<code class="literal">unified diff</code>".
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.prerequisites"></a>3.9.3.6.3.&nbsp;Prerequisites</h5></div></div></div><p>Contributers should have:</p><div class="itemizedlist"><ul type="disc"><li><p>
                    The source code of the documents as a local working copy of the 
                    SVN repository. If you are working with the current SVN HEAD then 
                    you will have already done a 
                    '<span><strong class="command">svn checkout castor</strong></span>'. However, see below for 
                    other ways of obtaining source for diff comparison.
                </p></li><li><p>
                    The tools with which to prepare a patch. On UNIX the "svn" program 
                    has the <span><strong class="command">svn diff</strong></span> command.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.steps"></a>3.9.3.6.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.steps.understand"></a>3.9.3.6.4.1.&nbsp;Understand what a patch is</h6></div></div></div><p>
                A "Patch" is the set of differences between two versions of the same 
                file. A patch comprises one or more "diff" files. These diffs are 
                produced by the program of the same name: diff.
            </p><p>
                Here is an example of a single diff for one of the Castor How-to 
                pages, where we are suggesting a minor text change. Do not get 
                frightened. These are just human-readable instructions to the "patch" 
                program.
            </p><pre class="programlisting">
            
Index: contrib.xml
===================================================================
RCS file: /home/projects/castor/src/doc/jdo-howto.xml,v
retrieving revision 1.7
diff -u -r1.7 contrib.xml
--- jdo-howto.xml 30 Apr 2002 07:44:52 -0000      1.7
+++ jdo-howto.xml 26 May 2002 04:08:23 -0000
@@ -208,7 +208,7 @@
    to create a patch. (The commands are for Linux.)
   &lt;/p&gt;

- &lt;s2 title="How to Establish your Local Repository"&gt;
+ &lt;s2 title="How to Establish your Local Working Copy"&gt;

   &lt;p&gt;
    This will checkout the current copy of the master cvs repository and
            </pre><p>
                That is a "unified diff" ... there a some lines of context on each 
                side of the changes. This patch is basically saying "Change the text 
                on line 208".
            </p><div class="itemizedlist"><ul type="disc"><li><p>lines to be deleted are preceded with -</p></li><li><p>lines to be added are preceded with +</p></li><li><p>contextual lines with no leader remain the same</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.modify-and-ensure-consistency"></a>3.9.3.6.4.2.&nbsp;Modify your document and ensure consistency</h6></div></div></div><p>
                Let us now go though the process of preparing that patch. Go ahead 
                and edit your local copy of the document at 
                <code class="filename">$CASTOR_HOME/src/doc/jdo-howto.xml</code>.
            </p><p>
                Ensure that it is valid XML using your favourite XML editor or an 
                external validating parser. Please do not leave it up to the poor 
                committer to fix broken XML.
            </p><p>
                Run the '<span><strong class="command">build doc</strong></span>' target to be sure that links 
                are not broken and that the new document is presented as you intend 
                it to be.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.get-ready"></a>3.9.3.6.4.3.&nbsp;Get ready</h6></div></div></div><p>
                If you are using the HEAD of SVN then ensure that your working copy 
                is up-to-date. Of course, if you are using a previous public release 
                version of Castor, then it is already up-to-date.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.generate-the-differences"></a>3.9.3.6.4.4.&nbsp;Generate the differences</h6></div></div></div><p>
                Prepare the diff file. SVN will contact the remote repository, ensure 
                that your working copy is up-to-date, then compare your local copy 
                with the master repository.
            </p><pre class="programlisting">
            
    cd src/doc
    svn diff jdo-howto.xml &gt; $TEMP/castor/patch/jdo-howto.xml.diff
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.describe-the-patch"></a>3.9.3.6.4.5.&nbsp;Describe the patch</h6></div></div></div><p>
                Prepare a brief explanation of what your patch does. Get this ready 
                in a text file before you go to Jira. See further hints about this 
                in the "Description" section of the How-to Jira.
            </p><p>
                What revision of SVN did you patch against? Was it HEAD branch? Was 
                it a nightly build? Was it a public release?
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.submit-via-jira"></a>3.9.3.6.4.6.&nbsp;Submit via Jira</h6></div></div></div><p>
                To contribute your patch to a specific project, use Jira - The Codehaus 
                Issue Database. The procedure is explained in How to Contribute a 
                Patch via Jira.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension"></a>3.9.3.6.5.&nbsp;Real World Extension</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension.multiple-diffs"></a>3.9.3.6.5.1.&nbsp;Multiple diffs in a single patch</h6></div></div></div><p>
                A patchfile can contain the differences to various individual 
                documents. For example, the following command does that ...
            </p><pre class="programlisting">
            
    cd src
    svn diff &gt; $WORK/castor/patch/src.dir.diff
            </pre><p>
                However, be careful not to go overboard with this technique. When 
                producing multiple diffs in one patchfile, try to limit it to one 
                particular topic, i.e when fixing the same broken external link in 
                various pages, then it would be fine to produce a single diff. 
                Consider the committer - they will find it hard to apply your patch 
                if it also attempts to fix other things.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.prepare-a-patch.real-world-extension.diff-other"></a>3.9.3.6.5.2.&nbsp;Other ways of obtaining source for diff comparison</h6></div></div></div><p>
                Ideally you will prepare your patches against a SVN repository. 
                There are other ways to do this. They do create more work for the 
                committers, however it may be the only way that you can do it. 
                We would certainly rather receive your patch however it comes. 
                As a matter of fact, we would politely ask you first to send us a 
                unified patch.
            </p><p>
                You could get the source document via the web interface to SVN. 
                Here are the steps ...
            </p><div class="itemizedlist"><ul type="disc"><li><p>get the relevant XML file via FishEye</p></li><li><p>
                        save the file to your local disk: 
                        <code class="code">./jdo-howto.xml.orig</code>
                    </p></li><li><p>
                        create a copy of the file: <code class="code">./jdo-howto.xml</code>
                    </p></li><li><p>make your modifications and validate the XML</p></li><li><p>
                        use the "<span><strong class="command">diff</strong></span>" command 
                        (i.e. not 'cvs diff') as follows
                    </p></li><li><p>
                        <code class="code">diff -u jdo-howto.xml.orig jdo-howto.xml &gt; 
                        $WORK/castor/patch/jdo-howto.xml.diff</code>
                    </p></li><li><p>proceed as for Step 5.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.tips"></a>3.9.3.6.6.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    Please review your diffs before you submit your patch to JIRA
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.prepare-a-patch.references"></a>3.9.3.6.7.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    The UNIX manual pages '<span><strong class="command">man diff</strong></span>' and 
                    '<span><strong class="command">man patch</strong></span>'.
                </p></li><li><p>
		            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://subversion.tigris.org/" target="_top">SVN Home</a> 
		            - many useful SVN related items
                </p></li></ul></div></div></div>

	      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e6447"></a>3.9.3.7.&nbsp;How to Contribute a Patch via Jira</h4></div></div></div></div>
	  </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.oql"></a>3.9.4.&nbsp;OQL</h3></div></div></div>
          
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-limit-clause"></a>3.9.4.1.&nbsp;How to use a LIMIT clause with OQL</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.overview"></a>3.9.4.1.1.&nbsp;Overview</h5></div></div></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.intended-audience"></a>3.9.4.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to execute an OQL statement and limit the result size.
        </p><p>
            The example given describes the addition of LIMIT/OFFEST clauses to an 
            existing OQL statement.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.prerequisites"></a>3.9.4.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for two Java classes 
            <code class="classname">Product</code> and <code class="classname">ProductGroup</code>, 
            similar to the following one:
        </p><pre class="programlisting">
        
<span class="hl-keyword">package</span> myapp;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product 
{
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name; 

    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span>     _price; 

    <span class="hl-keyword">private</span> ProductGroup _group;


    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> anId ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String aName ) { ... }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getPrice() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPrice( <span class="hl-keyword">float</span> aPrice ) { ... }

    <span class="hl-keyword">public</span> ProductGroup getProductGroup() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductGroup( ProductGroup aProductGroup ) { ... }
}
        </pre><p>
            The following fragment shows the Java class declaration for the 
            <code class="classname">ProductGroup</code> class:
        </p><pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductGroup
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>       _id;

    <span class="hl-keyword">private</span> String    _name;

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId( <span class="hl-keyword">int</span> id ) { ... }

    <span class="hl-keyword">public</span> String getName() { ... }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName( String name ) { ... }

}
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.steps"></a>3.9.4.1.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.obtain-all-productgroup-instances"></a>3.9.4.1.4.1.&nbsp;Compose an OQL statement to obtain all ProductGroup instances</h6></div></div></div><p>
                The following code fragment shows an OQL query to select the all 
                <code class="classname">ProductGroup</code> instances.
            </p><pre class="programlisting">
            
OQLQuery query = db.getOQLQuery(<span class="hl-string">"select product from ProductGroup product"</span>);
query.bind(10);
OQLResults results = query.execute();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.add-limit"></a>3.9.4.1.4.2.&nbsp;Add LIMIT clause to OQL statement</h6></div></div></div><p>
                The following code fragment shows the same OQL query as above, to 
                this time the LIMIT keyword is added to select the first 10 
                <code class="classname"></code> instances only.
            </p><pre class="programlisting">
            
    OQLQuery query = db.getOQLQuery(
            <span class="hl-string">"select product from ProductGroup product LIMIT $1"</span>);
    query.bind(10);
    OQLResults results = query.execute();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-limit-clause.steps.add-offset"></a>3.9.4.1.4.3.&nbsp;Add OFFSET clause to OQL statement</h6></div></div></div><p>
                Below is the same OQL query again, restricting the number of 
                <code class="classname">ProductGroup</code> instances returned to 10, though 
                this time it is specified that the <code class="classname">ProductGroup</code> 
                instances 101 to 110 should be returned.
            </p><pre class="programlisting">
            
OQLQuery query = db.getOQLQuery(
        <span class="hl-string">"select product from ProductGroup as product LIMIT $1 OFFSET $2"</span>);
query.bind(10);
query.bind(100);
OQLResults results = query.execute();
            </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.limitations"></a>3.9.4.1.5.&nbsp;Limitations</h5></div></div></div><p>The following RDBMS fully/partially support LIMIT/OFFSET clauses.</p><div class="table"><a name="d4e6495"></a><p class="title"><b>Table&nbsp;3.9.&nbsp;Support for LIMIT in RDBMS</b></p><div class="table-contents"><table summary="Support for LIMIT in RDBMS" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left"><span class="application">RDBMS</span></th><th>LIMIT</th><th>OFFSET</th></tr></thead><tbody><tr><td><span class="application">postgreSQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">mySQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">Oracle 1) 2)</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">HSQL</span></td><td>Yes</td><td>Yes</td></tr><tr><td><span class="application">MS SQL</span></td><td>Yes</td><td>-</td></tr><tr><td><span class="application">DB2</span></td><td>Yes</td><td>-</td></tr></tbody></table></div></div><br class="table-break"><p>
            1) Caster has full support for LIMIT/OFFSET clauses for Oracle 
            Releases 8.1.6 and later.
        </p><p>
            2) For the LIMIT/OFFSET clauses to work properly the OQL query is required 
            to include an ORDER BY clause.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.tips"></a>3.9.4.1.6.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    In the case a RDBMS does not support LIMIT/OFFSET clauses, a 
                    <code class="literal">SyntaxNotSupportedException</code> will be thrown.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-limit-clause.references"></a>3.9.4.1.7.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.oql-to-sql-translator" title="4.2.&nbsp;OQL to SQL translator">Castor JDO's 
                    OQL</a>
                </p></li></ul></div></div></div>
      </div>

      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.core-features"></a>3.9.5.&nbsp;Core features</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-a-cache"></a>3.9.5.1.&nbsp;How to use a (performance) cache with Castor</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.intended-audience"></a>3.9.5.1.1.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to enable caching for classes already mapped with 
            <span class="application">Castor JDO</span>.
        </p><p>
            This document addresses the basics to get people familiar with the basic 
            concepts and discusses some implementation details.
        </p><p>
            The example given describes the addition of a 
            <code class="literal">&lt;cache-type&gt;</code> element to an existing class mapping.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.prerequisites"></a>3.9.5.1.2.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for a Java class, similar to the 
            following one:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.steps"></a>3.9.5.1.3.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-a-cache.steps.add-cache-type-element-to-mapping"></a>3.9.5.1.3.1.&nbsp;Add &lt;cache-type&gt; element to class mapping</h6></div></div></div><p>
                Add a &lt;cache-type&gt; element as shown below, specifying the cache 
                provider to use in the 'type' attribute.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"time-limited"</span>/&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
                This, for example, defines the 'time-limited' cache provider to be 
                used for the <code class="classname">com.xyz.MyOtherObject</code>. This cache 
                provider applies internally a time-limited least-recently-used 
                algorithm for <code class="classname">com.xyz.MyObject</code> instances.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.tips"></a>3.9.5.1.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    With the current release, performance caches also serve a dual 
                    purpose as dirty checking caches for 
                    <a href="advanced-jdo.html#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">long-transactions</a>. 
                    This limitation implies that the object's duration in the 
                    performance cache determines the allowed time span of a long 
                    transaction. This might become an issue when performance caches 
                    of type '<code class="literal">count-limited</code>' or 
                    '<code class="literal">time-limited</code>' are being used, as objects will 
                    eventually be disposed. If an application tries to update an 
                    object that has been disposed from the dirty checking cache, an 
                    ObjectModifedException will be thrown.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-a-cache.references"></a>3.9.5.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.long-transactions" title="4.6.&nbsp;Castor JDO Long Transactions Support">Long 
                    transactions</a>
                </p></li><li><p><a href="advanced-jdo.html#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">Caching</a></p></li><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">Caching 
                    and clustered environments</a>
                </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.map-enums"></a>3.9.5.2.&nbsp;How to map typesafe enumerations with Castor</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.intended-audience"></a>3.9.5.2.1.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to persist object that refer to a typesafe enumeration.
        </p><p>
            This document addresses the basics and shows an example how to map an 
            object that has a typesafe enumeration property.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.prerequisites"></a>3.9.5.2.2.&nbsp;Prerequisites</h5></div></div></div><p>
            Enumerations are a common method for ensuring data integrity, both in 
            software and in relational databases. As a platform for linking the two, 
            we added support for persisting class fields whose type is a Java typesafe 
            enumeration to <span class="application">Castor JDO</span>.
        </p><p>
            To use this new feature your typesafe enumeration should follow the enum 
            pattern commonly used and provide a static
            <code class="methodname">valueOf(String)</code> method. An enum of 
            different kinds of computer equipment may look like:
        </p><pre class="programlisting">
        
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> KindEnum {
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Map KINDS = <span class="hl-keyword">new</span> HashMap();

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum MOUSE = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Mouse"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum KEYBOARD = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Keyboard"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum COMPUTER = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Computer"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum PRINTER = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Printer"</span>);
    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> KindEnum MONITOR = <span class="hl-keyword">new</span> KindEnum(<span class="hl-string">"Monitor"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> String _kind;

    <span class="hl-keyword">private</span> KindEnum(<span class="hl-keyword">final</span> String kind) {
        _kind = kind;
        KINDS.put(kind, <span class="hl-keyword">this</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> KindEnum valueOf(<span class="hl-keyword">final</span> String kind) {
	    <span class="hl-keyword">return</span> (KindEnum) KINDS.get(kind);
    }

    <span class="hl-keyword">public</span> String toString() { <span class="hl-keyword">return</span> _kind; }
}
        </pre><p>
            At your <code class="classname">Product</code> class you may want to have a 
            property that tells you what kind of computer equipment a product is of.
        </p><pre class="programlisting">
        
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Product {
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span>         _id;
    <span class="hl-keyword">private</span> String      _name;
    <span class="hl-keyword">private</span> KindEnum    _kind;
    
    <span class="hl-keyword">public</span> Product() { }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getId() { <span class="hl-keyword">return</span> _id; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(<span class="hl-keyword">int</span> id) { _id = id; }

    <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> _name; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { _name = name; }

    <span class="hl-keyword">public</span> KindEnum getKind() { <span class="hl-keyword">return</span> _kind; }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setKind(KindEnum kind) { _kind = kind; }
}
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.steps"></a>3.9.5.2.3.&nbsp;Steps</h5></div></div></div><p>
            Your mapping for the <code class="classname">Product</code> class should be:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Product"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
  &lt;<span class="hl-tag">description</span>&gt;Product with kind enum&lt;<span class="hl-tag">/description</span>&gt;
  &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"enum_prod"</span>/&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"kind"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"KindEnum"</span>&gt;
    &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"kind"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span>/&gt;
  &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.map-enums.tips"></a>3.9.5.2.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                   To add this new feature we added an additional check when searching 
                   for field types. Like before <span class="application">Castor</span> 
                   first searches for know types and thereafter for a mapping for 
                   the class you specified as type. If both of them do not match it 
                   now checks if the class specified as type is available at classpath 
                   and has a static <code class="methodname">valueOf(String)</code> method. 
                   Only if all of this conditions are met it will be viewed as a 
                   valid mapping.
               </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-connection-proxies"></a>3.9.5.3.&nbsp;How to use Castor JDO's connection proxies</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.introduction"></a>3.9.5.3.1.&nbsp;Introduction</h5></div></div></div><p>
            <span class="application">Castor JDO</span> uses the 
            <span class="application">Jakarta Common's Logging</span> package for output 
            information relevant to the execution of a specific JDO operations to a 
            log file. The information output historically included the SQL statements 
            used by <span class="application">Castor</span> to execute the various 
            persistence operations such as loading or updating domain entities. 
            Unfortunately, the SQL statements logged did not include any information 
            about the parameters being bound to the prepared statements immediately 
            before execution, and hence made it very hard for users of 
            <span class="application">Castor JDO</span> to analyze these in the case of an 
            issue/problem.
        </p><p>
            To improve this situation, proxy classes for the 
            <span class="interface">java.sql.Connection</span> and 
            <span class="interface">java.sql.PreparedStatement</span> interfaces have been 
            added, to allow for complete and better JDBC statements to be output to 
            the log files. As this might impose a performance penalty at run-time, 
            we have allowed for this to be turned off completely through the standard 
            Castor property file. 
        </p><p>
            A new property has been added to the Castor property file 
            (<code class="filename">castor.properties</code>) to allow configuration of this 
            feature.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.intended-audience"></a>3.9.5.3.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to use the new JDBC proxy classes with 
            <span class="application">Castor JDO</span> selectively, i.e. enabling and 
            disabling their use.
        </p><p>
            The example given describes how to turn the use of the proxy classes on/off.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.prerequisites"></a>3.9.5.3.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid <code class="filename">castor.properties</code> file as 
            part of your application.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.steps"></a>3.9.5.3.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-connection-proxies.steps.enable-jdbc-classes"></a>3.9.5.3.4.1.&nbsp;Enable the use of the JDBC proxy classes</h6></div></div></div><p>
                To enable the use of the JDBC proxy classes described above, please 
                add the following section to your 
                <code class="filename">castor.properties</code> file.
            </p><pre class="programlisting">
            
  # True if JDBC proxy classes should be used to enable more detailed logging output of SQL
  # statements; false otherwise (logging of SQL statements will be turned off completely).
  #
  org.exolab.castor.persist.useProxy=true
            </pre><p>
                This instructs <span class="application">Castor JDO</span> to use the JDBC 
                proxy classes and to output full information about the SQL statements 
                used at run-time. When disabled, no logging of SQL statements will 
                occur at all.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-connection-proxies.references"></a>3.9.5.3.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/conf-lib.html" target="_top">Configuration 
                    of Castor</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://jakarta.apache.org/commons/logging/" target="_top">Jakarta 
                    Common Logging</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.cascading"></a>3.9.6.&nbsp;Cascading</h3></div></div></div>
          
              
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-cascading-operations"></a>3.9.6.1.&nbsp;How to use cascading operations</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.overview"></a>3.9.6.1.1.&nbsp;Overview</h5></div></div></div><p>
            Up to Castor 1.3.1, users of Castor JDO have been able to automatically 
            store/update or delete objects across relations by issuing ...
        </p><pre class="programlisting">
        
  Database.setAutostore(true)
        </pre><p>
            before going starting a transaction. This feature was useful, indeed, but 
            on a second look its limitation (global definition across all entities) 
            became obvious, especially on big projects. You might want to have 
            cascading operations activated selectively (activated for one object, 
            but not for another). Or even more tricky, you might like to automatically 
            track changes across one relation from a starting object, but but not 
            across another relation from the very same object.
        </p><p>
		    As of <span class="application">Castor 1.3.2</span>, a new 
		    <code class="literal">cascading</code> attribute has been introduced 
		    to the <code class="literal">&lt;sql&gt;</code> tag of the JDO mapping file.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.intended-audience"></a>3.9.6.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            This and all other cascading documents address people familiar with the 
            basic concepts of mapping domain entities to database tables and defining 
            relations between objects (on database level as well as on object level). 
            But in particular, this document applies to the following user groups:
        </p><div class="orderedlist"><ol type="1"><li><p>
                    Everyone who wants to cascade operations across (any type of) 
                    object relation(s).
                </p></li><li><p>
                    Everyone who now uses 
                    <code class="methodname">Database.setAutoStore(boolean)</code> to have 
                    persistence operations cascaded across relations.
                </p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                Especially the second user group should change their approach towards 
                using cascading operations, and switch to using the new cascading 
                attribute. As of <span class="application">Castor 1.3.2</span>, the current 
                <code class="methodname">Database.setAutoStore(boolean)</code> methods will 
                be <span class="emphasis"><em>deprecated</em></span>, and in the long run, 
                this operations will be removed from the JDO interfaces.
            </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.prerequisites"></a>3.9.6.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
        	You should have a valid mapping file, containing at least two objects, 
        	being in relation with each other. For the remainder of this document, 
        	we'll be using the following example mapping file as a starting point. 
		</p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.Author"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"OneToOne_Author"</span> /&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time_stamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.Book"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
    &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
    &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"OneToOne_Book"</span> /&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"timestamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"time_stamp"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"numeric"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"char"</span> /&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.Author"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span>/&gt;
    &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.attribute"></a>3.9.6.1.4.&nbsp;Use of the cascading attribute</h5></div></div></div><p>
			In order to activate cascading for create operations for the 
			<span class="database">author</span> relation defined in the mapping 
			file above, you have to add the following attribute to the field mapping 
			of the <code class="literal">author</code> property:
        </p><pre class="programlisting">
	  
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Book"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
   &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"none"</span> /&gt;
   ...
	
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Author"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create"</span>/&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
        </pre><p>
			Remember that the code above adding a cascading attribute with a value 
			of <code class="literal">create</code> is only an example. You can define any 
			combination of cascading attributes, delimiting those values by spaces, 
			as shown in the following example:
		</p><pre class="programlisting">
        
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.cascading.one_to_one.Author"</span>&gt;
   &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"author_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create update"</span>/&gt;
&lt;<span class="hl-tag">/field</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.attribute-values"></a>3.9.6.1.5.&nbsp;Values for the cascading attribute</h5></div></div></div><p>
        	In order to achieve an optimal granulation of activating and de-activating
        	functionality, there are 5 possible values, out of which 3 can be activated 
        	separately or in any combination.
        </p><p>
        	In general, what you have to keep in mind is that some cascading types 
        	do not only affect the the (coincidentally) identically named database 
        	operation, but also other persistence operations. For more details please 
        	read the following references carefully. 
       	</p><div class="itemizedlist"><ul type="disc"><li><p>
    		        <span class="bold"><strong>create</strong></span>: 
    		        <a href="jdo.html#jdo.howto.cascade-creation" title="3.9.6.2.&nbsp;How to cascade creation">details on create 
    		        operation</a>
    		    </p></li><li><p>
    		        <span class="bold"><strong>delete</strong></span>: 
    		        <a href="jdo.html#jdo.howto.cascade-deletion" title="3.9.6.3.&nbsp;How to cascade deletion">details on delete 
    		        operation</a>
    		    </p></li><li><p>
    		        <span class="bold"><strong>update</strong></span>: 
    		        <a href="jdo.html#jdo.howto.cascade-update" title="3.9.6.4.&nbsp;How to cascade update">details on update 
    		        operation</a>
    		    </p></li><li><p>
                    <span class="bold"><strong>none</strong></span>: cascading operations are disabled.
                </p></li><li><p>
                    <span class="bold"><strong>all</strong></span>: Using the value 
                    <code class="literal">all</code>, you are providing a shortcut specifying 
                    that all three basic operations should be defined at the same 
                    moment. This basically equals to a value of 
                    <code class="literal">'create delete update'</code>.
                </p></li></ul></div><p>
            If no cascading attribute is defined, its default value will be 
            <code class="literal">none</code>.            
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-cascading-operations.references"></a>3.9.6.1.6.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><a href="jdo.html#jdo.mapping" title="3.6.&nbsp;Castor JDO Mapping">JDO Mapping</a></p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-creation"></a>3.9.6.2.&nbsp;How to cascade creation</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.overview"></a>3.9.6.2.1.&nbsp;Overview</h5></div></div></div><p>
		    Cascading creation allows you to transfer some of the responsibilities 
		    of creating objects to <span class="application">Castor JDO</span>. 
		    To be more precise: if you enable cascading creation on a relation between 
		    two classes, all objects on one end of that relation that have not yet 
		    been created will be created when the other end gets persisted.
		    This saves you from manually creating every single object, which is 
		    especially useful when dealing with large object graphs that have 1:M 
		    (one to many) relations or many objects in a single relationship.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.enable"></a>3.9.6.2.2.&nbsp;Enabling cascading creation</h5></div></div></div><p>
            To enable cascading creation on a relation, you simply set the cascading 
            attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
            relation to "<code class="literal">create</code>" (or "<code class="literal">all</code>"):
        </p><p>
            In other words, the field mapping for the Java property 
            <span class="emphasis"><em>book</em></span> ...
        </p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>becomes</p><pre class="programlisting">
        
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"create"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
            In case of bidirectional relations, it does matters on which end you 
            enable cascading creation. It is also possible to enable it on both ends.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.scenarios"></a>3.9.6.2.3.&nbsp;Scenarios</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.db-create"></a>3.9.6.2.3.1.&nbsp;db.create()</h6></div></div></div><p>
                The most intuitive case is when you explicitly call 
                <code class="methodname">db.create()</code> on an object that has cascading 
                creation enabled on one or more of his relations. If the objects in 
                those relationships have not yet been created, they will be as part 
                of the <code class="methodname">create()</code> execution.
            </p><p>
                Here is a simple example, where the objects Author and Book are in a 
                one-to-one relation (i.e. every Book has exactly one Author):
            </p><pre class="programlisting">
			
db.begin();

Author author = <span class="hl-keyword">new</span> Author();
author.setId(1);
author.setName(<span class="hl-string">"John Jackson"</span>);

Book book = <span class="hl-keyword">new</span> Book();
book.setId(1);
book.setTitle(<span class="hl-string">"My Life"</span>);
book.setAuthor(author);

db.create(book);

db.commit();
            </pre><p>
                Once the commit operation has successfully completed, both the 
                <code class="classname">Author</code> and the <code class="classname">Book</code> 
                instance will have been persisted to your data store. To highlight 
                this, lets's have a look at the corresponding database tables 
                <span class="emphasis"><em>before</em></span> and <span class="emphasis"><em>after</em></span> the 
                execution of above code fragment.
            </p><p><span class="bold"><strong>Before</strong></span></p><p>
				</p><div class="table"><a name="d4e6783"></a><p class="title"><b>Table&nbsp;3.10.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="2">(empty table)</td></tr></tbody></table></div></div><p><br class="table-break">
            </p><p>
				</p><div class="table"><a name="d4e6796"></a><p class="title"><b>Table&nbsp;3.11.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="3">(empty table)</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p><span class="bold"><strong>After</strong></span></p><p>
				</p><div class="table"><a name="d4e6813"></a><p class="title"><b>Table&nbsp;3.12.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
				</p><div class="table"><a name="d4e6825"></a><p class="title"><b>Table&nbsp;3.13.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><p><br class="table-break">
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.db-commit"></a>3.9.6.2.3.2.&nbsp;db.commit()</h6></div></div></div><p>
                Cascading creation also works implicitly: any objects that are on the 
                receiving end of a cascaded relation will be created upon transaction 
                commit, provided they do not exist yet and that the object on the 
                primary end of that relation does. In other words: if you modify a 
                relation property of a loaded object, any new objects that now need 
                to be created will be created.
            </p><p>
                To demonstrate, let's continue the example from the previous section.
				We, again, have a <span class="database">Book</span> and an 
				<span class="database">Author</span>, in a one-to-one relation, 
				both already persisted. If we now change the book's author to someone 
				new, any object that is not yet in the database will be persisted 
				automatically. Just call <code class="methodname">db.commit()</code> after 
				setting the new author, and the new author will be persisted as well.
            </p><pre class="programlisting">
			
db.begin();

Author author = <span class="hl-keyword">new</span> Author();
author.setId(2);
author.setName(<span class="hl-string">"Bruce Willis"</span>);

Book book = db.load(Book.<span class="hl-keyword">class</span>, 1);
book.setAuthor(author);

db.commit();
        </pre><p>
                In terms of unit test assertions, the current state of the author and 
                book instances can be expressed as follows:
            </p><pre class="programlisting">
            
db.begin();

Book book = db.load(Book.<span class="hl-keyword">class</span>, 1);
assertNotNull(book);
assertEquals(1, book.getId());

Author author = book.getAuthor();
assertNotNull(author);
assertEquals(2, book.getId());

db.commit();</pre><p>
                As above, let's have a look at the corresponding database tables for 
                the entities <code class="classname">Author</code> and 
                <code class="classname">Book</code>: 
            </p><p><span class="bold"><strong>Before</strong></span></p><p>
				</p><div class="table"><a name="d4e6854"></a><p class="title"><b>Table&nbsp;3.14.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><p><br class="table-break">
		    </p><p>
				</p><div class="table"><a name="d4e6866"></a><p class="title"><b>Table&nbsp;3.15.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p><span class="bold"><strong>After</strong></span></p><p>
				</p><div class="table"><a name="d4e6882"></a><p class="title"><b>Table&nbsp;3.16.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr><tr><td>2</td><td>"Bruce Willis"</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
				</p><div class="table"><a name="d4e6897"></a><p class="title"><b>Table&nbsp;3.17.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>2</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>
                Please note that we now have two authors stored, and that the book 
                with an id value of '1' now has a foreign key relationship to the 
                author with the id value '2'.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-creation.scenarios.collections"></a>3.9.6.2.3.3.&nbsp;Cascading create and collections</h6></div></div></div><p>
                The real benefit of using cascading for object creation shows when 
                dealing with 1:M relations, usually expressed through Java collections 
                in your entity classes.
            </p><p>
                For the remainder of this secction, we will use the Java classes 
                <code class="classname">Department</code> and <code class="classname">Employee</code>, 
                which have a 1:M relationship (in other words, every department has 
                one or more employees). On the Java side, this is expressed as the 
                <code class="classname">Department</code> having a collection of 
                <code class="classname">Employee</code> objects in form of a Java collection. 
                In the database, this will obviously be the other way around, with the 
                <span class="database">emp</span> table referencing the 
                <span class="database">dept</span> table. Every example in this 
                section will use the same database state as a starting point, as 
                shown here:
            </p><div class="table"><a name="d4e6921"></a><p class="title"><b>Table&nbsp;3.18.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e6932"></a><p class="title"><b>Table&nbsp;3.19.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>Example 1: Adding objects</strong></span></p><pre class="programlisting">
			
db.begin();

Employee employee = <span class="hl-keyword">new</span> Employee();
employee.setId(4);
employee.setName(<span class="hl-string">"George"</span>);

Department department = db.load(Department.<span class="hl-keyword">class</span>, 23);
department.getEmployees().add(employee);

db.commit();
        </pre><p><span class="bold"><strong>After</strong></span></p><div class="table"><a name="d4e6958"></a><p class="title"><b>Table&nbsp;3.20.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e6969"></a><p class="title"><b>Table&nbsp;3.21.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>23</td></tr><tr><td>4</td><td>"George"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p><span class="bold"><strong>Example 2: Removing objects</strong></span></p><pre class="programlisting">
			
db.begin();

Department department = db.load(Department.<span class="hl-keyword">class</span>, 23);
department.getEmployees().remove(2);

db.commit();
            </pre><p><span class="bold"><strong>After</strong></span></p><div class="table"><a name="d4e6999"></a><p class="title"><b>Table&nbsp;3.22.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7010"></a><p class="title"><b>Table&nbsp;3.23.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>23</td></tr><tr><td>2</td><td>"Paul"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>NULL</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                    this of course only works if you allow the employee's foreign 
                    key <span class="database">dept_id</span> to be 
                    <code class="literal">NULL</code> or, alternatively, also delete the Employee 
                    when you remove the relationship (either by manually calling 
                    <code class="methodname">db.remove()</code> or <span class="emphasis"><em>TODO</em></span>)
                </p></td></tr></table></div><p>
			    <span class="bold"><strong>Example 3: Adding &amp; removing 
			    objects</strong></span>
			</p><pre class="programlisting">
			
db.begin();

Employee e4 = <span class="hl-keyword">new</span> Employee();
e4.setId(4);
e4.setName(<span class="hl-string">"George"</span>);

Employee e5 = <span class="hl-keyword">new</span> Employee();
e5.setId(5);
e5.setName(<span class="hl-string">"Joe"</span>);

Employee e6 = <span class="hl-keyword">new</span> Employee();
e6.setId(6);
e6.setName(<span class="hl-string">"Jack"</span>);

Department dep = db.load(Department.<span class="hl-keyword">class</span>, 23);
dep.setEmployees(Arrays.asList(e4, e5, e6));

db.commit();
            </pre><p>Database after:</p><div class="table"><a name="d4e7041"></a><p class="title"><b>Table&nbsp;3.24.&nbsp;dept</b></p><div class="table-contents"><table summary="dept" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>23</td><td>"Accounting"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7052"></a><p class="title"><b>Table&nbsp;3.25.&nbsp;emp</b></p><div class="table-contents"><table summary="emp" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th><th>dept_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John"</td><td>NULL</td></tr><tr><td>2</td><td>"Paul"</td><td>NULL</td></tr><tr bgcolor="#DEDEDE"><td>3</td><td>"Ringo"</td><td>NULL</td></tr><tr><td>4</td><td>"George"</td><td>23</td></tr><tr bgcolor="#DEDEDE"><td>5</td><td>"Joe"</td><td>23</td></tr><tr><td>6</td><td>"Jack"</td><td>23</td></tr></tbody></table></div></div><br class="table-break"><p>The note to example 2 also applies here.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-creation.see-also"></a>3.9.6.2.4.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="jdo.html#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How to use 
					cascading operations - overview</a>
		       </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-deletion"></a>3.9.6.3.&nbsp;How to cascade deletion</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.overview"></a>3.9.6.3.1.&nbsp;Overview</h5></div></div></div><p>
		    If you enable cascading deletion on a relationship, deleting the object 
		    on one end of the relationship (i.e. calling db.remove() on the object) 
		    will also delete the object on the other end.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.enable"></a>3.9.6.3.2.&nbsp;Enabling cascading deletion</h5></div></div></div><p>
		    To enable cascading deletion on a relationship you simply set the cascading 
		    attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
		    relation to "<code class="literal">delete</code>" (or "<code class="literal">all</code>"):
		</p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"delete"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
	        In case of bidirectional relationships, be aware that it matters on which 
	        end you enable cascading deletion. It is also possible to enable it on 
	        both ends.
	    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.scenarios"></a>3.9.6.3.3.&nbsp;Scenarios</h5></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-deletion.scenarios.db-remove"></a>3.9.6.3.3.1.&nbsp;db.remove()</h6></div></div></div><p>
			    Let's say we have the objects Author and Book and they are in a 
			    one-to-one relationship, with every <code class="classname">Book</code> 
			    having exactly one <code class="classname">Author</code>. The database looks 
			    like this:
			</p><div class="table"><a name="d4e7115"></a><p class="title"><b>Table&nbsp;3.26.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7126"></a><p class="title"><b>Table&nbsp;3.27.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"><p>Now, since we specified the relationship to cascade deletion, if we remove the book, 
				the author gets removed too (after all, an author without a book isn't really an author).</p><pre class="programlisting">
			
db.begin();

Book b1 = db.load(Book.<span class="hl-keyword">class</span>, 1);
db.remove(db1);

db.commit();
            </pre><p>Afterwards, the database predictably looks like this:</p><div class="table"><a name="d4e7142"></a><p class="title"><b>Table&nbsp;3.28.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="2">(empty table)</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7154"></a><p class="title"><b>Table&nbsp;3.29.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td colspan="3">(empty table)</td></tr></tbody></table></div></div><br class="table-break"><p>Cascading the deletion of objects in to-many relationships works in exactly the same way.</p><p>Note: You need to explicitly invoke db.remove() to delete an object. Simply setting a relational property to NULL
				or removing an item from a collection will not remove the corresponding entity from the database, even with cascading
				deletion enabled.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-deletion.see-also"></a>3.9.6.3.4.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="jdo.html#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How to use 
					cascading operations - overview</a>
			    </p></li></ul></div></div></div>
          
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.cascade-update"></a>3.9.6.4.&nbsp;How to cascade update</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.overview"></a>3.9.6.4.1.&nbsp;Overview</h5></div></div></div><p>
			When working with long transactions, you can cascade the 
			<code class="methodname">db.update()</code> operation, so that, for example, 
			updating the root of a large object graph causes all connected entities 
			to update as well (provided cascading update is enabled on the particular 
			relationships, of course).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.enable"></a>3.9.6.4.2.&nbsp;Enabling cascading update</h5></div></div></div><p>
		    To enable cascading update on a relationship you simply set the cascading 
		    attribute of the <code class="literal">&lt;sql&gt;</code> field describing the 
		    relation to "<code class="literal">update</code>" (or "<code class="literal">all</code>"):
		</p><pre class="programlisting">
		
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"myapp.Book"</span> &gt;
  &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"book_id"</span> <span class="hl-attribute">cascading</span>=<span class="hl-value">"update"</span> /&gt;
&lt;<span class="hl-tag">/field</span>&gt;
     </pre><p>
            In case of bidirectional relationships, be aware that it matters on which 
            end you enable cascading update. It is also possible to enable it on both 
            ends.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.scenarios"></a>3.9.6.4.3.&nbsp;Scenarios</h5></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.cascade-update.scenarios.db-update"></a>3.9.6.4.3.1.&nbsp;db.update()</h6></div></div></div><p>
			    Let's say we have the objects Author and Book and they are in a 
			    one-to-one relationship, with every <code class="classname">Book</code> 
			    having exactly one <code class="classname">Author</code>. The database looks 
			    like this:
			</p><div class="table"><a name="d4e7200"></a><p class="title"><b>Table&nbsp;3.30.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7211"></a><p class="title"><b>Table&nbsp;3.31.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"><p>
			    Now let's change the book's title. Note that we never directly load 
			    the book and that the change happens outside of any transaction:
			</p><pre class="programlisting">
			
db.begin();
Author a1 = db.load(Author.<span class="hl-keyword">class</span>, 1);
db.commit();

a1.getBook().setName(<span class="hl-string">"My Fantastic Life"</span>);

db.begin();
db.update(a1);
db.commit();
            </pre><p>Afterwards, the database looks like this:</p><div class="table"><a name="d4e7227"></a><p class="title"><b>Table&nbsp;3.32.&nbsp;Author</b></p><div class="table-contents"><table summary="Author" border="1"><colgroup><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>name</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"John Jackson"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e7238"></a><p class="title"><b>Table&nbsp;3.33.&nbsp;Book</b></p><div class="table-contents"><table summary="Book" border="1"><colgroup><col><col><col></colgroup><thead><tr bgcolor="#7270c2"><th>id</th><th>title</th><th>author_id</th></tr></thead><tbody><tr bgcolor="#DEDEDE"><td>1</td><td>"My Fantastic Life"</td><td>1</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.limitations"></a>3.9.6.4.4.&nbsp;Limitations</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>To-many relationships are currently not supported (except many-to-one).</p></li><li><p>As it is now, enabling cascading update will cause db.update() to also create any entities 
					that have not yet been persisted. (In other words: setting cascading to "update" has the same 
					effect as setting it to "update create", but only when invoking db.update().)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.cascade-update.see-also"></a>3.9.6.4.5.&nbsp;See also</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a href="jdo.html#jdo.howto.use-cascading-operations.overview" title="3.9.6.1.1.&nbsp;Overview">How 
					to use cascading operations - overview</a>
			    </p></li></ul></div></div></div>
      </div>


      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.caches"></a>3.9.7.&nbsp;Caches</h3></div></div></div>
          
              
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster"></a>3.9.7.1.&nbsp;How to use Castor in a J2EE cluster</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.introduction"></a>3.9.7.1.1.&nbsp;Introduction</h5></div></div></div><p>
            With release 0.9.9, several cache providers have been added that are 
            distributed caches per se or can be configured to operate in such a mode. 
            This effectively allows <span class="application">Castor JDO</span> to be used 
            in a clustered J2EE (multi-JVM) environment, where 
            <span class="application">Castor JDO</span> runs on each of the cluster 
            instances, and where cache state is automatically synchronized between 
            these instances.
        </p><p>
            In such an environment, <span class="application">Castor JDO</span> will make 
            use of the underlying cache provider to replicate/distribute the content 
            of a specific cache between the various JDOManager instances. Through 
            the distribution mechanism of the cache provider, a client of a 
            <span class="application">Castor JDO</span> instance on one JVM will see any 
            updates made to domain objects performed against any other JVM/JDO instance.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.intended-audience"></a>3.9.7.1.2.&nbsp;Intended Audience</h5></div></div></div><p>
            Anyone who wants to use <span class="application">Castor JDO</span> in a 
            J2EE cluster.
        </p><p>
            The example given describes the use of the <span class="emphasis"><em>Coherence</em></span> 
            cache provider to enable distributed caching.
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.prerequisites"></a>3.9.7.1.3.&nbsp;Prerequisites</h5></div></div></div><p>
            You should have a valid class mapping for a Java class, similar to the 
            following one:
        </p><pre class="programlisting">
        
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps"></a>3.9.7.1.4.&nbsp;Steps</h5></div></div></div><p>Here is how to proceed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps.add-cache-type"></a>3.9.7.1.4.1.&nbsp;Add &lt;cache-type&gt; element to class mapping</h6></div></div></div><p>
                Add a <code class="literal">&lt;cache-type&gt;</code> element as shown below, 
                specifying the cache provider to use in the '<code class="literal">type</code>' 
                attribute.
            </p><pre class="programlisting">
            
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyOtherObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">cache-type</span> <span class="hl-attribute">type</span>=<span class="hl-value">"coherence"</span>/&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
               ...
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
                This instructs <span class="application">Castor JDO</span> to use the 
                '<code class="literal">coherence</code>' cache provider for objects of type
                <code class="classname">com.xyz.MyOtherObject</code>. It is the cache provider 
                that is responsible to distribute any changes to the cache state to 
                all other <span class="application">Castor JDO</span> instances within the 
                same cluster.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.steps.add-coherence-jars"></a>3.9.7.1.4.2.&nbsp;Add Coherence JARs to CLASSPATH</h6></div></div></div><p>
                Add the Coherence JARs to the class path of your e.g. web application 
                by putting the JARs into the 
                <code class="filename">WEB-INF/lib</code> folder of your 
                web application.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-castor-in-a-j2ee-cluster.references"></a>3.9.7.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><a href="advanced-jdo.html#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">Caching</a></p></li><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.caching.configuration.clustered-environments" title="4.1.5.&nbsp;Caching and clustered environments">Caching 
                    and clustered environments</a>
                </p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.tangosol.com/coherence.jsp" target="_top">Tangosol 
                    Coherence</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.connection-pooling"></a>3.9.8.&nbsp;Connection pooling</h3></div></div></div>
          
        
          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.use-jakarta-dbcp"></a>3.9.8.1.&nbsp;How to use Jakarta's DBCP for connection pooling</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.introduction"></a>3.9.8.1.1.&nbsp;Introduction</h5></div></div></div><p>
            This HOW-TO provide users with instructions on hot to configure
            <span class="application">Castor JDO</span> so that Apache Jakarta's DBCP 
            package is used as a connection pool.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.intended-audience"></a>3.9.8.1.2.&nbsp;Intended audience</h5></div></div></div><p>
            Anyone who wants to use DBCP as connection pool mechanism with 
            <span class="application">Castor JDO</span>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.steps"></a>3.9.8.1.3.&nbsp;Steps</h5></div></div></div><p>
            Below are defined the steps to configure 
            <span class="application">Castor JDO</span> to use DBCP's 
            <code class="literal">BasicDataSource</code> for connection pooling.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.use-jakarta-dbcp.steps.configuration"></a>3.9.8.1.3.1.&nbsp;Configuration</h6></div></div></div><p>
                To use a DBCP <code class="literal">BasicDataSource</code> with 
                <span class="application">Castor JDO</span>, please provide the following 
                <code class="literal">&lt;data-source&gt;</code> entry in the 
                <code class="filename">jdo-conf.xml</code> file.
            </p><pre class="programlisting">
            
  &lt;<span class="hl-tag">data-source</span> <span class="hl-attribute">class-name</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driver-class-name"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"com.mysql.jdbc.Driver"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:mysql://localhost/test"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"min-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"10"</span> /&gt;
    &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"max-active"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"40"</span> /&gt;
  &lt;<span class="hl-tag">/data-source</span>&gt;
            </pre><p>
                Above example makes use of the <span class="emphasis"><em>mySQL</em></span> JDBC driver 
                to establish a connection pool to a <span class="application">mySQL</span> 
                instance named 'test' running on the same machine as Castor itself. 
                The pool initially holds 10 connections, but is configured to allow 
                a maximum of 40 active connections at the same time.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.use-jakarta-dbcp.references"></a>3.9.8.1.4.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Other pooling examples</a>
                </p></li></ul></div></div></div>
      </div>


      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.castor-in-j2ee-apps"></a>3.9.9.&nbsp;Use of Castor in J2EE applications</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.howto.distributed-transactions"></a>3.9.9.1.&nbsp;How to use Castor with(in) distributed J2EE transactions</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.overview"></a>3.9.9.1.1.&nbsp;Overview</h5></div></div></div><p>
            J2EE applications depend on the J2EE container (hosting Servlet, EJB, etc) 
            to configure a database connection (as well as other resource managers) 
            and use JNDI to look it up. This model allows the application deployer 
            to configure the database properties from a central place, and gives the 
            J2EE container the ability to manage distributed transactions across 
            multiple data sources.
        </p><p>
            This HOW-TO shows how to seamlessly use 
            <span class="application">Castor JDO</span> in such a managed environment, 
            and how to make <span class="application">Castor</span> participate in a 
            distributed transaction.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.intended-audience"></a>3.9.9.1.2.&nbsp;Intended audience</h5></div></div></div><p>
            Anyone who wants to use <span class="application">Castor JDO</span> with(in) 
            distributed J2EE transactions.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.steps"></a>3.9.9.1.3.&nbsp;Steps</h5></div></div></div><p>
            The following sections highlight the steps necessary to use 
            <span class="application">Castor JDO</span> seamlessly in such a (managed) 
            environment, and how to make <span class="application">Castor</span> participate 
            in a distributed transaction.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.j2ee-participation"></a>3.9.9.1.3.1.&nbsp;Make Castor participate in a J2EE transaction</h6></div></div></div><p>
                The following code fragment shows how to use JNDI to lookup a database 
                and how to use a JTA <code class="classname">UserTransaction</code> instance 
                to manage the J2EE (aka distributed) transaction:
            </p><pre class="programlisting">
<span class="hl-comment">// Lookup databse in JNDI</span>
Context ctx = <span class="hl-keyword">new</span> InitialContext();
Database db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Begin a transaction</span>
UserTransaction ut = (UserTransaction) ctx.lookup( <span class="hl-string">"java:comp/UserTransaction"</span> );
ut.begin();
<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Commit the transaction, close database</span>
ut.commit();
db.close();
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.container-managed"></a>3.9.9.1.3.2.&nbsp;Make Castor participate in container-managed J2EE transaction</h6></div></div></div><p>
                If the transaction is managed by the container, a common case with 
                EJB beans and in particular entity beans, there is no need to 
                begin/commit the transaction explicitly. Instead the application 
                server takes care of enlisting the database used by 
                <span class="application">Castor JDO</span> to insert domain entities into 
                a database in the ongoing transaction and commiting/rolling back at 
                the relevant time.
            </p><p>
                The following code snippet relies on the container to manage the 
                transaction.
            </p><pre class="programlisting">
InitialContext  ctx;
UserTransaction ut;
Database        db;

<span class="hl-comment">// Lookup databse in JNDI</span>
ctx = <span class="hl-keyword">new</span> InitialContext();
db = (Database) ctx.lookup( <span class="hl-string">"java:comp/env/jdo/mydb"</span> );

<span class="hl-comment">// Do something</span>
. . .
<span class="hl-comment">// Close the database</span>
db.close();
            </pre><p>
                As transaction enregistration is dealt with at the J2EE container, 
                it is not necessary anymore to obtain a 
                <code class="classname">UserTransaction</code> and start/commit the transaction 
                manually.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="jdo.howto.distributed-transactions.steps.resource-enlisting"></a>3.9.9.1.3.3.&nbsp;Resource enlisting</h6></div></div></div><p>
                Instead of constructing required resources directly, a typical J2EE 
                application uses the JNDI API to look up resources from centrally 
                managed place such as a naming and directory service. In such an 
                environment, <span class="application">Castor JDO</span> takes on the role 
                of a managed resource as well. It follows that, instead of constructing 
                a <code class="classname">org.exolab.castor.jdo.JDOManager</code> directly, 
                a typical J2EE application should use <span class="application">JNDI</span> 
                to look it up.
            </p><p>
                We thus recommend enlisting the <code class="classname">JDOManager</code> 
                object under the <code class="literal">java:comp/env/jdo</code> namespace, 
                compatible with the convention for listing JDBC resources.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.tips"></a>3.9.9.1.4.&nbsp;Tips</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
			        When using <span class="application">Castor JDO</span> in a J2EE 
			        environment, <span class="application">Castor</span> allows you to 
			        enable a special Database instance pooling support. 
			        This option is configured via the 
			        <code class="methodname">org.exolab.castor.jdo.JDOManager.setDatabasePooling(boolean)</code>
				    method; by default, it is turned off. This option only affects 
				    <code class="classname">JDOManager</code> if J2EE transactions are used 
				    and if a transaction is associated with the thread that calls 
				    {@link #getDatabase}.
				</p><p>
				    If database pooling is enabled, <code class="classname">JDOManager</code> 
				    will first search in this special pool to see if there is already 
				    a <code class="classname">org.exolab.castor.jdo.Database</code> instance 
				    for the current transaction. If found, it returns this 
				    <code class="classname">org.exolab.castor.jdo.Database</code> instance; 
				    if not, it creates a new one, associates it will the transaction 
				    and returns the newly created 
				    <code class="classname">org.exolab.castor.jdo.Database</code> instance.
				 </p><p>
				     Please make sure that you call this method before calling 
				     {@link #getDatabase}.
				 </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdo.howto.distributed-transactions.references"></a>3.9.9.1.5.&nbsp;References</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
                    <a href="advanced-jdo.html#advanced-jdo.pooling" title="4.8.&nbsp;Using Pooled Database Connections">Other pooling examples</a>
                </p></li></ul></div></div></div>
      </div>
        
        
      <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.howto.database-specifica"></a>3.9.10.&nbsp;Database specifica</h3></div></div></div>
          

          <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e7420"></a>3.9.10.1.&nbsp;
                  How to connect to a Apache Derby instance in network server mode
              </h4></div></div></div>
              
          </div>
      </div>
  </div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.tips-tricks"></a>3.10.&nbsp;Castor JDO - Tips &amp; Tricks</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.logging-tracing"></a>3.10.1.&nbsp;Logging and Tracing</h3></div></div></div><p>
         When developing using Castor, we recommend that you use the various
         <code class="literal">setLogWriter</code> methods to get detailed information and error
         messages.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.mapping.Mapping</code> 
         will provide detailed information about mapping decisions made by Castor and
         will show the SQL statements being used.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.jdo.JDO</code> 
         will provide trace messages that show when Castor is loading, storing, 
         creating and deleting objects. All database operations will appear in 
         the log; if an object is retrieved from the cache or is not modified, 
         there will be no trace of load/store operations.
      </p><p>
         Using a logger with <code class="classname">org.exolab.castor.xml.Unmarshaller</code> 
         will provide trace messages that show conflicts between the XML document and
         loaded objects.
      </p><p>
         A simple trace logger can be obtained from
         <code class="classname">org.exolab.castor.util.Logger</code>. This logger uses the
         standard output stream, but prefixes each line with a short message
         that indicates who generated it. It can also print the time and date of
         each message. Since logging is used for warning messages and simple
         tracing, Castor does not require a sophisticated logging mechanism.
      </p><p>
         Interested in integratating Castor's logging with Log4J? Then see
         <a href="jdo.html#jdo.faq.logging.log4j" title="3.7.11.1.&nbsp; How can I integrate Castor's logging with a logging infrastructure using Log4J?">this question</a> 
         in the JDO FAQ.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.access-mode"></a>3.10.2.&nbsp;Access Mode</h3></div></div></div><p>
         If you are using JDO objects with the default access mode ('shared') and too many transactions
         abort when attempting to commit due to locks, you should consider upgrading to an 'exclusive'
         mode. When two transactions attempt to modify and store the same object at the same time,
         lock issues arise. Upgrading to an 'exclusive' mode will prevent concurrent transactions
         from modifying the same object at once.
      </p><p>
         If too many transactions abort when attempting to commit due to dirty checking, you should
         consider upgrading to a 'locked' mode. When external database access modifies the same objects
         being managed by Castor, Castor will complain that objects are dirty. Upgrading to a 'locked'
         mode will prevent concurrent update.
      </p><p>
         Be advised that 'exclusive' mode introduces lock contention in the Castor persistence engine,
         and 'locked' mode adds lock contention in the database. Lock contention has the effect of
         slowing down the application and consuming more CPU.
      </p><p>
         If too many transaction abort due to deadlock detection, consider modifying the application
         logic. Deadlock occurs when two transactions attempt to access the same objects but not in
         the same order.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.inheritence"></a>3.10.3.&nbsp;Inheritence</h3></div></div></div><p>
         There are two types of inheritence: Java inheritence and relational inheritence.
      </p><p>
         With Java inheritence, two objects extend the same base class and map to two different
         tables. The mapping file requires two different mappings for each of the objects.
         For example, if <code class="literal">Employee</code> and <code class="literal">Customer</code> both 
         extend <code class="literal">Person</code>, but <code class="literal">Employee</code> maps to the table 
         <code class="literal">emp</code> and <code class="literal">Person</code> to the table 
         <code class="literal">person</code>, the mapping file should map both of these objects 
         separately.
      </p><p>
         With relation inheritence, one table provides the base information and another table
         provides additional information using the same primary keys in both. Use the <code class="literal">extends</code>
         attribute to specify such inheritence in the mapping file. For example, if <code class="literal">Computer</code>
         extends <code class="literal">Product</code> and the table <code class="literal">comp</code> provides computer-specific columns
         in addition to product columns in <code class="literal">prod</code>, the mapping for <code class="literal">Computer</code> will
         specify <code class="literal">Product</code> as the extended class.
      </p><p>
         When a class just extends a generic base class or implements an interface, this form
         of inheritence is not reflected in the mapping file.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.views-of-the-same-object"></a>3.10.4.&nbsp;Views of Same Object</h3></div></div></div><p>
         It is possible to use different objects and mappings to the same tables. For example,
         it is possible to define a subset of a table and load only several of the columns,
         or load an object without its relations.
      </p><p>
         To determine the first and last names and e-mail address of an object without loading
         the entire person object, create a subset class and map that class to a portion of
         the table. Such a class cannot be used to create a new person, but can be used to
         delete or modify the person's details.
      </p><p>
         Use partial views with care. If you attempt to load the same record using a full
         object and a subset object, changes to one of these objects are allowed, but
         changes to both will result in a conflict and roll back the transaction.
         Locking will not work properly between full and subset objects.
         Also note, that each of the two objects will have its own cache, so
         if you update the first object and load the second, you may obtain old values.
         To avoid this situation you may turn off the cache for both objects:
         </p><pre class="programlisting">
             &lt;class ... &gt;
                &lt;cache-type type="none"&gt;
                ...
             &lt;/class&gt;
         </pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.upgrading-locks"></a>3.10.5.&nbsp;Upgrading Locks</h3></div></div></div><p>
         When an object is loaded into memory in the default access mode ('shared'),
         a read lock is acquired on that object. When the transaction commits, if there
         are changes to the object a write lock will be required. There is no guarantee
         that a write lock can be acquired, e.g. if another transaction attempts to
         change the same object at the same time.
      </p><p>
         To assure concurrent access, you may upgrade the object's lock by calling the
         <code class="methodname">org.exolab.castor.jdo.Database.lock(java.lang.Object)</code> 
         method. This method will either acquire a write lock or return if a timeout 
         elapses and the lock could not be acquired. Once a lock has been acquired, 
         no other transaction can attempt to read the object until the current 
         transaction completes.
      </p><p>
         Object locking is recommended only if concurrent access results in conflicts
         and aborted transactions. Generally locks results in lock contention which has an
         effect on performance.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.noclassdeffounderror"></a>3.10.6.&nbsp;NoClassDefFoundError</h3></div></div></div><p>
          Check your CLASSPATH, check it often, there is no reason not to!
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.tips-tricks.create-method"></a>3.10.7.&nbsp;Create method</h3></div></div></div><p>
         Castor requires that classes have a public, no-argument constructor
         in order to provide the ability to marshal &amp; unmarshal objects of that type.
      </p><p>
         create-method is an optional attribute to the <code class="literal">&lt;field&gt;</code> 
         mapping element that can be used to overcome this restriction in cases where 
         you have an existing object model that consists of, say, singleton classes
         where public, no-argument constructors must not be present by definition.
      </p><p>
         Assume for example that a class "<code class="literal">A</code>" that you want to be 
         able to unmarshal uses a singleton class as one of its properties. When
         attempting to unmarshal class "<code class="literal">A</code>", you should get an 
         exception because the singleton property has no public no-arg constructor.
         Assuming that a reference to the singleton can be obtained via a static
         getInstance() method, you can add a "create method" to class 
         <code class="literal">A</code> like this:
      </p><pre class="programlisting">
         
            public MySingleton getSingletonProperty()
            {
               return MySingleton.getInstance();
            }
      </pre><p>
         and in the mapping file for class A, you can define the singleton
         property like this:
      </p><pre class="programlisting">
         
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySingletonProperty"</span>
                  <span class="hl-attribute">type</span>=<span class="hl-value">"com.u2d.MySingleton"</span>
                  <span class="hl-attribute">create-method</span>=<span class="hl-value">"getSingletonProperty"</span>&gt;
               &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my-singleton-property"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
      </pre><p>
         This illustrates how the create-method attribute is quite a useful
         mechanism for dealing with exceptional situations where you might
         want to take advantage of marshaling even when some classes do not
         have no-argument public constructors.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
	        As of this writing, the specified 
	        create-method must exist as a method in the current class (i.e. the class 
	        being described by the current <code class="literal">&lt;class&gt;</code> element). 
	        In the future it may be possible to use external static factory methods.
	      </p></td></tr></table></div></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.advanced-features"></a>3.11.&nbsp;Castor JDO - Advanced features</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.introduction"></a>3.11.1.&nbsp;Introduction</h3></div></div></div><p>
           As explained at 
           <a href="jdo.html#jdo.introduction" title="3.1.&nbsp;Castor JDO - An introduction">the introduction to Castor JDO</a>,
           Castor has support for many advanced features such as caching, depend 
           relations, inheritance, polymorphism, etc. The below sections detail these 
           features, as their understanding is required to use Castor JDO in a 
           performant and secure way.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.caching"></a>3.11.2.&nbsp;Caching</h3></div></div></div><p>
           All information related to caching and related concepts supported 
           by Castor has been consolidated into one place, and is available 
           <a href="advanced-jdo.html#advanced-jdo.caching" title="4.1.&nbsp;Castor JDO - Caching">here</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.dependent-and-related"></a>3.11.3.&nbsp;Dependent and related relationships</h3></div></div></div><p>
           Castor distinguishes the relationship of two objects as dependent or related, 
           and maintains the life cycle independently for the two types of relationships. 
           Starting from Castor 0.9, the developer can explicitly define a dependent 
           relationship in the mapping file.
        </p><p>
           When using independent relations, related objects' life cycle is independent 
           of each other, meaning that they have to be created, removed and updated 
           (for long transaction) independently.
        </p><p>
           When using dependent relations, one data object class must be declared as 
           <span class="bold"><strong>depends</strong></span> on one other data object class in 
           the mapping file, and such an object is called a dependent data object class. 
           A data object class without <code class="literal">depends</code> 
           declared in the mapping is called a master object. A master object can be 
           depended upon by zero or more dependent data object class.
        </p><p>
           As of Castor 0.9, a dependent object class can be related to other master data 
           object classes including extended classes, but cannot depend on more than one 
           master class.
        </p><p>
           If an object class declared as <code class="literal">depends</code> 
           on another class, it may not be created, removed or updated separately. 
           Attempting to create, remove or update a dependent object will result in 
           ObjectNotPersistcapableException. Note that Castor doesn't allow a 
           dependent object instance to change its master object instance during a 
           transaction. Each dependent object can have only one master object. 
           Both dependent and master objects must have identities, and may or may 
           not make use of key-generators.
        </p><p>
            Here is the DTD for declaring dependent object:
            
            </p><pre class="programlisting">
&lt;!ATTLIST class     name ID  #REQUIRED
          extends   IDREF    #IMPLIED
          depends   IDREF    #IMPLIED
          identity  CDATA   #IMPLIED
          access    ( read-only | shared | exclusive | db-locked )  "shared"
          key-generator   IDREF #IMPLIED
            </pre><p>
        </p><p>
            For example,
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyDependentObject"</span>
        <span class="hl-attribute">depends</span>=<span class="hl-value">"com.xyz.MyObject"</span>&gt;
        ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
            declares the data object class 
            <code class="classname">com.xyz.MyDependentObject</code> as a dependent 
            upon class <code class="classname">com.xyz.MyObject</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.different-cardinalities"></a>3.11.4.&nbsp;Different cardinalities of relationship</h3></div></div></div><p>
           Castor supports different cardinalities of relationship, namely one-to-one, 
           one-to-many, and many-to-many. Many-to-many relationship must be related 
           rather than dependent, because each dependent object can have only one 
           master object.
        </p><p>
           Many-to-many requires a separate table for storing the relations between 
           two types of objects. Many-to-many introduces two attributes, namely 
           many-key and many-table that reside in the <code class="literal">&lt;sql&gt;</code> 
           element which is a sub-element of the <code class="literal">&lt;field&gt;</code>
           element. For all many-to-many relations, a many-table must be specified. 
           If the column name of the primary key of the class is different from the 
           foreign keys columns of the class in the relation tables, then the relation 
           table columns can be specified using the many-key attributes. Similarly, 
           if the column name of the primary key of the related class is different 
           from the foreign key columns of the related class, then the relation table 
           columns can be specified using the name attribute.
        </p><p>
            The many-table is used to store relations in a separate table
            
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span>&gt;
        &lt;<span class="hl-tag">field</span>&gt;
            &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"#OPTIONAL"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"#OPTIONAL"</span>
                 <span class="hl-attribute">many-table</span>=<span class="hl-value">"#REQURIED"</span>&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
        </p><p>
            So, for example, if the SQL table is the following,

            </p><div class="table"><a name="d4e7536"></a><p class="title"><b>Table&nbsp;3.34.&nbsp;employee_table</b></p><div class="table-contents"><table summary="employee_table" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>id</th><th>name</th><th>salary</th></tr></thead><tbody><tr><td>1482</td><td>Smith, Bob</td><td>$123,456</td></tr><tr><td>628</td><td>Lee, John</td><td>$43,210</td></tr><tr><td>1926</td><td>Arnold, Pascal</td><td>$24,680</td></tr></tbody></table></div></div><p><br class="table-break">


            </p><div class="table"><a name="d4e7557"></a><p class="title"><b>Table&nbsp;3.35.&nbsp;department_table</b></p><div class="table-contents"><table summary="department_table" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>id</th><th>name</th><th>comment</th></tr></thead><tbody><tr><td>3</td><td>Accounting</td><td>&nbsp;</td></tr><tr><td>7</td><td>Engineering</td><td>The very important department. :-)</td></tr></tbody></table></div></div><p><br class="table-break">


            </p><div class="table"><a name="d4e7574"></a><p class="title"><b>Table&nbsp;3.36.&nbsp;employee_department</b></p><div class="table-contents"><table summary="employee_department" border="1"><colgroup><col><col></colgroup><thead><tr><th>e_id</th><th>d_id</th></tr></thead><tbody><tr><td>....</td><td>....</td></tr></tbody></table></div></div><p><br class="table-break">
        </p><p>
            Then, the mapping for employee data object would look like this
                </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"id"</span>&gt;
        &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"employee_table"</span>/&gt;
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span>/&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
            &lt;<span class="hl-tag">field</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-table</span>=<span class="hl-value">"employee_department"</span>
                     <span class="hl-attribute">many-key</span>=<span class="hl-value">"e_id"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"d_id"</span>/&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
            &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"salary"</span>&gt;
                &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"salary"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
            &lt;<span class="hl-tag">/field</span>&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.lazy-loading"></a>3.11.5.&nbsp;Lazy Loading</h3></div></div></div><p>
		   As of release 0.9.6, Castor has full support for lazy loading object 
		   instances referenced as part of all relation types currently supported:
		</p><div class="itemizedlist"><ul type="disc"><li><p>1:1 relations</p></li><li><p>1:m relations</p></li><li><p>M:N relations.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.advanced-features.1-to-1-relations"></a>3.11.5.1.&nbsp;1:1 relations</h4></div></div></div><p>
        	   As of release 0.9.6, Castor supports lazy-loading of 1:1 relations. 
        	   Imagine the following class mapping:
        	</p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xzy.Department"</span>&gt;
       ...
       &lt;<span class="hl-tag">field</span> <span class="hl-attribute">"employee"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span> /&gt;
       ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
            </pre><p>
			   Per definition, when an instance of Department is loaded through e.g. 
			   Database.load(), Castor will not (pre-)load the Employee instance 
			   referenced (as such reducing the size of the initial query as well 
			   as the size of the result set returned). Only when the Emplyoee 
			   instance is accessed through Department.getEmployee(), Castor will load 
			   the actual object into memory from the persistence store.
			</p><p>
			   This means that if the Employee instance is not accessed at all, not 
			   only will the initial query to load the Department object have had its 
			   complexity reduced, but no performance penalty will be incurred for the 
			   additional access to the persistence store either.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdo.advanced-features.m-to-n-relations"></a>3.11.5.2.&nbsp;1:M and M:N relations</h4></div></div></div><p>
              The elements in the collection are only loaded when the application asks 
              for the object from the collection, using, for example, iterator.next(). 
              The iterator in Castor's lazy collection is optimized to return a loaded 
              object first.
           </p><p>
              In the mapping file, lazy loading is specified in the element of the 
              collection's <code class="literal">&lt;field&gt;</code>, for example,
           </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xzy.Department"</span>&gt;
       ...
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"employee"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"com.xyz.Employee"</span> <span class="hl-attribute">lazy</span>=<span class="hl-value">"true"</span>
               <span class="hl-attribute">collection</span>=<span class="hl-value">"collection"</span>/&gt;
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
              declares that the collection of type Employee in a Department is lazy loaded.
           </p><p>
              If lazy loading is specified for a field of a class, Castor will set the 
              field with a special collection which contains only the identities of the 
              objects. Because of that, it requires the data object to have the method 
              setDepartment( Collection department) in the data object class which was 
              not required in previous versions.
           </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                 Please note that currently <span class="bold"><strong>only</strong></span> the 
                 <span class="bold"><strong><span class="type">java.util.Collection</span></strong></span> 
	             type is supported. 
              </p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.multiple-cols-primary-keys"></a>3.11.6.&nbsp;Multiple columns primary keys</h3></div></div></div><p>
            The support of multiple column primary keys (also called compound primary 
            keys) was another major enhancement added into Castor 0.9. 
            Specifying multiple column primary keys is simple and straightforward, 
            in the mapping file, 
            </p><pre class="programlisting">
&lt;<span class="hl-tag">mapping</span>&gt;
    &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.xyz.MyObject"</span> <span class="hl-attribute">identity</span>=<span class="hl-value">"firstName lastName"</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"firstName"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"fname"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
        &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lastName"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
           &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"lname"</span>/&gt;
        &lt;<span class="hl-tag">/field</span>&gt;
           ...
    &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
           Multiple column primary keys work with both master and dependent objects, 
           all cardinalities of relationship, including one-to-one, one-to-many and 
           many-to-many, as well as lazy loading. 
        </p><p>
           However, multiple column primary keys should only be used to adhere to an 
           existing database design, not when designing a new database. In general, 
           it is not a good idea to use an identity or identities which can be modified 
           by the user, or which contain application-visible data. For example, if the 
           system allows the user name to be changed, using user name as identity is 
           highly discouraged, as this practice can require a major data migration to 
           a new schema to update all foreign keys to adhere to a new primary key 
           structure, should the user name no longer be adequate as a primary key. 
           It should be noted that Castor doesn't support identity change, as specified 
           in the ODMG 3.0 specification. So, primary keys changes are almost certainly 
           a large trade off between data integrity and performance. Well chosen 
           primary keys are usually single (not multiple) column numeric or character 
           fields for the reasons outlined above, as well as performance, as joining 
           operations are faster for single column primary keys.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.advanced-features.callback-interface"></a>3.11.7.&nbsp;Callback interface for persistent operations</h3></div></div></div><p>
            For the various persistence operations as available through the 
            <span class="interface">org.exolab.castor.jdo.Database</span> interface, 
            Castor JDO provides a callback interface that informs the implementing 
            class on events taking place related to selected persistence operations.
         </p><p>
            Once your entity class implements the 
            <span class="interface">org.exolab.castor.jdo.Persistence</span> interface, 
            you'll have to provide implementations for the following methods (with 
            their respective semantics described next to them):
         </p><div class="table"><a name="d4e7628"></a><p class="title"><b>Table&nbsp;3.37.&nbsp;Interface methods</b></p><div class="table-contents"><table summary="Interface methods" border="1"><colgroup><col><col></colgroup><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>jdoAfterCreate()</td><td>
	                    Indicates that an object has been created in persistent storage.
	                </td></tr><tr><td>jdoAfterRemove()</td><td>
	                     Indicates that an object has been removed from persistent storage.
	                </td></tr><tr><td>jdoBeforeCreate()</td><td>
	                    Indicates that an object is to be created in persistent storage.
	                </td></tr><tr><td>jdoBeforeRemove()</td><td>
	                    Indicates that an object is to be removed from persistent storage.
	                </td></tr><tr><td>jdoLoad()</td><td>
	                    Indicates that the object has been loaded from persistent storage.
	                </td></tr><tr><td>jdoPersistent(Database)</td><td>
	                    Sets the database to which this object belongs when this object 
	                    becomes persistent.
	                </td></tr><tr><td>jdoStore()</td><td>Indicates that an object is to be stored in persistent storage.
	                </td></tr><tr><td>jdoTransient()</td><td>Indicates the object is now transient.</td></tr><tr><td>jdoUpdate()</td><td>
	                    Indicates that an object has been included to the current 
	                    transaction by means of db.update() method (in other words, 
	                    at the end of a "long" transaction).
	                </td></tr></tbody></table></div></div><br class="table-break"></div></div>
  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdo.self-executable-examples"></a>3.12.&nbsp;Running the self-executable Castor JDO examples</h2></div><div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span class="firstname">Werner</span> <span class="surname">Guttmann</span> 
            ()
            </span></div></div></div></div><p>
      As of release 1.0M3, the Castor JDO examples have been packaged in a
      new way and are available for download at the
      <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/download.html" target="_top">download page</a>. In the 
      following sections, we explain the steps required to unpack this new archive, 
      and how to execute the tests.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.zip-archive"></a>3.12.1.&nbsp;Download the castor-$RELEASE-examples.zip archive</h3></div></div></div><p>
        In order to be able to run the new Castor JDO examples, please download
        the new <code class="literal">castor-</code>${RELEASE}<code class="literal">-examples.zip</code> from the
        <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://castor.org/download.html" target="_top">download page</a> and put it into 
        some location on your computer.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.unpack-zip"></a>3.12.2.&nbsp;Unpack the ZIP file</h3></div></div></div><p>
        To unpack the ZIP file downloaded, issue one of the following commands:
      </p><pre class="programlisting">unzip castor-1.1M2-examples.zip</pre><p>or</p><pre class="programlisting">jar xvf castor-1.1M2-examples.zip</pre><p>
        You can now run the examples using the directions provided in the
        next section.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.run"></a>3.12.3.&nbsp;Running the Castor JDO samples</h3></div></div></div><p>
        In the directory where you have unpacked the ZIP file you'll find a
        castor-1.1M2-examples.jar. In addition, you'll find a directory named
        <code class="literal">lib</code> where you'll find several JAR files required to
        run the samples.
      </p><p>To execute the samples, issue the following command:</p><pre class="programlisting">java -jar castor-1.1M2-examples.jar</pre><p>
        ... et voila ! You'll see various lines of logging output flashing
        by whilst the Castor JDO samples are executing against a database.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.what-happens"></a>3.12.4.&nbsp;What happens</h3></div></div></div><p>
        The Castor JDO sample will test persistence between a set of Java
        classes (Product, ProductGroup, ProductDetail, etc.) and perform this
        code against an Apache Derby instance as RDBMS. For this purpose, the
        sample code will start an embedded Derby instance on the fly, create
        the required tables, and then continue to execute several code
        fragments using various Castor JDO artifacts (JDOManager, Database,
        etc.) against this embedded database.
      </p><p>
        In other words, everything is self-contained and there is no need to
        install a database, create a database schema, or create database tables.
        Everything required for the tests is initiated and set up from within
        the sample code.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdo.self-executable-examples.hints"></a>3.12.5.&nbsp;Hints</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
	          If it is not set yet, you might have to set the 
	          <code class="literal">JAVA_HOME</code> environment variable, and add the 
	          $JAVA_HOME/bin directory to your path.
          </p></li></ul></div></div></div>
  
</div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xml.code.generator.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="advanced-jdo.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;XML code generation&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:85%;"><a href="http://www.castor.org/" title="The Castor community">The Castor community</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;4.&nbsp;Advanced JDO</td></tr></table></div></body></html>