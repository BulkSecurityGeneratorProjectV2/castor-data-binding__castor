<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Castor XML - XML data binding</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="up" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="prev" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="next" href="xml.code.generator.html" title="Chapter&nbsp;2.&nbsp;XML code generation"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top"><div id="header"><div class="projectlogo"><a href="./"><img class="logoImage" src="images/castor.gif" alt="Castor" border="0"></a></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="mhSpacer"></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="XML data binding"></a>Chapter&nbsp;1.&nbsp;Castor XML - XML data binding</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9"></a>1.1.&nbsp;XML framework</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e11"></a>1.1.1.&nbsp;Introduction</h3></div></div></div><p>
			Castor XML is an XML data binding framework. Unlike the two
			main XML APIs, DOM (Document Object Model) and SAX (Simple
			API for XML) which deal with the structure of an XML
			document, Castor enables you to deal with the data defined
			in an XML document through an object model which represents
			that data.
		</p><p>
			Castor XML can marshal almost any "bean-like" Java Object to
			and from XML. In most cases the marshalling framework uses a
			set of ClassDescriptors and FieldDescriptors to describe how
			an Object should be marshalled and unmarshalled from XML.
		</p><p>
			For those not familiar with the terms "marshal" and
			"unmarshal", it's simply the act of converting a stream
			(sequence of bytes) of data to and from an Object. The act
			of "marshalling" consists of converting an Object to a
			stream, and "unmarshalling" from a stream to an Object.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.data.binding.framework"></a>1.1.2.&nbsp;Castor XML - The XML data binding framework</h3></div></div></div><p>
			The XML data binding framework, as it's name implies, is
			responsible for doing the conversion between Java and XML.
			The framework consists of two worker classes,
			<code class="classname">org/exolab/castor/xml/Marshaller</code>	and
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			respectively, and a bootstrap class
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			used for configuration of the XML data binding framework and
			instantiation of the two worker objects.
		</p><p>
			Lets walk through a very simple example. Assume we have a
			simple
			<code class="classname">Person</code>
			class as follows:
		</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/** An simple person class */</span> 
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person <span class="hl-keyword">implements</span> java.io.Serializable {

   <span class="hl-comment">/** The name of the person */</span> 
   <span class="hl-keyword">private</span> String name = null;

   <span class="hl-comment">/** The Date of birth */</span> 
   <span class="hl-keyword">private</span> Date dob = null;

   <span class="hl-comment">/** Creates a Person with no name */</span> 
   <span class="hl-keyword">public</span> Person() {
      <span class="hl-keyword">super</span>(); 
   }

   <span class="hl-comment">/** Creates a Person with the given name */</span> 
   <span class="hl-keyword">public</span> Person(String name) { <span class="hl-keyword">this</span>.name = name; }

   <span class="hl-comment">/** 
     * @return date of birth of the person 
     */</span> 
   <span class="hl-keyword">public</span> Date getDateOfBirth() { <span class="hl-keyword">return</span> dob; }

   <span class="hl-comment">/** 
     * @return name of the person 
     */</span> 
   <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> name; }

   <span class="hl-comment">/** 
     * Sets the date of birth of the person 
     * @param name the name of the person 
     */</span> 
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDateOfBirth(Date dob) { <span class="hl-keyword">this</span>.dob = dob; }

   <span class="hl-comment">/** 
     * Sets the name of the person 
     * @param name the name of the person 
     */</span> 
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) { <span class="hl-keyword">this</span>.name = name; } 
}
		</pre><p>
			To (un-)marshal data to and from XML, Castor XML can be used
			in one of three modes:
		</p><div class="itemizedlist"><ul type="disc"><li><p>introspection mode</p></li><li><p>mapping mode</p></li><li><p>descriptor mode (aka generation mode)</p></li></ul></div><p>
			The following sections discuss each of these modes at a high
			level.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e34"></a>1.1.2.1.&nbsp;Introspection mode</h4></div></div></div><p>
				The
				<span class="italic">introspection mode</span>
				is the simplest mode to use from a user perspective, as
				it does not require any configuration from the user. As
				such, the user does not have to provide any mapping
				file(s), nor point Castor to any generated descriptor
				classes (as discussed in the 'descriptor mode' section).
			</p><p>
				In this mode, the user makes use of
				<span class="bold"><strong>static</strong></span>
				methods on the
				<code class="classname">org.exolab.castor.xml.Marshaller</code> and
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				classes, providing all required data as parameters on
				these method calls.
			</p><p>
				To marshal an instance of the person class you simply
				call the
				<code class="classname">org.exolab.castor.xml.Marshaller</code>
				as follows:
			</p><pre class="programlisting">
<span class="hl-comment">// Create a new Person</span>
Person person = <span class="hl-keyword">new</span> Person(<span class="hl-string">"Ryan 'Mad Dog' Madden"</span>);
person.setDateOfBirth(<span class="hl-keyword">new</span> Date(1955, 8, 15));

<span class="hl-comment">// Create a File to marshal to</span>
writer = <span class="hl-keyword">new</span> FileWriter(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Marshal the person object</span>
Marshaller.marshal(person, writer);
			</pre><p>
				This produces the XML shown in
				<a href="XML data binding.html#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a>
			</p><div class="example"><a name="xml.framework.introspection.ouput"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;XML produced in introspection mode</b></p><div class="example-contents"><pre class="programlisting">
XML to written
				</pre></div></div><br class="example-break"><p>
				To unmarshal an instance of the person class from XML,
				you simply call the
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				as follows:
			</p><pre class="programlisting">
<span class="hl-comment">// Create a Reader to the file to unmarshal from</span>
reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Marshal the person object</span>
Person person = (Person)
Unmarshaller.unmarshal(Person.<span class="hl-keyword">class</span>, reader);
			</pre><p>
				Marshalling and unmarshalling is basically that simple.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
				Note: The above example uses the
				<span class="italic">
					<span class="bold"><strong>static</strong></span>
				</span>
				methods of the marshalling framework, and as such no
				Marshaller and/or Unmarshaller instances need to be
				created. A common mistake in this context when using a
				<span class="bold"><strong>mapping file</strong></span>
				is to call the
				<code class="classname">org.exolab.castor.xml.Marshaller</code>	or
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				as in the above example. This won't work, as the mapping
				will be ignored.
			</td></tr></table></div><p>
				In
				<span class="italic">introspection mode</span>
				, Castor XML uses Java reflection to establish the
				binding between the Java classes (and their properties)
				and the XML, following a set of (default) naming rules.
				Whilst it is possible to change to a different set of
				naming rules, there's no way to override this (default)
				naming for individual artifacts. In such a case, a
				<span class="italic">mapping file</span>
				should be used.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e63"></a>1.1.2.2.&nbsp;Mapping mode</h4></div></div></div><p>
				In
				<span class="italic">mapping mode</span>
				, the user provides Castor XML with a user-defined
				mapping (in form of a mapping file) that allows the
				(partial) definition of a customized mapping between
				Java classes (and their properties) and XML.
			</p><p>
				When you are using a mapping file, create an instance of the
				<code class="classname">org.exolab.castor.xml.XMLContext</code> class and use the
				<code class="methodname">org.exolab.castor.xml.XMLContext.addMapping(Mapping)</code>
				method to provide Castor XML with one of more mapping files.
			</p><p>
				To start using Castor XML for marshalling and/or unmarshalling based upon your custom mapping, create
				instances of <code class="classname">org.exolab.castor.xml.Marshaller</code> and
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>as needed using one of the following methods:
			</p><div class="table"><a name="d4e73"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;
					Methods on XMLContext to create Un-/Marshaller
					objects
				</b></p><div class="table-contents"><table summary="&#xA;Methods on XMLContext to create Un-/Marshaller&#xA;objects&#xA;" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Method name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
								<p>
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
										createMarshaller
									</a>
								</p>
							</td><td align="center">
								<p>
									Creates a
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Marshaller" target="_top">
										Marshaller
									</a>
									instance.
								</p>
							</td></tr><tr><td align="center">
								<p>
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.XMLContext" target="_top">
										createUnmarshaller
									</a>
								</p>
							</td><td align="center">
								<p>
									Creates a
									<a xmlns:xlink="http://www.w3.org/1999/xlink" href="org.exolab.castor.xml.Unmarshaller" target="_top">
										Unmarshaller
									</a>
									instance.
								</p>
							</td></tr></tbody></table></div></div><br class="table-break"><p>
				and call any of the
				<span class="bold"><strong>non-static</strong></span>
				(un)marshal methods to trigger data binding in either
				way.
			</p><p>
				Below code shows a full example that demonstrates
				unmarshalling a
				<code class="literal">Person</code>
				instance from XML using a
				<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				instance as obtained from an XMLContext previously
				configured to your needs.
			</p><div class="example"><a name="d4e102"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Unmarshalling from XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.xml.XMLContext; <span class="hl-keyword">import</span>
org.exolab.castor.mapping.Mapping; <span class="hl-keyword">import</span>
org.exolab.castor.xml.Unmarshaller;

<span class="hl-comment">// Load Mapping</span>
Mapping mapping = <span class="hl-keyword">new</span> Mapping();
mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);


	<span class="hl-comment">// initialize and configure XMLContext</span>

XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addMapping(mapping);


	<span class="hl-comment">// Create a Reader to the file to unmarshal from</span>

reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);

<span class="hl-comment">// Create a new Unmarshaller</span>
Unmarshaller unmarshaller =
context.createUnmarshaller();
unmarshaller.setClass(Person.<span class="hl-keyword">class</span>);

<span class="hl-comment">// Unmarshal the person object</span>
Person person = (Person)
unmarshaller.unmarshal(reader);
				</pre></div></div><br class="example-break"><p>
				To marshal the very same
				<code class="literal">Person</code>
				instance to XML using a
				<code class="classname">org.exolab.castor.xml.Marshaller</code>
				obtained from the
				<span class="bold"><strong>same</strong></span>
				<code class="classname">org.exolab.castor.xml.XMLContext</code>, 
                use code as follows:
			</p><div class="example"><a name="d4e110"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Marshalling to XML using a mapping</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

<span class="hl-comment">// create a Writer to the file to marshal to</span>
Writer writer = <span class="hl-keyword">new</span> FileWriter(<span class="hl-string">"out.xml"</span>);

<span class="hl-comment">// create a new Marshaller</span>
Marshaller marshaller = context.createMarshaller();
marshaller.setWriter(writer);

<span class="hl-comment">// marshal the person object</span>
marshaller.marshal(person);
				</pre></div></div><br class="example-break"><p>
				Please have a look at
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping</a>
				for a detailed discussion of the mapping file and its
				structure.
			</p><p>
				For more information on how to effectively deal with
				loading mapping file(s) especially in multi-threaded
				environments, please check the
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-best-practice.html" target="_top">best practice</a>
				section.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e117"></a>1.1.2.3.&nbsp;Descriptor mode</h4></div></div></div><p>TBD</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e120"></a>1.1.3.&nbsp;Sources and destinations</h3></div></div></div><p>
            Castor supports multiple sources and destinations from which
            objects can be marshalled and unmarshalled.
        </p><div class="table"><a name="d4e123"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;
                Marshalling destinations.
            </b></p><div class="table-contents"><table summary="&#xA;                Marshalling destinations.&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Destination</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                            <p>
                                <code class="classname">marshal(java.io.Writer)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The character stream.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.xml.sax.DocumentHandler)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The SAX document handler.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.xml.sax.ContentHandler)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The SAX content handler.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(org.w3c.dom.Node)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The DOM node to marshall object into.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.stream.XMLStreamWriter)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The STaX cursor API.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.stream.XMLEventWriter)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                The STaX iterator API.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">marshal(javax.xml.transform.Result)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                <code class="literal">javax.xml.transform.dom.DOMResult</code>, 
                                <code class="literal">javax.xml.transform.sax.SAXResult</code> and 
                                <code class="literal">javax.xml.transform.stream.StreamResult</code> are supported.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d4e178"></a><p class="title"><b>Table&nbsp;1.3.&nbsp;
                Unmarshalling sources.
            </b></p><div class="table-contents"><table summary="&#xA;                Unmarshalling sources.&#xA;            " border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Source</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(java.io.Reader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A character stream.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(org.xml.sax.InputSource)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A SAX input source.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(org.w3c.dom.Node)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A W3C DOM node which will be used for unmarshalling.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.stream.XMLStreamReader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A StAX cursor.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.stream.XMLEventReader)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                A StAX iterator.
                            </p>
                        </td></tr><tr><td align="center">
                            <p>
                                <code class="classname">unmarshal(javax.xml.transform.Source)</code>
                            </p>
                        </td><td align="center">
                            <p>
                                Supports <code class="literal">javax.xml.transform.dom.DOMSource</code>, 
                                <code class="literal">javax.xml.transform.sax.SAXSource</code>
                                and <code class="literal">javax.xml.transform.stream.StreamSource</code>.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"><p>
            Castor 1.3.2 and 1.3.3 introduced support for the STaX API for
            both for marshalling and unmarshalling. The framework fully
            supports the STaX cursor and iterator API.
        </p><p>
            An example of marshalling using STaX:
        </p><div class="example"><a name="d4e229"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Marshalling to a StAX java.xml.stream.XMLStreamWriter</b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// marshalling using STaX</span>
StringWriter writer = <span class="hl-keyword">new</span> StringWriter();
XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();
XMLStreamWriter xmlStreamWriter = outputFactory.createXMLStreamWriter(writer);

marshaller.setXmlStreamWriter(xmlStreamWriter);
marshaller.marshal(object);
    		</pre></div></div><br class="example-break"><p>
            Also beginning from version 1.3.3, the framework has been
            modified to support Source and Result interfaces. Now it
            is possible to use SAXSource, DOMSource and StreamSource
            for unmarshalling and corresponding classes for marshalling.
        </p><p>
            Below an example of marshalling into Result:
        </p><div class="example"><a name="d4e234"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;Marshalling to a <code class="literal">javax.xml.transform.dom.DOMResult</code></b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// instance of object to be marshalled</span>
Object obj = ...

<span class="hl-comment">// marshalling into DOM node</span>
XMLContext xmlContext = ... <span class="hl-comment">// creates the xml context</span>

<span class="hl-comment">// creates marshaller</span>
Marshaller marshaller = xmlContext.createMarshaller();

<span class="hl-comment">// creates DOM factory</span>
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();

<span class="hl-comment">// creates document</span>
Document document = builder.newDocument();

<span class="hl-comment">// sets the DOM result for the marshaller</span>
marshaller.setResult(<span class="hl-keyword">new</span> DOMResult(document));

<span class="hl-comment">// marshalls object</span>
marshaller.marshall(obj);
		  </pre></div></div><br class="example-break"><p>
            Another example of unmarshalling from Source:
        </p><div class="example"><a name="d4e239"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;Unmarshalling from a <code class="literal">javax.xml.transform.sax.SAXSource</code></b></p><div class="example-contents"><pre class="programlisting">
<span class="hl-comment">// unmarshalling from SAX InputSource</span>
XMLContext xmlContext = ... <span class="hl-comment">// creates the xml context</span>

<span class="hl-comment">// creates unmarshaller</span>
Unmarshaller unmarshaller = xmlContext.createUnmarshaller();

<span class="hl-comment">// creates SAX input source</span>
InputSource inputSource = <span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> StringReader(xml));

<span class="hl-comment">// creates instance of SAXSource</span>
SAXSource saxSource = <span class="hl-keyword">new</span> SAXSource(inputSource);

<span class="hl-comment">// unmarshalls object</span>
Object result = unmarshaller.unmarshal(saxSource);
    		</pre></div></div><br class="example-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e243"></a>1.1.4.&nbsp;
			XMLContext - A consolidated way to bootstrap Castor
		</h3></div></div></div><p>
			With Castor 1.1.2, the
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			class has been added to the Castor marshalling framework.
			This new class provides a bootstrap mechanism for Castor
			XML, and allows easy (and efficient) instantiation of
			<code class="classname">org.exolab.castor.xml.Marshaller</code>
			and
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			instances as needed.
		</p><p>
			As shown above, the
			<code class="classname">org.exolab.castor.xml.XMLContext</code>
			class offers various factory methods to obtain a new
			<code class="classname">org.exolab.castor.xml.Marshaller</code>,
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>.
		</p><p>
			When you need more than one
			<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			instance in your application, please call
			<code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code>
			as required. As all
			<code class="literal">Unmarshaller</code>
			instances are created from the very same
			<code class="literal">XMLContext</code>
			instance, overhead will be minimal. Please note, though,
			that use of one
			<code class="literal">Unmarshaller</code>
			instance is not thread-safe.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e259"></a>1.1.5.&nbsp;Using existing Classes/Objects</h3></div></div></div><p>
			Castor can marshal "almost" any arbitrary Object to and from
			XML. When descriptors are not available for a specfic Class,
			the marshalling framework uses reflection to gain
			information about the object.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
			Actually an in memory set of descriptors are created for the
			object and we will soon have a way for saving these
			descriptors as Java source, so that they may be modified and
			compiled with little effort.
		</td></tr></table></div><p>
			If a set of descriptors exist for the classes, then Castor
			will use those to gain information about how to handle the
			marshalling. See <a href="XML data binding.html#xml.framework.class.descriptors" title="1.1.6.&nbsp;Class Descriptors">Section&nbsp;1.1.6, &#8220;Class Descriptors&#8221;</a>
			for more information.
		</p><p>
			There is one main restrictions to marshalling objects. These
			classes must have have a public default constructor (ie. a
			constructor with no arguments) and adequete "getter" and
			"setter" methods to be properly be marshalled and
			unmarshalled.
		</p><p>
			The example illustrated in the previous section
			<a href="XML data binding.html#xml.framework.data.binding.framework" title="1.1.2.&nbsp;Castor XML - The XML data binding framework">Section&nbsp;1.1.2, &#8220;Castor XML - The XML data binding framework&#8221;</a>
			demonstrates how to use the framework with existing classes.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.framework.class.descriptors"></a>1.1.6.&nbsp;Class Descriptors</h3></div></div></div><p>
			Class descriptors provide the "Castor Framework" with
			necessary information so that the Class can be marshalled
			properly. The class descriptors can be shared between the
			JDO and XML frameworks.
		</p><p>
			Class descriptors contain a set of
			<a href="">???</a>
		</p><p>
			XML Class descriptors provide the marshalling framework with
			the information it needs about a class in order to be
			marshalled to and from XML. The XMLClassDescriptor
			<code class="classname">org.exolab.castor.xml.XMLClassDescriptor</code>.
		</p><p>
			XML Class Descriptors are created in four main ways. Two of
			these are basically run-time, and the other two are compile
			time.

			</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e276"></a>1.&nbsp;Compile-Time Descriptors</h5></div></div></div><p>
					To use "compile-time" class descriptors, one can
					either implement the
					<code class="classname">org.exolab.castor.xml.XMLClassDescriptor</code>
					interface for each class which needs to be
					"described", or have the
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/sourcegen.xml" target="_top">Source Code Generator</a>
					create the proper descriptors.
				</p><p>
					The main advantage of compile-time descriptors is
					that they are faster than the run-time approach.
				</p></div><p>
			</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e282"></a>2.&nbsp;Run-Time Descriptors</h5></div></div></div><p>
					To use "run-time" class descriptors, one can either
					simply let Castor introspect the classes, a mapping
					file can be provided, or a combination of both
					"default introspection" and a specified mapping file
					may be used.
				</p><p>
					For "default introspection" to work the class being
					introspected must have adequete setter/getter
					methods for each field of the class that should be
					marshalled and unmarshalled. If no getter/setter
					methods exist, Castor can handle direct field access
					to public fields. It does not do both at the same
					time. So if the respective class has any
					getter/setter methods at all, then no direct field
					access will take place.
				</p><p>
					There is nothing to do to enable "default
					introspection". If a descriptor cannot be found for
					a class, introspection occurs automatically.
				</p><p>
					Some behavior of the introspector may be controlled
					by setting the appropriate properties in the
					<span class="italic">castor.properties</span>
					file. Such behavior consists of changing the naming
					conventions, and whether primitive types are treated
					as attributes or elements. See
					<span class="italic">castor.properties</span>
					file for more information.
				</p><p>
					A mapping file may also be used to "describe" the
					classes which are to be marshalled. The mapping is
					loaded before any marshalling/unmarshalling takes
					place. See
					<code class="classname">org.exolab.castor.mapping.Mapping</code>
				</p><p>
					The main advantage of run-time descriptors is that
					it takes very little effort to get something
					working.
				</p></div><p>
		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.mapping"></a>1.2.&nbsp;XML Mapping</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.introduction"></a>1.2.1.&nbsp;Introduction</h3></div></div></div><p>Castor XML mapping is a way to simplify the binding of java classes to
      XML document. It allows to transform the data contained in a java object
      model into/from an XML document.</p><p>Although it is possible to rely on Castor's default behavior to marshal and
        unmarshal Java objects into an XML document, it might be necessary to have more
        control over this behavior. For example, if a Java object model already exists,
        Castor XML Mapping can be used as a bridge between the XML document and that
        Java object model.</p><p>Castor allows one to specify some of its marshalling/unmarshalling behavior
        using a mapping file. This file gives explicit information to Castor on how a
        given XML document and a given set of Java objects relate to each other.</p><p>A Castor mapping file is a good way to dissociate the changes in the structure
        of a Java object model from the changes in the corresponding XML document
        format.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.overview"></a>1.2.2.&nbsp;Overview</h3></div></div></div><p>The mapping information is specified by an XML document. This document is
        written from the point of view of the Java object and describes how the
        properties of the object have to be translated into XML. One constraint for the
        mapping file is that Castor should be able to infer unambiguously from it how a
        given XML element/attribute has to be translated into the object model during
        unmarshalling.</p><p>The mapping file describes for each object how each of its fields have to be
        mapped into XML. A field is an abstraction for a property of an object. It can
        correspond directly to a public class variable or indirectly to a property via
        some accessor methods (setters and getters).</p><p>It is possible to use the mapping and Castor default behavior in conjunction:
        when Castor has to handle an object or an XML data but can't find information
        about it in the mapping file, it will rely on its default behavior. Castor will
        use the Java Reflection API to introspect the Java objects to determine what to do.</p><p><span class="bold"><strong>Note:</strong></span> Castor can't handle all possible mappings. In some complex cases, it may be
        necessary to rely on an XSL transformation in conjunction with Castor to adapt the
        XML document to a more friendly format.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.marshalling"></a>1.2.2.1.&nbsp;Marshalling Behavior</h4></div></div></div><p>For Castor, a Java class has to map into an XML element. When Castor marshals an
          object, it will:</p><div class="itemizedlist"><ul type="disc"><li><p>use the mapping information, if any, to find the name of the element to create</p></li></ul></div><p>or</p><div class="itemizedlist"><ul type="disc"><li><p>by default, create a name using the name of the class</p></li></ul></div><p>It will then use the fields information from the mapping file to determine how a
          given property of the object has to be translated into one and only one of the
          following:</p><div class="itemizedlist"><ul type="disc"><li><p>an attribute</p></li><li><p>an element</p></li><li><p>text content</p></li><li><p>nothing, as we can choose to ignore a particular field</p></li></ul></div><p>This process will be recursive: if Castor finds a property that has a class type
          specified elsewhere in the mapping file, it will use this information to marshal
          the object.</p><p>By default, if Castor finds no information for a given class in the mapping
          file, it will introspect the class and apply a set of default rules to guess the
          fields and marshal them. The default rules are as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>All primitive types, including the primitive type wrappers (Boolean,
            Short, etc...) are marshalled as attributes.</p></li><li><p>All other objects are marshalled as elements with either text content
            or element content.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.overview.unmarshalling"></a>1.2.2.2.&nbsp;Unmarshalling Behavior</h4></div></div></div><p>When Castor finds an element while unmarshalling a document, it will try to use
          the mapping information to determine which object to instantiate. If no mapping
          information is present, Castor will use the name of the element to try to guess
          the name of a class to instantiate (for example, for an element named
          'test-element', Castor will try to instantiate a class named 'TestElement' if no
          information is given in the mapping file). Castor will then use the field
          information of the mapping file to handle the content of the element.</p><p>If the class is not described in the mapping file, Castor will instrospect the
          class using the Java Reflection API to determine if there is any function of the
          form getXxxYyy()/setXxxYyy(&lt;type&gt; x). This accessor will be associated with XML
          element/attribute named 'xxx-yyy'. In the future, we will provide a way to
          override this default behavior.</p><p>Castor will introspect object variables and use direct access _only_ if no
          get/set methods have been found in the class. In this case, Castor will look for
          public variables of the form:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; xxxYYY;
        </pre><p>and expect an element/attribute named 'xxx-yyy'. The only handled
          collections for &lt;type&gt; are java.lang.Vector and array. (up to version
          0.8.10)</p><p>For primitive &lt;type&gt;, Castor will look for an attribute first and then an
          element. If &lt;type&gt; is not a primitive type, Castor will look for an element
          first and then an attribute.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile"></a>1.2.3.&nbsp;The Mapping File</h3></div></div></div><p>
    		The following sections define the syntax for each of the mapping file artefacts
    		and their semantical meaning.
    	</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.sampledomainobjects"></a>1.2.3.1.&nbsp;Sample domain objects</h4></div></div></div><p>
    			This section defines a small domain model that will be referenced by
    			various mapping file (fragments/samples) in the following sections. The model consists 
    			of two two classes <code class="classname">Order</code> and <code class="classname">OrderItem</code>, where an order 
    			holds a list of order items.
    		</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Order {

    <span class="hl-keyword">private</span> List orderItems;
    <span class="hl-keyword">private</span> String orderNumber;
    
    <span class="hl-keyword">public</span> List getOrderItems() {
        <span class="hl-keyword">return</span> orderItems;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderItems(List orderItems) {
        <span class="hl-keyword">this</span>.orderItems = orderItems;
    }
    <span class="hl-keyword">public</span> String getOrderNumber() {
        <span class="hl-keyword">return</span> orderNumber;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderNumber(String orderNumber) {
        <span class="hl-keyword">this</span>.orderNumber = orderNumber;
    }
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> OrderItem {
    
    <span class="hl-keyword">private</span> String id;
    <span class="hl-keyword">private</span> Integer orderQuantity;
    
    <span class="hl-keyword">public</span> String getId() {
        <span class="hl-keyword">return</span> id;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setId(String id) {
        <span class="hl-keyword">this</span>.id = id;
    }
    <span class="hl-keyword">public</span> Integer getOrderQuantity() {
        <span class="hl-keyword">return</span> orderQuantity;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrderQuantity(Integer orderQuantity) {
        <span class="hl-keyword">this</span>.orderQuantity = orderQuantity;
    }
}</pre><p>
	        	As shown above in bold, the <code class="classname">Order</code> instance has a (private) field <code class="classname">'orderItems'</code>
				to hold a collection of <code class="classname">OrderItem</code> instances. This field is publically exposed
				by corresponding getter and setter methods.
	        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapping"></a>1.2.3.2.&nbsp;The &lt;mapping&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT mapping ( description?, include*, field-handler*, <span class="hl-keyword">class</span>*, key-generator* )&gt;
        </pre><p>The &lt;mapping&gt; element is the root element of a mapping file. It contains:</p><div class="itemizedlist"><ul type="disc"><li><p>an optional description</p></li><li><p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li><li><p>zero of more &lt;field-handler&gt; defining custom, configurable field handlers</p></li><li><p>zero or more &lt;class&gt; descriptions: one for each class we intend to give
            mapping information</p></li><li><p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li></ul></div><p>A mapping file look like this:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;

&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
      castor.org
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
	&lt;description&gt;Description of the mapping&lt;/description&gt;
	
	&lt;include href=<span class="hl-string">"other_mapping_file.xml"</span>/&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'A'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"A"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;
	
	&lt;!-- mapping <span class="hl-keyword">for</span> <span class="hl-keyword">class</span> <span class="hl-string">'B'</span> --&gt;
	&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"B"</span>&gt;
	        .........
	&lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.class"></a>1.2.3.3.&nbsp;The &lt;class&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT class ( description?, cache-type?, map-to?, field+ )&gt;
&lt;!ATTLIST class
          name            ID       #REQUIRED
          extends         IDREF    #IMPLIED
          depends         IDREF    #IMPLIED
          auto-complete   ( true |false ) "false"
          identity        CDATA    #IMPLIED
          access          ( read-only | shared | exclusive | db-locked )  "shared"
          key-generator   IDREF    #IMPLIED &gt;</pre><p>The  <code class="classname">&lt;class&gt;</code> element contains all the information used to 
           map a Java class into an XML document. The content of <code class="classname">&lt;class&gt;</code>
           is mainly used to describe the fields that will be mapped.</p><div class="table"><a name="d4e382"></a><p class="title"><b>Table&nbsp;1.4.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The fuly-qualified name of the Java class that we want to map to.</td></tr><tr><td><span class="bold"><strong>extends</strong></span></td><td>The fully qualified name of a parent class. This attribute should be used <span class="bold"><strong>only</strong></span>
					if this class extends another class for which a class mapping is provided. It 
					should <span class="bold"><strong>not</strong></span> be used if there's no class maping for the extended 
					class.</td></tr><tr><td><span class="bold"><strong>depends</strong></span></td><td>Used with Castor JDO only; for more information on this field, please
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>auto-complete</strong></span></td><td>If true, the class will be introspected to determine its field and 
				    the fields specified in the mapping file will be used to overide the 
				    fields found during the introspection.</td></tr><tr><td><span class="bold"><strong>identity</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>access</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>key-generator</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr></tbody></table></div></div><br class="table-break"><p>The auto-complete attributes is interesting as it allow a fine degree
           of control of the introspector: it is possible to specifiy only the
           fields whose Castor default behavior does not suite our needs. These
           feature should simplify the handling of complexe class containing many
           fields. Please see below for an example usage of this attribute.</p><div class="table"><a name="d4e425"></a><p class="title"><b>Table&nbsp;1.5.&nbsp;Description of the content</b></p><div class="table-contents"><table summary="Description of the content" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>description</strong></span></td><td>An optional description.</td></tr><tr><td><span class="bold"><strong>cache-type</strong></span></td><td>Used with Castor JDO only; for more information on this field, please see
				    see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-mapping.html" target="_top">JDO documentation</a>.</td></tr><tr><td><span class="bold"><strong>map-to</strong></span></td><td>
					Used if the name of the element is not the name of the class. By
					default, Castor will infer the name of the element to be mapped from
					the name of the class: a Java class named 'XxxYyy' will be transformed
					in 'xxx-yyy'. If you don't want Castor to generate the name, you need
					to use &lt;map-to&gt; to specify the name you want to use. &lt;map-to&gt; is
					only used for the root element.
				</td></tr><tr><td><span class="bold"><strong>field</strong></span></td><td>Zero or more &lt;field&gt; elements, which are used to describe the properties 
				    of the Java class being mapped.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.sampleclassmappings"></a>1.2.3.3.1.&nbsp;Sample &lt;class&gt; mappings</h5></div></div></div><p>The following mapping fragment defines a class mapping for the <code class="classname">OrderItem</code>
           class:</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem&gt;
           
   &lt;map-to xml="</span>item"/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

   &lt;/field name=<span class="hl-string">"orderQuantity"</span> type=<span class="hl-string">"integer"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling an	<code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;quantity&gt;100&lt;/quantity&gt;
&lt;/item&gt;</pre><p>The following mapping fragment defines a class mapping for the same
			   class, where for all properties but <code class="classname">id</code> introspection should
			   be used; the use of the <code class="classname">auto-complete</code> attribute instructs Castor XML
			   to use introspection for all attributes other than <code class="classname">'id'</code>, where
			   the given field mapping will be used.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;map-to xml=<span class="hl-string">"item"</span>/&gt;

   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/item&gt;</pre><p>
        	By removing the &lt;map-to&gt; element from above class mapping, ...
        </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"mypackage.OrderItem auto-complete="</span>true"&gt;
           
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"string"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"identity"</span> node=<span class="hl-string">"attribute"</span>/&gt;
   &lt;/field&gt;

&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
        	... Castor will use introspection to infer the element name from the Java 
        	class name (<code class="classname">OrderItem</code>), applying a default naming convention scheme.
        </p><p>
        	When marshalling the very same <code class="classname">OrderItem</code> instance, this yields the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;order-item identity=<span class="hl-string">"12"</span>&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.mapto"></a>1.2.3.4.&nbsp;The &lt;map-to&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT map-to EMPTY&gt;
&lt;!ATTLIST map-to
          table               NMTOKEN  #IMPLIED
          xml                 NMTOKEN  #IMPLIED
          ns-uri              NMTOKEN  #IMPLIED
          ns-prefix           NMTOKEN  #IMPLIED
          ldap-dn             NMTOKEN  #IMPLIED
          element-definition  (true|false) "false"     <span class="bold"><strong>NEW as of 1.0M3</strong></span>
          ldap-oc             NMTOKEN  #IMPLIED&gt;</pre><p><code class="classname">&lt;map-to&gt;</code> is used to specify the name of the element that should 
           be associated with the given class. <code class="classname">&lt;map-to&gt;</code> is only used for 
           the root class. If this information is not present, Castor will:</p><div class="itemizedlist"><ul type="disc"><li><p>for marshalling, infer the name of the element to be mapped from the name of
            the class: a Java class named 'XxxYyy' will be transformed into 'xxx-yyy'.</p></li><li><p>for unmarshalling, infer the name of the class from the name of the element:
            for an element named 'test-element' Castor will try to use a
            class named 'TestElement'</p></li></ul></div><p>Please note that it is possible to change the naming scheme used by Castor 
           to translate between the XML name and the Java class name in the 
           <code class="classname">castor.properties</code> file.</p><div class="table"><a name="d4e489"></a><p class="title"><b>Table&nbsp;1.6.&nbsp;Description of attributes</b></p><div class="table-contents"><table summary="Description of attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>xml</strong></span></td><td>Name of the element that the class is associated to.</td></tr><tr><td><span class="bold"><strong>ns-uri</strong></span></td><td>Namespace URI</td></tr><tr><td><span class="bold"><strong>ns-prefix</strong></span></td><td>Desired namespace</td></tr><tr><td><span class="bold"><strong>element-definition</strong></span></td><td><code class="classname">True</code> if the descriptor as created from a schema definition that 
	              was of type element (as opposed to a &lt;complexType&gt; definition). This 
	              only is useful in the context of source code generation.</td></tr><tr><td><span class="bold"><strong>ldap-dn</strong></span></td><td>Not used for Castor XML</td></tr><tr><td><span class="bold"><strong>ldap-oc</strong></span></td><td>Not used for Castor XML</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.mapto.samples"></a>1.2.3.4.1.&nbsp;&lt;map-to&gt; samples</h5></div></div></div><p>The following mapping fragment defines a &lt;map-to element for the 
			   <code class="classname">OrderItem</code> class, manually setting the element name to a value 
			   of <code class="classname">'item'</code>.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> /&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>The following mapping fragment instructs Castor to assign a namespace URI of 
			   <code class="classname">http://castor.org/sample/mapping/</code> to the &lt;item&gt; element, 
			   and use a namespace prefix of <code class="classname">'castor'</code> during un-/marshalling.</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myPackage.OrderItem"</span>&gt;
   ...
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">xml</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">ns-uri</span>=<span class="hl-value">"http://castor.org/sample/mapping/"</span>
           <span class="hl-attribute">ns-prefix</span>=<span class="hl-value">"castor"</span>/&gt;
   ...
&lt;<span class="hl-tag">/class</span>&gt;</pre><p>
        	When marshalling an <code class="classname">OrderItem</code> instance, this will yield the 
        	following XML:
        </p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span> ?&gt;        
&lt;castor:order-item xmlns:castor=<span class="hl-string">"http://castor.org/sample/mapping/"</span> identity=<span class="hl-string">"12"</span>&gt;
   &lt;castor:order-quantity&gt;100&lt;/castor:order-quantity&gt;
&lt;/castor:order-item&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.field"></a>1.2.3.5.&nbsp;The &lt;field&gt; element</h4></div></div></div><pre class="programlisting">
&lt;!ELEMENT field ( description?, sql?, bind-xml?, ldap? )&gt;
&lt;!ATTLIST field
    name           NMTOKEN  #REQUIRED
    type           NMTOKEN  #IMPLIED
    handler        NMTOKEN  #IMPLIED
    required       ( true | false )  "false"
    direct         ( true | false )  "false"
    lazy           ( true | false )  "false"
    transient      ( true | false )  "false"
    nillable       ( true | false )  "false"
    container      ( true | false )  "false"
    get-method     NMTOKEN  #IMPLIED
    set-method     NMTOKEN  #IMPLIED
    create-method  NMTOKEN  #IMPLIED
    collection     ( array | vector | hashtable | collection | set | map )  #IMPLIED&gt;
        </pre><p><code class="classname">&lt;field&gt;</code> is used to describe a property of a Java object 
           we want to marshal/unmarshal. It gives:</p><div class="itemizedlist"><ul type="disc"><li><p>its identity ('name')</p></li><li><p>its type (infered from 'type' and 'collection')</p></li><li><p>its access method (infered from 'direct', 'get-method', 'set-method')</p></li></ul></div><p>From this information, Castor is able to access a given property in the Java
           class.</p><p>In order to determine the signature that Castor expects, there are two easy
          rules to apply.</p><p><span class="bold"><strong>1. Determine &lt;type&gt;.</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If there is no 'collection' attribute</strong></span>, the &lt;type&gt; is just the Java type
            specified in &lt;type_attribute&gt; (the value of the 'type' attribute in the XML
            document). The value of &lt;type_attribute&gt; can be a fully qualified Java object
            like 'java.lang.String' or one of the allowed short name:</p><div class="table"><a name="d4e553"></a><p class="title"><b>Table&nbsp;1.7.&nbsp;Type shortnames</b></p><div class="table-contents"><table summary="Type shortnames" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>short name</th><th>Primitive type?</th><th>Java Class</th></tr></thead><tbody><tr><td>other</td><td>N</td><td>java.lang.Object</td></tr><tr><td>string</td><td>N</td><td>java.lang.String</td></tr><tr><td>integer</td><td>Y</td><td>java.lang.Integer.TYPE</td></tr><tr><td>long</td><td>Y</td><td>java.lang.Long.TYPE</td></tr><tr><td>boolean</td><td>Y</td><td>java.lang.Boolean.TYPE</td></tr><tr><td>double</td><td>Y</td><td>java.lang.Double.TYPE</td></tr><tr><td>float</td><td>Y</td><td>java.lang.Float.TYPE</td></tr><tr><td>big-decimal</td><td>N</td><td>java.math.BigDecimal</td></tr><tr><td>byte</td><td>Y</td><td>java.lang.Byte.TYPE</td></tr><tr><td>date</td><td>N</td><td>java.util.Date</td></tr><tr><td>short</td><td>Y</td><td>java.lang.Short.TYPE</td></tr><tr><td>char</td><td>Y</td><td>java.lang.Character.TYPE</td></tr><tr><td>bytes</td><td>N</td><td>byte[]</td></tr><tr><td>chars</td><td>N</td><td>char[]</td></tr><tr><td>strings</td><td>N</td><td>String[]</td></tr><tr><td>locale</td><td>N</td><td>java.util.Locale</td></tr></tbody></table></div></div><br class="table-break"><p>Castor will try to cast the data in the XML file in the proper Java type.</p></li><li><p><span class="bold"><strong>If there is a collection attribute</strong></span>
	, you can use the following table:</p><div class="table"><a name="d4e630"></a><p class="title"><b>Table&nbsp;1.8.&nbsp;Type implementations</b></p><div class="table-contents"><table summary="Type implementations" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>name</th><th>&lt;type&gt;</th><th>default implementation</th></tr></thead><tbody><tr><td>array</td><td>&lt;type_attribute&gt;[]</td><td>&lt;type_attribute&gt;[]</td></tr><tr><td>arraylist</td><td>java.util.List</td><td>java.util.Arraylist</td></tr><tr><td>vector</td><td>java.util.Vector</td><td>java.util.Vector</td></tr><tr><td>hashtable</td><td>java.util.Hashtable</td><td>java.util.Hashtable</td></tr><tr><td>collection</td><td>java.util.Collection</td><td>java.util.Arraylist</td></tr><tr><td>set</td><td>java.util.Set</td><td>java.util.Hashset</td></tr><tr><td>map</td><td>java.util.Map</td><td>java.util.Hashmap</td></tr><tr><td>sortedset</td><td>java.util.SortedSet</td><td>java.util.TreeSet</td></tr></tbody></table></div></div><br class="table-break"><p>The type of the object inside the collection is &lt;type_attribute&gt;. The 'default
              implementation' is the type used if the object holding the collection is found
              to be null and need to be instantiated.</p><p>For hashtable and maps (since 0.9.5.3), Castor will save both key and values.
               When marshalling output &lt;key&gt; and &lt;value&gt;
               elements. These names can be controlled by using a top-level or nested class mapping for
               the org.exolab.castor.mapping.MapItem class.
            </p><p>Note: for backward compatibility with prior versions of Castor, the <span class="italic">saveMapKeys</span>
              property can be set to false in the castor.properties file.</p><p>For versions prior to 0.9.5.3, hashtable and maps, Castor will save only the value
               during marshalling and during unmarshalling will add a map entry using the object as
               both the key and value, e.g. map.put(object, object).
            </p></li></ul></div><p>It is necessary to use a collection when the content model of the
          element expects more than one element of the specified type.</p><p><span class="bold"><strong>Determine the signature of the function</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>If 'direct' is set to true</strong></span>, Castor expects to find a class variable with the
            given signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;name&gt;;
          </pre></li><li><p><span class="bold"><strong>If 'direct' is set to false or omitted</strong></span>, Castor will access the property
              though accessor methods. Castor determines the signature of the accessors as
              follow: If the 'get-method' or 'set-method' attributes are supplied, it will
              try to find a function with the following signature:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; &lt;get-method&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> &lt;set-method&gt;(&lt;type&gt; value);
            </pre><p>If 'get-method' and 'set-method' attributes are not provided, Castor will try to
              find the following function:</p><pre class="programlisting">
<span class="hl-keyword">public</span> &lt;type&gt; get&lt;capitalized-name&gt;();
            </pre><p>or</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> set&lt;capitalized-name&gt;(&lt;type&gt; value);
            </pre><p>&lt;capitalized-name&gt; means that Castor takes the &lt;name&gt; attribute and put its first
              letter in uppercase without modifying the other letters.</p><p>The content of &lt;field&gt; will contain the information on how to map this given
              field to SQL, XML, ...</p></li><li><p><span class="bold"><strong>Exceptions concerning collection fields:</strong></span></p><p>The default is to treat the 'get-method' as a simple getter returning 
                   the collection field, and the 'set-method' as a simple getter used to set
                   a new instance on the collection field.</p><div class="table"><a name="d4e700"></a><p class="title"><b>Table&nbsp;1.9.&nbsp;Collection field access</b></p><div class="table-contents"><table summary="Collection field access" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>'get-method'</td><td>
                					<p>
                						If a 'get-method' is provided
                						for a collection field, Castor -
                						in adition to the default
                						behaviour described above - will
                						deviate from the standard case
                						for the following special
                						prefixes:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Iterator iterate...();
                					</pre>

                					<p>
                						A 'get-method' starting with the
                						prefix '
                						<code class="classname">iterate</code>
                						' is treated as Iterator method
                						for the given collection field.
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> Enumeration enum...();
                					</pre>

                					<p>
                						A 'get-method' starting with '
                						<code class="classname">enum</code>
                						' is treated as Enumeration
                						method for the given collection
                						field.
                					</p>
                				</td></tr><tr><td>'set-method'</td><td>
                					<p>
                						If 'set-method' is provided for
                						a collection field, Castor - in
                						addition to the default
                						behaviour described above - will
                						accept an 'add' prefix and
                						expect the following signature:
                					</p>

                					<pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add...(&lt;type&gt; value);
                					</pre>

                					<p>
                						This method is called for each
                						collection element while
                						unmarshalling.
                					</p>
                				</td></tr></tbody></table></div></div><br class="table-break"></li></ul></div><div class="table"><a name="d4e724"></a><p class="title"><b>Table&nbsp;1.10.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The field 'name' is required even if no such field exists in the
                    class. If 'direct' access is used, 'name' should be the name of 
                    a public instance member in the object to be mapped (the field 
                    must be public, not static and not transient). If no direct access 
                    and no 'get-/set-method' is specified, this name will be used to 
                    infer the name of the accessors methods.</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>The Java type of the field. It is used to access the field. Castor 
                    will use this information to cast the XML information (like string 
                    into integer). It is also used to define the signature of the accessor 
                    methods. If a collection is specified, this is used to specify the 
                    type of the objects held by the collection. See description
                    above for more details.</td></tr><tr><td><span class="bold"><strong>required</strong></span></td><td>A field can be optional or required.</td></tr><tr><td><span class="bold"><strong>nillable</strong></span></td><td>A field can be of content '<code class="classname">nil</code>'.</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>If true, this field will be ignored during the marshalling. This 
                    is usefull when used together with the auto-complete="true"
                    option.</td></tr><tr><td><span class="bold"><strong>direct</strong></span></td><td>If true, Castor will expect a public variable in the containing class
                    and will access it directly (for both reading and writing).</td></tr><tr><td><span class="bold"><strong>container</strong></span></td><td>Indicates whether the field should be treated as a container, 
                    i.e. only it's fields should be persisted, but not the containing
                    class itself. In this case, the container attribute should be set 
                    to true (supported in Castor XML only).</td></tr><tr><td><span class="bold"><strong>collection</strong></span></td><td>If a parent expects more than one occurrence of one of its 
                    element, it is necessary to specify which collection Castor will 
                    use to handle them. The type specified is used to define the type 
                    of the content inside the collection.</td></tr><tr><td><span class="bold"><strong>get-method</strong></span></td><td>Optional name of the 'get method' Castor should use. If this attribute 
                    is not set and the set-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>set-method</strong></span></td><td>Optional name of the 'set method' Castor should use. If this attribute 
                    is not set and the get-method attribute is not set, then Castor will try 
                    to infer the name of this method with the algorithm described above.</td></tr><tr><td><span class="bold"><strong>create-method</strong></span></td><td>Optionally defines a factory method for the instantiation of a FieldHandler</td></tr><tr><td><span class="bold"><strong>handler</strong></span></td><td>If present, specifies one of the following:
                    <div class="itemizedlist"><ul type="disc"><li><p>The fully-qualified class name of a custom field handler implementation, or</p></li><li><p>The (short) name of a 
                           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-fieldhandlers.html#Use-ConfigurableFieldHandler-for-more-flexibility" target="_top">configurable field handler</a>
                           definition.</p></li></ul></div></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e787"></a>1.2.3.6.&nbsp;Description of the content</h4></div></div></div><p>
             In the case of XML mapping, the content of a field element should be one and
             only one <span class="bold"><strong>&lt;bind-xml&gt;</strong></span> element describing how this given field will be mapped into the
             XML document.
         </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.field.constructorarguments"></a>1.2.3.6.1.&nbsp;Mapping constructor arguments (since 0.9.5)</h5></div></div></div><p>
               Starting with release 0.9.5, for <span class="italic">attribute</span> 
               mapped fields, support has been added to map a constructor field using 
               the <code class="classname">set-method</code> attribute.
            </p><p>
               To specify that a field (mapped to an attribute) should be used as a constructor 
               argument during object initialization, please specify a <code class="classname">set-method</code> attribute on the
               <code class="classname">&lt;field&gt;</code> mapping and use "%X" as the value of the
               <code class="classname">set-method</code> attribute, where <code class="literal">X</code>
               is a positive integer number, e.g. <code class="literal">%1</code> or 
               <code class="literal">%21</code>.
            </p><p>For example:</p><pre class="programlisting">
&lt;field name=<span class="hl-string">"foo"</span> set-method=<span class="hl-string">"%1"</span> get-method=<span class="hl-string">"getFoo"</span> type=<span class="hl-string">"string"</span>&gt;
   &lt;bind-xml node=<span class="hl-string">"attribute"</span>/&gt;
&lt;/field&gt;</pre><p>
              Note that because the <code class="classname">set-method</code> is specified, the <code class="classname">get-method</code> also 
              must be specified.
           </p><p>
	          <span class="bold"><strong>Tip</strong></span>: the <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML HOW-TO section</span> has a HOW-TO document for 
	          mapping constructor arguments, incl. a fully working mapping.
	       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e812"></a>1.2.3.6.2.&nbsp;Sample 1: Defining a custom field handler</h5></div></div></div><p>The following mapping fragment defines a <code class="classname">&lt;field&gt;</code> element for the 
			   <code class="classname">member</code> property of the <code class="classname">org.some.package.Root</code> class, 
			   specifying a custom <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
			   implementation.</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e821"></a>1.2.3.6.3.&nbsp;Sample 2: Defining a custom configurable field handler</h5></div></div></div><p>
   			   The same custom field handler as in the previous sample can be defined 
   			   with a separate configurable &lt;field-handler&gt; definition, where additional 
   			   configuration can be provided.
   			</p><pre class="programlisting">
&lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"org.some.package.CustomFieldHandlerImpl"</span>&gt;
   &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
&lt;/field-handler&gt;</pre><p>
   				and subsequently be referred to by its <span class="bold"><strong>name</strong></span> as shown in the 
   				following field mapping:
   			</p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.some.package.Root"</span>&gt;
   &lt;field name=<span class="hl-string">"member"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e830"></a>1.2.3.6.4.&nbsp;Sample 3: Using the container attribute</h5></div></div></div><p>
               Assume you have a class mapping for a class <code class="classname">Order</code> which defines -
               amongst others - a field mapping as follows, where the field <code class="classname">item</code>
               refers to an instance of a class <code class="classname">Item</code>.
            </p><pre class="programlisting">
&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Order"</span>&gt;
            
   ...
   &lt;field name=<span class="hl-string">"item"</span> type=<span class="hl-string">"some.example.Item"</span> &gt;
      &lt;bind-xml&gt; name=<span class="hl-string">"item"</span> node=<span class="hl-string">"element"</span> /&gt;
   &lt;/field&gt;
   ...
&lt;/<span class="hl-keyword">class</span>&gt;

&lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"some.example.Item"</span>&gt;
   &lt;field name=<span class="hl-string">"id"</span> type=<span class="hl-string">"long"</span> /&gt;
   &lt;field name=<span class="hl-string">"description"</span> type=<span class="hl-string">"string"</span> /&gt;
&lt;/<span class="hl-keyword">class</span>&gt;</pre><p>
                Marshalling an instance of <code class="classname">Order</code> would produce XML as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">item</span>&gt;
        &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
        &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
    &lt;<span class="hl-tag">/item</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre><p>
               If you do not want the <code class="classname">Item</code> instance to be marshalled,
               but only its fields, change the field mapping for the <code class="classname">item</code>
               member to be as follows:
           </p><pre class="programlisting">
&lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"item"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"some.example.Item"</span> <span class="hl-attribute">container</span>=<span class="hl-value">"false"</span> &gt;
   &lt;<span class="hl-tag">bind-xml</span>&gt; name="item" node="element" /&gt;
&lt;<span class="hl-tag">/field</span>&gt;</pre><p>
                The resulting XML would look as follows:
            </p><pre class="programlisting">
&lt;<span class="hl-tag">order</span>&gt;
    ...
    &lt;<span class="hl-tag">id</span>&gt;100&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">description</span>&gt;...&lt;<span class="hl-tag">/description</span>&gt;
&lt;<span class="hl-tag">/order</span>&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml.mapping.mappingfile.bindxml"></a>1.2.3.7.&nbsp;The &lt;bind-xml&gt; element</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.grammar"></a>1.2.3.7.1.&nbsp;Grammar</h5></div></div></div><pre class="programlisting">
&lt;!ELEMENT bind-xml (class?, property*)&gt;
&lt;!ATTLIST bind-xml
          name     NMTOKEN     #IMPLIED
          type     NMTOKEN     #IMPLIED
          location CDATA       #IMPLIED
          matches  NMTOKENS    #IMPLIED
          QName-prefix NMTOKEN #IMPLIED
          reference   ( true | false ) "false"
          node        ( attribute | element | text )    #IMPLIED
          auto-naming ( deriveByClass | deriveByField ) #IMPLIED
          transient   ( true | false ) "false"&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="xml.mapping.mappingfile.bindxml.definition"></a>1.2.3.7.1.1.&nbsp;Definiton</h6></div></div></div><p>
            The <code class="classname">&lt;bind-xml&gt;</code> element is used to describe how a given Java field 
                should appear in an XML document. It is used both for marshalling 
                and unmarshalling.
        </p></div></div><div class="table"><a name="d4e855"></a><p class="title"><b>Table&nbsp;1.11.&nbsp;Description of the attributes</b></p><div class="table-contents"><table summary="Description of the attributes" border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>name</strong></span></td><td>The name of the element or attribute.
		              <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The name is a QName, and a namespace prefix may be used to indicate the
		              element or attribute belongs to a certain namespace. Note the prefix is not
		              preserved or used during marshalling, it's simply used for
		              qualification of which namespace the element or attribute belongs.</p></td></tr></table></div></td></tr><tr><td><span class="bold"><strong>auto-naming</strong></span></td><td>If no name is specified, this attribute controls how castor will 
		    	    automatically create a name for the field. Normally, the name is 
		    	    created using the field name, however many times it is necessary 
		    	    to create the name by using the class type instead (such as
            		heterogenenous collections).</td></tr><tr><td><span class="bold"><strong>type</strong></span></td><td>XML Schema type (of the value of this field) that requires specific 
            	    handling in the Castor Marshalling Framework (such as 'QName' for 
            	    instance).</td></tr><tr><td><span class="bold"><strong>location</strong></span> (since 0.9.4.4)</td><td>Allows the user to specify the "sub-path" for which the value
                    should be marshalled to and from. This is useful for "wrapping" values in 
                    elements or for mapping values that appear on sub-elements to the 
                    current "element" represented by the class mapping. For more information,
                    see the <a href="XML data binding.html#xml.mapping.mappingfile.locationattribute" title="1.2.6.&nbsp;Location attribute">Location attribute</a> below.</td></tr><tr><td><span class="bold"><strong>QName-prefix</strong></span></td><td>When the field represents a QName value, a prefix can be provided that
                    is used when marshalling value of type QName. More information on the 
                    use of 'QName-prefix' can be found in the 
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/SourceGeneratorUser.pdf" target="_top">SourceGenerator Documentation</a></td></tr><tr><td><span class="bold"><strong>reference</strong></span></td><td>Indicates if this field has to be treated as a reference by the 
            	    unmarshaller. In order to work properly, you must specify the node 
            	    type to 'attribute' for both the 'id' and the 'reference'. In 
            	    newer versions of Castor, 'element' node for reference is allowed. 
            	    Remember to make sure that an <span class="italic">identity</span> field is specified
                    on the <code class="classname">&lt;class&gt;</code> mapping for the object type being 
                    referenced so that Castor knows what the object's identity is.</td></tr><tr><td><span class="bold"><strong>matches</strong></span></td><td>Allows overriding the matches rules for the name of the element. It 
            	    is a standard regular expression and will be used instead of the 'name'
            	    field. A '*' will match any xml name, however it will only be matched 
            	    if no other field exists that matches the xml name.</td></tr><tr><td><span class="bold"><strong>node</strong></span></td><td>Indicates if the name corresponds to an attribute, an element,
                    or text content. By default, primitive types are assumed to be 
                    an attribute, otherwise the node is assumed to be an elemen</td></tr><tr><td><span class="bold"><strong>transient</strong></span></td><td>Allows for making this field transient for XML. The default value is 
            	    inherited from the &lt;field&gt; element.</td></tr></tbody></table></div></div><br class="table-break"><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xml.mapping.mappingfile.bindxml.nestedclassmapping"></a>1.2.3.7.2.&nbsp;Nested class mapping</h5></div></div></div><p>Since 0.9.5.3, the bind-xml element supports a nested class mapping, which 
             is often useful when needing to specify more than one mapping for a 
             particular class. A good example of this is when mapping Hashtable/HashMap/Map.</p><pre class="programlisting">
&lt;bind-xml ...&gt;
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"org.exolab.castor.mapping.MapItem"</span>&gt;
      &lt;field name=<span class="hl-string">"key"</span> type=<span class="hl-string">"java.lang.String"</span>&gt;
        &lt;bind-xml name=<span class="hl-string">"id"</span>/&gt;
      &lt;/field&gt;
      &lt;field name=<span class="hl-string">"value"</span> type=<span class="hl-string">"com.acme.Foo"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;
&lt;/bind-xml&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.bindxml.usagepattern"></a>1.2.4.&nbsp;Usage Pattern</h3></div></div></div><p>Here is an example of how Castor Mapping can be used. We want to map an XML
        document like the following one (called 'order.xml').
        model.</p><pre class="programlisting">
&lt;Order reference=<span class="hl-string">"12343-AHSHE-314159"</span>&gt;
  &lt;Client&gt;
    &lt;Name&gt;Jean Smith&lt;/Name&gt;
    &lt;Address&gt;2000, Alameda de las Pulgas, San Mateo, CA 94403&lt;/Address&gt;
  &lt;/Client&gt;

  &lt;Item reference=<span class="hl-string">"RF-0001"</span>&gt;
    &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
    &lt;Quantity&gt;10&lt;/Quantity&gt;
    &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-0034"</span>&gt;
    &lt;Description&gt;Chocolate&lt;/Description&gt;
    &lt;Quantity5&lt;/Quantity&gt;
    &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=<span class="hl-string">"RF-3341"</span>&gt;
     &lt;Description&gt;Cookie&lt;/Description&gt;
     &lt;Quantity&gt;30&lt;/Quantity&gt;
     &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
  &lt;/Item&gt;
&lt;/Order&gt;</pre><p>Into the following object model composed of 3 classes:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>MyOrder:</strong></span> represent an order</p></li><li><p><span class="bold"><strong>Client:</strong></span> used to store information on the client</p></li><li><p><span class="bold"><strong>Item:</strong></span> used to store item in an order</p></li></ul></div><p>The sources of these classes follow.</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Vector;
<span class="hl-keyword">import</span> java.util.Enumeration;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyOrder {

    <span class="hl-keyword">private</span> String _ref;
    <span class="hl-keyword">private</span> ClientData _client;
    <span class="hl-keyword">private</span> Vector _items;
    <span class="hl-keyword">private</span> <span class="hl-keyword">float</span> _total;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setReference(String ref) {
        _ref = ref;
    }

    <span class="hl-keyword">public</span> String getReference() {
        <span class="hl-keyword">return</span> _ref;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setClientData(ClientData client) {
        _client = client;
    }

    <span class="hl-keyword">public</span> ClientData getClientData() {
        <span class="hl-keyword">return</span> _client;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setItemsList(Vector items) {
        _items = items;
    }

    <span class="hl-keyword">public</span> Vector getItemsList() {
        <span class="hl-keyword">return</span> _items;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTotal(<span class="hl-keyword">float</span> total) {
        _total = total;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotal() {
        <span class="hl-keyword">return</span> _total;
    }

    <span class="hl-comment">// Do some processing on the data</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span> getTotalPrice() {
        <span class="hl-keyword">float</span> total = 0.0f;

        <span class="hl-keyword">for</span> (Enumeration e = _items.elements() ; e.hasMoreElements() ;) {
            Item item = (Item) e.nextElement();
            total += item._quantity * item._unitPrice;
        }

        <span class="hl-keyword">return</span> total;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ClientData {

    <span class="hl-keyword">private</span> String _name;
    <span class="hl-keyword">private</span> String _address;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setAddress(String address) {
        _address = address;
    }

    <span class="hl-keyword">public</span> String getAddress() {
        <span class="hl-keyword">return</span> _address;
    }
}</pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Item {
    <span class="hl-keyword">public</span> String _reference;
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>    _quantity;
    <span class="hl-keyword">public</span> <span class="hl-keyword">float</span>  _unitPrice;
    <span class="hl-keyword">public</span> String _description;
}</pre><p>The XML document and the java object model can be connected by using the
        following mapping file:</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;!DOCTYPE mapping PUBLIC <span class="hl-string">"-//EXOLAB/Castor Mapping DTD Version 1.0//EN"</span>
                         <span class="hl-string">"http://castor.org/mapping.dtd"</span>&gt;

&lt;mapping&gt;
  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyOrder"</span>&gt;
    &lt;map-to xml=<span class="hl-string">"Order"</span>/&gt;

    &lt;field name=<span class="hl-string">"Reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Total"</span>
           type=<span class="hl-string">"float"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"total-price"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ClientData"</span>
           type=<span class="hl-string">"ClientData"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Client"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"ItemsList"</span>
           type=<span class="hl-string">"Item"</span>
              collection=<span class="hl-string">"vector"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Item"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"ClientData"</span>&gt;
    &lt;field name=<span class="hl-string">"Name"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Name"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"Address"</span>
           type=<span class="hl-string">"java.lang.String"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Address"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Item"</span>&gt;
    &lt;field name=<span class="hl-string">"_reference"</span>
           type=<span class="hl-string">"java.lang.String"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"reference"</span> node=<span class="hl-string">"attribute"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_quantity"</span>
           type=<span class="hl-string">"integer"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Quantity"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_unitPrice"</span>
           type=<span class="hl-string">"float"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"UnitPrice"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;

    &lt;field name=<span class="hl-string">"_description"</span>
           type=<span class="hl-string">"string"</span>
           direct=<span class="hl-string">"true"</span>&gt;
      &lt;bind-xml name=<span class="hl-string">"Description"</span> node=<span class="hl-string">"element"</span>/&gt;
    &lt;/field&gt;
  &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;</pre><p>The following class is an example of how to use Castor XML Mapping to
        manipulate the file 'order.xml'. It unmarshals the document 'order.xml',
        computes the total price, sets the total price in the java object and
        marshals the object model back into XML with the calculated price.</p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.Mapping;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.MappingException;

<span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
<span class="hl-keyword">import</span> org.exolab.castor.xml.Marshaller;

<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> java.io.FileReader;
<span class="hl-keyword">import</span> java.io.OutputStreamWriter;

<span class="hl-keyword">import</span> org.xml.sax.InputSource;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> main {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String args[]) {

        Mapping      mapping = <span class="hl-keyword">new</span> Mapping();

        <span class="hl-keyword">try</span> {
            <span class="hl-comment">// 1. Load the mapping information from the file</span>
            mapping.loadMapping( <span class="hl-string">"mapping.xml"</span> );

            <span class="hl-comment">// 2. Unmarshal the data</span>
            Unmarshaller unmar = <span class="hl-keyword">new</span> Unmarshaller(mapping);
            MyOrder order = (MyOrder)unmar.unmarshal(<span class="hl-keyword">new</span> InputSource(<span class="hl-keyword">new</span> FileReader(<span class="hl-string">"order.xml"</span>)));

            <span class="hl-comment">// 3. Do some processing on the data</span>
            <span class="hl-keyword">float</span> total = order.getTotalPrice();
            System.out.println(<span class="hl-string">"Order total price = "</span> + total);
            order.setTotal(total);

            <span class="hl-comment">// 4. marshal the data with the total price back and print the XML in the console</span>
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(<span class="hl-keyword">new</span> OutputStreamWriter(System.out));
            marshaller.setMapping(mapping);
            marshaller.marshal(order);

        } <span class="hl-keyword">catch</span> (Exception e) {
            System.out.println(e);
            <span class="hl-keyword">return</span>;
        }
    }
}
       </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.xsitype"></a>1.2.5.&nbsp;xsi:type</h3></div></div></div><p>Ordinarily, a mapping will only reference types that are concrete classes (i.e. not interfaces
        nor abstract classes).  The reason is that to unmarshal a type requires instantiating it and
        one cannot instantiate an interface.  However, in many real situations, object models depend
        on the use of interfaces.  Many class properties are defined to have interface types to support
        the ability to swap implementations.  This is often the case in frameworks.</p><p>The problem is that a different mapping must be used each time the same model is to be
       used to marshal/unmarshal an implementation that uses different concrete types.  This is
       not convenient.  The mapping should represent the model and the specific concrete type
       used to unmarshal a document is a configuration parameter; it should be specified in the
       instance document to be unmarshalled, not the mapping.</p><p>For example, assume a very simple object model of an engine that has one property that
      is a processor:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> IProcessor {
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> process();
}

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Engine {
    <span class="hl-keyword">private</span> IProcessor processor;
    <span class="hl-keyword">public</span> IProcessor getProcessor() {
        <span class="hl-keyword">return</span> processor;
    }
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProcessor(IProcessor processor) {
        <span class="hl-keyword">this</span>.processor = processor;
    }
}
            </pre><p>A typical mapping file for such a design may be:</p><pre class="programlisting">  
&lt;mapping&gt;
    &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;

        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml name=<span class="hl-string">"processor"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;

     &lt;/<span class="hl-keyword">class</span>&gt;
  &lt;/mapping&gt;</pre><p>It is possible to use such a mapping and still have the marshal/unmarshal process work
       by specifying the concrete implementation of IProcessor in the document to be unmarshalled,
       using the xsi:type attribute, as follows:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;processor xsi:type=<span class="hl-string">"java:com.abc.MyProcessor"</span> /&gt;
  &lt;/engine&gt;
            </pre><p>In this manner, one is still able to maintain only a single mapping, but vary the
      manner in which the document is unmarshalled from one instance document to the next.
      This flexibility is powerful because it enables the support of polymorphism within
      the castor xml marshalling framework.</p><p>Suppose we wanted the following XML instead:</p><pre class="programlisting">
  &lt;engine&gt;
     &lt;myProcessor/&gt;
  &lt;/engine&gt;</pre><p>In the above output our XML name changed to match the type of the class used instead of
         relying on the xsi:type attribute. This can be achieved by modifying the mapping
         file as such:
      </p><pre class="programlisting">
  &lt;mapping&gt;
     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Engine"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"engine"</span> /&gt;
        &lt;field name=<span class="hl-string">"processor"</span> type=<span class="hl-string">"IProcessor"</span> required=<span class="hl-string">"true"</span>&gt;
           &lt;bind-xml auto-naming=<span class="hl-string">"deriveByClass"</span> node=<span class="hl-string">"element"</span> /&gt;
        &lt;/field&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

     &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"MyProcessor"</span>&gt;
        &lt;map-to xml=<span class="hl-string">"myProcessor"</span> /&gt;
     &lt;/<span class="hl-keyword">class</span>&gt;

  &lt;/mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.locationattribute"></a>1.2.6.&nbsp;Location attribute</h3></div></div></div><p>Since 0.9.5</p><p>
          The location attribute allows the user to map fields from nested
          elements or specify a wrapper element for a given field. Wrapper
          elements are simply elements which appear in the XML instance, but
          do not have a direct mapping to an object or field within the
          object model.
        </p><p>
          For example to map an instance of the following class:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Bar bar = null;

    <span class="hl-keyword">public</span> Foo();

    <span class="hl-keyword">public</span> getBar() {
        <span class="hl-keyword">return</span> bar;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setBar(Bar bar) {
        <span class="hl-keyword">this</span>.bar = bar;
    }
}</pre><p>
          into the following XML instance:
    </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;;
   &lt;<span class="hl-tag">abc</span>&gt;
      &lt;<span class="hl-tag">bar</span>&gt;...&lt;<span class="hl-tag">/bar</span>&gt;
   &lt;<span class="hl-tag">/abc</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;</pre><p>
          <span class="italic">(notice that an 'abc' field doesn't exist in the Bar class)</span>
          One would use the following mapping:</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
   ...
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"Bar"</span>&gt;
         &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span>/&gt;
      &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">/class</span>&gt;
   ...
&lt;<span class="hl-tag">/mapping</span>&gt;</pre><p>
          Note the "location" attribute. The value of this attribute is the name
          of the wrapper element. To use more than one wrapper element, the name
          is separated by a forward-slash as such:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc/xyz"</span> /&gt;</pre><p>
          Note that the name of the element is not part of the location itself and
          that the location is always relative to the class in which the field is
          being defined.

          This works for attributes also:
</p><pre class="programlisting">
&lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"bar"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"abc"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"attribute"</span> /&gt;</pre><p>
          will produce the following:
</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">abc</span> <span class="hl-attribute">bar</span>=<span class="hl-value">"..."</span>/&gt;;
&lt;<span class="hl-tag">/foo</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.mapping.mappingfile.tips"></a>1.2.7.&nbsp;Tips</h3></div></div></div><p>Some helpful hints...</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e964"></a>1.2.7.1.&nbsp;Automatically create a mapping file</h4></div></div></div><p>
         Castor comes with a tool that can automatically create a mapping from
         class files. Please see the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.faq" target="_top">XML FAQ</a> for more
         information.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e968"></a>1.2.7.2.&nbsp;Create your own FieldHandler</h4></div></div></div><p>
          Sometimes to handle complex situations you'll need to create your
          own FieldHandler. Normally a FieldHandler deals with a specific class
          and field, however generic, reusable FieldHandlers can also be created
          by extending org.exolab.castor.mapping.GeneralizedFieldHandler or
          org.exolab.castor.mapping.AbstractFieldHandler.
          The FieldHandler can be specified on the &lt;field&gt; element.
       </p><p>
          For more information on writing a custom FieldHandler please
          see the following:
          <span xmlns:xlink="http://www.w3.org/1999/xlink" class="olink">XML FieldHandlers</span>.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e973"></a>1.2.7.3.&nbsp;Mapping constructor arguments (since 0.9.5)</h4></div></div></div><p>
          You may map any attributes to constructor arguments. For more information
          on how to map constructor arguments see the information available
          in the section on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.mapping.mappingfile.field.constructorarguments" target="_top">set-method</a>
          above.
       </p><p>Please note that mapping <span class="bold"><strong>elements</strong></span> to constructor arguments is 
          not yet supported.
       </p><p>
          <span class="bold"><strong>Tip</strong></span>: the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="xml.how-to" target="_top">XML HOW-TO section</a> has a HOW-TO document for 
          mapping constructor arguments.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e982"></a>1.2.7.4.&nbsp;Preventing Castor from checking for a default constructor (since 0.9.5)</h4></div></div></div><p>
          Sometimes it's useful to prevent Castor from checking for a default constructor,
          such as when trying to write a mapping for an interface or type-safe enum. You can use the
          "undocumented" verify-constructable="false" attribute on the &lt;class&gt; element to
          prevent Castor from looking for the default constructor.
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e985"></a>1.2.7.5.&nbsp;Type safe enumeration mapping (since 0.9.5)</h4></div></div></div><p>
          While you can always use your own custom FieldHandler for handling type-safe enumeration
          classes, Castor does have a built-in approach to dealing with these types of classes.
          If the type-safe enum class has a <span class="bold"><strong>public static &lt;type&gt; valueOf(String)</strong></span> method
          Castor will call that method so that the proper instance of the enumeration is returned.
          Note: You'll also need to disable the default constructor check in the mapping file
          (see section 7.4 above to see more on this).
       </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml.configuration"></a>1.3.&nbsp;Configuring Castor XML (Un)Marshaller</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e991"></a>1.3.1.&nbsp;Introduction</h3></div></div></div><p>To be defined ...</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e994"></a>1.3.2.&nbsp;Configuring the Marshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Marshaller</code>
			class for marshalling Java objects to XML, the
			<code class="classname">Marshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e999"></a><p class="title"><b>Table&nbsp;1.12.&nbsp;Marshaller properties</b></p><div class="table-contents"><table summary="Marshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>suppressNamespaces</td><td>&nbsp;</td><td>
							<code class="literal">true</code>
							or
							<code class="literal">false</code>
						</td><td>
							<code class="literal">false</code>
						</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1019"></a>1.3.3.&nbsp;Configuring the Unmarshaller</h3></div></div></div><p>
			Before using the
			<code class="classname">Unmarshaller</code>
			class for unmarshalling Java objects from XML, the
			<code class="classname">Unmarshaller</code>
			can be fine-tuned according to your needs by calling a
			variety of set-methods on this class. This section enlists
			the available properties and provides you with information
			about their meaning, possible values and the default value.
		</p><div class="table"><a name="d4e1024"></a><p class="title"><b>Table&nbsp;1.13.&nbsp;Unmarshaller properties</b></p><div class="table-contents"><table summary="Unmarshaller properties" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>rootObject</td><td>&nbsp;</td><td>
							A Class instance identifying the root class
							to use for unmarshalling.
						</td><td>-</td><td>-</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1041"></a>1.4.&nbsp;Usage of Castor and XML parsers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1043"></a>1.4.1.&nbsp;SAX/DOM</h3></div></div></div><p>
           Being an <span class="bold"><strong>XML data binding framework</strong></span> by definition, Castor XML relies on the 
           availability of an XML parser at run-time. In Java, an XML parser is by 
           default accessed though either the DOM or the SAX APIs: that implies
           that the XML Parser used needs to comply with either (or both) of these APIs.
        </p><p>
           With the creation of the JAXP API (and its addition to the Java language 
           definition as of Java 5.0), Castor internally has been enabled to allow
           usage of the JAXP interfaces to interface to XML parsers. As such, 
           Castor XML allows the use of a JAXP-compliant XML parser as well.
        </p><p>
           By default, Castor ships with
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           2.6.2. You may, of course, upgrade to a newer version
           of
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           at your convenience, or switch to any other XML parser as long as it is
           JAXP compliant or implements a particular SAX interface. Please note that
           users of Java 5.0 and above do not need to have Xerces available 
           at run-time, as JAXP and Xerces have both been integrated into the run-time
           library of Java.
        </p><p>
           For marshalling, Castor XML can equally use any JAXP complaint XML parser (or
           interact with an XML parser that implements the SAX API), with the exception 
           of the following special case: when using 'pretty printing' during marshalling 
           (by setting the corresponding property in <code class="literal">castor.properties</code>
           to <code class="literal">true</code>) with Java 1.4 or below, 
           <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xml.apache.org/xerces" target="_top">Apache Xerces</a>
           has to be on the classpath, as Castor XML internally uses Xerces' <code class="literal">XMLSerializer</code>
           to implement this feature.
        </p><p>
           The following table enlists the requirements relative to the Java version
           used in your environment.
        </p><div class="table"><a name="d4e1057"></a><p class="title"><b>Table&nbsp;1.14.&nbsp;XML APIs on various Java versions</b></p><div class="table-contents"><table summary="XML APIs on various Java versions" border="1"><colgroup><col><col align="center"></colgroup><thead><tr><th>Java 1.4 and below</th><th align="center">Java 5.0 and above</th></tr></thead><tbody><tr><td>Xerces 2.6.2</td><td align="center"> - </td></tr><tr><td>XML APIs</td><td align="center"> - </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1073"></a>1.4.2.&nbsp;StAX</h3></div></div></div><p>
            As of Castor 1.3.2, Castor XML can be used with a StAX-compliant parser to unmarshal from XML. 
            Please see <a href="XML data binding.html#xml.framework.introspection.ouput" title="Example&nbsp;1.1.&nbsp;XML produced in introspection mode">Example&nbsp;1.1, &#8220;XML produced in introspection mode&#8221;</a> for StAX-specific 
            <code class="methodname">unmarshal</code> methods added to 
            <code class="classname">org.exolab.castor.xml.Unmarshaller</code>.  
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1079"></a>1.5.&nbsp;XML configuration file</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1081"></a>1.5.1.&nbsp;News</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					Added a section on how to access the properties as
					defined in the Castor properties file from within
					code.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2.1:</strong></span>
					: Added new
					<code class="classname">
						org.exolab.castor.xml.lenient.integer.validation
					</code>
					property to allow configuration of leniency for
					validation for Java properties generated from
					<code class="classname">&lt;xs:integer&gt;</code>
					types during code generation.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.2:</strong></span>
					: Access to the
					<code class="classname">org.exolab.castor.util.LocalConfiguration</code>
					class has been removed completely. To access the
					properties as used by Castor from code, please refer
					to the below section.
				</p></li><li><p>
					<span class="bold"><strong>Release 1.1.3:</strong></span>
					Added special processing of proxied classes. The
					property org.exolab.castor.xml.proxyInterfaces
					allows you to specify a list of interfaces that such
					proxied objects implement. If your object implements
					one of these interfaces Castor will not use the
					class itself but its superclass at introspection or
					to find class mappings and ClassDescriptors.
				</p></li><li><p>
					<span class="bold"><strong>Release 0.9.7:</strong></span>
					Added new org.exolab.castor.persist.useProxies
					property to allow configuration of JDBC proxy
					classes. If enabled, JDBC proxy classes will be used
					to wrap
					<code class="classname">java.sql.Connection</code>
					and
					<code class="classname">java.sql.PreparedStatement</code>
					instances, to allow for more detailed and complete
					JDBC statements to be output during logging. When
					turned off, no logging statements will be generated
					at all.
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1103"></a>1.5.2.&nbsp;Introduction</h3></div></div></div><p>
			Castor uses a configuration file for environmental
			properties that are shared across all the Castor sub
			systems. The configuration file is specified as a Java
			properties file with the name <code class="filename">castor.properties</code>.
		</p><p>
			By definition, a default configuration file is included with the
            Castor XML JAR. Custom properties can be supplied using one of the
            following methods. Please note that the custom properties specified
            will <span class="bold"><strong>override</strong></span> the default 
            configuration. 
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    anywhere on the classpath of your application.
                </p></li><li><p>
                    Place a file named <code class="filename">castor.properties</code>
                    in the working directory of your application.
                </p></li><li><p>
                    Use the system property 
                    <code class="literal">org.castor.user.properties.location</code> to
                    specify the location of your custom properties.
                </p></li></ul></div><p>
            Please note that Castor XML - upon startup - will try the methods
            given above in exactly the sequence as stated above; if it managed
            to find a custom property file using any of the given methods,
            it will cancel its search.
        </p><p>
			When running the provided examples, Castor will use the
			configuration file located in the examples directory which
			specifies additional debugging information as well as pretty
			printing of all produced XML documents.
		</p><p>
			The following properties are currently supported in the
			configuration file:
		</p><div class="table"><a name="d4e1122"></a><p class="title"><b>Table&nbsp;1.15.&nbsp;</b></p><div class="table-contents"><table border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>Values</th><th>Default</th><th>Since</th></tr></thead><tbody><tr><td>
						org.exolab.castor.xml.introspector.primitive.nodetype
					</td><td>
						Property specifying the type of XML node to use
						for primitive values, either
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">element</code>
						or
						<code class="classname">attribute</code>
					</td><td>
						<code class="classname">attribute</code>
					</td><td>-</td></tr><tr><td>org.exolab.castor.parser</td><td>
                        Property specifying the class name of the SAX
                        XML parser to use.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.parser.validation</td><td>
                        Specifies whether to perform XML document
                        validation by default.
                    </td><td>
                        <code class="classname">true</code>
                        and
                        <code class="classname">false</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.parser.namespaces</td><td>
                        Specifies whether to support XML namespaces by
                        default.
                    </td><td>
                        <code class="classname">false</code>
                        and
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.xml.nspackages</td><td>
                        Specifies a list of XML namespace to Java
                        package mappings.
                    </td><td>-</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.naming</td><td>
                        Property specifying the 'type' of the XML naming
                        conventions to use. Values of this property must
                        be either
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                        .
                    </td><td>
                        <code class="classname">mixed</code>
                        ,
                        <code class="classname">lower</code>
                        , or the name of a class which extends
                        <code class="classname">org.exolab.castor.xml.XMLNaming</code>
                    </td><td>
                        <code class="classname">lower</code>
                    </td><td>-</td></tr><tr><td>org.castor.xml.java.naming</td><td>
                        Property specifying the 'type' of the Java
                        naming conventions to use. Values of this
                        property must be either
                        <code class="classname">null</code>
                        or the name of a class which extends
                        <code class="classname">link org.castor.xml.JavaNaming</code>.
                    </td><td>
                        <p>
                           <code class="classname">null</code>
                           or the name of a class which extends
                           <code class="classname">link org.castor.xml.JavaNaming</code>.
                        </p>
                    </td><td>
                        <code class="classname">null</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.marshalling.validation
                    </td><td>
                        Specifies whether to use validation during
                        marshalling.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.indent</td><td>
                        Specifies whether XML documents (as generated at
                        marshalling) should use indentation or not.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>org.exolab.castor.sax.features</td><td>Specifies additional features for the XML parser.
                    </td><td>A comma separated list of SAX (parser) features (that might or might not be supported by the specified SAX parser).</td><td><code class="classname">http://apache.org/xml/features/disallow-doctype-decl</code></td><td>-</td></tr><tr><td>org.exolab.castor.sax.features-to-disable</td><td>Specifies features to be disbaled on the underlying SAX parser.</td><td>A comma separated list of SAX (parser) features to be disabled.</td><td>
                        <code class="classname">http://xml.org/sax/features/external-general-entities</code>, 
                        <code class="classname">http://xml.org/sax/features/external-parameter-entities</code>, 
                        <code class="classname">http://apache.org/xml/features/nonvalidating/load-external-dtd</code>
                    </td><td>
                        <p><span class="bold"><strong>1.0.4</strong></span></p>
                    </td></tr><tr><td>org.exolab.castor.regexp</td><td>Specifies the regular expression validator to use.</td><td>A class that implements <code class="classname">org.exolab.castor.util.RegExpValidator</code>.</td><td>-</td><td>-</td></tr><tr><td>org.exolab.castor.xml.strictelements</td><td>
                        Specifies whether to apply strictness to
                        elements when unmarshalling. When enabled, the
                        existence of elements in the XML document, which
                        cannot be mapped to a class, causes a {@link
                        SAXException} to be thrown. If set to false,
                        these 'unknown' elements are ignored.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>-</td></tr><tr><td>
                        org.exolab.castor.xml.loadPackageMappings
                    </td><td>
                        Specifies whether the ClassDescriptorResolver
                        should (automatically) search for and consult
                        with package mapping files (
                        <code class="classname">.castor.xml</code>
                        ) to retrieve class descriptor information
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">true</code>
                    </td><td>
                        <span class="bold"><strong>1.0.2</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.serializer.factory
                    </td><td>
                        Specifying what XML serializers factory to use.
                    </td><td>A class name</td><td>
                        org.exolab.castor.xml.XercesXMLSerializerFactory
                    </td><td>
                        <span class="bold"><strong>1.0</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.sequence.order
                    </td><td>
                        Specifies whether sequence order validation
                        should be lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.id.validation
                    </td><td>
                        Specifies whether id/href validation should be
                        lenient.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.proxyInterfaces</td><td>
                        Specifies whether or not to search for an proxy
                        interface at marshalling. If property is not
                        empty the objects to be marshalled will be
                        searched if they implement one of the given
                        interface names. If the interface is
                        implemented, the superclass will be marshalled
                        instead of the class itself.
                    </td><td>A list of proxy interfaces</td><td>-</td><td>
                        <span class="bold"><strong>1.1.3</strong></span>
                    </td></tr><tr><td>
                        org.exolab.castor.xml.lenient.integer.validation
                    </td><td>
                        Specifies whether validation for Java properties
                        generated from &lt;xs:integer&gt; should be
                        lenient, i.e. allow for
                        <code class="classname">int</code>
                        s as well.
                    </td><td>
                        <code class="classname">false</code>
                        or
                        <code class="classname">true</code>
                    </td><td>
                        <code class="classname">false</code>
                    </td><td>
                        <span class="bold"><strong>1.2.1</strong></span>
                    </td></tr><tr><td>org.exolab.castor.xml.version</td><td>
                        Specifies the XML document version number to be used 
                        during marshalling; defaults to 1.0.
                    </td><td>
                        <code class="classname">1.0</code>
                        or
                        <code class="classname">1.1</code>
                    </td><td>
                        <code class="classname">1.0</code>
                    </td><td>
                        <span class="bold"><strong>1.3.2</strong></span>
                    </td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         As of Castor 1.3.3, the default values for <code class="classname">org.exolab.castor.sax.features</code> 
         and <code class="classname">org.exolab.castor.sax.features-to-disable</code> have changed to include/disable 
         selected features.
        </td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1319"></a>1.5.3.&nbsp;Accessing the properties from within code</h3></div></div></div><p>
			As of Castor 1.1, it is possible to read and set the value of properties programmatically using the
			<code class="classname">getProperty(String)</code> and <code class="classname">setProperty(String,String)</code>
			on the following classes:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					<code class="classname">org.exolab.castor.xml.Unmarshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.Marshaller</code>
				</p></li><li><p>
					<code class="classname">org.exolab.castor.xml.XMLContext</code>
				</p></li></ul></div><p>
			Whilst using the setter methods on the first two classes will change the settings of the respective instances only,
			using the <code class="classname">setProperty()</code> method on the <code class="classname">org.exolab.castor.xml.XMLContext</code>
			class will change the configuration globally, and affect all <code class="classname">org.exolab.castor.xml.Unmarshaller</code>
			and <code class="classname">org.exolab.castor.xml.Marshaller</code> instances created thereafter using the
			<code class="methodname">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code> and
			<code class="methodname">org.exolab.castor.xml.XMLContext.createMarshaller()</code> methods.
		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1341"></a>1.6.&nbsp;Castor XML - Tips &amp; Tricks</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1343"></a>1.6.1.&nbsp;Logging and Tracing</h3></div></div></div><p>When developing using Castor, we recommend that you use the various
         <code class="literal">setLogWriter</code> methods to get detailed information and error
         messages.</p><p>Using a logger with <code class="classname">org.exolab.castor.mapping.Mapping</code> will
         provide detailed information about mapping decisions made by Castor and
         will show the SQL statements being used.</p><p>Using a logger with <code class="classname">org.exolab.castor.jdo.JDO</code> will provide
         trace messages that show when Castor is loading, storing, creating and
         deleting objects. All database operations will appear in the log; if an
         object is retrieved from the cache or is not modified, there will be no
         trace of load/store operations.</p><p>Using a logger with <code class="classname">org.exolab.castor.xml.Unmarshaller</code> will
         provide trace messages that show conflicts between the XML document and
         loaded objects.</p><p>A simple trace logger can be obtained from
         <code class="classname">org.exolab.castor.util.Logger</code>. This logger uses the
         standard output stream, but prefixes each line with a short message
         that indicates who generated it. It can also print the time and date of
         each message. Since logging is used for warning messages and simple
         tracing, Castor does not require a sophisticated logging mechanism.</p><p>Interested in integratating Castor's logging with Log4J? Then see
         <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo-faq.html#How-can-I-integrate-Castor's-logging-with-a-logging-infrastructure-using-Log4J?" target="_top">
         this question</a> in the JDO FAQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1357"></a>1.6.2.&nbsp;Indentation</h3></div></div></div><p>By default the marshaler writes XML documents without indentation. When
         developing using Castor or when debugging an application that uses
         Castor, it might be desireable to use indentation to make the XML
         documents human-readable. To turn indentation on, modify the Castor
         properties file, or create a new properties file in the classpath
         (named <code class="literal">castor.properties</code>) with the following content:</p><pre class="programlisting">
org.exolab.castor.indent=true
      </pre><p>Indentation inflates the size of the generated XML documents, and also
         consumes more CPU. It is recommended not to use indentation in a
         production environment.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1363"></a>1.6.3.&nbsp;XML:Marshal validation</h3></div></div></div><p>It is possible to disable the validation in the marshaling framework
           by modifying the Castor properties file or by creating a new
           properties file in the classpath (named <code class="literal">castor.properties</code>)
           with the following content:</p><pre class="programlisting">
 org.exolab.castor.marshalling.validation=false
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1368"></a>1.6.4.&nbsp;NoClassDefFoundError</h3></div></div></div><p>
          Check your CLASSPATH, check it often, there is no reason not to!
       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1371"></a>1.6.5.&nbsp;Mapping: auto-complete</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>This only works with Castor-XML.</p></td></tr></table></div><p>
          To save time when writing your mappings, try using the <span class="italic">auto-complete</span>
          attribute of <span class="italic">class</span>. When using auto-complete, Castor will introspect
          your class and automatically fill in any missing fields.
       </p><p>
          <span class="bold"><strong>Example:</strong></span>
          </p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"com.acme.Foo"</span> <span class="hl-attribute">auto-complete</span>=<span class="hl-value">"true"</span>/&gt;
          </pre><p>
       </p><p>
          This is also compatible with generated descriptor files. You can use a mapping file
          to override some of the behavior of a compiled descriptor by using auto-complete.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Be careful to make sure you use the exact field name as specified
          in the generated descriptor file in order to modify the behavior of the field descriptor!
          Otherwise, you'll probably end up with two fields being marshaled!
          </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1384"></a>1.6.6.&nbsp;Create method</h3></div></div></div><p>
         Castor requires that classes have a public, no-argument constructor
         in order to provide the ability to marshal &amp; unmarshal objects of that type.
      </p><p>
         create-method is an optional attribute to the <code class="literal">&lt;field&gt;</code> mapping
         element that can be used to overcome this restriction in cases where you
         have an existing object model that consists of, say, singleton classes
         where public, no-argument constructors must not be present by definition.
      </p><p>
         Assume for example that a class "<code class="literal">A</code>" that you want to be able
         to unmarshal uses a singleton class as one of its properties. When
         attempting to unmarshal class "<code class="literal">A</code>", you should get an exception
         because the singleton property has no public no-arg constructor.
         Assuming that a reference to the singleton can be obtained via a static
         getInstance() method, you can add a "create method" to class <code class="literal">A</code>
         like this:
      </p><pre class="programlisting">
 <span class="hl-keyword">public</span> MySingleton getSingletonProperty() {
    <span class="hl-keyword">return</span> MySingleton.getInstance();
 }
      </pre><p>
         and in the mapping file for class <code class="classname">A</code>, you can define 
         the singleton property like this:
      </p><pre class="programlisting">
 &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySingletonProperty"</span>
       <span class="hl-attribute">type</span>=<span class="hl-value">"com.u2d.MySingleton"</span>
       <span class="hl-attribute">create-method</span>=<span class="hl-value">"getSingletonProperty"</span>&gt;
    &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">name</span>=<span class="hl-value">"my-singleton-property"</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span> /&gt;
 &lt;<span class="hl-tag">/field</span>&gt;</pre><p>
         This illustrates how the create-method attribute is quite a useful
         mechanism for dealing with exceptional situations where you might
         want to take advantage of marshaling even when some classes do not
         have no-argument public constructors.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
           As of this writing, the specified create-method must
           exist as a method in the current class (i.e. the class being described
           by the current <code class="literal">&lt;class&gt;</code> element). In the future it may be possible
           to use external static factory methods.
        </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1401"></a>1.6.7.&nbsp;MarshalListener and UnmarshalListener</h3></div></div></div><p>
         Castor allows control on the object being marshaled or unmarshaled by
         a set of two listener interfaces: MarshalListener and UnmarshalListener.
      </p><p>
         The MarshalListener interface located in <code class="code">org.exolab.castor.xml</code> listens to
         two different events that are intercepted by the following methods:
         </p><div class="itemizedlist"><ul type="disc"><li><p>preMarshal: this method is called before an object gets marshaled.</p></li><li><p>postMarshal: this method is called once an object has been marshaled.</p></li></ul></div><p>
      </p><p>
         The UnmarshalListener located also in <code class="literal">org.castor.xml</code> listens to
         four different events that are intercepted by the following methods:
      </p><div class="itemizedlist"><ul type="disc"><li><p>initialized: this method is called once an object has been instantiated.</p></li><li><p>attributesProcessed: this method is called when the attributes have just been read and processed.</p></li><li><p>fieldAdded: this method is called when an object is added to a parent.</p></li><li><p>unmarshalled: this method is called when an object has been <span class="bold"><strong>fully</strong></span> unmarshaled</p></li></ul></div><p>
         <span class="bold"><strong>Note:</strong></span> The <code class="classname">UnmarshalListener</code> had been part of <code class="code">org.exolab.castor.xml</code>
         but as an extention of this interface had been required a new interface in <code class="code">org.castor.xml</code>
         was introduced. Currently the <code class="code">org.exolab.castor.xml.UnmarshalListener</code> interface
         can still be used but is deprecated.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1429"></a>1.7.&nbsp;Castor XML: Writing Custom FieldHandlers</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1431"></a>1.7.1.&nbsp;Introduction</h3></div></div></div><p>
          Sometimes we need to deal with a data format that Castor doesn't
          support out-of-the-box, such as an unsupported Date/Time
          representation, or we want to wrap and unwrap fields in Wrapper
          objects to get the desired XML output without changing our object
          model. To handle these cases Castor allows specifying a custom
          <code class="classname">org.exolab.castor.mapping.FieldHandler</code>
          which can do these varying conversions during calls to the fields
          setter and getter methods.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
       		The
       		<span class="italic">FieldHandler</span>
       		is the basic interface used by the Castor Framework when
       		accessing field values or setting them. By specifying a
       		custom
       		<span class="italic">FieldHandler</span>
       		in the mapping file we can basically intercept the calls
       		to retrieve or set a field's value and do whatever
       		conversions are necessary.
       	</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1439"></a>1.7.2.&nbsp;Writing a simple FieldHandler</h3></div></div></div><p>
         When a writing a FieldHandler handler we need to provide implementations
         of the various methods specified in the FieldHandler interface. The main
         two methods are the <span class="italic">getValue</span> and <span class="italic">setValue</span> methods which
         will basically handle all our conversion code. The other methods provide
         ways to create a new instance of the field's value or reset the field
         value.
       </p><p>
         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
                It's actually even easier to write custom field handlers if we use
                a GeneralizedFieldHandler. See more details in 
                <a href="XML data binding.html#xml.field.handler.generalized" title="1.7.3.&nbsp;Writing a GeneralizedFieldHandler">Section&nbsp;1.7.3, &#8220;Writing a GeneralizedFieldHandler&#8221;</a>
            </p></td></tr></table></div><p>
       </p><p>
         Let's take a look at how to convert a date in the format YYYY-MM-DD using
         a custom FieldHandler. We want to marshal the following XML input file <code class="classname">text.xml</code>:
         </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">root</span>&gt;2004-05-10&lt;<span class="hl-tag">/root</span>&gt;</pre><p>

         The class we'll be marshalling from and unmarshalling to looks as follows:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Root {

    <span class="hl-keyword">private</span> Date _date;

    <span class="hl-keyword">public</span> Root() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Date getDate() {
        <span class="hl-keyword">return</span> _date;
    }


    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDate(<span class="hl-keyword">final</span> Date date) {
        _date = date;
    }
         </pre><p>

        So we need to write a custom FieldHandler that takes the input String
        and converts it into the proper java.util.Date instance:

       </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">implements</span> FieldHandler
{

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(<span class="hl-keyword">final</span> Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value) 
       <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
       
        Root root = (Root)object;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }


    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }


    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }
}
       </pre><p>

         </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>The <span class="italic">newInstance</span> method should return null for immutable types.</p></td></tr></table></div><p>

       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
          There is also an
          <code class="classname">org.exolab.castor.mapping.AbstractFieldHandler</code>
          that we can extend instead of implementing FieldHandler directly.
          Not only do we not have to implement deprecated methods, but we can also
          gain access to the <span class="italic">FieldDescriptor</span> used by Castor.
        </p></td></tr></table></div><p>

       In order to tell Castor that we want to use our Custom FieldHandler
       we must specify it in the mapping file <code class="classname">mapping.xml</code>:

        </p><pre class="programlisting">

&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"MyDateHandler"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"text"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;

        </pre><p>

         We can now use a simple Test class to unmarshal our XML document:

         </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	       <span class="hl-comment">//--load mapping</span>
	       Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	       mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

           System.out.println(<span class="hl-string">"unmarshalling root instance:"</span>);
           System.out.println();

           Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
           Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Root.<span class="hl-keyword">class</span>);
           unmarshaller.setMapping(mapping);
           Root root = (Root) unmarshaller.unmarshal(reader);
           reader.close();

           System.out.println(<span class="hl-string">"Root#getDate : "</span> + root.getDate());
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}

         </pre><p>

         Now simply compile the code and run!

         </p><pre class="programlisting">
% java Test
unmarshalling root instance:

Root#getDate : Mon May 10 00:00:00 CDT 2004
         </pre><p>

         After running our test program we can see that Castor invoked our
         custom FieldHandler and we got our properly formatted date in our
         Root.class.

       </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.field.handler.generalized"></a>1.7.3.&nbsp;Writing a GeneralizedFieldHandler</h3></div></div></div><p>
         A <code class="classname">org.exolab.castor.mapping.GeneralizedFieldHandler</code>
         is an extension of FieldHandler interface
         where we simply write the conversion methods and Castor will automatically
         handle the underlying get/set operations. This allows us to re-use the
         same FieldHandler for fields from different classes that require the
         same conversion.
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
         <span class="bold"><strong>Note:</strong></span>
         Currently the GeneralizedFieldHandler cannot be used from a
         <span class="italic">binding-file</span> for use with the SourceGenerator, an
         enhancement patch will be checked into SVN for this feature,
         shortly after 0.9.6 final is released.
         </p></td></tr></table></div><p>
        The same FieldHandler we used above can be written as a GeneralizedFieldHandler
        as such:
        </p><pre class="programlisting">

<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-comment">/**
 * The FieldHandler for the Date class
 *
 */</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyDateHandler <span class="hl-keyword">extends</span> GeneralizedFieldHandler {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FORMAT = <span class="hl-string">"yyyy-MM-dd"</span>;

    <span class="hl-comment">/**
     * Creates a new MyDateHandler instance
     */</span>
    <span class="hl-keyword">public</span> MyDateHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * getValue method is called. The getValue method will
     * obtain the actual field value from given 'parent' object.
     * This convert method is then invoked with the field's
     * value. The value returned from this method will be
     * the actual value returned by getValue method.
     *
     * @param value the object value to convert after
     *  performing a get operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = (Date)value;
        <span class="hl-keyword">return</span> formatter.format(date);
    }


    <span class="hl-comment">/**
     * This method is used to convert the value when the
     * setValue method is called. The setValue method will
     * call this method to obtain the converted value.
     * The converted value will then be used as the value to
     * set for the field.
     *
     * @param value the object value to convert before
     *  performing a set operation
     * @return the converted value.
     */</span>
    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        SimpleDateFormat formatter = <span class="hl-keyword">new</span> SimpleDateFormat(FORMAT);
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        <span class="hl-keyword">return</span> date;
    }

    <span class="hl-comment">/**
     * Returns the class type for the field that this
     * GeneralizedFieldHandler converts to and from. This
     * should be the type that is used in the
     * object model.
     *
     * @return the class type of of the field
     */</span>
    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Date.<span class="hl-keyword">class</span>;
    }

    <span class="hl-comment">/**
     * Creates a new instance of the object described by
     * this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple
     *  type and cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent) <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}

        </pre><p>

        Everything else is the same. So we can re-run our test case using this
        GeneralizedFieldHandler and we'll get the same result. The main difference
        is that we implement the <span class="italic">convertUponGet</span> and <span class="italic">convertUponSet</span>
        methods.
        </p><p>
           Notice that we never reference the <span class="italic">Root</span> 
           class in our <code class="classname">GeneralizedFieldHandler</code>. This allows us 
           to use the same exact <code class="classname">FieldHandler</code> for any field 
           that requires this type of conversion.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1480"></a>1.7.4.&nbsp;Use ConfigurableFieldHandler for more flexibility</h3></div></div></div><p>
   		In some situations, the <code class="classname">GeneralizedFieldHandler</code> might not 
           provide sufficient flexibility. Suppose your XML document uses more than one 
           date format. You could solve this by creating a <code class="classname">GeneralizedFieldHandler</code> 
           subclass per date format, but that would lead to code duplication, which in 
           itself is not desirable. 
         </p><p>
         	A <code class="classname">ConfigurableFieldHandler</code> is a <code class="classname">FieldHandler</code> 
            that can be configured in the mapping file
         	with any kind and any number of parameters. You can simply configure two (or more)
         	instances of the same <code class="classname">ConfigurableFieldHandler</code> class 
            with different date format patterns.
         	Here's a mapping file that uses a <code class="classname">ConfigurableFieldHandler</code> 
            to marshal and unmarshal the
         	date field, similar to the preceding examples:
            
         	</p><pre class="programlisting">
&lt;?xml version=<span class="hl-string">"1.0"</span>?&gt;
&lt;mapping&gt;
   
   &lt;field-handler name=<span class="hl-string">"myHandler"</span> <span class="hl-keyword">class</span>=<span class="hl-string">"FieldHandlerImpl"</span>&gt;
      &lt;param name=<span class="hl-string">"date-format"</span> value=<span class="hl-string">"yyyyMMddHHmmss"</span>/&gt;
   &lt;/field-handler&gt;
   
   &lt;<span class="hl-keyword">class</span> name=<span class="hl-string">"Root"</span>&gt;
      &lt;field name=<span class="hl-string">"date"</span> type=<span class="hl-string">"string"</span> handler=<span class="hl-string">"myHandler"</span>/&gt;
   &lt;/<span class="hl-keyword">class</span>&gt;

&lt;/mapping&gt;
         	</pre><p>
         	
         	The <span class="italic">field-handler</span> element defines the 
            <code class="classname">ConfigurableFieldHandler</code>. 
         	The class must be an implementation of the 
         	<span class="italic">org.exolab.castor.mapping.ConfigurableFieldHandler</span> 
            interface. This 
         	instance is configured with a date format. However, each implementation can decide
         	which, and how many parameters to use.
         </p><p>
         	The field handler instance is referenced by the 
            <span class="italic">field</span> element, using
         	the <span class="italic">handler</span> attribute.
         </p><p>
      	Here's the ConfigurableFieldHandler implementation:
      	</p><pre class="programlisting">
<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.util.Date;

<span class="hl-keyword">import</span> java.text.ParseException;
<span class="hl-keyword">import</span> java.text.SimpleDateFormat;
<span class="hl-keyword">import</span> java.text.DateFormat;
<span class="hl-keyword">import</span> java.util.Date;
<span class="hl-keyword">import</span> java.util.Properties;

<span class="hl-keyword">import</span> org.exolab.castor.mapping.ConfigurableFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.ValidityException;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler {

    <span class="hl-keyword">private</span> DateFormat formatter;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setConfiguration(<span class="hl-keyword">final</span> Properties config) <span class="hl-keyword">throws</span> ValidityException {
    	String pattern = config.getProperty(<span class="hl-string">"date-format"</span>);
    	<span class="hl-keyword">if</span> (pattern == null) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Required parameter \"date-format\" is missing for FieldHandlerImpl."</span>);
    	}
    	<span class="hl-keyword">try</span> {
    		formatter = <span class="hl-keyword">new</span> SimpleDateFormat(pattern);
    	} <span class="hl-keyword">catch</span> (IllegalArgumentException e) {
    		<span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> ValidityException(<span class="hl-string">"Pattern \""</span>+pattern+<span class="hl-string">"\" is not a valid date format."</span>);
    	}
    }

    <span class="hl-comment">/**
     * Returns the value of the field from the object.
     *
     * @param object The object
     * @return The value of the field
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> Object getValue(Object object) <span class="hl-keyword">throws</span> IllegalStateException {
        Root root = (Root)object;
        Date value = root.getDate();
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        <span class="hl-keyword">return</span> formatter.format(value);
    }

    <span class="hl-comment">/**
     * Sets the value of the field on the object.
     *
     * @param object The object
     * @param value The new value
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     * @throws IllegalArgumentException The value passed is not of
     *  a supported type
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValue(Object object, Object value)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        Root root = (Root)object;
        Date date = null;
        <span class="hl-keyword">try</span> {
            date = formatter.parse((String)value);
        }
        <span class="hl-keyword">catch</span>(ParseException px) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(px.getMessage());
        }
        root.setDate(date);
    }
    
    <span class="hl-comment">/**
     * Creates a new instance of the object described by this field.
     *
     * @param parent The object for which the field is created
     * @return A new instance of the field's value
     * @throws IllegalStateException This field is a simple type and
     *  cannot be instantiated
     */</span>
    <span class="hl-keyword">public</span> Object newInstance(Object parent)
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

    <span class="hl-comment">/**
     * Sets the value of the field to a default value.
     *
     * Reference fields are set to null, primitive fields are set to
     * their default value, collection fields are emptied of all
     * elements.
     *
     * @param object The object
     * @throws IllegalStateException The Java object has changed and
     *  is no longer supported by this handler, or the handler is not
     *  compatible with the Java object
     */</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resetValue(Object object)
        <span class="hl-keyword">throws</span> IllegalStateException, IllegalArgumentException {
        ((Root)object).setDate(null);
    }

}
      	</pre><p>
         
         	This implementation is similar to the first 
            <span class="italic">MyDateHandler</span> example
         	on this page, except that is adds a 
            <span class="italic">setConfiguration</span> method as
         	specified by the 
            <span class="italic">ConfigurableFieldHandler</span> interface. All parameters 
         	that are configured	in the mapping file will be passed in as a 
            <span class="italic">Properties</span>
         	object. The implementing method is responsible for processing 
            the configuration data.
         </p><p>
         	As a convenience, 
            <span class="italic">org.exolab.castor.mapping.AbstractFieldHandler</span> 
            already 
         	implements <span class="italic">ConfigurableFieldHandler</span>. However, 
            the <span class="italic">setConfiguration</span>
         	method is not doing anything. Any subclass of 
            <span class="italic">AbstractFieldHandler</span> only
         	has to override this method to leverage the configuration capabilities. Since 
            <span class="italic">
         	AbstractFieldHandler</span> and its subclass 
            <span class="italic">GeneralizedFieldHandler</span> are
         	useful abstract classes, you'd probably want to use them anyway. It eliminates the 
         	need to	implement the 
            <span class="italic">ConfigurableFieldHandler</span> interface yourself. 
         </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1511"></a>1.7.5.&nbsp;Reuse a <code class="classname">ConfigurableFieldHandler</code> for more than one field definition</h3></div></div></div><p>
    		Imagine a scenario where you want to use above <code class="classname">ConfigurableFieldHandler</code> 
    		instance for more than one field - a valid use case as it promotes reuse.
    	</p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
   
   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"myFirstHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyyMMddHHmmss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;

   &lt;<span class="hl-tag">field-handler</span> <span class="hl-attribute">name</span>=<span class="hl-value">"mySecondHandler"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"FieldHandlerImpl"</span>&gt;
      &lt;<span class="hl-tag">param</span> <span class="hl-attribute">name</span>=<span class="hl-value">"date-format"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"yyyy-MM-ddHH:mm:ss"</span>/&gt;
   &lt;<span class="hl-tag">/field-handler</span>&gt;
   
   &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Root"</span>&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"firstDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"secondDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"myFirstHandler"</span>/&gt;
      &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"thirdDate"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"mySecondHandler"</span>/&gt;
   &lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">/mapping</span>&gt;
         </pre><p>
    		For this to work, there's one more thing you will have to do: your 
    		<code class="classname">ConfigurableFieldHandler</code> implementation has to implement the 
    		<code class="classname">ClonableFieldHandlerMarker</code> interface and implement
    		the <code class="methodname">copyFieldHandler()</code> method. As indicated by the name, 
    		please return a clone/copy of your <code class="classname">FieldHandler</code> instance ... and you 
    		are all set.
    	</p><p>
    		A simplified sample implementation could look as follows, extending the 
    		<code class="classname">FieldHandlerImpl</code> class from the previous section:
    	</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> FieldHandlerImpl <span class="hl-keyword">implements</span> FieldHandler, ConfigurableFieldHandler, ClonableFieldHandlerMarker {

    <span class="hl-keyword">private</span> DateFormat format;

    ...

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFormat(DateFormat format) {
        <span class="hl-keyword">this</span>.format = format;
    }

    @Override
    <span class="hl-keyword">public</span> FieldHandler copyFieldHandler() {
        FieldHandlerImpl handler = <span class="hl-keyword">new</span> FieldHandlerImpl();
        handler.setFormat(<span class="hl-keyword">this</span>.getFormat());
        <span class="hl-keyword">return</span> handler;
    }
    
}    	
    	</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1525"></a>1.7.6.&nbsp;No Constructor, No Problem!</h3></div></div></div><p>
         A number of classes such as type-safe enum style classes have no constructor, but
         instead have some sort of static factory method used for converting a string value
         into an instance of the class. With a custom FieldHandler we can allow Castor to
         work nicely with these types of classes.
      </p><p>
       </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
          Castor XML automatically supports these types of classes if they have a specific
          method:
          </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">static</span> {Type} valueOf(String)
          </pre><p>
          </p></td></tr></table></div><p>
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>We're working on the same support for Castor JDO</p></td></tr></table></div><p>
     </p><p>
     Even though Castor XML supports the "valueOf" method type-safe enum style classes, we'll
     show you how to write a custom handler for these classes anyway since it's useful for
     any type of class regardless of the name of the factory method.
     </p><p>
       Let's look at how to write a handler for the following type-safe enum style class,
       which was actually generated by Castor XML (javadoc removed for brevity):
       </p><pre class="programlisting">
<span class="hl-keyword">import</span> java.io.Serializable;
<span class="hl-keyword">import</span> java.util.Enumeration;
<span class="hl-keyword">import</span> java.util.Hashtable;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Color <span class="hl-keyword">implements</span> java.io.Serializable {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> RED_TYPE = 0;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color RED = <span class="hl-keyword">new</span> Color(RED_TYPE, <span class="hl-string">"red"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> GREEN_TYPE = 1;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color GREEN = <span class="hl-keyword">new</span> Color(GREEN_TYPE, <span class="hl-string">"green"</span>);

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">int</span> BLUE_TYPE = 2;

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> Color BLUE = <span class="hl-keyword">new</span> Color(BLUE_TYPE, <span class="hl-string">"blue"</span>);

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable _memberTable = init();

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> type = -1;

    <span class="hl-keyword">private</span> java.lang.String stringValue = null;


    <span class="hl-keyword">private</span> Color(<span class="hl-keyword">int</span> type, java.lang.String value) {
        <span class="hl-keyword">super</span>();
        <span class="hl-keyword">this</span>.type = type;
        <span class="hl-keyword">this</span>.stringValue = value;
    } <span class="hl-comment">//-- test.types.Color(int, java.lang.String)</span>


    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> java.util.Enumeration enumerate()
    {
        <span class="hl-keyword">return</span> _memberTable.elements();
    } <span class="hl-comment">//-- java.util.Enumeration enumerate()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getType()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.type;
    } <span class="hl-comment">//-- int getType()</span>

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> java.util.Hashtable init()
    {
        Hashtable members = <span class="hl-keyword">new</span> Hashtable();
        members.put(<span class="hl-string">"red"</span>, RED);
        members.put(<span class="hl-string">"green"</span>, GREEN);
        members.put(<span class="hl-string">"blue"</span>, BLUE);
        <span class="hl-keyword">return</span> members;
    } <span class="hl-comment">//-- java.util.Hashtable init()</span>

    <span class="hl-keyword">public</span> java.lang.String toString()
    {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.stringValue;
    } <span class="hl-comment">//-- java.lang.String toString()</span>

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> Color valueOf(java.lang.String string)
    {
        Object obj = null;
        <span class="hl-keyword">if</span> (string != null) obj = _memberTable.get(string);
        <span class="hl-keyword">if</span> (obj == null) {
            String err = <span class="hl-string">"'"</span> + string + <span class="hl-string">"' is not a valid Color"</span>;
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalArgumentException(err);
        }
        <span class="hl-keyword">return</span> (Color) obj;
    } <span class="hl-comment">//-- test.types.Color valueOf(java.lang.String)</span>

}
       </pre><p>

      The <span class="italic">GeneralizedFieldHandler</span> for the above <span class="italic">Color</span> class is as follows
      (javadoc removed for brevity):

      </p><pre class="programlisting">
<span class="hl-keyword">import</span> org.exolab.castor.mapping.GeneralizedFieldHandler;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.FieldDescriptor;

<span class="hl-comment">/**
 * The FieldHandler for the Color class
**/</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ColorHandler
    <span class="hl-keyword">extends</span> GeneralizedFieldHandler
{

    <span class="hl-keyword">public</span> ColorHandler() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Object convertUponGet(Object value) {
        <span class="hl-keyword">if</span> (value == null) <span class="hl-keyword">return</span> null;
        Color color = (Color)value;
        <span class="hl-keyword">return</span> color.toString();
    }


    <span class="hl-keyword">public</span> Object convertUponSet(Object value) {
        <span class="hl-keyword">return</span> Color.valueOf((String)value);
    }

    <span class="hl-keyword">public</span> Class getFieldType() {
        <span class="hl-keyword">return</span> Color.<span class="hl-keyword">class</span>;
    }

    <span class="hl-keyword">public</span> Object newInstance( Object parent )
        <span class="hl-keyword">throws</span> IllegalStateException
    {
        <span class="hl-comment">//-- Since it's marked as a string...just return null,</span>
        <span class="hl-comment">//-- it's not needed.</span>
        <span class="hl-keyword">return</span> null;
    }

}
     </pre><p>
     </p><p>
      That's all there really is to it. Now we just need to hook this up to our mapping file
      and run a sample test.
     </p><p>
       If we have a root class <span class="italic">Foo</span> as such:
     </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Foo {

    <span class="hl-keyword">private</span> Color _color = null;
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> _size = 0;
    <span class="hl-keyword">private</span> String _name = null;

    <span class="hl-keyword">public</span> Foo() {
        <span class="hl-keyword">super</span>();
    }

    <span class="hl-keyword">public</span> Color getColor() {
        <span class="hl-keyword">return</span> _color;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> _name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getSize() {
        <span class="hl-keyword">return</span> _size;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setColor(Color color) {
        _color = color;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(String name) {
        _name = name;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSize(<span class="hl-keyword">int</span> size) {
        _size = size;
    }

}
       </pre><p>
       Our mapping file would be the following:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">mapping</span>&gt;
  &lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"Foo"</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"size"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span>&gt;
        &lt;<span class="hl-tag">bind-xml</span> <span class="hl-attribute">node</span>=<span class="hl-value">"element"</span>/&gt;
     &lt;<span class="hl-tag">/field</span>&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"name"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>/&gt;
     &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"color"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span> <span class="hl-attribute">handler</span>=<span class="hl-value">"ColorHandler"</span>/&gt;
  &lt;<span class="hl-tag">/class</span>&gt;
&lt;<span class="hl-tag">/mapping</span>&gt;
       </pre><p>

       We can now use our custom FieldHandler to unmarshal the following xml input:
       </p><pre class="programlisting">
&lt;<span class="hl-tag">?xml version="1.0"?</span>&gt;
&lt;<span class="hl-tag">foo</span>&gt;
   &lt;<span class="hl-tag">name</span>&gt;MyFoo&lt;<span class="hl-tag">/name</span>&gt;
   &lt;<span class="hl-tag">size</span>&gt;345&lt;<span class="hl-tag">/size</span>&gt;
   &lt;<span class="hl-tag">color</span>&gt;blue&lt;<span class="hl-tag">/color</span>&gt;
&lt;<span class="hl-tag">/foo</span>&gt;
       </pre><p>

       A sample test class is as follows:
       </p><pre class="programlisting">

<span class="hl-keyword">import</span> java.io.*;
<span class="hl-keyword">import</span> org.exolab.castor.xml.*;
<span class="hl-keyword">import</span> org.exolab.castor.mapping.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Test {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) {
	    <span class="hl-keyword">try</span> {

	        <span class="hl-comment">//--load mapping</span>
	        Mapping mapping = <span class="hl-keyword">new</span> Mapping();
	        mapping.loadMapping(<span class="hl-string">"mapping.xml"</span>);

            System.out.println(<span class="hl-string">"unmarshalling Foo:"</span>);
            System.out.println();

            Reader reader = <span class="hl-keyword">new</span> FileReader(<span class="hl-string">"test.xml"</span>);
            Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller(Foo.<span class="hl-keyword">class</span>);
            unmarshaller.setMapping(mapping);
            Foo foo = (Foo) unmarshaller.unmarshal(reader);
            reader.close();

            System.out.println(<span class="hl-string">"Foo#size : "</span> + foo.getSize());
            System.out.print(<span class="hl-string">"Foo#color: "</span>);
            <span class="hl-keyword">if</span> (foo.getColor() == null) {
                System.out.println(<span class="hl-string">"null"</span>);
            }
            <span class="hl-keyword">else</span> {
                System.out.println(foo.getColor().toString());
            }

            PrintWriter pw = <span class="hl-keyword">new</span> PrintWriter(System.out);
            Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(pw);
            marshaller.setMapping(mapping);
            marshaller.marshal(foo);
            pw.flush();
	    }
	    <span class="hl-keyword">catch</span> (Exception e) {
	        e.printStackTrace();
	    }
    }
}
        </pre><p>
     </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1548"></a>1.7.7.&nbsp;Collections and FieldHandlers</h3></div></div></div><p>
         </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
                With Castor 0.9.6 and later, the <span class="italic">GeneralizedFieldHandler</span> 
                automatically supports iterating over the items of a collection and passing them 
                one-by-one to the <span class="italic">convertUponGet</span>.
            </p><p> 
                For backward compatibility or to handle the collection iteration yourself, 
                simply add the following to the constructor of your 
                <code class="classname">GeneralizedFieldHandler</code> implementation:

            </p><pre class="programlisting">
setCollectionIteration(false);
            </pre><p>
         
            </p></td></tr></table></div><p>
      </p><p>
         If you're going to be using custom field handlers for collection fields with
         a <code class="classname">GeneralizedFieldHandler</code> using versions of Castor 
         prior to 0.9.6, then you'll need to handle the collection iteration yourself in the
         <span class="italic">convertUponGet</span>  method.
       </p><p>
         If you're not using a <code class="classname">GeneralizedFieldHandler</code>, then 
         you'll need to handle the collection iteration yourself in the 
         <span class="italic">FieldHandler#getValue()</span> method.
       </p><p>
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>
               Since Castor incrementally adds items to collection fields, there
               usually is no need to handle collections directly in the
               <span class="italic">convertUponSet</span> method (or the <span class="italic">setValue()</span> for those
               not using <code class="classname">GeneralizedFieldHandler</code>).
            </p></td></tr></table></div><p>
       </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1570"></a>1.8.&nbsp;Best practice</h2></div></div></div><p>
        There are many users of Castor XML who (want to) use Castor XML in in
        high-volume applications. To fine-tune Castor for such an environment,
        it is necessary to understand many of the product features in detail
        and to be able to balance their use according to the application needs.
        Even though many of these features are documented in various places,
        people frequently asked for a 'best practices' document, a document
        that brings together these technical topics in one place and that
        presents them as a set of easy-to-use recipes.
    </p><p>
        Please be aware that this document is <span class="italic">under construction</span>.  
        But still we believe that this document -- even when in its conception
        phase -- provides valuable information to users of Castor XML.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1575"></a>1.8.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1577"></a>1.8.1.1.&nbsp;Source Generator</h4></div></div></div><p>
             It is not generally recommended to generate code into the default
             package, especially since code in the default package cannot be
             referenced from code in any other package.
           </p><p>
             Additionally, we recommend that generated code go into a different
             package then the code that makes use of the generated code.  For
             example, if your application uses Castor to process an XML
             configuration file that is used by code in the package
             <code class="literal">org.example.userdialog</code> then we do not recommend that the
             generated code also go into that package.  However, it would be
             reasonable to generate source to process this XML configuration file
             into the package <code class="literal">org.example.userdialog.xmlconfig</code>.
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1583"></a>1.8.2.&nbsp;Performance Considerations</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1585"></a>1.8.2.1.&nbsp;General</h4></div></div></div><p>
          Creating instances of <code class="classname">org.exolab.castor.xml.Marshaller</code> and
          <code class="classname">org.exolab.castor.xml.Unmarshaller</code> for the purpose of XML
          data binding is easy to achieve at the API usage level.  However,
          details of API use have an impact on application performance; each
          instance creation involves setup operations.
        </p><p>
          This is generally not an issue for one-off invocations; however, in a
          multi-threaded, high volume use scenario this can be become a serious
          issue. Internally, Castor uses a collection of <span class="italic">Descriptor</span>
          classes to keep information about the Java entities to be marshaled
          and unmarshaled. With each instance creation of (Un)Marshaller, this
          collection will be built from scratch (again and again).
        </p><p>
          To avoid this initial configuration 'penalty', Castor allows you to
          cache these Descriptor classes through its
          <code class="classname">org.exolab.castor.xml.ClassDescriptorResolver</code> component.
          This cache allows reuse of these Descriptor instances between
          (Un)Marshaller invocations.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1594"></a>1.8.2.2.&nbsp;Use of XMLContext - With and without a mapping file</h4></div></div></div><p>
          With the introduction of the new <code class="classname">org.exolab.castor.xml.XMLContext</code> 
          class, the use of a 
          <code class="literal">ClassDescriptorResolver</code> has been greatly simplified in that such
          an instance is managed by the XMLContext per default. As such, there's no need
          to pass a <code class="literal">ClassDescriptorResolver</code> instance to 
          <code class="literal">Marshaller</code>/
          <code class="literal">Unmarshaller</code> instances anymore, as this is done automatically
          when such instances are created through
          
          </p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createMarshaller()</code></p></li><li><p><code class="literal">org.exolab.castor.xml.XMLContext.createUnmarshaller()</code></p></li></ul></div><p>
          
          For example, to create a <code class="literal">Marshaller</code> instance that is pre-configured
          with an instance of <code class="literal">ClassDescriptorResolver</code>, use the following code 
          fragment:
        </p><pre class="programlisting">
Mapping mapping = <span class="hl-keyword">new</span> Mapping();
mapping.loadMapping(<span class="hl-keyword">new</span> InputSource(...));
        
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addMapping(mapping);

Marshaller marshaller = context.createMarshaller();</pre><p>
            In the case where no mapping file is used, it is still possible 
            to instruct the <code class="classname">org.exolab.castor.xml.XMLContext</code> to
            <span class="italic">pre-load</span> class descriptors for a given 
            package via the methods enlisted below.
         </p><p>
            As above, create an instance of <code class="classname">org.exolab.castor.xml.XMLContext</code> 
            and configure it according to your needs as shown below:
         </p><pre class="programlisting">
XMLContext context = <span class="hl-keyword">new</span> XMLContext();
context.addPackage(<span class="hl-string">"your.package.name"</span>);

Marshaller marshaller = context.createMarshaller();</pre><p>
            The <code class="classname">org.exolab.castor.xml.XMLContext</code> class 
            provides for various methods to load class descriptors for individual classes 
            and/or packages.
         </p><div class="table"><a name="d4e1620"></a><p class="title"><b>Table&nbsp;1.16.&nbsp;Methods on XMLContext to create Un-/Marshaller objects</b></p><div class="table-contents"><table summary="Methods on XMLContext to create Un-/Marshaller objects" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th><code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(Class)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for one class.</td><td>n/a</td></tr><tr><td><code class="methodname">addClass(Class[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptors for a collection of classes.</td><td>n/a</td></tr><tr><td><code class="methodname">addPackage(String)</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined package.</td><td>Required</td></tr><tr><td><code class="methodname">addPackages(String[])</code> on <code class="classname">org.exolab.castor.xml.XMLContext</code></td><td>Loads the class descriptor for all classes in the defined packages.</td><td>Required</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
               For some of the methods, pre-loading class descriptords will only work if you provide 
               the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
               code generator). If no such file is shipped, Castor will not be able to pre-load the 
               descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1660"></a>1.8.2.3.&nbsp;Use of Marshaller/Unmarshaller</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1662"></a>1.8.2.3.1.&nbsp;Use of ClassDescriptorResolver</h5></div></div></div><p>
             When you do not use the <code class="literal">XMLContext</code> class, you will have 
             to manually manage your 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>. To do 
             so, first create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
             using the following code fragment:
           </p><pre class="programlisting">
XMLClassDescriptorResolver classDescriptorResolver = 
   (XMLClassDescriptorResolver) ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
MappingUnmarshaller mappingUnmarshaller = <span class="hl-keyword">new</span> MappingUnmarshaller();
MappingLoader mappingLoader = 
   mappingUnmarshaller.getMappingLoader(mapping, BindingType.XML);
classDescriptorResolver.setMappingLoader(mappingLoader);</pre><p>and then reuse this instance as shown below:</p><pre class="programlisting">
   Unmarshaller unmarshaller = <span class="hl-keyword">new</span> Unmarshaller();
   unmarshaller.setResolver(classDescriptorResolver);
   unmarshaller.unmarshal(...);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d4e1671"></a>1.8.2.3.2.&nbsp;Use of ClassDescriptorResolver for pre-loading compiled descriptors</h5></div></div></div><p>
               When you are not using a mapping file, but you have generated Java 
               classes and their corresponding descriptor classes using the Castor
               XML code generator, you might want to instruct the 
               <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code> to
               <span class="italic">pre-load</span> class descriptors (as enumerated explicitly 
               or for a given package) using various <code class="literal">add*</code> methods.
            </p><p>
             As above, create an instance of 
             <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver"&gt;XMLClassDescriptorResolver</code> 
             using the following code fragment:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.A"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.B"</span>);
   classDescriptorResolver.addClass(<span class="hl-string">"your.package.name.C"</span>);
           </pre><p>
              and then reuse this instance as shown above. Alternatively, add complete
              packages to the resolver configuration as follows:
           </p><pre class="programlisting">
   XMLClassDescriptorResolver classDescriptorResolver = (XMlClassDescriptorResolver)
      ClassDescriptorResolverFactory.createClassDescriptorResolver(BindingType.XML);
   classDescriptorResolver.setClassLoader(...);
   classDescriptorResolver.addPackage(<span class="hl-string">"your.package.name"</span>);
           </pre><p>
              The <code class="classname">org.exolab.castor.xml.XMLClassDescriptorResolver</code>
              interface provides various other methods to load class descriptors for individual
              classes and/or packages.
           </p><div class="table"><a name="d4e1684"></a><p class="title"><b>Table&nbsp;1.17.&nbsp;blah</b></p><div class="table-contents"><table summary="blah" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Description</th><th>Requires <code class="literal">.castor.cdr</code></th></tr></thead><tbody><tr><td><code class="methodname">addClass(String)</code></td><td>Loads the class descriptor for one class.</td><td>No</td></tr><tr><td><code class="methodname">addClass(String[])</code></td><td>Loads the class descriptors for a collection of classes.</td><td>No</td></tr><tr><td><code class="methodname">addPackage(String)</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr><tr><td><code class="methodname">addPackages(String[])</code></td><td>Loads the class descriptors for all classes in the package defined.</td><td>Yes</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
              For some of the methods, pre-loading class descriptords will only work if you provide 
              the <code class="literal">.castor.cdr</code> file with your generated classes (as generated by the XML 
              code generator). If no such file is shipped, Castor will not be able to pre-load the 
              descriptors, and will fall back to its default descriptor loading mechanism.
            </p></td></tr></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1720"></a>1.9.&nbsp;Castor XML - HOW-TO's</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1722"></a>1.9.1.&nbsp;Introduction</h3></div></div></div><p>
			This is a collection of HOW-TOs. The Castor project is
			actively seeking additional HOW-TO contributors to expand
			this collection. For information on how to do that, please
			see 'How to write a How-to'.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1725"></a>1.9.2.&nbsp;Documentation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					How to Author a How-To
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author an FAQ
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author a Code Snippet
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					How to Author Core Documentation
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1740"></a>1.9.3.&nbsp;Contribution</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-submit-an-xml-bug.html" target="_top">
						How to submit an XML-specific bug report
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prepare-a-patch.html" target="_top">
						How to prepare a patch
					</a>
				</p></li><li><p>
					How to Contribute a Patch via Jira
					<span class="bold"><strong>(Author wanted!)</strong></span>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-run-xml-ctf-suite.html" target="_top">
						How to run Castor XML's test suite
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1755"></a>1.9.4.&nbsp;Mapping</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-XMLContext.html" target="_top">
						How to use XMLContext for un-/marshalling
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-collection.html" target="_top">
						How to map a collection of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-hashtable.html" target="_top">
						How to map a map/hashtable of elements
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-list-at-root.html" target="_top">
						How to map a list of elements at the root
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-a-class-with-constructors.html" target="_top">
						How to map constructor arguments
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-an-inner-class.html" target="_top">
						How to map an inner class
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-unmarshal-raw-xml.html" target="_top">
						How to Unmarshal raw XML segments into arbitrary
						types
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-references-in-xml.html" target="_top">
						How to use references in XML and Castor
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-wrap-a-collection-with-a-wrapper-element.html" target="_top">
						How to wrap a collection with a wrapper element
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-prevent-collection-from-being-exposed.html" target="_top">
						How to prevent a collection from being exposed
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-write-a-configurablefieldhandler.html" target="_top">
						How to write a configurable field handler
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-both-structure-and-content.html" target="_top">
						How to map text content
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-work-with-wrapper-elements-around-collections.html" target="_top">
						How to work with wrapper elements around
						collections
					</a>
				</p></li><li><p>
                    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-marshall-version-1.1-xml.html" target="_top">
                        How to work marshal XML documents with version 1.1
                    </a>
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1800"></a>1.9.5.&nbsp;Validation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-enable-xml-validation.html" target="_top">
						How to use XML validation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1806"></a>1.9.6.&nbsp;Source generation</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-use-a-binding-file-with-source-generation.html" target="_top">
						How to use a binding file with source generation
					</a>
				</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1812"></a>1.9.7.&nbsp;Others</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-implement-custom-serializer.html" target="_top">
						How to implement a custom serializer
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-fetch-dtds-and-schemas-from-jars.html" target="_top">
						How to fetch DTDs and XML Schemas from JAR files
					</a>
				</p></li><li><p>
					<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/how-to-map-hibernate-proxies.html" target="_top">
						How to marshal Hibernate proxies
					</a>
				</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1824"></a>1.10.&nbsp;XML FAQ</h2></div></div></div><p>
        This section provides answers to frequently answered questions, i.e.
        questions that have been asked repeatedly on one of the mailing 
        lists. Please check with these F.A.Q.s frequently, as addressing questions
        that have been answered in the past already again and again places
        an unnecessary burden on the committers/contributors. 
    </p><p>
        This section is structured along the lines of the following areas ...
        
    </p><div class="itemizedlist"><ul type="disc"><li><p><a href="XML data binding.html#xml.faq.general" title="1.10.1.&nbsp;General">Section&nbsp;1.10.1, &#8220;General&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.introspection" title="1.10.2.&nbsp;Introspection">Section&nbsp;1.10.2, &#8220;Introspection&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.mapping" title="1.10.3.&nbsp;Mapping">Section&nbsp;1.10.3, &#8220;Mapping&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.marshalling" title="1.10.4.&nbsp;Marshalling">Section&nbsp;1.10.4, &#8220;Marshalling&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.generation" title="1.10.5.&nbsp;Source code generation">Section&nbsp;1.10.5, &#8220;Source code generation&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.misc" title="1.10.6.&nbsp;Miscellaneous">Section&nbsp;1.10.6, &#8220;Miscellaneous&#8221;</a></p></li><li><p><a href="XML data binding.html#xml.faq.serialization" title="1.10.7.&nbsp;Serialization">Section&nbsp;1.10.7, &#8220;Serialization&#8221;</a></p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.general"></a>1.10.1.&nbsp;General</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1852"></a>1.10.1.1.&nbsp;How do I set the encoding?</h4></div></div></div><p>
				Create a new instance of the
				<code class="classname">Marshaller</code>
				class and use the
				<code class="classname">setEncoding</code>
				method. You'll also need to make sure the encoding for
				the Writer is set properly as well:
			</p><pre class="programlisting">
 ...
 String encoding = <span class="hl-string">"ISO-8859-1"</span>;
 FileOutputStream fos = <span class="hl-keyword">new</span> FileOutputStream(<span class="hl-string">"result.xml"</span>);
 OutputStreamWriter osw = <span class="hl-keyword">new</span> OuputStreamWriter(fos, encoding);
 Marshaller marshaller = <span class="hl-keyword">new</span> Marshaller(osw);
 marshaller.setEncoding(encoding);
 ...
			</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1858"></a>1.10.1.2.&nbsp;
				I'm getting an error about 'xml' prefix already
				declared?
			</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>For Castor 0.9.5.2 only</p></td></tr></table></div><p>
				The issue occurs with newer versions of Xerces than the
				version 1.4 that ships with Castor. The older version
				works OK. For some reason, when the newer version of
				Xerces encounters an "xml" prefixed attribute, such as
				"xml:lang", it tries to automatically start a prefix
				mapping for "xml". Which, in my opinion, is technically
				incorrect. They shouldn't be doing that. According to
				the w3c, the "xml" prefix should never be declared.
			</p><p>
				The reason it started appearing in the new Castor
				(0.9.5.2), is because of a switch to SAX 2 by default
				during unmarshaling.
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>
				A built in work-around has been checked into the Castor
				SVN and will automatically exist in any post 0.9.5.2
				releases. For those who are using 0.9.5.2 and can't
				upgrade, I found a simple workaround (tested with Xerces
				2.5). At first I thought about disabling namespace
				processing in Xerces, but then realized that it's
				already disabled by default by Castor ... so I have no
				idea why they call #startPrefixMapping when namespace
				processing has been disabled. But in any event...
				explicitly enabling namespace processing seems to fix
				the problem:
			</p><p>
				in the
				<code class="classname">castor.properties</code>
				file, change the following line:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=false
			</pre><p>to:</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
			</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					This work-around has only been tested with
					Xerces 2.5 and above.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1873"></a>1.10.1.3.&nbsp;Why is my 'get' method called twice?</h4></div></div></div><p>
				The get method will be called a second time during the
				validation process. To prevent this from happening,
				simply disable validation on the Marshaller or
				Unmarshaller.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1876"></a>1.10.1.4.&nbsp;
				How can I speed up marshalling/unmarshalling
				performance?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Cache the descriptors!</p><pre class="programlisting">
 <span class="hl-keyword">import</span> org.exolab.castor.xml.ClassDescriptorResolver;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.Unmarshaller;
 <span class="hl-keyword">import</span> org.exolab.castor.xml.util.ClassDescriptorResolverImpl;
 ...
 ClassDescriptorResolver cdr = <span class="hl-keyword">new</span> ClassDescriptorResovlerImpl(); 
 ...
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setResolver(cdr);
					</pre><p>
						By reusing the same <code class="classname">ClassDescriptorResolver</code> any
						time you create an Unmarshaller instance, you
						will be reusing the existing class descriptors
						previously loaded.
					</p></li><li><p>Disable validation</p><pre class="programlisting">
 unm.setValidation(false);
					</pre></li><li><p>
						Reuse objects
                    </p><p>
						To cut down on object creation, you can reuse an
						existing object model, but be careful because
						this is an experimental feature. Create an
						Unmarshaller with your existing root object and
						set object reuse to true...
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span>
 Unmarshaller(myObjectRoot);
					</pre><pre class="programlisting">
 unm.setReuseObjects(true);
					</pre></li><li><p>
						If you have enabled pretty-printing (indenting),
						then disable it. The Xerces Serializer is much
						slower with indenting enabled.
					</p></li><li><p>
						Try changing parsers to something other than
						Xerces.
					</p></li></ul></div><p>
				There are probably other approaches you can use as well,
				but those seem to be the most popular ones. Let us know
				if you have a solution that you think we should add
				here.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1897"></a>1.10.1.5.&nbsp;
				How do I ignore elements during unmarshalling?
			</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>
						Use the
						<code class="classname">
							Unmarshaller#setIgnoreExtraElements()
						</code>
						method:
					</p><pre class="programlisting">
 Unmarshaller unm = <span class="hl-keyword">new</span> Unmarshaller(...);
 unm.setIgnoreExtraElements(true);
					</pre><p>
						If any elements appear in the XML instance that
						Castor cannot find mappings for, they will be
						skipped.
					</p></li><li><p>
						You can also set the 
						<code class="classname">
							org.exolab.castor.xml.strictelements 
						</code>
						property in the
						<code class="classname">castor.properties</code>
						file:
					</p><pre class="programlisting">
 org.exolab.castor.xml.strictelements=true
					</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1910"></a>1.10.1.6.&nbsp;
				Where does Castor search for the castor.properties file?
			</h4></div></div></div><p>
				Castor loads the castor.properties in the following
				order:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						From classpath (usually from the jar file)
					</p></li><li><p>From {java.home}/lib (if present)</p></li><li><p>From the local working directory</p></li></ul></div><p>
				Each properties file overrides the previous. So you
				don't have to come up with a properties file with all
				the properties and values, just the ones you want to
				change. This also means you don't have to touch the
				properties file found in the jar file.
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					Note: You can also use
					<code class="classname">
						LocalConfiguration.getInstance().getProperties()
					</code>
					to change the properties values programatically.
				</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1924"></a>1.10.1.7.&nbsp;
				Can I programmatically change the properties found in
				the castor.properties file?
			</h4></div></div></div><p>
				Yes, many of these properties can be set directly on the
				Marshaller or Unmarshaller, but you can also use
				<code class="classname">
					LocalConfiguration.getInstance().getProperties()
				</code>
				to change the properties values programatically.
				
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.introspection"></a>1.10.2.&nbsp;Introspection</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1930"></a>1.10.2.1.&nbsp;Can private methods be introspected?</h4></div></div></div><p>
				Castor does not currently support introspection of
				private methods. Please make sure proper public
				accesssor methods are available for all fields that you
				wish to be handled by the Marshalling Framework.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.mapping"></a>1.10.3.&nbsp;Mapping</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1935"></a>1.10.3.1.&nbsp;My mapping file seems to have no effect!</h4></div></div></div><p>
				Make sure you are not using one of the
				<span class="italic">static</span>
				methods on the Marshaller/Unmarshaller. Any
				configuration changes that you make to the Marshaller or
				Unmarshaller are not available from the static methods.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1939"></a>1.10.3.2.&nbsp;
				Are there any tools to automatically create a mapping
				file?
			</h4></div></div></div><p>
				Yes! We provide one such tool, see
				<code class="classname">org.exolab.castor.tools.MappingTool</code>
				. There are some 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/extras.html" target="_top">3rd party</a> 
                tools as well.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1944"></a>1.10.3.3.&nbsp;
				How do I specify a namespace in the mapping file?
			</h4></div></div></div><p>
				For a specific field you can use a QName for the value
				of the bind-xml name attribute as such:
			</p><pre class="programlisting">
 &lt;bind-xml name=<span class="hl-string">"foo:bar"</span> xmlns:foo=<span class="hl-string">"http://www.acme.com/foo"</span>/&gt;
			</pre><p>
				Note: The namespace prefix is only used for
				qualification during the loading of the mapping, it is
				not used during Marshaling. To map namespace prefixes
				during marshaling you currently need to set these via
				the Marshaler directly.
			</p><p>
				For a class mapping, use the &lt;map-to&gt; element. For
				more information see the
				<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/xml-mapping.html" target="_top">XML Mapping documentation</a>
				.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1951"></a>1.10.3.4.&nbsp;
				How do I prevent a field from being marshaled?
			</h4></div></div></div><p>
				Set the
				<span class="bold"><strong>transient</strong></span>
				attribute on the &lt;bind-xml&gt; element to true:
			</p><pre class="programlisting">
 &lt;bind-xml <span class="hl-keyword">transient</span>=<span class="hl-string">"true"</span>/&gt;
			</pre><p>
				Note: You can also set transient="true" on the
				&lt;field&gt; element.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.marshalling"></a>1.10.4.&nbsp;Marshalling</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1959"></a>1.10.4.1.&nbsp;
				The XML is marshalled on one line, how do I force
				line-breaks?
			</h4></div></div></div><p>For all versions of Castor:</p><p>
				To enable pretty-printing (indenting, line-breaks) just
				modify the
				<span class="italic">
					<span class="bold"><strong>castor.properties</strong></span>
				</span>
				file and uncomment the following:
			</p><pre class="programlisting">
 # True <span class="hl-keyword">if</span> all documents should be indented on output by <span class="hl-keyword">default</span>
 #
 #org.exolab.castor.indent=true
			</pre><p>
				Note: This will slow down the marshalling process
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1967"></a>1.10.4.2.&nbsp;What is the order of the marshalled XML elements?</h4></div></div></div><p>
      			If you are using Castor's default introspection to
      			automatically map the objects into XML, then there is no
      			guarantee on the order. It simply depends on the order in
      			which the fields are returned to Castor using the Java
      			reflection API.
      		</p><p>
      			Note: If you use a mapping file Castor will generate the XML
      			in the order in which the mapping file is specified.
      		</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.generation"></a>1.10.5.&nbsp;Source code generation</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1973"></a>1.10.5.1.&nbsp;Can I use a DTD with the source generator?</h4></div></div></div><p>
				Not directly, however you can convert your DTD to an XML
				Schema fairly easily. We provide a tool (
				<code class="classname">
					org.exolab.castor.xml.dtd.Converter
				</code>
				) to do this. You can also use any number of 3rd-party
				tools such as XML Spy or XML Authority.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1977"></a>1.10.5.2.&nbsp;
				My XML output looks incorrect, what could be wrong?
			</h4></div></div></div><p>
				Also: I used the source code generator, but all my xml
				element names are getting marshaled as lowercase with
				hyphens, what's up with that?
			</p><p>
				<span class="bold"><strong>Solution:</strong></span>

				Are the generated class descriptors compiled? Make sure
				they get compiled along with the source code for the
				object model.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1982"></a>1.10.5.3.&nbsp;
				The generated source code has incorrect or missing
				imports for imported schema types
			</h4></div></div></div><p>
				<span class="bold"><strong>Example:</strong></span>
				Castor generates the following:
			</p><pre class="programlisting">
 <span class="hl-keyword">import</span> types.Foo;
			</pre><p>instead of:</p><pre class="programlisting">
 <span class="hl-keyword">import</span> com.acme.types.Foo;
			</pre><p>
				This usually happens when the namespaces for the
				imported schemas have not been mapped to appropriate
				java packages in the
				<span class="italic">
					castorbuilder.properties
				</span>
				file.
			</p><p><span class="bold"><strong>Solution:</strong></span>
				</p><div class="itemizedlist"><ul type="disc"><li><p>
							Make sure the
							<code class="classname">
								castorbuilder.properties
							</code>
							is in your classpath when you run the
							SourceGenerator.
						</p></li><li><p>
							Uncomment and edit the
							<code class="classname">
								org.exolab.castor.builder.nspackages
							</code>
							property. Make sure to copy the value of the
							imported namespace exactly as it's referred
							to in the schema (i.e. trailing slashes and
							case-sensitivity matter!).
						</p></li></ul></div><p>
			</p><p>
				For those using 0.9.5.1, you'll need to upgrade due to a
				bug that is fixed in later releases.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2001"></a>1.10.5.4.&nbsp;
				How can I make the generated source code more JDO
				friendly?
			</h4></div></div></div><p>For Castor 0.9.4 and above:</p><p>
				Castor JDO requires a reference to the actual collection
				to be returned from the get-method. By default the
				source generator does not provide such a method. To
				enable such methods to be created, simple add the
				following line to your
				<code class="classname">castorbuilder.properties</code>
				file:
			</p><pre class="programlisting">
 org.exolab.castor.builder.extraCollectionMethods=true
			</pre><p>
				Note: The default
				<code class="classname">castorbuilder.properties</code>
				file has this line commented out. Simply uncomment it.
			</p><p>
				Your mapping file will also need to be updated to
				include the proper set/get method names.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.misc"></a>1.10.6.&nbsp;Miscellaneous</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2012"></a>1.10.6.1.&nbsp;
				Is there a way to automatically create an XML Schema
				from an XML instance?
			</h4></div></div></div><p>
				Yes! We provide such a tool. Please see
				<code class="classname">
					org.exolab.castor.xml.schema.util.XMLInstance2Schema
				</code>
				. It's not 100% perfect, but it does a reasonable job.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2016"></a>1.10.6.2.&nbsp;How to enable XML validation with Castor XML</h4></div></div></div><p>
				To enable XML validation at the parser level, please add
				properties to your
				<code class="classname">castor.properties</code>
				file as follows:
			</p><pre class="programlisting">
 org.exolab.castor.parser.namespaces=true
 org.exolab.castor.sax.features=http:<span class="hl-comment">//xml.org/sax/features/validation,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema,\</span>
 http:<span class="hl-comment">//apache.org/xml/features/validation/schema-full-checking</span>
			</pre><p>
				Please note that the example given relies on the use of
				Apache Xerces, hence the
				<code class="classname">apache.org</code>
				properties; similar options should exist for other
				parsers.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2023"></a>1.10.6.3.&nbsp;
				Why is mapping ignored when using a FieldHandlerFactory
			</h4></div></div></div><p>
				When using a custom FieldHandlerFactory as in the
				following example
			</p><pre class="programlisting">
 Mapping mapping = ... ;
 FieldHandlerFactoyt factory = ...;
 Marshaller m = <span class="hl-keyword">new</span> Marshaller(writer);
 ClassDescriptorResolverImpl cdr = <span class="hl-keyword">new</span> ClassDescriptorResolverImpl();
 cdr.getIntrospector().addFieldHandlerFactory(factory);
 m.setResolver(cdr);
 marshaller.setMapping(mapping);
			</pre><p>
				please make sure that you set the mapping file
				<span class="bold"><strong>after</strong></span>
				you set the ClassDescriptorResolver. You will note the
				following in the Javadoc for
				<code class="classname">org.exolab.castor.xml.Marshaller.html#setResolver(org.exolab.castor.xml.ClassDescriptorResolver)</code>
				:
			</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
					<span class="bold"><strong>Note:</strong></span>
					This method will nullify any Mapping currently being
					used by this Marshaller
				</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml.faq.serialization"></a>1.10.7.&nbsp;Serialization</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2036"></a>1.10.7.1.&nbsp;
				Is it true that the use of Castor XML mandates 
                <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://xerces.apache.org" target="_top">Apache Xerces</a> as
				XML parser?
			</h4></div></div></div><p>
				Yes and no. It actually depends. When requiring
				<span class="italic">pretty printing</span>
				during marshalling, Castor internally relies on Apache's
				Xerces to implement this feature. As such, when not
				using this feature, Xerces is not a requirement, and any
				JAXP-compliant XML parser can be used (for
				unmarshalling).
			</p><p>
				In other words, with the latter use case, you do
				<span class="bold"><strong>not</strong></span>
				have to download (and use) Xerces separetely.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e2043"></a>1.10.7.2.&nbsp;
				Do I still have to download Xerces when using Castor XML
				with Java 5.0?
			</h4></div></div></div><p>
				No. Starting with release 1.1, we have added support for
				using the Xerces instance as shipped with the JRE/JDK
				for serialization. As such, for Java 5.0 users, this
				removes the requirement to download Xerces separately
				when wanting to use 'pretty printing' with Castor XML
				during marshalling.
			</p><p>
				To enable this feature, please change the following
				properties in your
				<span class="bold"><strong>local</strong></span>
				<code class="classname">castor.properties</code>
				file (thus redefining the default value) as shown below:
			</p><pre class="programlisting">
 # Defines the XML parser to be used by Castor. 
 # The parser must implement org.xml.sax.Parser.
 org.exolab.castor.parser=org.xml.sax.helpers.XMLReaderAdapter

 # Defines the (<span class="hl-keyword">default</span>) XML serializer factory to use by Castor, which must
 # implement org.exolab.castor.xml.SerializerFactory; <span class="hl-keyword">default</span> is
 # org.exolab.castor.xml.XercesXMLSerializerFactory
 org.exolab.castor.xml.serializer.factory=org.exolab.castor.xml.XercesJDK5XMLSerializerFactory

 # Defines the <span class="hl-keyword">default</span> XML parser to be used by Castor.
 org.exolab.castor.parser=com.sun.org.apache.xerces.internal.parsers.SAXParser
			</pre></div></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="xml.code.generator.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Castor 1.3.3 - Reference documentation&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:85%;"><a href="http://www.castor.org/" title="The Castor community">The Castor community</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;XML code generation</td></tr></table></div></body></html>