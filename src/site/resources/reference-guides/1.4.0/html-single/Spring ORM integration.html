<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="up" href="index.html" title="Castor 1.3.3 - Reference documentation"><link rel="prev" href="advanced-jdo.html" title="Chapter&nbsp;4.&nbsp;Advanced JDO"><link rel="next" href="jpa.html" title="Chapter&nbsp;6.&nbsp;Castor JDO - Support for the JPA specification"><!--begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-3544187-1");
            
            
            pageTracker._trackPageview();
        </script><!--end Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" id="top"><div id="header"><div class="projectlogo"><a href="./"><img class="logoImage" src="images/castor.gif" alt="Castor" border="0"></a></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="mhSpacer"></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="Spring ORM integration"></a>Chapter&nbsp;5.&nbsp;Castor JDO - Integration with Spring ORM</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9308"></a>5.1.&nbsp;Usage</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9310"></a>5.1.1.&nbsp;Getting started using Maven 2</h3></div></div></div><p>
         In order to start using the Spring ORM module for Castor JDO, you will 
         have to have Maven 2 installed:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Download and install <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org" target="_top">Maven 2</a></p></li></ul></div><p>
        As this project uses Maven 2 for build and deployment, all required 
        compile-time and run-time dependencies will automatically be resolved 
        by Maven 2 and deployed into your local Maven 2 repository.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9318"></a>5.1.2.&nbsp;Project dependencies</h3></div></div></div><p>
         Please add the following Maven dependency to your POM to include the 
         <span class="italic">Spring ORM package for Castor JDO</span> 
         with your project:
      </p><pre class="programlisting">
&lt;<span class="hl-tag">dependency</span>&gt;
   &lt;<span class="hl-tag">groupId</span>&gt;org.codehaus.castor&lt;<span class="hl-tag">/groupId</span>&gt;
   &lt;<span class="hl-tag">artifactId</span>&gt;spring-orm&lt;<span class="hl-tag">/artifactId</span>&gt;
   &lt;<span class="hl-tag">version</span>&gt;1.3&lt;<span class="hl-tag">/version</span>&gt;
&lt;<span class="hl-tag">/dependency</span>&gt;
      </pre><p>
         If you create a dependency against a SNAPSHOT release, you will
         have to add the following <code class="literal">&lt;repository&gt;</code> element 
         to your POM as well, so that Maven 2 knows about the 
         <span class="italic">Codehaus Snapshot repository</span> when 
         trying to resolve and download dependencies.
      </p><pre class="programlisting">
&lt;<span class="hl-tag">repository</span>&gt;
    &lt;<span class="hl-tag">id</span>&gt;codehaus-snapshots&lt;<span class="hl-tag">/id</span>&gt;
    &lt;<span class="hl-tag">name</span>&gt;Maven Codehaus Snapshots&lt;<span class="hl-tag">/name</span>&gt;
    &lt;<span class="hl-tag">url</span>&gt;http://snapshots.maven.codehaus.org/maven2/&lt;<span class="hl-tag">/url</span>&gt;
&lt;<span class="hl-tag">/repository</span>&gt;</pre>&gt;

    </div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9327"></a>5.2.&nbsp;A high-level overview</h2></div></div></div><p>
        This guide assumes that you are an experienced Castor JDO users that knows how
	    to use Castor's interfaces and classes to interact with a database. If 
	    this is not the case, please familiarize yourself with 
	    <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.castor.org/jdo.html" target="_top">Castor JDO</a> first. 
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9331"></a>5.2.1.&nbsp;Sample domain objects</h3></div></div></div><p>
            The sample domain objects used in here basically define a <code class="literal">Catalogue</code>, 
		    which is a collection of <code class="literal">Product</code>s. A possible castor JDO mapping could look
		    as follows:</p><pre class="programlisting">
&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Catalogue"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"catalogue"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"products"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"org.castor.sample.Product"</span> <span class="hl-attribute">collection</span>=<span class="hl-value">"arraylist"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">many-key</span>=<span class="hl-value">"c_id"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;

&lt;<span class="hl-tag">class</span> <span class="hl-attribute">name</span>=<span class="hl-value">"org.castor.sample.Product"</span>&gt;
   &lt;<span class="hl-tag">map-to</span> <span class="hl-attribute">table</span>=<span class="hl-value">"product"</span>/&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"long"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"id"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"integer"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
   &lt;<span class="hl-tag">field</span> <span class="hl-attribute">name</span>=<span class="hl-value">"description"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"string"</span>&gt;
      &lt;<span class="hl-tag">sql</span> <span class="hl-attribute">name</span>=<span class="hl-value">"desc"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"varchar"</span> /&gt;
   &lt;<span class="hl-tag">/field</span>&gt;
&lt;<span class="hl-tag">/class</span>&gt;
		</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9337"></a>5.2.2.&nbsp;Using Castor JDO manually</h3></div></div></div><p>
            To e.g. load a given <code class="literal">Catalogue</code> instance as defined by its identity,
		    and all its associated <code class="literal">Product</code> instances, the following code could be used, 
		    based upon the Castor-specific interfaces <code class="literal">JDOManager</code> and <code class="literal">Database</code>.
        </p><pre class="programlisting">
JDOManager.loadConfiguration(<span class="hl-string">"jdo-conf.xml"</span>);
JDOManager jdoManager = JDOmanager.createInstance(<span class="hl-string">"sample"</span>);

Database database = jdoManager.getDatabase();		
database.begin();
Catalogue catalogue = database.load(catalogue.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Long(1));
database.commit();
database.close();
		</pre><p>For brevity, exception handling has been omitted completely. But is is quite obvious
		   that - when using such code fragments to implement various methods of a DAO - 
		   there's a lot of redundant code that needed to be written again and again - and exception
		   handling is adding some additional complexity here as well.</p><p>
            Enters Spring ORM for Castor JDO, a small layer that allows usage of Castor JDO
		    through Spring ORM, with all the known benefits (exception conversion, templates, 
          tx handling).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9347"></a>5.2.3.&nbsp;Using Castor JDO with Spring ORM - Without CastorTemplate</h3></div></div></div><p>
            Let's see how one might implement the <code class="literal">loadProduct(int)</code> of a 
            <code class="literal">ProductDAO</code> class with the help of Spring ORM using Castor 
            JDO:
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> JDOManager jdoManager;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
    <span class="hl-keyword">this</span>.jdoManager = jdoManager;
  }

  <span class="hl-keyword">public</span> Product loadProduct(<span class="hl-keyword">final</span> <span class="hl-keyword">int</span> id) {
    CastorTemplate tempate = <span class="hl-keyword">new</span> CastorTemplate(<span class="hl-keyword">this</span>.jdoManager);
    <span class="hl-keyword">return</span> (Product) template.execute(
        <span class="hl-keyword">new</span> CastorCallback() {
          <span class="hl-keyword">public</span> Object doInJdo(Database database) <span class="hl-keyword">throws</span> PersistenceException {
            <span class="hl-keyword">return</span> (Product) database.load(Product.<span class="hl-keyword">class</span>, <span class="hl-keyword">new</span> Integer (id));
          }
        });
  }
}
		</pre><p>
            Still a lot of code to write, but compared to the above section, the DAO gets
		    passed a fully configured <code class="literal">JDOManager</code> instance through Spring's dependency
		    injection mechanism. All that's required is configuration of Castor's JDOManager
		    as a Spring bean definition in an Spring application context as 
		    follows.
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:jdo-conf.xml"</span> /&gt;
&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImpl"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9356"></a>5.2.4.&nbsp;Using Castor JDO with Spring ORM - With CastorTemplate</h3></div></div></div><p>
            Above code is still quite verbose, as it requires you to write short 
            (though complex) callback functions. To ease life of the Castor JDO 
            user even more, a range of template methods have been added to 
            <code class="classname">CastorTemplate</code>, allowing the implementation of 
            above <code class="classname">ProductDAO</code> to be shortened considerably.
        </p><pre class="programlisting">
public class ProductDaoImplUsingTemplate extends CastorTemplate implements ProductDao {

  private JDOManager jdoManager;

  public void setJDOManager(JDOManager jdoManager) {
    this.jdoManager = jdoManager;
  }

  public Product loadProduct(final int id) {
    return (Product) load(Integer.valueOf(id));
  }
  
  ...
}
		</pre><p>
            Changing the bean definition for <code class="literal">myProductDAO</code> to ...
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImplUsingTemplate"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myJdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
            loading an instance of <code class="classname">Product</code> by its identifier 
            is reduced to ...</p><pre class="programlisting">
ProductDao dao = (ProductDAO) context.getBean (<span class="hl-string">"myProductDAO"</span>);
Product product = dao.load(1);
		</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9368"></a>5.2.5.&nbsp;Using Castor JDO with Spring ORM - With CastorDaoSupport</h3></div></div></div><p>
            Alternatively to extending <code class="literal">CastorTemplate</code>, one could extend the
		    <code class="classname">CastorDaoSupport</code> class and implement the 
            <code class="classname">ProductDAO</code> as 
		    follows.
        </p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImplUsingDaoSupport <span class="hl-keyword">extends</span> CastorDaoSupport <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> JDOManager jdoManager;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
    <span class="hl-keyword">this</span>.jdoManager = jdoManager;
  }

  <span class="hl-keyword">public</span> Product loadProduct(<span class="hl-keyword">final</span> <span class="hl-keyword">int</span> id) {
    <span class="hl-keyword">return</span> (Product) getCastorTemplate().load(Integer.valueOf(id));
  }
  
  ...
}
		</pre><p>
            Changing the bean definition for <code class="literal">myProductDAO</code> to ...
        </p><pre class="programlisting">
&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductDaoImplUsingDaoSupport"</span>&gt;
  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;
    &lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"myJdoManager"</span>/&gt;
  &lt;<span class="hl-tag">/property</span>&gt;
&lt;<span class="hl-tag">/bean</span>&gt;</pre><p>
            the code to load an instance of <code class="classname">Product</code> still 
            is as shown above.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9380"></a>5.3.&nbsp;Data access through Castor JDO with the Spring framework</h2></div></div></div><p>We will start with a coverage of Hibernate in a Spring environment, using 
	   it to demonstrate the approach that Spring takes towards integrating O/R 
	   mappers. This section will cover many issues in detail and show different 
	   variations of DAO implementations and transaction demarcations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9383"></a>5.3.1.&nbsp;Resource management</h3></div></div></div><p>Typical business applications are often cluttered with repetitive 
		   resource management code. Many projects try to invent their own 
		   solutions for this issue, sometimes sacrificing proper handling of 
		   failures for programming convenience. Spring advocates strikingly 
		   simple solutions for proper resource handling, namely IoC via 
		   templating; for example infrastructure classes with callback 
		   interfaces, or applying AOP interceptors. The infrastructure cares for 
		   proper resource handling, and for appropriate conversion of specific API 
		   exceptions to an unchecked infrastructure exception hierarchy. Spring introduces 
		   a DAO exception hierarchy, applicable to any data access strategy. For 
		   direct JDBC, the JdbcTemplate class mentioned in a previous section cares 
		   for connection handling, and for proper conversion of SQLException to 
		   the DataAccessException hierarchy, including translation of database-specific 
		   SQL error codes to meaningful exception classes. It supports both JTA 
		   and JDBC transactions, via respective Spring transaction managers.</p><p>This module implements Spring ORM/DAO support for Castor JDO, consisting of a 
		   CastorTemplate analogous to JdbcTemplate, a CastorInterceptor, and a Castor 
		   transaction manager. The major goal is to allow for clear application 
		   layering, with any data access and transaction technology, and for 
		   loose coupling of application objects. No more business service dependencies 
		   on the data access or transaction strategy, no more hard-coded resource 
		   lookups, no more hard-to-replace singletons, no more custom service 
		   registries. One simple and consistent approach to wiring up application 
		   objects, keeping them as reusable and free from container dependencies 
		   as possible. All the individual data access features are usable on their 
		   own but integrate nicely with Spring's application context concept, providing 
		   XML-based configuration and cross-referencing of plain JavaBean instances 
		   that don't need to be Spring-aware. In a typical Spring app, many important 
		   objects are JavaBeans: data access templates, data access objects (that 
		   use the templates), transaction managers, business services (that use 
		   the data access objects and transaction managers), web view resolvers, web 
		   controllers (that use the business services), and so on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9387"></a>5.3.2.&nbsp;JDOManager setup in a Spring container</h3></div></div></div><p>To avoid tying application objects to hard-coded resource lookups, 
		   Spring allows you to define resources like a JDBC DataSource or a 
		   Castor JDOManager as beans in an application context. Application objects 
		   that need to access resources just receive references to such 
		   pre-defined instances via bean references (the DAO definition in the 
		   next section illustrates this). The following excerpt from an XML 
		   application context definition shows how to set up a JDBC DataSource 
		   and a Castor JDOManager on top of it:</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.apache.commons.dbcp.BasicDataSource"</span>
		<span class="hl-attribute">destroy-method</span>=<span class="hl-value">"close"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"driverClassName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"org.hsqldb.jdbcDriver"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"url"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"jdbc:hsqldb:hsql://localhost:9001"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"username"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"sa"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"password"</span> <span class="hl-attribute">value</span>=<span class="hl-value">""</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myJDOManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.LocalCastorFactoryBean"</span>&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"databaseName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"test"</span> /&gt;
        &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"configLocation"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"classpath:jdo-conf.xml"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
		</pre><p>Note that switching from a local Jakarta Commons DBCP BasicDataSource 
		   to a JNDI-located DataSource (usually managed by an application server) 
		   is just a matter of configuration:</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myDataSource"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.jndi.JndiObjectFactoryBean"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jndiName"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"java:comp/env/jdbc/myds"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
		</pre><p>You can also access a JNDI-located SessionFactory, using Spring's
		   JndiObjectFactoryBean to retrieve and expose it. However, that is
		   typically not common outside of an EJB context. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9394"></a>5.3.3.&nbsp;The CastorTemplate</h3></div></div></div><p>
			The basic programming model for templating looks as follows,
			for methods that can be part of any custom data access
			object or business service. There are no restrictions on the
			implementation of the surrounding object at all, it just
			needs to provide a Castor JDOManager. It can get the
			latter from anywhere, but preferably as bean reference from
			a Spring application context - via a simple
			setJDOManager(..) bean property setter. The following
			snippets show a DAO definition in a Spring container,
			referencing the above defined JDOManager, and an example
			for a DAO method implementation.
		</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductDao"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"org.exolab.castor.dao.ProductDaoImpl"</span>&gt;
	  &lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"JDOManager"</span>&gt;&lt;<span class="hl-tag">ref</span> <span class="hl-attribute">bean</span>=<span class="hl-value">"jdoManager"</span>/&gt;&lt;<span class="hl-tag">/property</span>&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

  <span class="hl-keyword">private</span> Castor castorTemplate;

  <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setJDOManager(JDOManager jdoManager) {
     <span class="hl-keyword">this</span>.castorTemplate = <span class="hl-keyword">new</span> CastorTemplate(jdoManager);
  }

  <span class="hl-keyword">public</span> Collection loadProductsByCategory(<span class="hl-keyword">final</span> String category) 
     <span class="hl-keyword">throws</span> DataAccessException { 
    <span class="hl-keyword">return</span> (Collection) <span class="hl-keyword">this</span>.castorTemplate.execute(
       <span class="hl-keyword">new</span> CastorCallback() {
          <span class="hl-keyword">public</span> Object doInCastor(Database database) <span class="hl-keyword">throws</span> PersistenceException {
             database.begin();
             OQLQuery query = database.getOQL(<span class="hl-string">"select p from org.exolab.castor.dao.ProductDao p "</span> + 
                <span class="hl-string">" where p.category = ?"</span>);
             query.bind(category);
             QueryResults results = query.execute();
             database.commit();
             <span class="hl-keyword">return</span> Collections.list();
          }
    );
  }
}
</pre><p>A callback implementation can effectively be used for any Castor 
		   data access. CastorTemplate will ensure that Database instances are
		   properly opened and closed, and automatically participate in
		   transactions. The template instances are thread-safe and reusable, they
		   can thus be kept as instance variables of the surrounding class.</p><p>For simple single step actions like a single find, load, saveOrUpdate, or
		   delete call, CastorTemplate offers alternative convenience methods
		   that can replace such one line callback implementations. Furthermore,
		   Spring provides a convenient CastorDaoSupport base class that
		   provides a setJDOManager(..) method for receiving a JDOManager,
		   and getJDOManager() and getCastorTemplate()for use by subclasses.</p><p>In combination, this allows for very simple DAO implementations for
		   typical requirements:</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">extends</span> HibernateDaoSupport 
   <span class="hl-keyword">implements</span> ProductDao {

   <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) 
      <span class="hl-keyword">throws</span> DataAccessException {
      <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.getCastorTemplate().find(<span class="hl-string">"select p from
test.Product product where p.category=?"</span>, category);
   }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9403"></a>5.3.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div></div><p>As alternative to using Spring's CastorTemplate to implement DAOs,
		   data access code can also be written in a more traditional fashion,
		   without wrapping the Hibernate access code in a callback, while still
		   complying to Spring's generic DataAccessException hierarchy. Spring's
		   CastorDaoSupport base class offers methods to access the current
		   transactional Database and to convert exceptions in such a scenario;
		   similar methods are also available as static helpers on the
		   JDOManagerUtils class. Note that such code will usually pass "false"
		   into the getDatabased(..) method's "allowCreate" argument, to enforce
		   running within a transaction (which avoids the need to close the
		   returned Database, as it's lifecycle is managed by the transaction).</p><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">extends</span> HibernateDaoSupport 
   <span class="hl-keyword">implements</span> ProductDao {

   <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) 
      <span class="hl-keyword">throws</span> DataAccessException, MyException {

      Database database = getDatabase(getJDOManager(), false);
      <span class="hl-keyword">try</span> {
         List result = database.find( <span class="hl-string">"select p from test.Product p where "</span> + 
            <span class="hl-string">" product.category=?"</span>, category, Castor.STRING);
         <span class="hl-keyword">if</span> (result == null) {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> MyException(<span class="hl-string">"invalid search result"</span>);
         }
         <span class="hl-keyword">return</span> result;
      } <span class="hl-keyword">catch</span> (PersistenceException ex) {
         <span class="hl-keyword">throw</span> convertCastorAccessException(ex);
      }
   }
}
        </pre><p>The major advantage of such direct Castor JDO access code is that it
		   allows any checked application exception to be thrown within the data
		   access code, while CastorTemplate is restricted to unchecked
		   exceptions within the callback. Note that one can often defer the
		   corresponding checks and the throwing of application exceptions to after
		   the callback, which still allows working with CastorTemplate. In
		   general, the CastorTemplate class' convenience methods are simpler
		   and more convenient for many scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9408"></a>5.3.5.&nbsp;Programmatic transaction demarcation</h3></div></div></div><p>Transactions can be demarcated in a higher level of the application, on
		   top of such lower-level data access services spanning any number of
		   operations. There are no restrictions on the implementation of the
		   surrounding business service here as well, it just needs a Spring
		   PlatformTransactionManager. Again, the latter can come from anywhere,
		   but preferably as bean reference via a setTransactionManager(..) method
		   - just like the productDAO should be set via a setProductDao(..) method.</p><p>The following snippets show a transaction manager and a business service
		   definition in a Spring application context, and an example for a
		   business method implementation.</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myJDOManager"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.ProductServiceImpl"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"transactionManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myTxManager"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

   <span class="hl-keyword">private</span> TransactionTemplate transactionTemplate; 
   
   <span class="hl-keyword">private</span> ProductDao productDao;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTransactionManager(PlatformTransactionManager transactionManager) {
      <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
      <span class="hl-keyword">this</span>.productDao = productDao;
   }

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
      <span class="hl-keyword">this</span>.transactionTemplate.execute(
         <span class="hl-keyword">new</span> TransactionCallbackWithoutResult() {
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
               List productsToChange = productDAO.loadProductsByCategory(category); 
               <span class="hl-comment">// do the price increase...</span>
            }
         }
      );
   }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9414"></a>5.3.6.&nbsp;Declarative transaction demarcation</h3></div></div></div><p>Alternatively, one can use Spring's declarative transaction support,
		   which essentially enables you to replace explicit transaction
		   demarcation API calls in your Java code with an AOP transaction
		   interceptor configured in a Spring container. This allows you to keep
		   business services free of repetitive transaction demarcation code, and
		   allows you to focus on adding business logic which is where the real
		   value of your application lies. Furthermore, transaction semantics like
		   propagation behavior and isolation level can be changed in a
		   configuration file and do not affect the business service
		   implementations.</p><pre class="programlisting">
&lt;<span class="hl-tag">beans</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myTxManager"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.castor.spring.orm.CastorTransactionManager"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"jdoManager"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myJDOManager"</span> /&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

	&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">"myProductService"</span>
		<span class="hl-attribute">class</span>=<span class="hl-value">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"proxyInterfaces"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"product.ProductService"</span> /&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"target"</span>&gt;
			&lt;<span class="hl-tag">bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">"product.DefaultProductService"</span>&gt;
				&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"productDao"</span> <span class="hl-attribute">ref</span>=<span class="hl-value">"myProductDao"</span> /&gt;
			&lt;<span class="hl-tag">/bean</span>&gt;
		&lt;<span class="hl-tag">/property</span>&gt;
		&lt;<span class="hl-tag">property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"interceptorNames"</span>&gt;
			&lt;<span class="hl-tag">list</span>&gt;
				&lt;<span class="hl-tag">value</span>&gt;myTxInterceptor&lt;<span class="hl-tag">/value</span>&gt;&lt;<span class="hl-comment">!-- the transaction interceptor (configured elsewhere) --</span>&gt;
			&lt;<span class="hl-tag">/list</span>&gt;
		&lt;<span class="hl-tag">/property</span>&gt;
	&lt;<span class="hl-tag">/bean</span>&gt;

&lt;<span class="hl-tag">/beans</span>&gt;
        </pre><pre class="programlisting">
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

   <span class="hl-keyword">private</span> ProductDao productDao;

   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
      <span class="hl-keyword">this</span>.productDao = productDao;
   }

   <span class="hl-comment">// notice the absence of transaction demarcation code in this method </span>
   <span class="hl-comment">// Spring's declarative transaction infrastructure will be demarcating</span>
   <span class="hl-comment">//transactions on your behalf </span>
   <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
      List productsToChange = <span class="hl-keyword">this</span>.productDAO.loadProductsByCategory(category); 
      <span class="hl-comment">// ... </span>
   }
} 
        </pre><p>Spring's TransactionInterceptor allows any checked application exception
		   to be thrown with the callback code, while TransactionTemplate is
		   restricted to unchecked exceptions within the callback.
		   TransactionTemplate will trigger a rollback in case of an unchecked
		   application exception, or if the transaction has been marked
		   rollback-only by the application (via TransactionStatus).
		   TransactionInterceptor behaves the same way by default but allows
		   configurable rollback policies per method.</p><p>The following higher level approach to declarative transactions doesn't
		   use the ProxyFactoryBean, and as such may be easier to use if you have a
		   large number of service objects that you wish to make transactional.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>You are strongly encouraged to read the section entitled Section 9.5,
		      &#8220;Declarative transaction management&#8221; if you have not done so already
		      prior to continuing.
            </p></td></tr></table></div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd"&gt;

	&lt;!-- JDOManager, DataSource, etc. omitted --&gt;

	&lt;bean id="myTxManager"
		class="org.castor.spring.orm.CastorTransactionManager"&gt;
		&lt;property name="jdoManager" ref="myJDOManager" /&gt;
	&lt;/bean&gt;

	&lt;aop:config&gt;
		&lt;aop:pointcut id="productServiceMethods"
			expression="execution(* product.ProductService.*(..))" /&gt;
		&lt;aop:advisor advice-ref="txAdvice"
			pointcut-ref="productServiceMethods" /&gt;
	&lt;/aop:config&gt;

	&lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
		&lt;tx:attributes&gt;
			&lt;tx:method name="increasePrice*" propagation="REQUIRED" /&gt;
			&lt;tx:method name="someOtherBusinessMethod"
				propagation="REQUIRES_NEW" /&gt;
			&lt;tx:method name="*" propagation="SUPPORTS" read-only="true" /&gt;
		&lt;/tx:attributes&gt;
	&lt;/tx:advice&gt;

	&lt;bean id="myProductService" class="product.SimpleProductService"&gt;
		&lt;property name="productDao" ref="myProductDao" /&gt;
	&lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9424"></a>5.3.7.&nbsp;Transaction management strategies</h3></div></div></div><p>Both TransactionTemplate and TransactionInterceptor delegate the actual
		   transaction handling to a PlatformTransactionManager instance, which can
		   be a CastorTransactionManager (for a single Castor JDOManager,
		   using a ThreadLocal Database under the hood) or a JtaTransactionManager
		   (delegating to the JTA subsystem of the container) for Castor
		   applications. You could even use a custom PlatformTransactionManager
		   implementation. So switching from native Castor transaction
		   management to JTA, such as when facing distributed transaction
		   requirements for certain deployments of your application, is just a
		   matter of configuration. Simply replace the Castor transaction
		   manager with Spring's JTA transaction implementation. Both transaction
		   demarcation and data access code will work without changes, as they just
		   use the generic transaction management APIs.</p><p>For distributed transactions across multiple Castor JDOManager instances,
		   simply combine JtaTransactionManager as a transaction
		   strategy with multiple LocalCastorFactoryBean definitions. Each of your
		   DAOs then gets one specific JDOManager reference passed into it's
		   respective bean property. If all underlying JDBC data sources are
		   transactional container ones, a business service can demarcate
		   transactions across any number of DAOs and any number of session
		   factories without special regard, as long as it is using
		   JtaTransactionManager as the strategy.</p><pre class="programlisting">
&lt;beans&gt;

	&lt;bean id="myDataSource1"
		class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
		&lt;property name="jndiName value=" java:comp/env/jdbc/myds1" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myDataSource2"
		class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
		&lt;property name="jndiName" value="java:comp/env/jdbc/myds2" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myJDOManager1"
		class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
        &lt;property name="databaseName" value="test1" /&gt;      
        &lt;property name="configLocation" value="classpath:jdo-conf-1.xml" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myJDOManager2"
		class="org.castor.spring.orm.LocalCastorFactoryBean"&gt;
        &lt;property name="databaseName" value="test2" /&gt;      
        &lt;property name="configLocation" value="classpath:jdo-conf-2.xml" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myTxManager"
		class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;

	&lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
		&lt;property name="jdoManager" ref="myJDOManager1" /&gt;
	&lt;/bean&gt;

	&lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
		&lt;property name="jdoManager" ref="myJDOManager2" /&gt;
	&lt;/bean&gt;

	&lt;!-- this shows the Spring 1.x style of declarative transaction configuration --&gt;
	&lt;!-- it is totally supported, 100% legal in Spring 2.x, but see also above for the sleeker, Spring 2.0 style --&gt;
	&lt;bean id="myProductService"
		class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
		&lt;property name="transactionManager" ref="myTxManager" /&gt;
		&lt;property name="target"&gt;
			&lt;bean class="product.ProductServiceImpl"&gt;
				&lt;property name="productDao" ref="myProductDao" /&gt;
				&lt;property name="inventoryDao" ref="myInventoryDao" /&gt;
			&lt;/bean&gt;
		&lt;/property&gt;
		&lt;property name="transactionAttributes"&gt;
			&lt;props&gt;
				&lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
				&lt;prop key="someOtherBusinessMethod"&gt;
					PROPAGATION_REQUIRES_NEW
				&lt;/prop&gt;
				&lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
			&lt;/props&gt;
		&lt;/property&gt;
	&lt;/bean&gt;

&lt;/beans&gt;
        </pre><p>Both CastorTransactionManager and JtaTransactionManager allow for
		   proper JVM-level cache handling with Castor - without
		   container-specific transaction manager lookup or JCA connector (as long
		   as not using EJB to initiate transactions).</p><p>CastorTransactionManager can export the JDBC Connection used by
		   Castor to plain JDBC access code, for a specific DataSource. This
		   allows for high-level transaction demarcation with mixed Castor/JDBC
		   data access completely without JTA, as long as you are just accessing
		   one database! CastorTransactionManager will automatically expose the
		   Castor transaction as JDBC transaction if the passed-in
		   JDOManager has been set up with a DataSource (through the
		   "dataSource" property of the LocalCastorFactoryBean class).</p><p>Alternatively, the DataSource that the transactions are supposed to be
		   exposed for can also be specified explicitly, through the "dataSource"
		   property of the CastorTransactionManager class.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e9432"></a>5.4.&nbsp;Build instructions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9434"></a>5.4.1.&nbsp;Prerequisites</h3></div></div></div><p>
         In order to build the Sping ORM module for Castor JDO, you will have 
         the following requirements met on your system:
      </p><div class="itemizedlist"><ul type="disc"><li><p>Download and install <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://maven.apache.org" target="_top">Maven 2</a></p></li><li><p>Download and install a Subversion client.</p></li></ul></div><p>
        As this project uses Maven 2 for build and deployment, all required 
        compile-time dependencies will automatically be resolved by Maven 2
        and deployed into your local Maven 2 repository.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e9444"></a>5.4.2.&nbsp;Building the Spring ORM module</h3></div></div></div><p>
            This section describes how to build the Spring module from a command 
            line using Maven 2. Whilst there is support for Maven 2 in various
            IDEs (including e.g. Eclipse, IDEA, etc.), using the Maven command 
            line seems to be the most adequate least common denominator.
        </p><p>
            This section assumes that you have ckecked out the latest sources
            from the SVN repsitory for the Spring ORM module for Castor JDO.
            Instructions for doing so are provided 
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="source-repository.html" target="_top">here</a>.
        </p><p>
            Open a command line (shell) on your system, and issue the following 
            commands:
        </p><pre class="programlisting">
 &gt; mvn jar            
        </pre><p>
            Above command will compile the sources and create the distribution JAR
            in the <code class="literal">target</code> directory of the project root.
        </p><p>
           To install the newly created distribution JAR into your local Maven 2
           repository, please issue the following command:
        </p><pre class="programlisting">
 &gt; mvn install            
        </pre><p>
           To create the complete project documentation - in addition to
           the distribution assembly, please issue ...
        </p><pre class="programlisting">
 &gt; mvn site            
        </pre></div></div></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="advanced-jdo.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="jpa.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Advanced JDO&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:85%;"><a href="http://www.castor.org/" title="The Castor community">The Castor community</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Castor JDO - Support for the JPA specification</td></tr></table></div></body></html>