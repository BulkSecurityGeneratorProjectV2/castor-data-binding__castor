<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7 at 2016-05-15 
 | Rendered using Apache Maven Fluido Skin 1.5
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20160515" />
    <meta http-equiv="Content-Language" content="en" />
    <title>castor &#x2013; XML Mapping</title>
    <link rel="stylesheet" href="../../../css/apache-maven-fluido-1.5.min.css" />
    <link rel="stylesheet" href="../../../css/site.css" />
    <link rel="stylesheet" href="../../../css/print.css" media="print" />

      
    <script type="text/javascript" src="../../../js/apache-maven-fluido-1.5.min.js"></script>

                      </head>
        <body class="topBarDisabled">
          
    
    
            
    
        
    <a href="https://github.com/castor-data-binding/castor">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"
        alt="Fork me on GitHub">
    </a>
  
                
                    
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                    <a href="http://castor.org/" id="bannerLeft">
                <h2>Castor</h2>
                </a>
                      </div>
        <div class="pull-right">              <div id="bannerRight">
                                                                                                <img src="../../../images/castor.gif" />
                </div>
      </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
              
                              <li class="">
                    <a href="http://castor-data-binding.github.io/castor/" class="externalLink" title="Castor data binding">
        Castor data binding</a>
                    <span class="divider">/</span>
      </li>
            <li class="">
                    <a href="../../.././" title="castor">
        castor</a>
                    <span class="divider">/</span>
      </li>
        <li class="active ">XML Mapping</li>
        
              
                  <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2016-05-15</li>
              <li id="projectVersion" class="pull-right">
                      <span class="divider">|</span>
                    Version: 1.4.1
        </li>
            
                                    
    <li class="pull-right">
        <span class="divider">|</span>
                      <a href="http://github.com/" class="externalLink" title="Github">
        Github</a>
      </li>

  
    <li class="pull-right">
                      <a href="http://maven.apache.org/" class="externalLink" title="Maven">
        Maven</a>
      </li>

                    </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
              
                <ul class="nav nav-list">
                    <li class="nav-header">Main</li>
                              
      <li>
  
                          <a href="../../../main/index.html" title="Introduction">
          <span class="none"></span>
        Introduction</a>
            </li>
                
      <li>
  
                          <a href="../../../main/features.html" title="Features">
          <span class="none"></span>
        Features</a>
            </li>
                
      <li>
  
                          <a href="../../../main/download.html" title="Binary distributions">
          <span class="none"></span>
        Binary distributions</a>
            </li>
                
      <li>
  
                          <a href="../../../github-report.html" title="Recent changes">
          <span class="none"></span>
        Recent changes</a>
            </li>
                
      <li>
  
                          <a href="../../../main/maven-archetypes.html" title="Maven archetypes">
          <span class="none"></span>
        Maven archetypes</a>
            </li>
                
      <li>
  
                                        <a href="../../../rss/castor-announce.xml" target="_blank" title="RSS">RSS                                               <img class="imageLink" src="../../../images/rss.svg" alt="" width="16" height="16"/>
  </a>
                      </li>
                              <li class="nav-header">Documentation</li>
                              
      <li>
  
                          <a href="../../../reference-guide/index.html" title="Reference guide">
          <span class="none"></span>
        Reference guide</a>
            </li>
                
      <li>
  
                          <a href="../../../documentation/reference.guide.html" title="Reference guide (older versions)">
          <span class="none"></span>
        Reference guide (older versions)</a>
            </li>
                
      <li>
  
                          <a href="../../../documentation/publications.html" title="Publications">
          <span class="none"></span>
        Publications</a>
            </li>
                
      <li>
  
                          <a href="../../../../wiki" title="Project Wiki">
          <span class="none"></span>
        Project Wiki</a>
            </li>
                              <li class="nav-header">Development/Support</li>
                              
      <li>
  
                          <a href="../../../support/mailing-lists.html" title="Mailing lists">
          <span class="none"></span>
        Mailing lists</a>
            </li>
                
      <li>
  
                          <a href="../../../support/contributing.html" title="Contributing">
          <span class="none"></span>
        Contributing</a>
            </li>
                
      <li>
  
                          <a href="../../../support/contributors.html" title="Contributors">
          <span class="none"></span>
        Contributors</a>
            </li>
                
      <li>
  
                          <a href="../../../support/support.html" title="Support">
          <span class="none"></span>
        Support</a>
            </li>
                
      <li>
  
                          <a href="../../../support/professional-services.html" title="Professional services">
          <span class="none"></span>
        Professional services</a>
            </li>
                              <li class="nav-header">Tools</li>
                              
      <li>
  
                          <a href="../../../tools/schema-generator.html" title="Schema generator">
          <span class="none"></span>
        Schema generator</a>
            </li>
                              <li class="nav-header">More</li>
                              
      <li>
  
                          <a href="../../../more/examples.html" title="Examples">
          <span class="none"></span>
        Examples</a>
            </li>
                              <li class="nav-header">About</li>
                              
      <li>
  
                          <a href="../../../about/licenses.html" title="License">
          <span class="none"></span>
        License</a>
            </li>
                
      <li>
  
                          <a href="../../../about/references.html" title="References">
          <span class="none"></span>
        References</a>
            </li>
                
      <li>
  
                          <a href="../../../about/project-name.html" title="Project name">
          <span class="none"></span>
        Project name</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                                                                                                          
      <li>
  
                          <a href="../../../project-info.html" title="Project Information">
          <span class="icon-chevron-right"></span>
        Project Information</a>
                  </li>
                                                                                                                                                                                                                                    
      <li>
  
                          <a href="../../../project-reports.html" title="Project Reports">
          <span class="icon-chevron-right"></span>
        Project Reports</a>
                  </li>
            </ul>
              
                            <form id="search-form" action="https://www.google.com/search" method="get" >
    
  <input value="http://castor-data-binding.github.io/castor/" name="sitesearch" type="hidden"/>
  <input class="search-query" name="q" id="query" type="text" />
</form>
<script type="text/javascript" src="https://cse.google.com/brand?form=search-form"></script>
          
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                                                                                                                   <a href="https://travis-ci.org/castor-data-binding/castor" title="Travis-CI Build status (master branch)" class="builtBy">
        <img class="builtBy"  alt="Travis-CI Build status (master branch)" src="https://travis-ci.org/castor-data-binding/castor.svg?branch=master"    />
      </a>
                                                                                                    <a href="https://maven-badges.herokuapp.com/maven-central/org.codehaus.castor/castor/" title="Maven Central" class="builtBy">
        <img class="builtBy"  alt="Maven Central" src="https://maven-badges.herokuapp.com/maven-central/org.codehaus.castor/castor/badge.svg"    />
      </a>
                      </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <h1>XML Mapping</h1>
<div class="section">
<h2><a name="Introduction"></a>Introduction</h2>
<p>Castor XML mapping is a way to simplify the binding of java classes to XML document. It allows to transform the data contained in a java object model into/from an XML document.</p>
<p>Although it is possible to rely on Castor&#x2019;s default behavior to marshal and unmarshal Java objects into an XML document, it might be necessary to have more control over this behavior. For example, if a Java object model already exists, Castor XML Mapping can be used as a bridge between the XML document and that Java object model.</p>
<p>Castor allows one to specify some of its marshalling/unmarshalling behavior using a mapping file. This file gives explicit information to Castor on how a given XML document and a given set of Java objects relate to each other.</p>
<p>A Castor mapping file is a good way to dissociate the changes in the structure of a Java object model from the changes in the corresponding XML document format.</p></div>
<div class="section">
<h2><a name="Overview"></a>Overview</h2>
<p>The mapping information is specified by an XML document. This document is written from the point of view of the Java object and describes how the properties of the object have to be translated into XML. One constraint for the mapping file is that Castor should be able to infer unambiguously from it how a given XML element/attribute has to be translated into the object model during unmarshalling.</p>
<p>The mapping file describes for each object how each of its fields have to be mapped into XML. A field is an abstraction for a property of an object. It can correspond directly to a public class variable or indirectly to a property via some accessor methods (setters and getters).</p>
<p>It is possible to use the mapping and Castor default behavior in conjunction: when Castor has to handle an object or an XML data but can&#x2019;t find information about it in the mapping file, it will rely on its default behavior. Castor will use the Java Reflection API to introspect the Java objects to determine what to do.</p>
<p><b>Note:</b> Castor can&#x2019;t handle all possible mappings. In some complex cases, it may be necessary to rely on an XSL transformation in conjunction with Castor to adapt the XML document to a more friendly format.</p>
<div class="section">
<h3><a name="Marshalling_Behavior"></a>Marshalling Behavior</h3>
<p>For Castor, a Java class has to map into an XML element. When Castor marshals an object, it will:</p>

<ul>
  
<li>use the mapping information, if any, to find the name of the element to create</li>
</ul>
<p>or</p>

<ul>
  
<li>by default, create a name using the name of the class</li>
</ul>
<p>It will then use the fields information from the mapping file to determine how a given property of the object has to be translated into one and only one of the following:</p>

<ul>
  
<li>
<p>an attribute</p></li>
  
<li>
<p>an element</p></li>
  
<li>
<p>text content</p></li>
  
<li>
<p>nothing, as we can choose to ignore a particular field</p></li>
</ul>
<p>This process will be recursive: if Castor finds a property that has a class type specified elsewhere in the mapping file, it will use this information to marshal the object.</p>
<p>By default, if Castor finds no information for a given class in the mapping file, it will introspect the class and apply a set of default rules to guess the fields and marshal them. The default rules are as follows:</p>

<ul>
  
<li>
<p>All primitive types, including the primitive type wrappers (Boolean, Short, etc&#x2026;) are marshalled as attributes.</p></li>
  
<li>
<p>All other objects are marshalled as elements with either text content or element content.</p></li>
</ul></div>
<div class="section">
<h3><a name="Unmarshalling_Behavior"></a>Unmarshalling Behavior</h3>
<p>When Castor finds an element while unmarshalling a document, it will try to use the mapping information to determine which object to instantiate. If no mapping information is present, Castor will use the name of the element to try to guess the name of a class to instantiate (for example, for an element named &#x2018;test-element&#x2019;, Castor will try to instantiate a class named &#x2018;TestElement&#x2019; if no information is given in the mapping file). Castor will then use the field information of the mapping file to handle the content of the element.</p>
<p>If the class is not described in the mapping file, Castor will instrospect the class using the Java Reflection API to determine if there is any function of the form getXxxYyy()/setXxxYyy(&lt;type&gt; x). This accessor will be associated with XML element/attribute named &#x2018;xxx-yyy&#x2019;. In the future, we will provide a way to override this default behavior.</p>
<p>Castor will introspect object variables and use direct access _only_ if no get/set methods have been found in the class. In this case, Castor will look for public variables of the form:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public &lt;type&gt; xxxYYY;        
</pre></div></div>
<p>and expect an element/attribute named &#x2018;xxx-yyy&#x2019;. The only handled collections for &lt;type&gt; are java.lang.Vector and array. (up to version 0.8.10)</p>
<p>For primitive &lt;type&gt;, Castor will look for an attribute first and then an element. If &lt;type&gt; is not a primitive type, Castor will look for an element first and then an attribute.</p></div></div>
<div class="section">
<h2><a name="The_Mapping_File"></a>The Mapping File</h2>
<p>The following sections define the syntax for each of the mapping file artefacts and their semantical meaning.</p>
<div class="section">
<h3><a name="Sample_domain_objects"></a>Sample domain objects</h3>
<p>This section defines a small domain model that will be referenced by various mapping file (fragments/samples) in the following sections. The model consists of two two classes <tt>Order</tt> and <tt>OrderItem</tt>, where an order holds a list of order items.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class Order {

    private List orderItems;
    private String orderNumber;
    
    public List getOrderItems() {
        return orderItems;
    }
    public void setOrderItems(List orderItems) {
        this.orderItems = orderItems;
    }
    public String getOrderNumber() {
        return orderNumber;
    }
    public void setOrderNumber(String orderNumber) {
        this.orderNumber = orderNumber;
    }
}

public class OrderItem {
    
    private String id;
    private Integer orderQuantity;
    
    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public Integer getOrderQuantity() {
        return orderQuantity;
    }
    public void setOrderQuantity(Integer orderQuantity) {
        this.orderQuantity = orderQuantity;
    }
}
</pre></div></div>
<p>As shown above in bold, the <tt>Order</tt> instance has a (private) field <tt>'orderItems'</tt> to hold a collection of <tt>OrderItem</tt> instances. This field is publically exposed by corresponding getter and setter methods.</p></div>
<div class="section">
<h3><a name="The_mapping_element"></a>The &lt;mapping&gt; element</h3>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;!ELEMENT mapping ( description?, include*, field-handler*, class*, key-generator* )&gt;        
</pre></div></div>
<p>The &lt;mapping&gt; element is the root element of a mapping file. It contains:</p>

<ul>
  
<li>
<p>an optional description</p></li>
  
<li>
<p>zero or more &lt;include&gt; which facilitates reusing mapping files</p></li>
  
<li>
<p>zero of more &lt;field-handler&gt; defining custom, configurable field handlers</p></li>
  
<li>
<p>zero or more &lt;class&gt; descriptions: one for each class we intend to give mapping information</p></li>
  
<li>
<p>zero or more &lt;key-generator&gt;: not used for XML mapping</p></li>
</ul>
<p>A mapping file look like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE mapping PUBLIC &quot;-//EXOLAB/Castor Mapping DTD Version 1.0//EN&quot;
      castor.org
                         &quot;http://castor.org/mapping.dtd&quot;&gt;

&lt;mapping&gt;
    &lt;description&gt;Description of the mapping&lt;/description&gt;
    
    &lt;include href=&quot;other_mapping_file.xml&quot;/&gt;
    
    &lt;!-- mapping for class 'A' --&gt;
    &lt;class name=&quot;A&quot;&gt;
            .........
    &lt;/class&gt;
    
    &lt;!-- mapping for class 'B' --&gt;
    &lt;class name=&quot;B&quot;&gt;
            .........
    &lt;/class&gt;

&lt;/mapping&gt;
</pre></div></div></div>
<div class="section">
<h3><a name="The_class_element"></a>The &lt;class&gt; element</h3>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;!ELEMENT class ( description?, cache-type?, map-to?, field+ )&gt;
&lt;!ATTLIST class
          name            ID       #REQUIRED
          extends         IDREF    #IMPLIED
          depends         IDREF    #IMPLIED
          auto-complete   ( true |false ) &quot;false&quot;
          identity        CDATA    #IMPLIED
          access          ( read-only | shared | exclusive | db-locked )  &quot;shared&quot;
          key-generator   IDREF    #IMPLIED &gt;
</pre></div></div>
<p>The <tt>&lt;class&gt;</tt> element contains all the information used to map a Java class into an XML document. The content of <tt>&lt;class&gt;</tt> is mainly used to describe the fields that will be mapped.</p>

<table border="0" class="table table-striped"><caption>Description of the attributes</caption>
  <thead>
    
<tr class="a">
      
<th>Name </th>
      
<th>Description</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>name</b> </td>
      
<td>The fuly-qualified name of the Java class that we want to map to.</td>
    </tr>
    
<tr class="a">
      
<td><b>extends</b> </td>
      
<td>The fully qualified name of a parent class. This attribute should be used <b>only</b> if this class extends another class for which a class mapping is provided. It should <b>not</b> be used if there&#x2019;s no class maping for the extended class.</td>
    </tr>
    
<tr class="b">
      
<td><b>depends</b> </td>
      
<td>Used with Castor JDO only; for more information on this field, please see the <a class="externalLink" href="http://www.castor.org/jdo-mapping.html">JDO documentation</a>.</td>
    </tr>
    
<tr class="a">
      
<td><b>auto-complete</b> </td>
      
<td>If true, the class will be introspected to determine its field and the fields specified in the mapping file will be used to overide the fields found during the introspection.</td>
    </tr>
    
<tr class="b">
      
<td><b>identity</b> </td>
      
<td>Used with Castor JDO only; for more information on this field, please see see the <a class="externalLink" href="http://www.castor.org/jdo-mapping.html">JDO documentation</a>.</td>
    </tr>
    
<tr class="a">
      
<td><b>access</b> </td>
      
<td>Used with Castor JDO only; for more information on this field, please see see the <a class="externalLink" href="http://www.castor.org/jdo-mapping.html">JDO documentation</a>.</td>
    </tr>
    
<tr class="b">
      
<td><b>key-generator</b> </td>
      
<td>Used with Castor JDO only; for more information on this field, please see see the <a class="externalLink" href="http://www.castor.org/jdo-mapping.html">JDO documentation</a>.</td>
    </tr>
  </tbody>
  
</table>
<p>The auto-complete attributes is interesting as it allow a fine degree of control of the introspector: it is possible to specifiy only the fields whose Castor default behavior does not suite our needs. These feature should simplify the handling of complexe class containing many fields. Please see below for an example usage of this attribute.</p>

<table border="0" class="table table-striped"><caption>Description of the content</caption>
  <thead>
    
<tr class="a">
      
<th>Name </th>
      
<th>Description</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>description</b> </td>
      
<td>An optional description.</td>
    </tr>
    
<tr class="a">
      
<td><b>cache-type</b> </td>
      
<td>Used with Castor JDO only; for more information on this field, please see see the <a class="externalLink" href="http://www.castor.org/jdo-mapping.html">JDO documentation</a>.</td>
    </tr>
    
<tr class="b">
      
<td><b>map-to</b> </td>
      
<td>Used if the name of the element is not the name of the class. By default, Castor will infer the name of the element to be mapped from the name of the class: a Java class named &#x2018;XxxYyy&#x2019; will be transformed in &#x2018;xxx-yyy&#x2019;. If you don&#x2019;t want Castor to generate the name, you need to use &lt;map-to&gt; to specify the name you want to use. &lt;map-to&gt; is only used for the root element.</td>
    </tr>
    
<tr class="a">
      
<td><b>field</b> </td>
      
<td>Zero or more &lt;field&gt; elements, which are used to describe the properties of the Java class being mapped.</td>
    </tr>
  </tbody>
  
</table>
<div class="section">
<h4><a name="Sample_class_mappings"></a>Sample &lt;class&gt; mappings</h4>
<p>The following mapping fragment defines a class mapping for the <tt>OrderItem</tt> class:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;mypackage.OrderItem&gt;
           
   &lt;map-to xml=&quot;item&quot;/&gt;

   &lt;field name=&quot;id&quot; type=&quot;string&quot;&gt;
      &lt;bind-xml name=&quot;identity&quot; node=&quot;attribute&quot;/&gt;
   &lt;/field&gt;

   &lt;/field name=&quot;orderQuantity&quot; type=&quot;integer&quot;&gt;
      &lt;bind-xml name=&quot;quantity&quot; node=&quot;element&quot;/&gt;
   &lt;/field&gt;

&lt;/class&gt;
</pre></div></div>
<p>When marshalling an <tt>OrderItem</tt> instance, this yields the following XML:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; ?&gt;        
&lt;item identity=&quot;12&quot;&gt;
   &lt;quantity&gt;100&lt;/quantity&gt;
&lt;/item&gt;
</pre></div></div>
<p>The following mapping fragment defines a class mapping for the same class, where for all properties but <tt>id</tt> introspection should be used; the use of the <tt>auto-complete</tt> attribute instructs Castor XML to use introspection for all attributes other than <tt>'id'</tt>, where the given field mapping will be used.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;mypackage.OrderItem auto-complete=&quot;true&quot;&gt;
           
   &lt;map-to xml=&quot;item&quot;/&gt;

   &lt;field name=&quot;id&quot; type=&quot;string&quot;&gt;
      &lt;bind-xml name=&quot;identity&quot; node=&quot;attribute&quot;/&gt;
   &lt;/field&gt;

&lt;/class&gt;
</pre></div></div>
<p>When marshalling the very same <tt>OrderItem</tt> instance, this yields the following XML:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; ?&gt;        
&lt;item identity=&quot;12&quot;&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/item&gt;
</pre></div></div>
<p>By removing the &lt;map-to&gt; element from above class mapping, &#x2026;</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;mypackage.OrderItem auto-complete=&quot;true&quot;&gt;
           
   &lt;field name=&quot;id&quot; type=&quot;string&quot;&gt;
      &lt;bind-xml name=&quot;identity&quot; node=&quot;attribute&quot;/&gt;
   &lt;/field&gt;

&lt;/class&gt;
</pre></div></div>
<p>&#x2026; Castor will use introspection to infer the element name from the Java class name (<tt>OrderItem</tt>), applying a default naming convention scheme.</p>
<p>When marshalling the very same <tt>OrderItem</tt> instance, this yields the following XML:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; ?&gt;        
&lt;order-item identity=&quot;12&quot;&gt;
   &lt;order-quantity&gt;100&lt;/order-quantity&gt;
&lt;/order-item&gt;
</pre></div></div></div></div>
<div class="section">
<h3><a name="The_map-to_element"></a>The &lt;map-to&gt; element</h3>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;!ELEMENT map-to EMPTY&gt;
&lt;!ATTLIST map-to
          table               NMTOKEN  #IMPLIED
          xml                 NMTOKEN  #IMPLIED
          ns-uri              NMTOKEN  #IMPLIED
          ns-prefix           NMTOKEN  #IMPLIED
          ldap-dn             NMTOKEN  #IMPLIED
          element-definition  (true|false) &quot;false&quot;     NEW as of 1.0M3
          ldap-oc             NMTOKEN  #IMPLIED&gt;
</pre></div></div>
<p><tt>&lt;map-to&gt;</tt> is used to specify the name of the element that should be associated with the given class. <tt>&lt;map-to&gt;</tt> is only used for the root class. If this information is not present, Castor will:</p>

<ul>
  
<li>
<p>for marshalling, infer the name of the element to be mapped from the name of the class: a Java class named &#x2018;XxxYyy&#x2019; will be transformed into &#x2018;xxx-yyy&#x2019;.</p></li>
  
<li>
<p>for unmarshalling, infer the name of the class from the name of the element: for an element named &#x2018;test-element&#x2019; Castor will try to use a class named &#x2018;TestElement&#x2019;</p></li>
</ul>
<p>Please note that it is possible to change the naming scheme used by Castor to translate between the XML name and the Java class name in the <tt>castor.properties</tt> file.</p>

<table border="0" class="table table-striped"><caption>Description of attributes</caption>
  <thead>
    
<tr class="a">
      
<th>Attribute </th>
      
<th>Description</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>xml</b> </td>
      
<td>Name of the element that the class is associated to.</td>
    </tr>
    
<tr class="a">
      
<td><b>ns-uri</b> </td>
      
<td>Namespace URI</td>
    </tr>
    
<tr class="b">
      
<td><b>ns-prefix</b> </td>
      
<td>Desired namespace</td>
    </tr>
    
<tr class="a">
      
<td><b>element-definition</b> </td>
      
<td><tt>True</tt> if the descriptor as created from a schema definition that was of type element (as opposed to a &lt;complexType&gt; definition). This only is useful in the context of source code generation.</td>
    </tr>
    
<tr class="b">
      
<td><b>ldap-dn</b> </td>
      
<td>Not used for Castor XML</td>
    </tr>
    
<tr class="a">
      
<td><b>ldap-oc</b> </td>
      
<td>Not used for Castor XML</td>
    </tr>
  </tbody>
  
</table>
<div class="section">
<h4><a name="amap-to_samples"></a>&lt;map-to&gt; samples</h4>
<p>The following mapping fragment defines a &lt;map-to element for the <tt>OrderItem</tt> class, manually setting the element name to a value of <tt>'item'</tt>.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;myPackage.OrderItem&quot;&gt;
   ...
   &lt;map-to xml=&quot;item&quot; /&gt;
   ...
&lt;/class&gt;
</pre></div></div>
<p>The following mapping fragment instructs Castor to assign a namespace URI of <tt>http://castor.org/sample/mapping/</tt> to the &lt;item&gt; element, and use a namespace prefix of <tt>'castor'</tt> during un-/marshalling.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;myPackage.OrderItem&quot;&gt;
   ...
   &lt;map-to xml=&quot;item&quot; ns-uri=&quot;http://castor.org/sample/mapping/&quot;
           ns-prefix=&quot;castor&quot;/&gt;
   ...
&lt;/class&gt;
</pre></div></div>
<p>When marshalling an <tt>OrderItem</tt> instance, this will yield the following XML:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot; ?&gt;        
&lt;castor:order-item xmlns:castor=&quot;http://castor.org/sample/mapping/&quot; identity=&quot;12&quot;&gt;
   &lt;castor:order-quantity&gt;100&lt;/castor:order-quantity&gt;
&lt;/castor:order-item&gt;
</pre></div></div></div></div>
<div class="section">
<h3><a name="The_field_element"></a>The &lt;field&gt; element</h3>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;!ELEMENT field ( description?, sql?, bind-xml?, ldap? )&gt;
&lt;!ATTLIST field
    name           NMTOKEN  #REQUIRED
    type           NMTOKEN  #IMPLIED
    handler        NMTOKEN  #IMPLIED
    required       ( true | false )  &quot;false&quot;
    direct         ( true | false )  &quot;false&quot;
    lazy           ( true | false )  &quot;false&quot;
    transient      ( true | false )  &quot;false&quot;
    nillable       ( true | false )  &quot;false&quot;
    container      ( true | false )  &quot;false&quot;
    get-method     NMTOKEN  #IMPLIED
    set-method     NMTOKEN  #IMPLIED
    create-method  NMTOKEN  #IMPLIED
    collection     ( array | vector | hashtable | collection | set | map )  #IMPLIED&gt;
</pre></div></div>
<p><tt>&lt;field&gt;</tt> is used to describe a property of a Java object we want to marshal/unmarshal. It gives:</p>

<ul>
  
<li>
<p>its identity (&#x2018;name&#x2019;)</p></li>
  
<li>
<p>its type (infered from &#x2018;type&#x2019; and &#x2018;collection&#x2019;)</p></li>
  
<li>
<p>its access method (infered from &#x2018;direct&#x2019;, &#x2018;get-method&#x2019;, &#x2018;set-method&#x2019;)</p></li>
</ul>
<p>From this information, Castor is able to access a given property in the Java class.</p>
<p>In order to determine the signature that Castor expects, there are two easy rules to apply.</p>
<p><b>1. Determine &lt;type&gt;.</b></p>

<ul>
  
<li><b>If there is no &#x2018;collection&#x2019; attribute</b>, the &lt;type&gt; is just the Java type specified in &lt;type_attribute&gt; (the value of the &#x2018;type&#x2019; attribute in the XML document). The value of &lt;type_attribute&gt; can be a fully qualified Java object like &#x2018;java.lang.String&#x2019; or one of the allowed short name:</li>
</ul>

<table border="0" class="table table-striped"><caption>Type shortnames</caption>
  <thead>
    
<tr class="a">
      
<th>short name </th>
      
<th>Primitive type? </th>
      
<th>Java Class</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td>other </td>
      
<td>N </td>
      
<td>java.lang.Object</td>
    </tr>
    
<tr class="a">
      
<td>string </td>
      
<td>N </td>
      
<td>java.lang.String</td>
    </tr>
    
<tr class="b">
      
<td>integer </td>
      
<td>Y </td>
      
<td>java.lang.Integer.TYPE</td>
    </tr>
    
<tr class="a">
      
<td>long </td>
      
<td>Y </td>
      
<td>java.lang.Long.TYPE</td>
    </tr>
    
<tr class="b">
      
<td>boolean </td>
      
<td>Y </td>
      
<td>java.lang.Boolean.TYPE</td>
    </tr>
    
<tr class="a">
      
<td>double </td>
      
<td>Y </td>
      
<td>java.lang.Double.TYPE</td>
    </tr>
    
<tr class="b">
      
<td>float </td>
      
<td>Y </td>
      
<td>java.lang.Float.TYPE</td>
    </tr>
    
<tr class="a">
      
<td>big-decimal </td>
      
<td>N </td>
      
<td>java.math.BigDecimal</td>
    </tr>
    
<tr class="b">
      
<td>byte </td>
      
<td>Y </td>
      
<td>java.lang.Byte.TYPE</td>
    </tr>
    
<tr class="a">
      
<td>date </td>
      
<td>N </td>
      
<td>java.util.Date</td>
    </tr>
    
<tr class="b">
      
<td>short </td>
      
<td>Y </td>
      
<td>java.lang.Short.TYPE</td>
    </tr>
    
<tr class="a">
      
<td>char </td>
      
<td>Y </td>
      
<td>java.lang.Character.TYPE</td>
    </tr>
    
<tr class="b">
      
<td>bytes </td>
      
<td>N </td>
      
<td>byte[]</td>
    </tr>
    
<tr class="a">
      
<td>chars </td>
      
<td>N </td>
      
<td>char[]</td>
    </tr>
    
<tr class="b">
      
<td>strings </td>
      
<td>N </td>
      
<td>String[]</td>
    </tr>
    
<tr class="a">
      
<td>locale </td>
      
<td>N </td>
      
<td>java.util.Locale</td>
    </tr>
  </tbody>
  
</table>
<p>Castor will try to cast the data in the XML file in the proper Java type.</p>

<ul>
  
<li><b>If there is a collection attribute</b> , you can use the following table:</li>
</ul>

<table border="0" class="table table-striped"><caption>Type implementations</caption>
  <thead>
    
<tr class="a">
      
<th>name </th>
      
<th>&lt;type&gt; </th>
      
<th>default implementation</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td>array </td>
      
<td>&lt;type_attribute&gt;[] </td>
      
<td>&lt;type_attribute&gt;[]</td>
    </tr>
    
<tr class="a">
      
<td>arraylist </td>
      
<td>java.util.List </td>
      
<td>java.util.Arraylist</td>
    </tr>
    
<tr class="b">
      
<td>vector </td>
      
<td>java.util.Vector </td>
      
<td>java.util.Vector</td>
    </tr>
    
<tr class="a">
      
<td>hashtable </td>
      
<td>java.util.Hashtable </td>
      
<td>java.util.Hashtable</td>
    </tr>
    
<tr class="b">
      
<td>collection </td>
      
<td>java.util.Collection </td>
      
<td>java.util.Arraylist</td>
    </tr>
    
<tr class="a">
      
<td>set </td>
      
<td>java.util.Set </td>
      
<td>java.util.Hashset</td>
    </tr>
    
<tr class="b">
      
<td>map </td>
      
<td>java.util.Map </td>
      
<td>java.util.Hashmap</td>
    </tr>
    
<tr class="a">
      
<td>sortedset </td>
      
<td>java.util.SortedSet </td>
      
<td>java.util.TreeSet</td>
    </tr>
  </tbody>
  
</table>
<p>The type of the object inside the collection is &lt;type_attribute&gt;. The &#x2018;default implementation&#x2019; is the type used if the object holding the collection is found to be null and need to be instantiated.</p>
<p>For hashtable and maps (since 0.9.5.3), Castor will save both key and values. When marshalling output &lt;key&gt; and &lt;value&gt; elements. These names can be controlled by using a top-level or nested class mapping for the org.exolab.castor.mapping.MapItem class.</p>
<p>Note: for backward compatibility with prior versions of Castor, the <i>saveMapKeys</i> property can be set to false in the castor.properties file.</p>
<p>For versions prior to 0.9.5.3, hashtable and maps, Castor will save only the value during marshalling and during unmarshalling will add a map entry using the object as both the key and value, e.g. map.put(object, object).</p>
<p>It is necessary to use a collection when the content model of the element expects more than one element of the specified type.</p>
<p><b>Determine the signature of the function</b></p>

<ul>
  
<li><b>If &#x2018;direct&#x2019; is set to true</b>, Castor expects to find a class variable with the given signature:</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    public &lt;type&gt; &lt;name&gt;;
</pre></div></div>

<ul>
  
<li><b>If &#x2018;direct&#x2019; is set to false or omitted</b>, Castor will access the property though accessor methods. Castor determines the signature of the accessors as follow: If the &#x2018;get-method&#x2019; or &#x2018;set-method&#x2019; attributes are supplied, it will try to find a function with the following signature:</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    public &lt;type&gt; &lt;get-method&gt;();
</pre></div></div>
<p>or</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    public void &lt;set-method&gt;(&lt;type&gt; value);
</pre></div></div>
<p>If &#x2018;get-method&#x2019; and &#x2018;set-method&#x2019; attributes are not provided, Castor will try to find the following function:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    public &lt;type&gt; get&lt;capitalized-name&gt;();
</pre></div></div>
<p>or</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">    public void set&lt;capitalized-name&gt;(&lt;type&gt; value);
</pre></div></div>
<p>&lt;capitalized-name&gt; means that Castor takes the &lt;name&gt; attribute and put its first letter in uppercase without modifying the other letters.</p>
<p>The content of &lt;field&gt; will contain the information on how to map this given field to SQL, XML, &#x2026;</p>

<ul>
  
<li><b>Exceptions concerning collection fields:</b></li>
</ul>
<p>The default is to treat the &#x2018;get-method&#x2019; as a simple getter returning the collection field, and the &#x2018;set-method&#x2019; as a simple getter used to set a new instance on the collection field.</p>
<div class="section">
<div class="section">
<h5><a name="aget-method:"></a>&#x2018;get-method&#x2019;:</h5>
<p>If a &#x2018;get-method&#x2019; is provided for a collection field, Castor - in adition to the default behaviour described above - will deviate from the standard case for the following special prefixes:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public Iterator iterate...();
</pre></div></div>
<p>A &#x2018;get-method&#x2019; starting with the prefix &#x2018; <tt>iterate</tt> &#x2019; is treated as Iterator method for the given collection field.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public Enumeration enum...();
</pre></div></div>
<p>A &#x2018;get-method&#x2019; starting with &#x2018; <tt>enum</tt> &#x2019; is treated as Enumeration method for the given collection field.</p></div>
<div class="section">
<h5><a name="aset-method"></a>&#x2018;set-method&#x2019;</h5>
<p>If &#x2018;set-method&#x2019; is provided for a collection field, Castor - in addition to the default behaviour described above - will accept an &#x2018;add&#x2019; prefix and expect the following signature:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public void add...(&lt;type&gt; value);
</pre></div></div>
<p>This method is called for each collection element while unmarshalling. </p>

<table border="0" class="table table-striped">
  <thead>
    
<tr class="a">
      
<th>Name </th>
      
<th>Description</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>name</b> </td>
      
<td>The field &#x2018;name&#x2019; is required even if no such field exists in the class. If &#x2018;direct&#x2019; access is used, &#x2018;name&#x2019; should be the name of a public instance member in the object to be mapped (the field must be public, not static and not transient). If no direct access and no &#x2018;get-/set-method&#x2019; is specified, this name will be used to infer the name of the accessors methods.</td>
    </tr>
    
<tr class="a">
      
<td><b>type</b> </td>
      
<td>The Java type of the field. It is used to access the field. Castor will use this information to cast the XML information (like string into integer). It is also used to define the signature of the accessor methods. If a collection is specified, this is used to specify the type of the objects held by the collection. See description above for more details.</td>
    </tr>
    
<tr class="b">
      
<td><b>required</b> </td>
      
<td>A field can be optional or required.</td>
    </tr>
    
<tr class="a">
      
<td><b>nillable</b> </td>
      
<td>A field can be of content &#x2018;<tt>nil</tt>&#x2019;.</td>
    </tr>
    
<tr class="b">
      
<td><b>transient</b> </td>
      
<td>If true, this field will be ignored during the marshalling. This is usefull when used together with the auto-complete=&#x201c;true&#x201d; option.</td>
    </tr>
    
<tr class="a">
      
<td><b>direct</b> </td>
      
<td>If true, Castor will expect a public variable in the containing class and will access it directly (for both reading and writing).</td>
    </tr>
    
<tr class="b">
      
<td><b>container</b> </td>
      
<td>Indicates whether the field should be treated as a container, i.e. only it&#x2019;s fields should be persisted, but not the containing class itself. In this case, the container attribute should be set to true (supported in Castor XML only).</td>
    </tr>
    
<tr class="a">
      
<td><b>collection</b> </td>
      
<td>If a parent expects more than one occurrence of one of its element, it is necessary to specify which collection Castor will use to handle them. The type specified is used to define the type of the content inside the collection.</td>
    </tr>
    
<tr class="b">
      
<td><b>get-method</b> </td>
      
<td>Optional name of the &#x2018;get method&#x2019; Castor should use. If this attribute is not set and the set-method attribute is not set, then Castor will try to infer the name of this method with the algorithm described above.</td>
    </tr>
    
<tr class="a">
      
<td><b>set-method</b> </td>
      
<td>Optional name of the &#x2018;set method&#x2019; Castor should use. If this attribute is not set and the get-method attribute is not set, then Castor will try to infer the name of this method with the algorithm described above.</td>
    </tr>
    
<tr class="b">
      
<td><b>create-method</b> </td>
      
<td>Optionally defines a factory method for the instantiation of a FieldHandler</td>
    </tr>
    
<tr class="a">
      
<td><b>handler</b> </td>
      
<td>If present, specifies one of the following:</td>
    </tr>
  </tbody>
</table>

<div class="source">
<div class="source"><pre class="prettyprint linenums">                  -   The fully-qualified class name of a custom field handler implementation, or
                  -   The (short) name of a [configurable field handler](http://www.castor.org/xml-fieldhandlers.html#Use-ConfigurableFieldHandler-for-more-flexibility) definition.
</pre></div></div>
<p>[Description of the attributes]</p></div></div></div>
<div class="section">
<h3><a name="Description_of_the_content"></a>Description of the content</h3>
<p>In the case of XML mapping, the content of a field element should be one and only one <b>&lt;bind-xml&gt;</b> element describing how this given field will be mapped into the XML document.</p>
<div class="section">
<h4><a name="Mapping_constructor_arguments_since_0.9.5"></a>Mapping constructor arguments (since 0.9.5)</h4>
<p>Starting with release 0.9.5, for <i>attribute</i> mapped fields, support has been added to map a constructor field using the <tt>set-method</tt> attribute.</p>
<p>To specify that a field (mapped to an attribute) should be used as a constructor argument during object initialization, please specify a <tt>set-method</tt> attribute on the <tt>&lt;field&gt;</tt> mapping and use &#x201c;%X&#x201d; as the value of the <tt>set-method</tt> attribute, where <tt>X</tt> is a positive integer number, e.g. <tt>%1</tt> or <tt>%21</tt>.</p>
<p>For example:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;field name=&quot;foo&quot; set-method=&quot;%1&quot; get-method=&quot;getFoo&quot; type=&quot;string&quot;&gt;
   &lt;bind-xml node=&quot;attribute&quot;/&gt;
&lt;/field&gt;
</pre></div></div>
<p>Note that because the <tt>set-method</tt> is specified, the <tt>get-method</tt> also must be specified.</p>
<p><b>Tip</b>: the XML HOW-TO section has a HOW-TO document for mapping constructor arguments, incl. a fully working mapping.</p></div>
<div class="section">
<h4><a name="Sample_1:_Defining_a_custom_field_handler"></a>Sample 1: Defining a custom field handler</h4>
<p>The following mapping fragment defines a <tt>&lt;field&gt;</tt> element for the <tt>member</tt> property of the <tt>org.some.package.Root</tt> class, specifying a custom <tt>org.exolab.castor.mapping.FieldHandler</tt> implementation.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;org.some.package.Root&quot;&gt;
   &lt;field name=&quot;member&quot; type=&quot;string&quot; handler=&quot;org.some.package.CustomFieldHandlerImpl&quot;/&gt;
&lt;/class&gt;
</pre></div></div></div>
<div class="section">
<h4><a name="Sample_2:_Defining_a_custom_configurable_field_handler"></a>Sample 2: Defining a custom configurable field handler</h4>
<p>The same custom field handler as in the previous sample can be defined with a separate configurable &lt;field-handler&gt; definition, where additional configuration can be provided.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;field-handler name=&quot;myHandler&quot; class=&quot;org.some.package.CustomFieldHandlerImpl&quot;&gt;
   &lt;param name=&quot;date-format&quot; value=&quot;yyyyMMddHHmmss&quot;/&gt;
&lt;/field-handler&gt;
</pre></div></div>
<p>and subsequently be referred to by its <b>name</b> as shown in the following field mapping:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;org.some.package.Root&quot;&gt;
   &lt;field name=&quot;member&quot; type=&quot;string&quot; handler=&quot;myHandler&quot;/&gt;
&lt;/class&gt;
</pre></div></div></div>
<div class="section">
<h4><a name="Sample_3:_Using_the_container_attribute"></a>Sample 3: Using the container attribute</h4>
<p>Assume you have a class mapping for a class <tt>Order</tt> which defines - amongst others - a field mapping as follows, where the field <tt>item</tt> refers to an instance of a class <tt>Item</tt>.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;class name=&quot;some.example.Order&quot;&gt;
            
   ...
   &lt;field name=&quot;item&quot; type=&quot;some.example.Item&quot; &gt;
      &lt;bind-xml&gt; name=&quot;item&quot; node=&quot;element&quot; /&gt;
   &lt;/field&gt;
   ...
&lt;/class&gt;

&lt;class name=&quot;some.example.Item&quot;&gt;
   &lt;field name=&quot;id&quot; type=&quot;long&quot; /&gt;
   &lt;field name=&quot;description&quot; type=&quot;string&quot; /&gt;
&lt;/class&gt;
</pre></div></div>
<p>Marshalling an instance of <tt>Order</tt> would produce XML as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;order&gt;
    ...
    &lt;item&gt;
        &lt;id&gt;100&lt;/id&gt;
        &lt;description&gt;...&lt;/description&gt;
    &lt;/item&gt;
&lt;/order&gt;
</pre></div></div>
<p>If you do not want the <tt>Item</tt> instance to be marshalled, but only its fields, change the field mapping for the <tt>item</tt> member to be as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;field name=&quot;item&quot; type=&quot;some.example.Item&quot; container=&quot;false&quot; &gt;
   &lt;bind-xml&gt; name=&quot;item&quot; node=&quot;element&quot; /&gt;
&lt;/field&gt;
</pre></div></div>
<p>The resulting XML would look as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;order&gt;
    ...
    &lt;id&gt;100&lt;/id&gt;
    &lt;description&gt;...&lt;/description&gt;
&lt;/order&gt;
</pre></div></div></div></div>
<div class="section">
<h3><a name="The_bind-xml_element"></a>The &lt;bind-xml&gt; element</h3>
<div class="section">
<h4><a name="Grammar"></a>Grammar</h4>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;!ELEMENT bind-xml (class?, property*)&gt;
&lt;!ATTLIST bind-xml
          name     NMTOKEN     #IMPLIED
          type     NMTOKEN     #IMPLIED
          location CDATA       #IMPLIED
          matches  NMTOKENS    #IMPLIED
          QName-prefix NMTOKEN #IMPLIED
          reference   ( true | false ) &quot;false&quot;
          node        ( attribute | element | text )    #IMPLIED
          auto-naming ( deriveByClass | deriveByField ) #IMPLIED
          transient   ( true | false ) &quot;false&quot;&gt;
</pre></div></div>
<div class="section">
<h5><a name="Definiton"></a>Definiton</h5>
<p>The <tt>&lt;bind-xml&gt;</tt> element is used to describe how a given Java field should appear in an XML document. It is used both for marshalling and unmarshalling.</p>

<table border="0" class="table table-striped"><caption>Description of the attributes</caption>
  <thead>
    
<tr class="a">
      
<th>Field </th>
      
<th>Description</th>
    </tr>
  </thead>
  <tbody>
    
<tr class="b">
      
<td><b>name</b> </td>
      
<td>The name of the element or attribute. The name is a QName, and a namespace prefix may be used to indicate the element or attribute belongs to a certain namespace. Note the prefix is not preserved or used during marshaling, it&#x2019;s simply used for qualification of which namespace the element or attribute belongs.</td>
    </tr>
    
<tr class="a">
      
<td><b>auto-naming</b> </td>
      
<td>If no name is specified, this attribute controls how castor will automatically create a name for the field. Normally, the name is created using the field name, however many times it is necessary to create the name by using the class type instead (such as heterogeneous collections).</td>
    </tr>
    
<tr class="b">
      
<td><b>type</b> </td>
      
<td>XML Schema type (of the value of this field) that requires specific handling in the Castor Marshaling Framework (such as &#x2018;QName&#x2019; for instance).</td>
    </tr>
    
<tr class="a">
      
<td><b>location</b> (since 0.9.4.4) </td>
      
<td>Allows the user to specify the &#x201c;sub-path&#x201d; for which the value should be marshaled to and from. This is useful for &#x201c;wrapping&#x201d; values in elements or for mapping values that appear on sub-elements to the current &#x201c;element&#x201d; represented by the class mapping. For more information, see the location attribute.</td>
    </tr>
    
<tr class="b">
      
<td><b>QName-prefix</b> </td>
      
<td>When the field represents a QName value, a prefix can be provided that is used when marshaling value of type QName. More information on the use of &#x2018;QName-prefix&#x2019; can be found in the <a class="externalLink" href="http://www.castor.org/SourceGeneratorUser.pdf">SourceGenerator Documentation</a></td>
    </tr>
    
<tr class="a">
      
<td><b>reference</b> </td>
      
<td>Indicates if this field has to be treated as a reference by the unmarshaler. In order to work properly, you must specify the node type to &#x2018;attribute&#x2019; for both the &#x2018;id&#x2019; and the &#x2018;reference&#x2019;. In newer versions of Castor, &#x2018;element&#x2019; node for reference is allowed. Remember to make sure that an <i>identity</i> field is specified on the <tt>&lt;class&gt;</tt> mapping for the object type being referenced so that Castor knows what the object&#x2019;s identity is.</td>
    </tr>
    
<tr class="b">
      
<td><b>matches</b> </td>
      
<td>Allows overriding the matches rules for the name of the element. It is a standard regular expression and will be used instead of the &#x2018;name&#x2019; field. A &#x2018;*&#x2019; will match any XML name, however it will only be matched if no other field exists that matches the xml name.</td>
    </tr>
    
<tr class="a">
      
<td><b>node</b> </td>
      
<td>Indicates if the name corresponds to an attribute, an element, or text content. By default, primitive types are assumed to be an attribute, otherwise the node is assumed to be an element</td>
    </tr>
    
<tr class="b">
      
<td><b>transient</b> </td>
      
<td>Allows for making this field transient for XML. The default value is inherited from the &lt;field&gt; element.</td>
    </tr>
  </tbody>
  
</table></div></div>
<div class="section">
<h4><a name="Nested_class_mapping"></a>Nested class mapping</h4>
<p>Since 0.9.5.3, the bind-xml element supports a nested class mapping, which is often useful when needing to specify more than one mapping for a particular class. A good example of this is when mapping Hashtable/HashMap/Map.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;bind-xml ...&gt;
   &lt;class name=&quot;org.exolab.castor.mapping.MapItem&quot;&gt;
      &lt;field name=&quot;key&quot; type=&quot;java.lang.String&quot;&gt;
        &lt;bind-xml name=&quot;id&quot;/&gt;
      &lt;/field&gt;
      &lt;field name=&quot;value&quot; type=&quot;com.acme.Foo&quot;/&gt;
   &lt;/class&gt;
&lt;/bind-xml&gt;
</pre></div></div></div></div></div>
<div class="section">
<h2><a name="Usage_Pattern"></a>Usage Pattern</h2>
<p>Here is an example of how Castor Mapping can be used. We want to map an XML document like the following one (called &#x2018;order.xml&#x2019;). model.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;Order reference=&quot;12343-AHSHE-314159&quot;&gt;
  &lt;Client&gt;
    &lt;Name&gt;Jean Smith&lt;/Name&gt;
    &lt;Address&gt;2000, Alameda de las Pulgas, San Mateo, CA 94403&lt;/Address&gt;
  &lt;/Client&gt;

  &lt;Item reference=&quot;RF-0001&quot;&gt;
    &lt;Description&gt;Stuffed Penguin&lt;/Description&gt;
    &lt;Quantity&gt;10&lt;/Quantity&gt;
    &lt;UnitPrice&gt;8.95&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=&quot;RF-0034&quot;&gt;
    &lt;Description&gt;Chocolate&lt;/Description&gt;
    &lt;Quantity5&lt;/Quantity&gt;
    &lt;UnitPrice&gt;28.50&lt;/UnitPrice&gt;
  &lt;/Item&gt;

  &lt;Item reference=&quot;RF-3341&quot;&gt;
     &lt;Description&gt;Cookie&lt;/Description&gt;
     &lt;Quantity&gt;30&lt;/Quantity&gt;
     &lt;UnitPrice&gt;0.85&lt;/UnitPrice&gt;
  &lt;/Item&gt;
&lt;/Order&gt;
</pre></div></div>
<p>Into the following object model composed of 3 classes:</p>

<ul>
  
<li>
<p><b>MyOrder:</b> represent an order</p></li>
  
<li>
<p><b>Client:</b> used to store information on the client</p></li>
  
<li>
<p><b>Item:</b> used to store item in an order</p></li>
</ul>
<p>The sources of these classes follow.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">import java.util.Vector;
import java.util.Enumeration;

public class MyOrder {

    private String _ref;
    private ClientData _client;
    private Vector _items;
    private float _total;

    public void setReference(String ref) {
        _ref = ref;
    }

    public String getReference() {
        return _ref;
    }

    public void setClientData(ClientData client) {
        _client = client;
    }

    public ClientData getClientData() {
        return _client;
    }

    public void setItemsList(Vector items) {
        _items = items;
    }

    public Vector getItemsList() {
        return _items;
    }


    public void setTotal(float total) {
        _total = total;
    }

    public float getTotal() {
        return _total;
    }

    // Do some processing on the data
    public float getTotalPrice() {
        float total = 0.0f;

        for (Enumeration e = _items.elements() ; e.hasMoreElements() ;) {
            Item item = (Item) e.nextElement();
            total += item._quantity * item._unitPrice;
        }

        return total;
    }
}
</pre></div></div>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class ClientData {

    private String _name;
    private String _address;

    public void setName(String name) {
        _name = name;
    }

    public String getName() {
        return _name;
    }

    public void setAddress(String address) {
        _address = address;
    }

    public String getAddress() {
        return _address;
    }
}
</pre></div></div>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class Item {
    public String _reference;
    public int    _quantity;
    public float  _unitPrice;
    public String _description;
}
</pre></div></div>
<p>The XML document and the java object model can be connected by using the following mapping file:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE mapping PUBLIC &quot;-//EXOLAB/Castor Mapping DTD Version 1.0//EN&quot;
                         &quot;http://castor.org/mapping.dtd&quot;&gt;

&lt;mapping&gt;
  &lt;class name=&quot;MyOrder&quot;&gt;
    &lt;map-to xml=&quot;Order&quot;/&gt;

    &lt;field name=&quot;Reference&quot;
           type=&quot;java.lang.String&quot;&gt;
      &lt;bind-xml name=&quot;reference&quot; node=&quot;attribute&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;Total&quot;
           type=&quot;float&quot;&gt;
      &lt;bind-xml name=&quot;total-price&quot; node=&quot;attribute&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;ClientData&quot;
           type=&quot;ClientData&quot;&gt;
      &lt;bind-xml name=&quot;Client&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;ItemsList&quot;
           type=&quot;Item&quot;
              collection=&quot;vector&quot;&gt;
      &lt;bind-xml name=&quot;Item&quot;/&gt;
    &lt;/field&gt;
  &lt;/class&gt;

  &lt;class name=&quot;ClientData&quot;&gt;
    &lt;field name=&quot;Name&quot;
           type=&quot;java.lang.String&quot;&gt;
      &lt;bind-xml name=&quot;Name&quot; node=&quot;element&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;Address&quot;
           type=&quot;java.lang.String&quot;&gt;
      &lt;bind-xml name=&quot;Address&quot; node=&quot;element&quot;/&gt;
    &lt;/field&gt;
  &lt;/class&gt;

  &lt;class name=&quot;Item&quot;&gt;
    &lt;field name=&quot;_reference&quot;
           type=&quot;java.lang.String&quot;
           direct=&quot;true&quot;&gt;
      &lt;bind-xml name=&quot;reference&quot; node=&quot;attribute&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;_quantity&quot;
           type=&quot;integer&quot;
           direct=&quot;true&quot;&gt;
      &lt;bind-xml name=&quot;Quantity&quot; node=&quot;element&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;_unitPrice&quot;
           type=&quot;float&quot;
           direct=&quot;true&quot;&gt;
      &lt;bind-xml name=&quot;UnitPrice&quot; node=&quot;element&quot;/&gt;
    &lt;/field&gt;

    &lt;field name=&quot;_description&quot;
           type=&quot;string&quot;
           direct=&quot;true&quot;&gt;
      &lt;bind-xml name=&quot;Description&quot; node=&quot;element&quot;/&gt;
    &lt;/field&gt;
  &lt;/class&gt;

&lt;/mapping&gt;
</pre></div></div>
<p>The following class is an example of how to use Castor XML Mapping to manipulate the file &#x2018;order.xml&#x2019;. It unmarshals the document &#x2018;order.xml&#x2019;, computes the total price, sets the total price in the java object and marshals the object model back into XML with the calculated price.</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">import org.exolab.castor.mapping.Mapping;
import org.exolab.castor.mapping.MappingException;

import org.exolab.castor.xml.Unmarshaller;
import org.exolab.castor.xml.Marshaller;

import java.io.IOException;
import java.io.FileReader;
import java.io.OutputStreamWriter;

import org.xml.sax.InputSource;

public class main {

    public static void main(String args[]) {

        Mapping      mapping = new Mapping();

        try {
            // 1. Load the mapping information from the file
            mapping.loadMapping( &quot;mapping.xml&quot; );

            // 2. Unmarshal the data
            Unmarshaller unmar = new Unmarshaller(mapping);
            MyOrder order = (MyOrder)unmar.unmarshal(new InputSource(new FileReader(&quot;order.xml&quot;)));

            // 3. Do some processing on the data
            float total = order.getTotalPrice();
            System.out.println(&quot;Order total price = &quot; + total);
            order.setTotal(total);

            // 4. marshal the data with the total price back and print the XML in the console
            Marshaller marshaller = new Marshaller(new OutputStreamWriter(System.out));
            marshaller.setMapping(mapping);
            marshaller.marshal(order);

        } catch (Exception e) {
            System.out.println(e);
            return;
        }
    }
}       
</pre></div></div></div>
<div class="section">
<h2><a name="xsi:type"></a>xsi:type</h2>
<p>Ordinarily, a mapping will only reference types that are concrete classes (i.e. not interfaces nor abstract classes). The reason is that to unmarshal a type requires instantiating it and one cannot instantiate an interface. However, in many real situations, object models depend on the use of interfaces. Many class properties are defined to have interface types to support the ability to swap implementations. This is often the case in frameworks.</p>
<p>The problem is that a different mapping must be used each time the same model is to be used to marshal/unmarshal an implementation that uses different concrete types. This is not convenient. The mapping should represent the model and the specific concrete type used to unmarshal a document is a configuration parameter; it should be specified in the instance document to be unmarshalled, not the mapping.</p>
<p>For example, assume a very simple object model of an engine that has one property that is a processor:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public interface IProcessor {
    public void process();
}

public class Engine {
    private IProcessor processor;
    public IProcessor getProcessor() {
        return processor;
    }
    public void setProcessor(IProcessor processor) {
        this.processor = processor;
    }
}         
</pre></div></div>
<p>A typical mapping file for such a design may be:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;mapping&gt;
    &lt;class name=&quot;Engine&quot;&gt;
        &lt;map-to xml=&quot;engine&quot; /&gt;

        &lt;field name=&quot;processor&quot; type=&quot;IProcessor&quot; required=&quot;true&quot;&gt;
           &lt;bind-xml name=&quot;processor&quot; node=&quot;element&quot; /&gt;
        &lt;/field&gt;

     &lt;/class&gt;
  &lt;/mapping&gt;
</pre></div></div>
<p>It is possible to use such a mapping and still have the marshal/unmarshal process work by specifying the concrete implementation of IProcessor in the document to be unmarshalled, using the xsi:type attribute, as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">  &lt;engine&gt;
     &lt;processor xsi:type=&quot;java:com.abc.MyProcessor&quot; /&gt;
  &lt;/engine&gt;            
</pre></div></div>
<p>In this manner, one is still able to maintain only a single mapping, but vary the manner in which the document is unmarshalled from one instance document to the next. This flexibility is powerful because it enables the support of polymorphism within the castor xml marshalling framework.</p>
<p>Suppose we wanted the following XML instead:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">  &lt;engine&gt;
     &lt;myProcessor/&gt;
  &lt;/engine&gt;
</pre></div></div>
<p>In the above output our XML name changed to match the type of the class used instead of relying on the xsi:type attribute. This can be achieved by modifying the mapping file as such:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">  &lt;mapping&gt;
     &lt;class name=&quot;Engine&quot;&gt;
        &lt;map-to xml=&quot;engine&quot; /&gt;
        &lt;field name=&quot;processor&quot; type=&quot;IProcessor&quot; required=&quot;true&quot;&gt;
           &lt;bind-xml auto-naming=&quot;deriveByClass&quot; node=&quot;element&quot; /&gt;
        &lt;/field&gt;
     &lt;/class&gt;

     &lt;class name=&quot;MyProcessor&quot;&gt;
        &lt;map-to xml=&quot;myProcessor&quot; /&gt;
     &lt;/class&gt;

  &lt;/mapping&gt;
</pre></div></div></div>
<div class="section">
<h2><a name="Location_attribute"></a>Location attribute</h2>
<p>Since version 0.9.5</p>
<p>The location attribute allows the user to map fields from nested elements or specify a wrapper element for a given field. Wrapper elements are simply elements which appear in the XML instance, but do not have a direct mapping to an object or field within the object model.</p>
<p>For example to map an instance of the following class:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">public class Foo {

    private Bar bar = null;

    public Foo();

    public getBar() {
        return bar;
    }

    public void setBar(Bar bar) {
        this.bar = bar;
    }
}
</pre></div></div>
<p>into the following XML instance:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;foo&gt;;
   &lt;abc&gt;
      &lt;bar&gt;...&lt;/bar&gt;
   &lt;/abc&gt;
&lt;/foo&gt;
</pre></div></div>
<p><i>(notice that an &#x2018;abc&#x2019; field doesn&#x2019;t exist in the Bar class)</i> One would use the following mapping:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot;?&gt;
   ...
   &lt;class name=&quot;Foo&quot;&gt;
      &lt;field name=&quot;bar&quot; type=&quot;Bar&quot;&gt;
         &lt;bind-xml name=&quot;bar&quot; location=&quot;abc&quot;/&gt;
      &lt;/field&gt;
   &lt;/class&gt;
   ...
&lt;/mapping&gt;
</pre></div></div>
<p>Note the &#x201c;location&#x201d; attribute. The value of this attribute is the name of the wrapper element. To use more than one wrapper element, the name is separated by a forward-slash as such:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;bind-xml name=&quot;bar&quot; location=&quot;abc/xyz&quot; /&gt;
</pre></div></div>
<p>Note that the name of the element is not part of the location itself and that the location is always relative to the class in which the field is being defined. This works for attributes also:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;bind-xml name=&quot;bar&quot; location=&quot;abc&quot; node=&quot;attribute&quot; /&gt;
</pre></div></div>
<p>will produce the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint linenums">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;foo&gt;
   &lt;abc bar=&quot;...&quot;/&gt;;
&lt;/foo&gt;
</pre></div></div></div>
<div class="section">
<h2><a name="Tips"></a>Tips</h2>
<p>Some helpful hints&#x2026;</p>
<div class="section">
<h3><a name="Automatically_create_a_mapping_file"></a>Automatically create a mapping file</h3>
<p>Castor comes with a tool that can automatically create a mapping from class files. Please see the <a href="xml-faq.html">XML FAQ</a> for more information.</p></div>
<div class="section">
<h3><a name="Create_your_own_FieldHandler"></a>Create your own FieldHandler</h3>
<p>Sometimes to handle complex situations you&#x2019;ll need to create your own FieldHandler. Normally a FieldHandler deals with a specific class and field, however generic, reusable FieldHandlers can also be created by extending org.exolab.castor.mapping.GeneralizedFieldHandler or org.exolab.castor.mapping.AbstractFieldHandler. The FieldHandler can be specified on the &lt;field&gt; element.</p>
<p>For more information on writing a custom FieldHandler please see the following: XML FieldHandlers.</p></div>
<div class="section">
<h3><a name="Mapping_constructor_arguments_since_0.9.5"></a>Mapping constructor arguments (since 0.9.5)</h3>
<p>You may map any attributes to constructor arguments. For more information on how to map constructor arguments see the information available in the section on set-method above.</p>
<p>Please note that mapping <b>elements</b> to constructor arguments is not yet supported.</p>
<p><b>Tip</b>: the <a href="xml-howto.html">XML HOW-TO section</a> has a HOW-TO document for mapping constructor arguments.</p></div>
<div class="section">
<h3><a name="Preventing_Castor_from_checking_for_a_default_constructor_since_0.9.5"></a>Preventing Castor from checking for a default constructor (since 0.9.5)</h3>
<p>Sometimes it&#x2019;s useful to prevent Castor from checking for a default constructor, such as when trying to write a mapping for an interface or type-safe enum. You can use the &#x201c;undocumented&#x201d; verify-constructable=&#x201c;false&#x201d; attribute on the &lt;class&gt; element to prevent Castor from looking for the default constructor.</p></div>
<div class="section">
<h3><a name="Type_safe_enumeration_mapping_since_0.9.5"></a>Type safe enumeration mapping (since 0.9.5)</h3>
<p>While you can always use your own custom FieldHandler for handling type-safe enumeration classes, Castor does have a built-in approach to dealing with these types of classes. If the type-safe enum class has a <b>public static &lt;type&gt; valueOf(String)</b> method Castor will call that method so that the proper instance of the enumeration is returned. Note: You&#x2019;ll also need to disable the default constructor check in the mapping file (see section 7.4 above to see more on this).</p></div></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                   2016.
          All rights reserved.    
      </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
